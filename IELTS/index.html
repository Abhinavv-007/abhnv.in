<!DOCTYPE html>
<html lang="en" class="antialiased">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>IELTS ACE</title>
  <script>
    window.process = { env: { NODE_ENV: 'production' } };
    window.global = window;
  </script>
  <script>
    window.onerror = function (msg, url, line, col, error) {
      var div = document.createElement("div");
      div.style.cssText = "position:fixed;top:0;left:0;width:100%;background:red;color:white;z-index:9999;padding:20px;font-family:monospace;white-space:pre-wrap;";
      div.innerText = "Runtime Error:\n" + msg + "\n" + url + ":" + line + ":" + col + "\n" + (error ? error.stack : "");
      document.body.appendChild(div);
    };
    window.addEventListener('unhandledrejection', function (event) {
      var div = document.createElement("div");
      div.style.cssText = "position:fixed;bottom:0;left:0;width:100%;background:orange;color:black;z-index:9999;padding:20px;font-family:monospace;white-space:pre-wrap;";
      div.innerText = "Unhandled Promise Rejection:\n" + event.reason;
      document.body.appendChild(div);
    });
  </script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          fontFamily: {
            sans: ['Inter', 'sans-serif'],
          },
          animation: {
            'blob': 'blob 7s infinite',
            'shimmer': 'shimmer 3s linear infinite',
          },
          keyframes: {
            blob: {
              '0%': { transform: 'translate(0px, 0px) scale(1)' },
              '33%': { transform: 'translate(30px, -50px) scale(1.1)' },
              '66%': { transform: 'translate(-20px, 20px) scale(0.9)' },
              '100%': { transform: 'translate(0px, 0px) scale(1)' },
            },
            shimmer: {
              '0%': { backgroundPosition: '200% 0' },
              '100%': { backgroundPosition: '-200% 0' }
            }
          }
        }
      }
    }
  </script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Inter', sans-serif;
    }

    /* Custom scrollbar for cleaner look */
    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 3px;
    }

    .dark ::-webkit-scrollbar-thumb {
      background: #475569;
    }
  </style>


  <script type="importmap">
{
  "imports": {
    "lucide-react": "https://aistudiocdn.com/lucide-react@^0.554.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react-router-dom": "https://aistudiocdn.com/react-router-dom@^7.9.6",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.30.0",
    "firebase/app": "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js",
    "firebase/analytics": "https://www.gstatic.com/firebasejs/12.6.0/firebase-analytics.js",
    "firebase/auth": "https://www.gstatic.com/firebasejs/12.6.0/firebase-auth.js"
  }
}
</script>
  <script type="module" crossorigin>var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
import { initializeApp, getApp } from "firebase/app";
import { getAnalytics } from "firebase/analytics";
import { getAuth, GoogleAuthProvider, signInWithPopup, signInAnonymously, linkWithPopup, signOut, onAuthStateChanged } from "firebase/auth";
var require_index_001 = __commonJS({
  "index-Bx9clc0P.js"(exports) {
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node of mutation.addedNodes) {
            if (node.tagName === "LINK" && node.rel === "modulepreload")
              processPreload(node);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link) {
        const fetchOpts = {};
        if (link.integrity) fetchOpts.integrity = link.integrity;
        if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
        if (link.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
        else fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link) {
        if (link.ep)
          return;
        link.ep = true;
        const fetchOpts = getFetchOpts(link);
        fetch(link.href, fetchOpts);
      }
    })();
    function getDefaultExportFromCjs(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    var jsxRuntime = { exports: {} };
    var reactJsxRuntime_production = {};
    /**
     * @license React
     * react-jsx-runtime.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var hasRequiredReactJsxRuntime_production;
    function requireReactJsxRuntime_production() {
      if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production;
      hasRequiredReactJsxRuntime_production = 1;
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      function jsxProd(type, config, maybeKey) {
        var key = null;
        void 0 !== maybeKey && (key = "" + maybeKey);
        void 0 !== config.key && (key = "" + config.key);
        if ("key" in config) {
          maybeKey = {};
          for (var propName in config)
            "key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        config = maybeKey.ref;
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref: void 0 !== config ? config : null,
          props: maybeKey
        };
      }
      reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE;
      reactJsxRuntime_production.jsx = jsxProd;
      reactJsxRuntime_production.jsxs = jsxProd;
      return reactJsxRuntime_production;
    }
    var hasRequiredJsxRuntime;
    function requireJsxRuntime() {
      if (hasRequiredJsxRuntime) return jsxRuntime.exports;
      hasRequiredJsxRuntime = 1;
      {
        jsxRuntime.exports = requireReactJsxRuntime_production();
      }
      return jsxRuntime.exports;
    }
    var jsxRuntimeExports = requireJsxRuntime();
    var react = { exports: {} };
    var react_production = {};
    /**
     * @license React
     * react.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var hasRequiredReact_production;
    function requireReact_production() {
      if (hasRequiredReact_production) return react_production;
      hasRequiredReact_production = 1;
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      var ReactNoopUpdateQueue = {
        isMounted: function() {
          return false;
        },
        enqueueForceUpdate: function() {
        },
        enqueueReplaceState: function() {
        },
        enqueueSetState: function() {
        }
      }, assign = Object.assign, emptyObject = {};
      function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      Component.prototype.isReactComponent = {};
      Component.prototype.setState = function(partialState, callback) {
        if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      };
      Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      function ComponentDummy() {
      }
      ComponentDummy.prototype = Component.prototype;
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
      pureComponentPrototype.constructor = PureComponent;
      assign(pureComponentPrototype, Component.prototype);
      pureComponentPrototype.isPureReactComponent = true;
      var isArrayImpl = Array.isArray;
      function noop() {
      }
      var ReactSharedInternals = { H: null, A: null, T: null, S: null }, hasOwnProperty = Object.prototype.hasOwnProperty;
      function ReactElement(type, key, props) {
        var refProp = props.ref;
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref: void 0 !== refProp ? refProp : null,
          props
        };
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        return ReactElement(oldElement.type, newKey, oldElement.props);
      }
      function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function escape(key) {
        var escaperLookup = { "=": "=0", ":": "=2" };
        return "$" + key.replace(/[=:]/g, function(match) {
          return escaperLookup[match];
        });
      }
      var userProvidedKeyEscapeRegex = /\/+/g;
      function getElementKey(element, index) {
        return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index.toString(36);
      }
      function resolveThenable(thenable) {
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            switch ("string" === typeof thenable.status ? thenable.then(noop, noop) : (thenable.status = "pending", thenable.then(
              function(fulfilledValue) {
                "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
              },
              function(error) {
                "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
              }
            )), thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
        }
        throw thenable;
      }
      function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if ("undefined" === type || "boolean" === type) children = null;
        var invokeCallback = false;
        if (null === children) invokeCallback = true;
        else
          switch (type) {
            case "bigint":
            case "string":
            case "number":
              invokeCallback = true;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
                  break;
                case REACT_LAZY_TYPE:
                  return invokeCallback = children._init, mapIntoArray(
                    invokeCallback(children._payload),
                    array,
                    escapedPrefix,
                    nameSoFar,
                    callback
                  );
              }
          }
        if (invokeCallback)
          return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
            return c;
          })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(
            callback,
            escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
              userProvidedKeyEscapeRegex,
              "$&/"
            ) + "/") + invokeCallback
          )), array.push(callback)), 1;
        invokeCallback = 0;
        var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
        if (isArrayImpl(children))
          for (var i = 0; i < children.length; i++)
            nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if (i = getIteratorFn(children), "function" === typeof i)
          for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
            nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if ("object" === type) {
          if ("function" === typeof children.then)
            return mapIntoArray(
              resolveThenable(children),
              array,
              escapedPrefix,
              nameSoFar,
              callback
            );
          array = String(children);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return invokeCallback;
      }
      function mapChildren(children, func, context) {
        if (null == children) return children;
        var result = [], count = 0;
        mapIntoArray(children, result, "", "", function(child) {
          return func.call(context, child, count++);
        });
        return result;
      }
      function lazyInitializer(payload) {
        if (-1 === payload._status) {
          var ctor = payload._result;
          ctor = ctor();
          ctor.then(
            function(moduleObject) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 1, payload._result = moduleObject;
            },
            function(error) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 2, payload._result = error;
            }
          );
          -1 === payload._status && (payload._status = 0, payload._result = ctor);
        }
        if (1 === payload._status) return payload._result.default;
        throw payload._result;
      }
      var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      }, Children = {
        map: mapChildren,
        forEach: function(children, forEachFunc, forEachContext) {
          mapChildren(
            children,
            function() {
              forEachFunc.apply(this, arguments);
            },
            forEachContext
          );
        },
        count: function(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        },
        toArray: function(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        },
        only: function(children) {
          if (!isValidElement(children))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return children;
        }
      };
      react_production.Activity = REACT_ACTIVITY_TYPE;
      react_production.Children = Children;
      react_production.Component = Component;
      react_production.Fragment = REACT_FRAGMENT_TYPE;
      react_production.Profiler = REACT_PROFILER_TYPE;
      react_production.PureComponent = PureComponent;
      react_production.StrictMode = REACT_STRICT_MODE_TYPE;
      react_production.Suspense = REACT_SUSPENSE_TYPE;
      react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
      react_production.__COMPILER_RUNTIME = {
        __proto__: null,
        c: function(size) {
          return ReactSharedInternals.H.useMemoCache(size);
        }
      };
      react_production.cache = function(fn) {
        return function() {
          return fn.apply(null, arguments);
        };
      };
      react_production.cacheSignal = function() {
        return null;
      };
      react_production.cloneElement = function(element, config, children) {
        if (null === element || void 0 === element)
          throw Error(
            "The argument must be a React element, but you passed " + element + "."
          );
        var props = assign({}, element.props), key = element.key;
        if (null != config)
          for (propName in void 0 !== config.key && (key = "" + config.key), config)
            !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
        var propName = arguments.length - 2;
        if (1 === propName) props.children = children;
        else if (1 < propName) {
          for (var childArray = Array(propName), i = 0; i < propName; i++)
            childArray[i] = arguments[i + 2];
          props.children = childArray;
        }
        return ReactElement(element.type, key, props);
      };
      react_production.createContext = function(defaultValue) {
        defaultValue = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        };
        defaultValue.Provider = defaultValue;
        defaultValue.Consumer = {
          $$typeof: REACT_CONSUMER_TYPE,
          _context: defaultValue
        };
        return defaultValue;
      };
      react_production.createElement = function(type, config, children) {
        var propName, props = {}, key = null;
        if (null != config)
          for (propName in void 0 !== config.key && (key = "" + config.key), config)
            hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength) props.children = children;
        else if (1 < childrenLength) {
          for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
            childArray[i] = arguments[i + 2];
          props.children = childArray;
        }
        if (type && type.defaultProps)
          for (propName in childrenLength = type.defaultProps, childrenLength)
            void 0 === props[propName] && (props[propName] = childrenLength[propName]);
        return ReactElement(type, key, props);
      };
      react_production.createRef = function() {
        return { current: null };
      };
      react_production.forwardRef = function(render) {
        return { $$typeof: REACT_FORWARD_REF_TYPE, render };
      };
      react_production.isValidElement = isValidElement;
      react_production.lazy = function(ctor) {
        return {
          $$typeof: REACT_LAZY_TYPE,
          _payload: { _status: -1, _result: ctor },
          _init: lazyInitializer
        };
      };
      react_production.memo = function(type, compare) {
        return {
          $$typeof: REACT_MEMO_TYPE,
          type,
          compare: void 0 === compare ? null : compare
        };
      };
      react_production.startTransition = function(scope) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
        } catch (error) {
          reportGlobalError(error);
        } finally {
          null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
        }
      };
      react_production.unstable_useCacheRefresh = function() {
        return ReactSharedInternals.H.useCacheRefresh();
      };
      react_production.use = function(usable) {
        return ReactSharedInternals.H.use(usable);
      };
      react_production.useActionState = function(action, initialState, permalink) {
        return ReactSharedInternals.H.useActionState(action, initialState, permalink);
      };
      react_production.useCallback = function(callback, deps) {
        return ReactSharedInternals.H.useCallback(callback, deps);
      };
      react_production.useContext = function(Context) {
        return ReactSharedInternals.H.useContext(Context);
      };
      react_production.useDebugValue = function() {
      };
      react_production.useDeferredValue = function(value, initialValue) {
        return ReactSharedInternals.H.useDeferredValue(value, initialValue);
      };
      react_production.useEffect = function(create, deps) {
        return ReactSharedInternals.H.useEffect(create, deps);
      };
      react_production.useEffectEvent = function(callback) {
        return ReactSharedInternals.H.useEffectEvent(callback);
      };
      react_production.useId = function() {
        return ReactSharedInternals.H.useId();
      };
      react_production.useImperativeHandle = function(ref, create, deps) {
        return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
      };
      react_production.useInsertionEffect = function(create, deps) {
        return ReactSharedInternals.H.useInsertionEffect(create, deps);
      };
      react_production.useLayoutEffect = function(create, deps) {
        return ReactSharedInternals.H.useLayoutEffect(create, deps);
      };
      react_production.useMemo = function(create, deps) {
        return ReactSharedInternals.H.useMemo(create, deps);
      };
      react_production.useOptimistic = function(passthrough, reducer) {
        return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
      };
      react_production.useReducer = function(reducer, initialArg, init) {
        return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
      };
      react_production.useRef = function(initialValue) {
        return ReactSharedInternals.H.useRef(initialValue);
      };
      react_production.useState = function(initialState) {
        return ReactSharedInternals.H.useState(initialState);
      };
      react_production.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
        return ReactSharedInternals.H.useSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      };
      react_production.useTransition = function() {
        return ReactSharedInternals.H.useTransition();
      };
      react_production.version = "19.2.0";
      return react_production;
    }
    var hasRequiredReact;
    function requireReact() {
      if (hasRequiredReact) return react.exports;
      hasRequiredReact = 1;
      {
        react.exports = requireReact_production();
      }
      return react.exports;
    }
    var reactExports = requireReact();
    const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
    var client = { exports: {} };
    var reactDomClient_production = {};
    var scheduler = { exports: {} };
    var scheduler_production = {};
    /**
     * @license React
     * scheduler.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var hasRequiredScheduler_production;
    function requireScheduler_production() {
      if (hasRequiredScheduler_production) return scheduler_production;
      hasRequiredScheduler_production = 1;
      (function(exports$1) {
        function push(heap, node) {
          var index = heap.length;
          heap.push(node);
          a: for (; 0 < index; ) {
            var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
            if (0 < compare(parent, node))
              heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
            else break a;
          }
        }
        function peek(heap) {
          return 0 === heap.length ? null : heap[0];
        }
        function pop(heap) {
          if (0 === heap.length) return null;
          var first = heap[0], last = heap.pop();
          if (last !== first) {
            heap[0] = last;
            a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength; ) {
              var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
              if (0 > compare(left, last))
                rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
              else if (rightIndex < length && 0 > compare(right, last))
                heap[index] = right, heap[rightIndex] = last, index = rightIndex;
              else break a;
            }
          }
          return first;
        }
        function compare(a, b) {
          var diff = a.sortIndex - b.sortIndex;
          return 0 !== diff ? diff : a.id - b.id;
        }
        exports$1.unstable_now = void 0;
        if ("object" === typeof performance && "function" === typeof performance.now) {
          var localPerformance = performance;
          exports$1.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date, initialTime = localDate.now();
          exports$1.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
        function advanceTimers(currentTime) {
          for (var timer = peek(timerQueue); null !== timer; ) {
            if (null === timer.callback) pop(timerQueue);
            else if (timer.startTime <= currentTime)
              pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
            else break;
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled)
            if (null !== peek(taskQueue))
              isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
            else {
              var firstTimer = peek(timerQueue);
              null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
        }
        var isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
        function shouldYieldToHost() {
          return needsPaint ? true : exports$1.unstable_now() - startTime < frameInterval ? false : true;
        }
        function performWorkUntilDeadline() {
          needsPaint = false;
          if (isMessageLoopRunning) {
            var currentTime = exports$1.unstable_now();
            startTime = currentTime;
            var hasMoreWork = true;
            try {
              a: {
                isHostCallbackScheduled = false;
                isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
                isPerformingWork = true;
                var previousPriorityLevel = currentPriorityLevel;
                try {
                  b: {
                    advanceTimers(currentTime);
                    for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                      var callback = currentTask.callback;
                      if ("function" === typeof callback) {
                        currentTask.callback = null;
                        currentPriorityLevel = currentTask.priorityLevel;
                        var continuationCallback = callback(
                          currentTask.expirationTime <= currentTime
                        );
                        currentTime = exports$1.unstable_now();
                        if ("function" === typeof continuationCallback) {
                          currentTask.callback = continuationCallback;
                          advanceTimers(currentTime);
                          hasMoreWork = true;
                          break b;
                        }
                        currentTask === peek(taskQueue) && pop(taskQueue);
                        advanceTimers(currentTime);
                      } else pop(taskQueue);
                      currentTask = peek(taskQueue);
                    }
                    if (null !== currentTask) hasMoreWork = true;
                    else {
                      var firstTimer = peek(timerQueue);
                      null !== firstTimer && requestHostTimeout(
                        handleTimeout,
                        firstTimer.startTime - currentTime
                      );
                      hasMoreWork = false;
                    }
                  }
                  break a;
                } finally {
                  currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
                }
                hasMoreWork = void 0;
              }
            } finally {
              hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
            }
          }
        }
        var schedulePerformWorkUntilDeadline;
        if ("function" === typeof localSetImmediate)
          schedulePerformWorkUntilDeadline = function() {
            localSetImmediate(performWorkUntilDeadline);
          };
        else if ("undefined" !== typeof MessageChannel) {
          var channel = new MessageChannel(), port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
          };
        } else
          schedulePerformWorkUntilDeadline = function() {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        function requestHostTimeout(callback, ms) {
          taskTimeoutID = localSetTimeout(function() {
            callback(exports$1.unstable_now());
          }, ms);
        }
        exports$1.unstable_IdlePriority = 5;
        exports$1.unstable_ImmediatePriority = 1;
        exports$1.unstable_LowPriority = 4;
        exports$1.unstable_NormalPriority = 3;
        exports$1.unstable_Profiling = null;
        exports$1.unstable_UserBlockingPriority = 2;
        exports$1.unstable_cancelCallback = function(task) {
          task.callback = null;
        };
        exports$1.unstable_forceFrameRate = function(fps) {
          0 > fps || 125 < fps ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
        };
        exports$1.unstable_getCurrentPriorityLevel = function() {
          return currentPriorityLevel;
        };
        exports$1.unstable_next = function(eventHandler) {
          switch (currentPriorityLevel) {
            case 1:
            case 2:
            case 3:
              var priorityLevel = 3;
              break;
            default:
              priorityLevel = currentPriorityLevel;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports$1.unstable_requestPaint = function() {
          needsPaint = true;
        };
        exports$1.unstable_runWithPriority = function(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
            default:
              priorityLevel = 3;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports$1.unstable_scheduleCallback = function(priorityLevel, callback, options) {
          var currentTime = exports$1.unstable_now();
          "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
          switch (priorityLevel) {
            case 1:
              var timeout = -1;
              break;
            case 2:
              timeout = 250;
              break;
            case 5:
              timeout = 1073741823;
              break;
            case 4:
              timeout = 1e4;
              break;
            default:
              timeout = 5e3;
          }
          timeout = options + timeout;
          priorityLevel = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: options,
            expirationTime: timeout,
            sortIndex: -1
          };
          options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
          return priorityLevel;
        };
        exports$1.unstable_shouldYield = shouldYieldToHost;
        exports$1.unstable_wrapCallback = function(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        };
      })(scheduler_production);
      return scheduler_production;
    }
    var hasRequiredScheduler;
    function requireScheduler() {
      if (hasRequiredScheduler) return scheduler.exports;
      hasRequiredScheduler = 1;
      {
        scheduler.exports = requireScheduler_production();
      }
      return scheduler.exports;
    }
    var reactDom = { exports: {} };
    var reactDom_production = {};
    /**
     * @license React
     * react-dom.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var hasRequiredReactDom_production;
    function requireReactDom_production() {
      if (hasRequiredReactDom_production) return reactDom_production;
      hasRequiredReactDom_production = 1;
      var React2 = requireReact();
      function formatProdErrorMessage(code) {
        var url = "https://react.dev/errors/" + code;
        if (1 < arguments.length) {
          url += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var i = 2; i < arguments.length; i++)
            url += "&args[]=" + encodeURIComponent(arguments[i]);
        }
        return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function noop() {
      }
      var Internals = {
        d: {
          f: noop,
          r: function() {
            throw Error(formatProdErrorMessage(522));
          },
          D: noop,
          C: noop,
          L: noop,
          m: noop,
          X: noop,
          S: noop,
          M: noop
        },
        p: 0,
        findDOMNode: null
      }, REACT_PORTAL_TYPE = Symbol.for("react.portal");
      function createPortal$1(children, containerInfo, implementation) {
        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: null == key ? null : "" + key,
          children,
          containerInfo,
          implementation
        };
      }
      var ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      function getCrossOriginStringAs(as, input) {
        if ("font" === as) return "";
        if ("string" === typeof input)
          return "use-credentials" === input ? input : "";
      }
      reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
      reactDom_production.createPortal = function(children, container) {
        var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
          throw Error(formatProdErrorMessage(299));
        return createPortal$1(children, container, null, key);
      };
      reactDom_production.flushSync = function(fn) {
        var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
        try {
          if (ReactSharedInternals.T = null, Internals.p = 2, fn) return fn();
        } finally {
          ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
        }
      };
      reactDom_production.preconnect = function(href, options) {
        "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
      };
      reactDom_production.prefetchDNS = function(href) {
        "string" === typeof href && Internals.d.D(href);
      };
      reactDom_production.preinit = function(href, options) {
        if ("string" === typeof href && options && "string" === typeof options.as) {
          var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
          "style" === as ? Internals.d.S(
            href,
            "string" === typeof options.precedence ? options.precedence : void 0,
            {
              crossOrigin,
              integrity,
              fetchPriority
            }
          ) : "script" === as && Internals.d.X(href, {
            crossOrigin,
            integrity,
            fetchPriority,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0
          });
        }
      };
      reactDom_production.preinitModule = function(href, options) {
        if ("string" === typeof href)
          if ("object" === typeof options && null !== options) {
            if (null == options.as || "script" === options.as) {
              var crossOrigin = getCrossOriginStringAs(
                options.as,
                options.crossOrigin
              );
              Internals.d.M(href, {
                crossOrigin,
                integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                nonce: "string" === typeof options.nonce ? options.nonce : void 0
              });
            }
          } else null == options && Internals.d.M(href);
      };
      reactDom_production.preload = function(href, options) {
        if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
          var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
          Internals.d.L(href, as, {
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0,
            type: "string" === typeof options.type ? options.type : void 0,
            fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
            referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
            imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
            imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
            media: "string" === typeof options.media ? options.media : void 0
          });
        }
      };
      reactDom_production.preloadModule = function(href, options) {
        if ("string" === typeof href)
          if (options) {
            var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
            Internals.d.m(href, {
              as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0
            });
          } else Internals.d.m(href);
      };
      reactDom_production.requestFormReset = function(form) {
        Internals.d.r(form);
      };
      reactDom_production.unstable_batchedUpdates = function(fn, a) {
        return fn(a);
      };
      reactDom_production.useFormState = function(action, initialState, permalink) {
        return ReactSharedInternals.H.useFormState(action, initialState, permalink);
      };
      reactDom_production.useFormStatus = function() {
        return ReactSharedInternals.H.useHostTransitionStatus();
      };
      reactDom_production.version = "19.2.0";
      return reactDom_production;
    }
    var hasRequiredReactDom;
    function requireReactDom() {
      if (hasRequiredReactDom) return reactDom.exports;
      hasRequiredReactDom = 1;
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      {
        checkDCE();
        reactDom.exports = requireReactDom_production();
      }
      return reactDom.exports;
    }
    /**
     * @license React
     * react-dom-client.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var hasRequiredReactDomClient_production;
    function requireReactDomClient_production() {
      if (hasRequiredReactDomClient_production) return reactDomClient_production;
      hasRequiredReactDomClient_production = 1;
      var Scheduler = requireScheduler(), React2 = requireReact(), ReactDOM2 = requireReactDom();
      function formatProdErrorMessage(code) {
        var url = "https://react.dev/errors/" + code;
        if (1 < arguments.length) {
          url += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var i = 2; i < arguments.length; i++)
            url += "&args[]=" + encodeURIComponent(arguments[i]);
        }
        return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function isValidContainer(node) {
        return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
      }
      function getNearestMountedFiber(fiber) {
        var node = fiber, nearestMounted = fiber;
        if (fiber.alternate) for (; node.return; ) node = node.return;
        else {
          fiber = node;
          do
            node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
          while (fiber);
        }
        return 3 === node.tag ? nearestMounted : null;
      }
      function getSuspenseInstanceFromFiber(fiber) {
        if (13 === fiber.tag) {
          var suspenseState = fiber.memoizedState;
          null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
          if (null !== suspenseState) return suspenseState.dehydrated;
        }
        return null;
      }
      function getActivityInstanceFromFiber(fiber) {
        if (31 === fiber.tag) {
          var activityState = fiber.memoizedState;
          null === activityState && (fiber = fiber.alternate, null !== fiber && (activityState = fiber.memoizedState));
          if (null !== activityState) return activityState.dehydrated;
        }
        return null;
      }
      function assertIsMounted(fiber) {
        if (getNearestMountedFiber(fiber) !== fiber)
          throw Error(formatProdErrorMessage(188));
      }
      function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;
        if (!alternate) {
          alternate = getNearestMountedFiber(fiber);
          if (null === alternate) throw Error(formatProdErrorMessage(188));
          return alternate !== fiber ? null : fiber;
        }
        for (var a = fiber, b = alternate; ; ) {
          var parentA = a.return;
          if (null === parentA) break;
          var parentB = parentA.alternate;
          if (null === parentB) {
            b = parentA.return;
            if (null !== b) {
              a = b;
              continue;
            }
            break;
          }
          if (parentA.child === parentB.child) {
            for (parentB = parentA.child; parentB; ) {
              if (parentB === a) return assertIsMounted(parentA), fiber;
              if (parentB === b) return assertIsMounted(parentA), alternate;
              parentB = parentB.sibling;
            }
            throw Error(formatProdErrorMessage(188));
          }
          if (a.return !== b.return) a = parentA, b = parentB;
          else {
            for (var didFindChild = false, child$0 = parentA.child; child$0; ) {
              if (child$0 === a) {
                didFindChild = true;
                a = parentA;
                b = parentB;
                break;
              }
              if (child$0 === b) {
                didFindChild = true;
                b = parentA;
                a = parentB;
                break;
              }
              child$0 = child$0.sibling;
            }
            if (!didFindChild) {
              for (child$0 = parentB.child; child$0; ) {
                if (child$0 === a) {
                  didFindChild = true;
                  a = parentB;
                  b = parentA;
                  break;
                }
                if (child$0 === b) {
                  didFindChild = true;
                  b = parentB;
                  a = parentA;
                  break;
                }
                child$0 = child$0.sibling;
              }
              if (!didFindChild) throw Error(formatProdErrorMessage(189));
            }
          }
          if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
        }
        if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
        return a.stateNode.current === a ? fiber : alternate;
      }
      function findCurrentHostFiberImpl(node) {
        var tag = node.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
        for (node = node.child; null !== node; ) {
          tag = findCurrentHostFiberImpl(node);
          if (null !== tag) return tag;
          node = node.sibling;
        }
        return null;
      }
      var assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
      var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch (type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return type.displayName || "Context";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      var isArrayImpl = Array.isArray, ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, sharedNotPendingObject = {
        pending: false,
        data: null,
        method: null,
        action: null
      }, valueStack = [], index = -1;
      function createCursor(defaultValue) {
        return { current: defaultValue };
      }
      function pop(cursor) {
        0 > index || (cursor.current = valueStack[index], valueStack[index] = null, index--);
      }
      function push(cursor, value) {
        index++;
        valueStack[index] = cursor.current;
        cursor.current = value;
      }
      var contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null);
      function pushHostContainer(fiber, nextRootInstance) {
        push(rootInstanceStackCursor, nextRootInstance);
        push(contextFiberStackCursor, fiber);
        push(contextStackCursor, null);
        switch (nextRootInstance.nodeType) {
          case 9:
          case 11:
            fiber = (fiber = nextRootInstance.documentElement) ? (fiber = fiber.namespaceURI) ? getOwnHostContext(fiber) : 0 : 0;
            break;
          default:
            if (fiber = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
              nextRootInstance = getOwnHostContext(nextRootInstance), fiber = getChildHostContextProd(nextRootInstance, fiber);
            else
              switch (fiber) {
                case "svg":
                  fiber = 1;
                  break;
                case "math":
                  fiber = 2;
                  break;
                default:
                  fiber = 0;
              }
        }
        pop(contextStackCursor);
        push(contextStackCursor, fiber);
      }
      function popHostContainer() {
        pop(contextStackCursor);
        pop(contextFiberStackCursor);
        pop(rootInstanceStackCursor);
      }
      function pushHostContext(fiber) {
        null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
        var context = contextStackCursor.current;
        var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
        context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
      }
      function popHostContext(fiber) {
        contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
        hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
      }
      var prefix, suffix;
      function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix)
          try {
            throw Error();
          } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || "";
            suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return "\n" + prefix + name + suffix;
      }
      var reentry = false;
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) return "";
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          var RunInRootFrame = {
            DetermineComponentFrameRoot: function() {
              try {
                if (construct) {
                  var Fake = function() {
                    throw Error();
                  };
                  Object.defineProperty(Fake.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  });
                  if ("object" === typeof Reflect && Reflect.construct) {
                    try {
                      Reflect.construct(Fake, []);
                    } catch (x) {
                      var control = x;
                    }
                    Reflect.construct(fn, [], Fake);
                  } else {
                    try {
                      Fake.call();
                    } catch (x$1) {
                      control = x$1;
                    }
                    fn.call(Fake.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (x$2) {
                    control = x$2;
                  }
                  (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                  });
                }
              } catch (sample) {
                if (sample && control && "string" === typeof sample.stack)
                  return [sample.stack, control.stack];
              }
              return [null, null];
            }
          };
          RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var namePropDescriptor = Object.getOwnPropertyDescriptor(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name"
          );
          namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
          if (sampleStack && controlStack) {
            var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
            for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
              RunInRootFrame++;
            for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            ); )
              namePropDescriptor++;
            if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
              for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
                namePropDescriptor--;
            for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
              if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
                  do
                    if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                      var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                      fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
                      return frame;
                    }
                  while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
                }
                break;
              }
          }
        } finally {
          reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
        }
        return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
      }
      function describeFiber(fiber, childFiber) {
        switch (fiber.tag) {
          case 26:
          case 27:
          case 5:
            return describeBuiltInComponentFrame(fiber.type);
          case 16:
            return describeBuiltInComponentFrame("Lazy");
          case 13:
            return fiber.child !== childFiber && null !== childFiber ? describeBuiltInComponentFrame("Suspense Fallback") : describeBuiltInComponentFrame("Suspense");
          case 19:
            return describeBuiltInComponentFrame("SuspenseList");
          case 0:
          case 15:
            return describeNativeComponentFrame(fiber.type, false);
          case 11:
            return describeNativeComponentFrame(fiber.type.render, false);
          case 1:
            return describeNativeComponentFrame(fiber.type, true);
          case 31:
            return describeBuiltInComponentFrame("Activity");
          default:
            return "";
        }
      }
      function getStackByFiberInDevAndProd(workInProgress2) {
        try {
          var info = "", previous = null;
          do
            info += describeFiber(workInProgress2, previous), previous = workInProgress2, workInProgress2 = workInProgress2.return;
          while (workInProgress2);
          return info;
        } catch (x) {
          return "\nError generating stack: " + x.message + "\n" + x.stack;
        }
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null;
      function setIsStrictModeForDevtools(newIsStrictMode) {
        "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
        if (injectedHook && "function" === typeof injectedHook.setStrictMode)
          try {
            injectedHook.setStrictMode(rendererID, newIsStrictMode);
          } catch (err) {
          }
      }
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2;
      function clz32Fallback(x) {
        x >>>= 0;
        return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
      }
      var nextTransitionUpdateLane = 256, nextTransitionDeferredLane = 262144, nextRetryLane = 4194304;
      function getHighestPriorityLanes(lanes) {
        var pendingSyncLanes = lanes & 42;
        if (0 !== pendingSyncLanes) return pendingSyncLanes;
        switch (lanes & -lanes) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
            return 64;
          case 128:
            return 128;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
            return lanes & 261888;
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return lanes & 3932160;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return lanes & 62914560;
          case 67108864:
            return 67108864;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 0;
          default:
            return lanes;
        }
      }
      function getNextLanes(root2, wipLanes, rootHasPendingCommit) {
        var pendingLanes = root2.pendingLanes;
        if (0 === pendingLanes) return 0;
        var nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
        root2 = root2.warmLanes;
        var nonIdlePendingLanes = pendingLanes & 134217727;
        0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
        return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
      }
      function checkIfRootIsPrerendering(root2, renderLanes2) {
        return 0 === (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2);
      }
      function computeExpirationTime(lane, currentTime) {
        switch (lane) {
          case 1:
          case 2:
          case 4:
          case 8:
          case 64:
            return currentTime + 250;
          case 16:
          case 32:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return currentTime + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return -1;
          case 67108864:
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function claimNextRetryLane() {
        var lane = nextRetryLane;
        nextRetryLane <<= 1;
        0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
        return lane;
      }
      function createLaneMap(initial) {
        for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
        return laneMap;
      }
      function markRootUpdated$1(root2, updateLane) {
        root2.pendingLanes |= updateLane;
        268435456 !== updateLane && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
      }
      function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
        var previouslyPendingLanes = root2.pendingLanes;
        root2.pendingLanes = remainingLanes;
        root2.suspendedLanes = 0;
        root2.pingedLanes = 0;
        root2.warmLanes = 0;
        root2.expiredLanes &= remainingLanes;
        root2.entangledLanes &= remainingLanes;
        root2.errorRecoveryDisabledLanes &= remainingLanes;
        root2.shellSuspendCounter = 0;
        var entanglements = root2.entanglements, expirationTimes = root2.expirationTimes, hiddenUpdates = root2.hiddenUpdates;
        for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
          var index$7 = 31 - clz32(remainingLanes), lane = 1 << index$7;
          entanglements[index$7] = 0;
          expirationTimes[index$7] = -1;
          var hiddenUpdatesForLane = hiddenUpdates[index$7];
          if (null !== hiddenUpdatesForLane)
            for (hiddenUpdates[index$7] = null, index$7 = 0; index$7 < hiddenUpdatesForLane.length; index$7++) {
              var update = hiddenUpdatesForLane[index$7];
              null !== update && (update.lane &= -536870913);
            }
          remainingLanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, 0);
        0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root2.tag && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
      }
      function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
        root2.pendingLanes |= spawnedLane;
        root2.suspendedLanes &= ~spawnedLane;
        var spawnedLaneIndex = 31 - clz32(spawnedLane);
        root2.entangledLanes |= spawnedLane;
        root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 261930;
      }
      function markRootEntangled(root2, entangledLanes) {
        var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
        for (root2 = root2.entanglements; rootEntangledLanes; ) {
          var index$8 = 31 - clz32(rootEntangledLanes), lane = 1 << index$8;
          lane & entangledLanes | root2[index$8] & entangledLanes && (root2[index$8] |= entangledLanes);
          rootEntangledLanes &= ~lane;
        }
      }
      function getBumpedLaneForHydration(root2, renderLanes2) {
        var renderLane = renderLanes2 & -renderLanes2;
        renderLane = 0 !== (renderLane & 42) ? 1 : getBumpedLaneForHydrationByLane(renderLane);
        return 0 !== (renderLane & (root2.suspendedLanes | renderLanes2)) ? 0 : renderLane;
      }
      function getBumpedLaneForHydrationByLane(lane) {
        switch (lane) {
          case 2:
            lane = 1;
            break;
          case 8:
            lane = 4;
            break;
          case 32:
            lane = 16;
            break;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            lane = 128;
            break;
          case 268435456:
            lane = 134217728;
            break;
          default:
            lane = 0;
        }
        return lane;
      }
      function lanesToEventPriority(lanes) {
        lanes &= -lanes;
        return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
      }
      function resolveUpdatePriority() {
        var updatePriority = ReactDOMSharedInternals.p;
        if (0 !== updatePriority) return updatePriority;
        updatePriority = window.event;
        return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
      }
      function runWithPriority(priority, fn) {
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          return ReactDOMSharedInternals.p = priority, fn();
        } finally {
          ReactDOMSharedInternals.p = previousPriority;
        }
      }
      var randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey;
      function detachDeletedInstance(node) {
        delete node[internalInstanceKey];
        delete node[internalPropsKey];
        delete node[internalEventHandlersKey];
        delete node[internalEventHandlerListenersKey];
        delete node[internalEventHandlesSetKey];
      }
      function getClosestInstanceFromNode(targetNode) {
        var targetInst = targetNode[internalInstanceKey];
        if (targetInst) return targetInst;
        for (var parentNode = targetNode.parentNode; parentNode; ) {
          if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
            parentNode = targetInst.alternate;
            if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
              for (targetNode = getParentHydrationBoundary(targetNode); null !== targetNode; ) {
                if (parentNode = targetNode[internalInstanceKey]) return parentNode;
                targetNode = getParentHydrationBoundary(targetNode);
              }
            return targetInst;
          }
          targetNode = parentNode;
          parentNode = targetNode.parentNode;
        }
        return null;
      }
      function getInstanceFromNode(node) {
        if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
          var tag = node.tag;
          if (5 === tag || 6 === tag || 13 === tag || 31 === tag || 26 === tag || 27 === tag || 3 === tag)
            return node;
        }
        return null;
      }
      function getNodeFromInstance(inst) {
        var tag = inst.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
        throw Error(formatProdErrorMessage(33));
      }
      function getResourcesFromRoot(root2) {
        var resources = root2[internalRootNodeResourcesKey];
        resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
        return resources;
      }
      function markNodeAsHoistable(node) {
        node[internalHoistableMarker] = true;
      }
      var allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {};
      function registerTwoPhaseEvent(registrationName, dependencies) {
        registerDirectEvent(registrationName, dependencies);
        registerDirectEvent(registrationName + "Capture", dependencies);
      }
      function registerDirectEvent(registrationName, dependencies) {
        registrationNameDependencies[registrationName] = dependencies;
        for (registrationName = 0; registrationName < dependencies.length; registrationName++)
          allNativeEvents.add(dependencies[registrationName]);
      }
      var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
        "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
          return true;
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
          return validatedAttributeNameCache[attributeName] = true;
        illegalAttributeNameCache[attributeName] = true;
        return false;
      }
      function setValueForAttribute(node, name, value) {
        if (isAttributeNameSafe(name))
          if (null === value) node.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
                node.removeAttribute(name);
                return;
              case "boolean":
                var prefix$10 = name.toLowerCase().slice(0, 5);
                if ("data-" !== prefix$10 && "aria-" !== prefix$10) {
                  node.removeAttribute(name);
                  return;
                }
            }
            node.setAttribute(name, "" + value);
          }
      }
      function setValueForKnownAttribute(node, name, value) {
        if (null === value) node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              node.removeAttribute(name);
              return;
          }
          node.setAttribute(name, "" + value);
        }
      }
      function setValueForNamespacedAttribute(node, namespace, name, value) {
        if (null === value) node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              node.removeAttribute(name);
              return;
          }
          node.setAttributeNS(namespace, name, "" + value);
        }
      }
      function getToStringValue(value) {
        switch (typeof value) {
          case "bigint":
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return value;
          case "object":
            return value;
          default:
            return "";
        }
      }
      function isCheckable(elem) {
        var type = elem.type;
        return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
      }
      function trackValueOnNode(node, valueField, currentValue) {
        var descriptor = Object.getOwnPropertyDescriptor(
          node.constructor.prototype,
          valueField
        );
        if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
          var get = descriptor.get, set = descriptor.set;
          Object.defineProperty(node, valueField, {
            configurable: true,
            get: function() {
              return get.call(this);
            },
            set: function(value) {
              currentValue = "" + value;
              set.call(this, value);
            }
          });
          Object.defineProperty(node, valueField, {
            enumerable: descriptor.enumerable
          });
          return {
            getValue: function() {
              return currentValue;
            },
            setValue: function(value) {
              currentValue = "" + value;
            },
            stopTracking: function() {
              node._valueTracker = null;
              delete node[valueField];
            }
          };
        }
      }
      function track(node) {
        if (!node._valueTracker) {
          var valueField = isCheckable(node) ? "checked" : "value";
          node._valueTracker = trackValueOnNode(
            node,
            valueField,
            "" + node[valueField]
          );
        }
      }
      function updateValueIfChanged(node) {
        if (!node) return false;
        var tracker = node._valueTracker;
        if (!tracker) return true;
        var lastValue = tracker.getValue();
        var value = "";
        node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
        node = value;
        return node !== lastValue ? (tracker.setValue(node), true) : false;
      }
      function getActiveElement(doc) {
        doc = doc || ("undefined" !== typeof document ? document : void 0);
        if ("undefined" === typeof doc) return null;
        try {
          return doc.activeElement || doc.body;
        } catch (e) {
          return doc.body;
        }
      }
      var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
      function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
        return value.replace(
          escapeSelectorAttributeValueInsideDoubleQuotesRegex,
          function(ch) {
            return "\\" + ch.charCodeAt(0).toString(16) + " ";
          }
        );
      }
      function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
        element.name = "";
        null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? element.type = type : element.removeAttribute("type");
        if (null != value)
          if ("number" === type) {
            if (0 === value && "" === element.value || element.value != value)
              element.value = "" + getToStringValue(value);
          } else
            element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
        else
          "submit" !== type && "reset" !== type || element.removeAttribute("value");
        null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
        null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
        null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
        null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
      }
      function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
        null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (element.type = type);
        if (null != value || null != defaultValue) {
          if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value)) {
            track(element);
            return;
          }
          defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
          value = null != value ? "" + getToStringValue(value) : defaultValue;
          isHydrating2 || value === element.value || (element.value = value);
          element.defaultValue = value;
        }
        checked = null != checked ? checked : defaultChecked;
        checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
        element.checked = isHydrating2 ? element.checked : !!checked;
        element.defaultChecked = !!checked;
        null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
        track(element);
      }
      function setDefaultValue(node, type, value) {
        "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
      }
      function updateOptions(node, multiple, propValue, setDefaultSelected) {
        node = node.options;
        if (multiple) {
          multiple = {};
          for (var i = 0; i < propValue.length; i++)
            multiple["$" + propValue[i]] = true;
          for (propValue = 0; propValue < node.length; propValue++)
            i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = true);
        } else {
          propValue = "" + getToStringValue(propValue);
          multiple = null;
          for (i = 0; i < node.length; i++) {
            if (node[i].value === propValue) {
              node[i].selected = true;
              setDefaultSelected && (node[i].defaultSelected = true);
              return;
            }
            null !== multiple || node[i].disabled || (multiple = node[i]);
          }
          null !== multiple && (multiple.selected = true);
        }
      }
      function updateTextarea(element, value, defaultValue) {
        if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
          element.defaultValue !== value && (element.defaultValue = value);
          return;
        }
        element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
      }
      function initTextarea(element, value, defaultValue, children) {
        if (null == value) {
          if (null != children) {
            if (null != defaultValue) throw Error(formatProdErrorMessage(92));
            if (isArrayImpl(children)) {
              if (1 < children.length) throw Error(formatProdErrorMessage(93));
              children = children[0];
            }
            defaultValue = children;
          }
          null == defaultValue && (defaultValue = "");
          value = defaultValue;
        }
        defaultValue = getToStringValue(value);
        element.defaultValue = defaultValue;
        children = element.textContent;
        children === defaultValue && "" !== children && null !== children && (element.value = children);
        track(element);
      }
      function setTextContent(node, text) {
        if (text) {
          var firstChild = node.firstChild;
          if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
            firstChild.nodeValue = text;
            return;
          }
        }
        node.textContent = text;
      }
      var unitlessNumbers = new Set(
        "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
          " "
        )
      );
      function setValueForStyle(style2, styleName, value) {
        var isCustomProperty = 0 === styleName.indexOf("--");
        null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : style2[styleName] = ("" + value).trim() : style2[styleName] = value + "px";
      }
      function setValueForStyles(node, styles, prevStyles) {
        if (null != styles && "object" !== typeof styles)
          throw Error(formatProdErrorMessage(62));
        node = node.style;
        if (null != prevStyles) {
          for (var styleName in prevStyles)
            !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
          for (var styleName$16 in styles)
            styleName = styles[styleName$16], styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node, styleName$16, styleName);
        } else
          for (var styleName$17 in styles)
            styles.hasOwnProperty(styleName$17) && setValueForStyle(node, styleName$17, styles[styleName$17]);
      }
      function isCustomElement(tagName) {
        if (-1 === tagName.indexOf("-")) return false;
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var aliases = /* @__PURE__ */ new Map([
        ["acceptCharset", "accept-charset"],
        ["htmlFor", "for"],
        ["httpEquiv", "http-equiv"],
        ["crossOrigin", "crossorigin"],
        ["accentHeight", "accent-height"],
        ["alignmentBaseline", "alignment-baseline"],
        ["arabicForm", "arabic-form"],
        ["baselineShift", "baseline-shift"],
        ["capHeight", "cap-height"],
        ["clipPath", "clip-path"],
        ["clipRule", "clip-rule"],
        ["colorInterpolation", "color-interpolation"],
        ["colorInterpolationFilters", "color-interpolation-filters"],
        ["colorProfile", "color-profile"],
        ["colorRendering", "color-rendering"],
        ["dominantBaseline", "dominant-baseline"],
        ["enableBackground", "enable-background"],
        ["fillOpacity", "fill-opacity"],
        ["fillRule", "fill-rule"],
        ["floodColor", "flood-color"],
        ["floodOpacity", "flood-opacity"],
        ["fontFamily", "font-family"],
        ["fontSize", "font-size"],
        ["fontSizeAdjust", "font-size-adjust"],
        ["fontStretch", "font-stretch"],
        ["fontStyle", "font-style"],
        ["fontVariant", "font-variant"],
        ["fontWeight", "font-weight"],
        ["glyphName", "glyph-name"],
        ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
        ["glyphOrientationVertical", "glyph-orientation-vertical"],
        ["horizAdvX", "horiz-adv-x"],
        ["horizOriginX", "horiz-origin-x"],
        ["imageRendering", "image-rendering"],
        ["letterSpacing", "letter-spacing"],
        ["lightingColor", "lighting-color"],
        ["markerEnd", "marker-end"],
        ["markerMid", "marker-mid"],
        ["markerStart", "marker-start"],
        ["overlinePosition", "overline-position"],
        ["overlineThickness", "overline-thickness"],
        ["paintOrder", "paint-order"],
        ["panose-1", "panose-1"],
        ["pointerEvents", "pointer-events"],
        ["renderingIntent", "rendering-intent"],
        ["shapeRendering", "shape-rendering"],
        ["stopColor", "stop-color"],
        ["stopOpacity", "stop-opacity"],
        ["strikethroughPosition", "strikethrough-position"],
        ["strikethroughThickness", "strikethrough-thickness"],
        ["strokeDasharray", "stroke-dasharray"],
        ["strokeDashoffset", "stroke-dashoffset"],
        ["strokeLinecap", "stroke-linecap"],
        ["strokeLinejoin", "stroke-linejoin"],
        ["strokeMiterlimit", "stroke-miterlimit"],
        ["strokeOpacity", "stroke-opacity"],
        ["strokeWidth", "stroke-width"],
        ["textAnchor", "text-anchor"],
        ["textDecoration", "text-decoration"],
        ["textRendering", "text-rendering"],
        ["transformOrigin", "transform-origin"],
        ["underlinePosition", "underline-position"],
        ["underlineThickness", "underline-thickness"],
        ["unicodeBidi", "unicode-bidi"],
        ["unicodeRange", "unicode-range"],
        ["unitsPerEm", "units-per-em"],
        ["vAlphabetic", "v-alphabetic"],
        ["vHanging", "v-hanging"],
        ["vIdeographic", "v-ideographic"],
        ["vMathematical", "v-mathematical"],
        ["vectorEffect", "vector-effect"],
        ["vertAdvY", "vert-adv-y"],
        ["vertOriginX", "vert-origin-x"],
        ["vertOriginY", "vert-origin-y"],
        ["wordSpacing", "word-spacing"],
        ["writingMode", "writing-mode"],
        ["xmlnsXlink", "xmlns:xlink"],
        ["xHeight", "x-height"]
      ]), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
      function sanitizeURL(url) {
        return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
      }
      function noop$1() {
      }
      var currentReplayingEvent = null;
      function getEventTarget(nativeEvent) {
        nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
        nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
        return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
      }
      var restoreTarget = null, restoreQueue = null;
      function restoreStateOfTarget(target) {
        var internalInstance = getInstanceFromNode(target);
        if (internalInstance && (target = internalInstance.stateNode)) {
          var props = target[internalPropsKey] || null;
          a: switch (target = internalInstance.stateNode, internalInstance.type) {
            case "input":
              updateInput(
                target,
                props.value,
                props.defaultValue,
                props.defaultValue,
                props.checked,
                props.defaultChecked,
                props.type,
                props.name
              );
              internalInstance = props.name;
              if ("radio" === props.type && null != internalInstance) {
                for (props = target; props.parentNode; ) props = props.parentNode;
                props = props.querySelectorAll(
                  'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                    "" + internalInstance
                  ) + '"][type="radio"]'
                );
                for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                  var otherNode = props[internalInstance];
                  if (otherNode !== target && otherNode.form === target.form) {
                    var otherProps = otherNode[internalPropsKey] || null;
                    if (!otherProps) throw Error(formatProdErrorMessage(90));
                    updateInput(
                      otherNode,
                      otherProps.value,
                      otherProps.defaultValue,
                      otherProps.defaultValue,
                      otherProps.checked,
                      otherProps.defaultChecked,
                      otherProps.type,
                      otherProps.name
                    );
                  }
                }
                for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                  otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
              }
              break a;
            case "textarea":
              updateTextarea(target, props.value, props.defaultValue);
              break a;
            case "select":
              internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
          }
        }
      }
      var isInsideEventHandler = false;
      function batchedUpdates$1(fn, a, b) {
        if (isInsideEventHandler) return fn(a, b);
        isInsideEventHandler = true;
        try {
          var JSCompiler_inline_result = fn(a);
          return JSCompiler_inline_result;
        } finally {
          if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
            if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
              for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
          }
        }
      }
      function getListener(inst, registrationName) {
        var stateNode = inst.stateNode;
        if (null === stateNode) return null;
        var props = stateNode[internalPropsKey] || null;
        if (null === props) return null;
        stateNode = props[registrationName];
        a: switch (registrationName) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
            inst = !props;
            break a;
          default:
            inst = false;
        }
        if (inst) return null;
        if (stateNode && "function" !== typeof stateNode)
          throw Error(
            formatProdErrorMessage(231, registrationName, typeof stateNode)
          );
        return stateNode;
      }
      var canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = false;
      if (canUseDOM)
        try {
          var options = {};
          Object.defineProperty(options, "passive", {
            get: function() {
              passiveBrowserEventsSupported = true;
            }
          });
          window.addEventListener("test", options, options);
          window.removeEventListener("test", options, options);
        } catch (e) {
          passiveBrowserEventsSupported = false;
        }
      var root = null, startText = null, fallbackText = null;
      function getData() {
        if (fallbackText) return fallbackText;
        var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
        for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
        var minEnd = startLength - start;
        for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
        return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
      }
      function getEventCharCode(nativeEvent) {
        var keyCode = nativeEvent.keyCode;
        "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
        10 === nativeEvent && (nativeEvent = 13);
        return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
      }
      function functionThatReturnsTrue() {
        return true;
      }
      function functionThatReturnsFalse() {
        return false;
      }
      function createSyntheticEvent(Interface) {
        function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
          this._reactName = reactName;
          this._targetInst = targetInst;
          this.type = reactEventType;
          this.nativeEvent = nativeEvent;
          this.target = nativeEventTarget;
          this.currentTarget = null;
          for (var propName in Interface)
            Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
          this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
          this.isPropagationStopped = functionThatReturnsFalse;
          return this;
        }
        assign(SyntheticBaseEvent.prototype, {
          preventDefault: function() {
            this.defaultPrevented = true;
            var event = this.nativeEvent;
            event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
          },
          stopPropagation: function() {
            var event = this.nativeEvent;
            event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
          },
          persist: function() {
          },
          isPersistent: functionThatReturnsTrue
        });
        return SyntheticBaseEvent;
      }
      var EventInterface = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(event) {
          return event.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
      }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: getEventModifierState,
        button: 0,
        buttons: 0,
        relatedTarget: function(event) {
          return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
        },
        movementX: function(event) {
          if ("movementX" in event) return event.movementX;
          event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
          return lastMovementX;
        },
        movementY: function(event) {
          return "movementY" in event ? event.movementY : lastMovementY;
        }
      }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, {
        clipboardData: function(event) {
          return "clipboardData" in event ? event.clipboardData : window.clipboardData;
        }
      }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface), normalizeKey = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      }, translateToKey = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      }, modifierKeyToProp = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
      };
      function modifierStateGetter(keyArg) {
        var nativeEvent = this.nativeEvent;
        return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
      }
      function getEventModifierState() {
        return modifierStateGetter;
      }
      var KeyboardEventInterface = assign({}, UIEventInterface, {
        key: function(nativeEvent) {
          if (nativeEvent.key) {
            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if ("Unidentified" !== key) return key;
          }
          return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: getEventModifierState,
        charCode: function(event) {
          return "keypress" === event.type ? getEventCharCode(event) : 0;
        },
        keyCode: function(event) {
          return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        },
        which: function(event) {
          return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        }
      }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign({}, MouseEventInterface, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
      }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign({}, UIEventInterface, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: getEventModifierState
      }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign({}, EventInterface, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign({}, MouseEventInterface, {
        deltaX: function(event) {
          return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
        },
        deltaY: function(event) {
          return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign({}, EventInterface, {
        newState: 0,
        oldState: 0
      }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
      canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
      var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CHAR = String.fromCharCode(32), hasSpaceKeypress = false;
      function isFallbackCompositionEnd(domEventName, nativeEvent) {
        switch (domEventName) {
          case "keyup":
            return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
          case "keydown":
            return 229 !== nativeEvent.keyCode;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function getDataFromCustomEvent(nativeEvent) {
        nativeEvent = nativeEvent.detail;
        return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
      }
      var isComposing = false;
      function getNativeBeforeInputChars(domEventName, nativeEvent) {
        switch (domEventName) {
          case "compositionend":
            return getDataFromCustomEvent(nativeEvent);
          case "keypress":
            if (32 !== nativeEvent.which) return null;
            hasSpaceKeypress = true;
            return SPACEBAR_CHAR;
          case "textInput":
            return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
          default:
            return null;
        }
      }
      function getFallbackBeforeInputChars(domEventName, nativeEvent) {
        if (isComposing)
          return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
        switch (domEventName) {
          case "paste":
            return null;
          case "keypress":
            if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
              if (nativeEvent.char && 1 < nativeEvent.char.length)
                return nativeEvent.char;
              if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
            }
            return null;
          case "compositionend":
            return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
          default:
            return null;
        }
      }
      var supportedInputTypes = {
        color: true,
        date: true,
        datetime: true,
        "datetime-local": true,
        email: true,
        month: true,
        number: true,
        password: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true
      };
      function isTextInputElement(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
      }
      function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
        restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
        inst = accumulateTwoPhaseListeners(inst, "onChange");
        0 < inst.length && (nativeEvent = new SyntheticEvent(
          "onChange",
          "change",
          null,
          nativeEvent,
          target
        ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
      }
      var activeElement$1 = null, activeElementInst$1 = null;
      function runEventInBatch(dispatchQueue) {
        processDispatchQueue(dispatchQueue, 0);
      }
      function getInstIfValueChanged(targetInst) {
        var targetNode = getNodeFromInstance(targetInst);
        if (updateValueIfChanged(targetNode)) return targetInst;
      }
      function getTargetInstForChangeEvent(domEventName, targetInst) {
        if ("change" === domEventName) return targetInst;
      }
      var isInputEventSupported = false;
      if (canUseDOM) {
        var JSCompiler_inline_result$jscomp$286;
        if (canUseDOM) {
          var isSupported$jscomp$inline_427 = "oninput" in document;
          if (!isSupported$jscomp$inline_427) {
            var element$jscomp$inline_428 = document.createElement("div");
            element$jscomp$inline_428.setAttribute("oninput", "return;");
            isSupported$jscomp$inline_427 = "function" === typeof element$jscomp$inline_428.oninput;
          }
          JSCompiler_inline_result$jscomp$286 = isSupported$jscomp$inline_427;
        } else JSCompiler_inline_result$jscomp$286 = false;
        isInputEventSupported = JSCompiler_inline_result$jscomp$286 && (!document.documentMode || 9 < document.documentMode);
      }
      function stopWatchingForValueChange() {
        activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
      }
      function handlePropertyChange(nativeEvent) {
        if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
          var dispatchQueue = [];
          createAndAccumulateChangeEvent(
            dispatchQueue,
            activeElementInst$1,
            nativeEvent,
            getEventTarget(nativeEvent)
          );
          batchedUpdates$1(runEventInBatch, dispatchQueue);
        }
      }
      function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
        "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
      }
      function getTargetInstForInputEventPolyfill(domEventName) {
        if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
          return getInstIfValueChanged(activeElementInst$1);
      }
      function getTargetInstForClickEvent(domEventName, targetInst) {
        if ("click" === domEventName) return getInstIfValueChanged(targetInst);
      }
      function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
        if ("input" === domEventName || "change" === domEventName)
          return getInstIfValueChanged(targetInst);
      }
      function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = "function" === typeof Object.is ? Object.is : is;
      function shallowEqual(objA, objB) {
        if (objectIs(objA, objB)) return true;
        if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
          return false;
        var keysA = Object.keys(objA), keysB = Object.keys(objB);
        if (keysA.length !== keysB.length) return false;
        for (keysB = 0; keysB < keysA.length; keysB++) {
          var currentKey = keysA[keysB];
          if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
            return false;
        }
        return true;
      }
      function getLeafNode(node) {
        for (; node && node.firstChild; ) node = node.firstChild;
        return node;
      }
      function getNodeForCharacterOffset(root2, offset) {
        var node = getLeafNode(root2);
        root2 = 0;
        for (var nodeEnd; node; ) {
          if (3 === node.nodeType) {
            nodeEnd = root2 + node.textContent.length;
            if (root2 <= offset && nodeEnd >= offset)
              return { node, offset: offset - root2 };
            root2 = nodeEnd;
          }
          a: {
            for (; node; ) {
              if (node.nextSibling) {
                node = node.nextSibling;
                break a;
              }
              node = node.parentNode;
            }
            node = void 0;
          }
          node = getLeafNode(node);
        }
      }
      function containsNode(outerNode, innerNode) {
        return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
      }
      function getActiveElementDeep(containerInfo) {
        containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
        for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
          try {
            var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
          } catch (err) {
            JSCompiler_inline_result = false;
          }
          if (JSCompiler_inline_result) containerInfo = element.contentWindow;
          else break;
          element = getActiveElement(containerInfo.document);
        }
        return element;
      }
      function hasSelectionCapabilities(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
      }
      var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false;
      function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
        var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
        mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
          anchorNode: doc.anchorNode,
          anchorOffset: doc.anchorOffset,
          focusNode: doc.focusNode,
          focusOffset: doc.focusOffset
        }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
          "onSelect",
          "select",
          null,
          nativeEvent,
          nativeEventTarget
        ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
      }
      function makePrefixMap(styleProp, eventName) {
        var prefixes = {};
        prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
        prefixes["Webkit" + styleProp] = "webkit" + eventName;
        prefixes["Moz" + styleProp] = "moz" + eventName;
        return prefixes;
      }
      var vendorPrefixes = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        animationiteration: makePrefixMap("Animation", "AnimationIteration"),
        animationstart: makePrefixMap("Animation", "AnimationStart"),
        transitionrun: makePrefixMap("Transition", "TransitionRun"),
        transitionstart: makePrefixMap("Transition", "TransitionStart"),
        transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
      }, prefixedEventNames = {}, style = {};
      canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
      function getVendorPrefixedEventName(eventName) {
        if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
        if (!vendorPrefixes[eventName]) return eventName;
        var prefixMap = vendorPrefixes[eventName], styleProp;
        for (styleProp in prefixMap)
          if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
            return prefixedEventNames[eventName] = prefixMap[styleProp];
        return eventName;
      }
      var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
        " "
      );
      simpleEventPluginEvents.push("scrollEnd");
      function registerSimpleEvent(domEventName, reactName) {
        topLevelEventsToReactNames.set(domEventName, reactName);
        registerTwoPhaseEvent(reactName, [domEventName]);
      }
      var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      }, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0;
      function finishQueueingConcurrentUpdates() {
        for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
          var fiber = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var queue = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var update = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var lane = concurrentQueues[i];
          concurrentQueues[i++] = null;
          if (null !== queue && null !== update) {
            var pending = queue.pending;
            null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
            queue.pending = update;
          }
          0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
        }
      }
      function enqueueUpdate$1(fiber, queue, update, lane) {
        concurrentQueues[concurrentQueuesIndex++] = fiber;
        concurrentQueues[concurrentQueuesIndex++] = queue;
        concurrentQueues[concurrentQueuesIndex++] = update;
        concurrentQueues[concurrentQueuesIndex++] = lane;
        concurrentlyUpdatedLanes |= lane;
        fiber.lanes |= lane;
        fiber = fiber.alternate;
        null !== fiber && (fiber.lanes |= lane);
      }
      function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
        enqueueUpdate$1(fiber, queue, update, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function enqueueConcurrentRenderForLane(fiber, lane) {
        enqueueUpdate$1(fiber, null, null, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
        sourceFiber.lanes |= lane;
        var alternate = sourceFiber.alternate;
        null !== alternate && (alternate.lanes |= lane);
        for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
          parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
        return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
      }
      function getRootForUpdatedFiber(sourceFiber) {
        if (50 < nestedUpdateCount)
          throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
        for (var parent = sourceFiber.return; null !== parent; )
          sourceFiber = parent, parent = sourceFiber.return;
        return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
      }
      var emptyContextObject = {};
      function FiberNode(tag, pendingProps, key, mode) {
        this.tag = tag;
        this.key = key;
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
        this.index = 0;
        this.refCleanup = this.ref = null;
        this.pendingProps = pendingProps;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = mode;
        this.subtreeFlags = this.flags = 0;
        this.deletions = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
      }
      function createFiberImplClass(tag, pendingProps, key, mode) {
        return new FiberNode(tag, pendingProps, key, mode);
      }
      function shouldConstruct(Component) {
        Component = Component.prototype;
        return !(!Component || !Component.isReactComponent);
      }
      function createWorkInProgress(current, pendingProps) {
        var workInProgress2 = current.alternate;
        null === workInProgress2 ? (workInProgress2 = createFiberImplClass(
          current.tag,
          pendingProps,
          current.key,
          current.mode
        ), workInProgress2.elementType = current.elementType, workInProgress2.type = current.type, workInProgress2.stateNode = current.stateNode, workInProgress2.alternate = current, current.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null);
        workInProgress2.flags = current.flags & 65011712;
        workInProgress2.childLanes = current.childLanes;
        workInProgress2.lanes = current.lanes;
        workInProgress2.child = current.child;
        workInProgress2.memoizedProps = current.memoizedProps;
        workInProgress2.memoizedState = current.memoizedState;
        workInProgress2.updateQueue = current.updateQueue;
        pendingProps = current.dependencies;
        workInProgress2.dependencies = null === pendingProps ? null : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
        workInProgress2.sibling = current.sibling;
        workInProgress2.index = current.index;
        workInProgress2.ref = current.ref;
        workInProgress2.refCleanup = current.refCleanup;
        return workInProgress2;
      }
      function resetWorkInProgress(workInProgress2, renderLanes2) {
        workInProgress2.flags &= 65011714;
        var current = workInProgress2.alternate;
        null === current ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null) : (workInProgress2.childLanes = current.childLanes, workInProgress2.lanes = current.lanes, workInProgress2.child = current.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current.memoizedProps, workInProgress2.memoizedState = current.memoizedState, workInProgress2.updateQueue = current.updateQueue, workInProgress2.type = current.type, renderLanes2 = current.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
          lanes: renderLanes2.lanes,
          firstContext: renderLanes2.firstContext
        });
        return workInProgress2;
      }
      function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
        var fiberTag = 0;
        owner = type;
        if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
        else if ("string" === typeof type)
          fiberTag = isHostHoistableType(
            type,
            pendingProps,
            contextStackCursor.current
          ) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
        else
          a: switch (type) {
            case REACT_ACTIVITY_TYPE:
              return type = createFiberImplClass(31, pendingProps, key, mode), type.elementType = REACT_ACTIVITY_TYPE, type.lanes = lanes, type;
            case REACT_FRAGMENT_TYPE:
              return createFiberFromFragment(pendingProps.children, mode, lanes, key);
            case REACT_STRICT_MODE_TYPE:
              fiberTag = 8;
              mode |= 24;
              break;
            case REACT_PROFILER_TYPE:
              return type = createFiberImplClass(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;
            case REACT_SUSPENSE_TYPE:
              return type = createFiberImplClass(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;
            case REACT_SUSPENSE_LIST_TYPE:
              return type = createFiberImplClass(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
            default:
              if ("object" === typeof type && null !== type)
                switch (type.$$typeof) {
                  case REACT_CONTEXT_TYPE:
                    fiberTag = 10;
                    break a;
                  case REACT_CONSUMER_TYPE:
                    fiberTag = 9;
                    break a;
                  case REACT_FORWARD_REF_TYPE:
                    fiberTag = 11;
                    break a;
                  case REACT_MEMO_TYPE:
                    fiberTag = 14;
                    break a;
                  case REACT_LAZY_TYPE:
                    fiberTag = 16;
                    owner = null;
                    break a;
                }
              fiberTag = 29;
              pendingProps = Error(
                formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
              );
              owner = null;
          }
        key = createFiberImplClass(fiberTag, pendingProps, key, mode);
        key.elementType = type;
        key.type = owner;
        key.lanes = lanes;
        return key;
      }
      function createFiberFromFragment(elements, mode, lanes, key) {
        elements = createFiberImplClass(7, elements, key, mode);
        elements.lanes = lanes;
        return elements;
      }
      function createFiberFromText(content, mode, lanes) {
        content = createFiberImplClass(6, content, null, mode);
        content.lanes = lanes;
        return content;
      }
      function createFiberFromDehydratedFragment(dehydratedNode) {
        var fiber = createFiberImplClass(18, null, null, 0);
        fiber.stateNode = dehydratedNode;
        return fiber;
      }
      function createFiberFromPortal(portal, mode, lanes) {
        mode = createFiberImplClass(
          4,
          null !== portal.children ? portal.children : [],
          portal.key,
          mode
        );
        mode.lanes = lanes;
        mode.stateNode = {
          containerInfo: portal.containerInfo,
          pendingChildren: null,
          implementation: portal.implementation
        };
        return mode;
      }
      var CapturedStacks = /* @__PURE__ */ new WeakMap();
      function createCapturedValueAtFiber(value, source) {
        if ("object" === typeof value && null !== value) {
          var existing = CapturedStacks.get(value);
          if (void 0 !== existing) return existing;
          source = {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source)
          };
          CapturedStacks.set(value, source);
          return source;
        }
        return {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source)
        };
      }
      var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "";
      function pushTreeFork(workInProgress2, totalChildren) {
        forkStack[forkStackIndex++] = treeForkCount;
        forkStack[forkStackIndex++] = treeForkProvider;
        treeForkProvider = workInProgress2;
        treeForkCount = totalChildren;
      }
      function pushTreeId(workInProgress2, totalChildren, index2) {
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextProvider = workInProgress2;
        var baseIdWithLeadingBit = treeContextId;
        workInProgress2 = treeContextOverflow;
        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
        baseIdWithLeadingBit &= ~(1 << baseLength);
        index2 += 1;
        var length = 32 - clz32(totalChildren) + baseLength;
        if (30 < length) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
          baseIdWithLeadingBit >>= numberOfOverflowBits;
          baseLength -= numberOfOverflowBits;
          treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index2 << baseLength | baseIdWithLeadingBit;
          treeContextOverflow = length + workInProgress2;
        } else
          treeContextId = 1 << length | index2 << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
      }
      function pushMaterializedTreeId(workInProgress2) {
        null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
      }
      function popTreeContext(workInProgress2) {
        for (; workInProgress2 === treeForkProvider; )
          treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
        for (; workInProgress2 === treeContextProvider; )
          treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
      }
      function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextId = suspendedContext.id;
        treeContextOverflow = suspendedContext.overflow;
        treeContextProvider = workInProgress2;
      }
      var hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(formatProdErrorMessage(519));
      function throwOnHydrationMismatch(fiber) {
        var error = Error(
          formatProdErrorMessage(
            418,
            1 < arguments.length && void 0 !== arguments[1] && arguments[1] ? "text" : "HTML",
            ""
          )
        );
        queueHydrationError(createCapturedValueAtFiber(error, fiber));
        throw HydrationMismatchException;
      }
      function prepareToHydrateHostInstance(fiber) {
        var instance = fiber.stateNode, type = fiber.type, props = fiber.memoizedProps;
        instance[internalInstanceKey] = fiber;
        instance[internalPropsKey] = props;
        switch (type) {
          case "dialog":
            listenToNonDelegatedEvent("cancel", instance);
            listenToNonDelegatedEvent("close", instance);
            break;
          case "iframe":
          case "object":
          case "embed":
            listenToNonDelegatedEvent("load", instance);
            break;
          case "video":
          case "audio":
            for (type = 0; type < mediaEventTypes.length; type++)
              listenToNonDelegatedEvent(mediaEventTypes[type], instance);
            break;
          case "source":
            listenToNonDelegatedEvent("error", instance);
            break;
          case "img":
          case "image":
          case "link":
            listenToNonDelegatedEvent("error", instance);
            listenToNonDelegatedEvent("load", instance);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", instance);
            break;
          case "input":
            listenToNonDelegatedEvent("invalid", instance);
            initInput(
              instance,
              props.value,
              props.defaultValue,
              props.checked,
              props.defaultChecked,
              props.type,
              props.name,
              true
            );
            break;
          case "select":
            listenToNonDelegatedEvent("invalid", instance);
            break;
          case "textarea":
            listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children);
        }
        type = props.children;
        "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || instance.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(instance.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance), null != props.onClick && (instance.onclick = noop$1), instance = true) : instance = false;
        instance || throwOnHydrationMismatch(fiber, true);
      }
      function popToNextHostParent(fiber) {
        for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
          switch (hydrationParentFiber.tag) {
            case 5:
            case 31:
            case 13:
              rootOrSingletonContext = false;
              return;
            case 27:
            case 3:
              rootOrSingletonContext = true;
              return;
            default:
              hydrationParentFiber = hydrationParentFiber.return;
          }
      }
      function popHydrationState(fiber) {
        if (fiber !== hydrationParentFiber) return false;
        if (!isHydrating) return popToNextHostParent(fiber), isHydrating = true, false;
        var tag = fiber.tag, JSCompiler_temp;
        if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
          if (JSCompiler_temp = 5 === tag)
            JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
          JSCompiler_temp = !JSCompiler_temp;
        }
        JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
        popToNextHostParent(fiber);
        if (13 === tag) {
          fiber = fiber.memoizedState;
          fiber = null !== fiber ? fiber.dehydrated : null;
          if (!fiber) throw Error(formatProdErrorMessage(317));
          nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
        } else if (31 === tag) {
          fiber = fiber.memoizedState;
          fiber = null !== fiber ? fiber.dehydrated : null;
          if (!fiber) throw Error(formatProdErrorMessage(317));
          nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
        } else
          27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
        return true;
      }
      function resetHydrationState() {
        nextHydratableInstance = hydrationParentFiber = null;
        isHydrating = false;
      }
      function upgradeHydrationErrorsToRecoverable() {
        var queuedErrors = hydrationErrors;
        null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
          workInProgressRootRecoverableErrors,
          queuedErrors
        ), hydrationErrors = null);
        return queuedErrors;
      }
      function queueHydrationError(error) {
        null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
      }
      var valueCursor = createCursor(null), currentlyRenderingFiber$1 = null, lastContextDependency = null;
      function pushProvider(providerFiber, context, nextValue) {
        push(valueCursor, context._currentValue);
        context._currentValue = nextValue;
      }
      function popProvider(context) {
        context._currentValue = valueCursor.current;
        pop(valueCursor);
      }
      function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
        for (; null !== parent; ) {
          var alternate = parent.alternate;
          (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
          if (parent === propagationRoot) break;
          parent = parent.return;
        }
      }
      function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
        var fiber = workInProgress2.child;
        null !== fiber && (fiber.return = workInProgress2);
        for (; null !== fiber; ) {
          var list = fiber.dependencies;
          if (null !== list) {
            var nextFiber = fiber.child;
            list = list.firstContext;
            a: for (; null !== list; ) {
              var dependency = list;
              list = fiber;
              for (var i = 0; i < contexts.length; i++)
                if (dependency.context === contexts[i]) {
                  list.lanes |= renderLanes2;
                  dependency = list.alternate;
                  null !== dependency && (dependency.lanes |= renderLanes2);
                  scheduleContextWorkOnParentPath(
                    list.return,
                    renderLanes2,
                    workInProgress2
                  );
                  forcePropagateEntireTree || (nextFiber = null);
                  break a;
                }
              list = dependency.next;
            }
          } else if (18 === fiber.tag) {
            nextFiber = fiber.return;
            if (null === nextFiber) throw Error(formatProdErrorMessage(341));
            nextFiber.lanes |= renderLanes2;
            list = nextFiber.alternate;
            null !== list && (list.lanes |= renderLanes2);
            scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
            nextFiber = null;
          } else nextFiber = fiber.child;
          if (null !== nextFiber) nextFiber.return = fiber;
          else
            for (nextFiber = fiber; null !== nextFiber; ) {
              if (nextFiber === workInProgress2) {
                nextFiber = null;
                break;
              }
              fiber = nextFiber.sibling;
              if (null !== fiber) {
                fiber.return = nextFiber.return;
                nextFiber = fiber;
                break;
              }
              nextFiber = nextFiber.return;
            }
          fiber = nextFiber;
        }
      }
      function propagateParentContextChanges(current, workInProgress2, renderLanes2, forcePropagateEntireTree) {
        current = null;
        for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
          if (!isInsidePropagationBailout) {
            if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
            else if (0 !== (parent.flags & 262144)) break;
          }
          if (10 === parent.tag) {
            var currentParent = parent.alternate;
            if (null === currentParent) throw Error(formatProdErrorMessage(387));
            currentParent = currentParent.memoizedProps;
            if (null !== currentParent) {
              var context = parent.type;
              objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
            }
          } else if (parent === hostTransitionProviderCursor.current) {
            currentParent = parent.alternate;
            if (null === currentParent) throw Error(formatProdErrorMessage(387));
            currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
          }
          parent = parent.return;
        }
        null !== current && propagateContextChanges(
          workInProgress2,
          current,
          renderLanes2,
          forcePropagateEntireTree
        );
        workInProgress2.flags |= 262144;
      }
      function checkIfContextChanged(currentDependencies) {
        for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
          if (!objectIs(
            currentDependencies.context._currentValue,
            currentDependencies.memoizedValue
          ))
            return true;
          currentDependencies = currentDependencies.next;
        }
        return false;
      }
      function prepareToReadContext(workInProgress2) {
        currentlyRenderingFiber$1 = workInProgress2;
        lastContextDependency = null;
        workInProgress2 = workInProgress2.dependencies;
        null !== workInProgress2 && (workInProgress2.firstContext = null);
      }
      function readContext(context) {
        return readContextForConsumer(currentlyRenderingFiber$1, context);
      }
      function readContextDuringReconciliation(consumer, context) {
        null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
        return readContextForConsumer(consumer, context);
      }
      function readContextForConsumer(consumer, context) {
        var value = context._currentValue;
        context = { context, memoizedValue: value, next: null };
        if (null === lastContextDependency) {
          if (null === consumer) throw Error(formatProdErrorMessage(308));
          lastContextDependency = context;
          consumer.dependencies = { lanes: 0, firstContext: context };
          consumer.flags |= 524288;
        } else lastContextDependency = lastContextDependency.next = context;
        return value;
      }
      var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
        var listeners = [], signal = this.signal = {
          aborted: false,
          addEventListener: function(type, listener) {
            listeners.push(listener);
          }
        };
        this.abort = function() {
          signal.aborted = true;
          listeners.forEach(function(listener) {
            return listener();
          });
        };
      }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0
      };
      function createCache() {
        return {
          controller: new AbortControllerLocal(),
          data: /* @__PURE__ */ new Map(),
          refCount: 0
        };
      }
      function releaseCache(cache) {
        cache.refCount--;
        0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
          cache.controller.abort();
        });
      }
      var currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null;
      function entangleAsyncAction(transition, thenable) {
        if (null === currentEntangledListeners) {
          var entangledListeners = currentEntangledListeners = [];
          currentEntangledPendingCount = 0;
          currentEntangledLane = requestTransitionLane();
          currentEntangledActionThenable = {
            status: "pending",
            value: void 0,
            then: function(resolve) {
              entangledListeners.push(resolve);
            }
          };
        }
        currentEntangledPendingCount++;
        thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
        return thenable;
      }
      function pingEngtangledActionScope() {
        if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
          null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
          var listeners = currentEntangledListeners;
          currentEntangledListeners = null;
          currentEntangledLane = 0;
          currentEntangledActionThenable = null;
          for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
        }
      }
      function chainThenableValue(thenable, result) {
        var listeners = [], thenableWithOverride = {
          status: "pending",
          value: null,
          reason: null,
          then: function(resolve) {
            listeners.push(resolve);
          }
        };
        thenable.then(
          function() {
            thenableWithOverride.status = "fulfilled";
            thenableWithOverride.value = result;
            for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
          },
          function(error) {
            thenableWithOverride.status = "rejected";
            thenableWithOverride.reason = error;
            for (error = 0; error < listeners.length; error++)
              (0, listeners[error])(void 0);
          }
        );
        return thenableWithOverride;
      }
      var prevOnStartTransitionFinish = ReactSharedInternals.S;
      ReactSharedInternals.S = function(transition, returnValue) {
        globalMostRecentTransitionTime = now();
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
        null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
      };
      var resumedCache = createCursor(null);
      function peekCacheFromPool() {
        var cacheResumedFromPreviousRender = resumedCache.current;
        return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
      }
      function pushTransition(offscreenWorkInProgress, prevCachePool) {
        null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
      }
      function getSuspendedCache() {
        var cacheFromPool = peekCacheFromPool();
        return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
      }
      var SuspenseException = Error(formatProdErrorMessage(460)), SuspenseyCommitException = Error(formatProdErrorMessage(474)), SuspenseActionException = Error(formatProdErrorMessage(542)), noopSuspenseyCommitThenable = { then: function() {
      } };
      function isThenableResolved(thenable) {
        thenable = thenable.status;
        return "fulfilled" === thenable || "rejected" === thenable;
      }
      function trackUsedThenable(thenableState2, thenable, index2) {
        index2 = thenableState2[index2];
        void 0 === index2 ? thenableState2.push(thenable) : index2 !== thenable && (thenable.then(noop$1, noop$1), thenable = index2);
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
          default:
            if ("string" === typeof thenable.status) thenable.then(noop$1, noop$1);
            else {
              thenableState2 = workInProgressRoot;
              if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
                throw Error(formatProdErrorMessage(482));
              thenableState2 = thenable;
              thenableState2.status = "pending";
              thenableState2.then(
                function(fulfilledValue) {
                  if ("pending" === thenable.status) {
                    var fulfilledThenable = thenable;
                    fulfilledThenable.status = "fulfilled";
                    fulfilledThenable.value = fulfilledValue;
                  }
                },
                function(error) {
                  if ("pending" === thenable.status) {
                    var rejectedThenable = thenable;
                    rejectedThenable.status = "rejected";
                    rejectedThenable.reason = error;
                  }
                }
              );
            }
            switch (thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
            }
            suspendedThenable = thenable;
            throw SuspenseException;
        }
      }
      function resolveLazy(lazyType) {
        try {
          var init = lazyType._init;
          return init(lazyType._payload);
        } catch (x) {
          if (null !== x && "object" === typeof x && "function" === typeof x.then)
            throw suspendedThenable = x, SuspenseException;
          throw x;
        }
      }
      var suspendedThenable = null;
      function getSuspendedThenable() {
        if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
        var thenable = suspendedThenable;
        suspendedThenable = null;
        return thenable;
      }
      function checkIfUseWrappedInAsyncCatch(rejectedReason) {
        if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
          throw Error(formatProdErrorMessage(483));
      }
      var thenableState$1 = null, thenableIndexCounter$1 = 0;
      function unwrapThenable(thenable) {
        var index2 = thenableIndexCounter$1;
        thenableIndexCounter$1 += 1;
        null === thenableState$1 && (thenableState$1 = []);
        return trackUsedThenable(thenableState$1, thenable, index2);
      }
      function coerceRef(workInProgress2, element) {
        element = element.props.ref;
        workInProgress2.ref = void 0 !== element ? element : null;
      }
      function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
        if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
          throw Error(formatProdErrorMessage(525));
        returnFiber = Object.prototype.toString.call(newChild);
        throw Error(
          formatProdErrorMessage(
            31,
            "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber
          )
        );
      }
      function createChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
          if (shouldTrackSideEffects) {
            var deletions = returnFiber.deletions;
            null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
          }
        }
        function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects) return null;
          for (; null !== currentFirstChild; )
            deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
          return null;
        }
        function mapRemainingChildren(currentFirstChild) {
          for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
            null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
          return existingChildren;
        }
        function useFiber(fiber, pendingProps) {
          fiber = createWorkInProgress(fiber, pendingProps);
          fiber.index = 0;
          fiber.sibling = null;
          return fiber;
        }
        function placeChild(newFiber, lastPlacedIndex, newIndex) {
          newFiber.index = newIndex;
          if (!shouldTrackSideEffects)
            return newFiber.flags |= 1048576, lastPlacedIndex;
          newIndex = newFiber.alternate;
          if (null !== newIndex)
            return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
          newFiber.flags |= 67108866;
          return lastPlacedIndex;
        }
        function placeSingleChild(newFiber) {
          shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
          return newFiber;
        }
        function updateTextNode(returnFiber, current, textContent, lanes) {
          if (null === current || 6 !== current.tag)
            return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
          current = useFiber(current, textContent);
          current.return = returnFiber;
          return current;
        }
        function updateElement(returnFiber, current, element, lanes) {
          var elementType = element.type;
          if (elementType === REACT_FRAGMENT_TYPE)
            return updateFragment(
              returnFiber,
              current,
              element.props.children,
              lanes,
              element.key
            );
          if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type))
            return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
          current = createFiberFromTypeAndProps(
            element.type,
            element.key,
            element.props,
            null,
            returnFiber.mode,
            lanes
          );
          coerceRef(current, element);
          current.return = returnFiber;
          return current;
        }
        function updatePortal(returnFiber, current, portal, lanes) {
          if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation)
            return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
          current = useFiber(current, portal.children || []);
          current.return = returnFiber;
          return current;
        }
        function updateFragment(returnFiber, current, fragment, lanes, key) {
          if (null === current || 7 !== current.tag)
            return current = createFiberFromFragment(
              fragment,
              returnFiber.mode,
              lanes,
              key
            ), current.return = returnFiber, current;
          current = useFiber(current, fragment);
          current.return = returnFiber;
          return current;
        }
        function createChild(returnFiber, newChild, lanes) {
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return newChild = createFiberFromText(
              "" + newChild,
              returnFiber.mode,
              lanes
            ), newChild.return = returnFiber, newChild;
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return lanes = createFiberFromTypeAndProps(
                  newChild.type,
                  newChild.key,
                  newChild.props,
                  null,
                  returnFiber.mode,
                  lanes
                ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
              case REACT_PORTAL_TYPE:
                return newChild = createFiberFromPortal(
                  newChild,
                  returnFiber.mode,
                  lanes
                ), newChild.return = returnFiber, newChild;
              case REACT_LAZY_TYPE:
                return newChild = resolveLazy(newChild), createChild(returnFiber, newChild, lanes);
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return newChild = createFiberFromFragment(
                newChild,
                returnFiber.mode,
                lanes,
                null
              ), newChild.return = returnFiber, newChild;
            if ("function" === typeof newChild.then)
              return createChild(returnFiber, unwrapThenable(newChild), lanes);
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return createChild(
                returnFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectTypeImpl(returnFiber, newChild);
          }
          return null;
        }
        function updateSlot(returnFiber, oldFiber, newChild, lanes) {
          var key = null !== oldFiber ? oldFiber.key : null;
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_PORTAL_TYPE:
                return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_LAZY_TYPE:
                return newChild = resolveLazy(newChild), updateSlot(returnFiber, oldFiber, newChild, lanes);
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
            if ("function" === typeof newChild.then)
              return updateSlot(
                returnFiber,
                oldFiber,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateSlot(
                returnFiber,
                oldFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectTypeImpl(returnFiber, newChild);
          }
          return null;
        }
        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return existingChildren = existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
              case REACT_PORTAL_TYPE:
                return existingChildren = existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
              case REACT_LAZY_TYPE:
                return newChild = resolveLazy(newChild), updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes
                );
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
            if ("function" === typeof newChild.then)
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectTypeImpl(returnFiber, newChild);
          }
          return null;
        }
        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(
              returnFiber,
              oldFiber,
              newChildren[newIdx],
              lanes
            );
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (newIdx === newChildren.length)
            return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
          if (null === oldFiber) {
            for (; newIdx < newChildren.length; newIdx++)
              oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(
                oldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
            nextOldFiber = updateFromMap(
              oldFiber,
              returnFiber,
              newIdx,
              newChildren[newIdx],
              lanes
            ), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
              null === nextOldFiber.key ? newIdx : nextOldFiber.key
            ), currentFirstChild = placeChild(
              nextOldFiber,
              currentFirstChild,
              newIdx
            ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
          shouldTrackSideEffects && oldFiber.forEach(function(child) {
            return deleteChild(returnFiber, child);
          });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
          if (null == newChildren) throw Error(formatProdErrorMessage(151));
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (step.done)
            return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
          if (null === oldFiber) {
            for (; !step.done; newIdx++, step = newChildren.next())
              step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
            step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
          shouldTrackSideEffects && oldFiber.forEach(function(child) {
            return deleteChild(returnFiber, child);
          });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
          "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                a: {
                  for (var key = newChild.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === key) {
                      key = newChild.type;
                      if (key === REACT_FRAGMENT_TYPE) {
                        if (7 === currentFirstChild.tag) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(
                            currentFirstChild,
                            newChild.props.children
                          );
                          lanes.return = returnFiber;
                          returnFiber = lanes;
                          break a;
                        }
                      } else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(currentFirstChild, newChild.props);
                        coerceRef(lanes, newChild);
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      }
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    } else deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                    newChild.props.children,
                    returnFiber.mode,
                    lanes,
                    newChild.key
                  ), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(
                    newChild.type,
                    newChild.key,
                    newChild.props,
                    null,
                    returnFiber.mode,
                    lanes
                  ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
                }
                return placeSingleChild(returnFiber);
              case REACT_PORTAL_TYPE:
                a: {
                  for (key = newChild.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === key)
                      if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(currentFirstChild, newChild.children || []);
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      } else {
                        deleteRemainingChildren(returnFiber, currentFirstChild);
                        break;
                      }
                    else deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                }
                return placeSingleChild(returnFiber);
              case REACT_LAZY_TYPE:
                return newChild = resolveLazy(newChild), reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes
                );
            }
            if (isArrayImpl(newChild))
              return reconcileChildrenArray(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
            if (getIteratorFn(newChild)) {
              key = getIteratorFn(newChild);
              if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
              newChild = key.call(newChild);
              return reconcileChildrenIterator(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
            }
            if ("function" === typeof newChild.then)
              return reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectTypeImpl(returnFiber, newChild);
          }
          return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
        }
        return function(returnFiber, currentFirstChild, newChild, lanes) {
          try {
            thenableIndexCounter$1 = 0;
            var firstChildFiber = reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
            thenableState$1 = null;
            return firstChildFiber;
          } catch (x) {
            if (x === SuspenseException || x === SuspenseActionException) throw x;
            var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
            fiber.lanes = lanes;
            fiber.return = returnFiber;
            return fiber;
          } finally {
          }
        };
      }
      var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), hasForceUpdate = false;
      function initializeUpdateQueue(fiber) {
        fiber.updateQueue = {
          baseState: fiber.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: { pending: null, lanes: 0, hiddenCallbacks: null },
          callbacks: null
        };
      }
      function cloneUpdateQueue(current, workInProgress2) {
        current = current.updateQueue;
        workInProgress2.updateQueue === current && (workInProgress2.updateQueue = {
          baseState: current.baseState,
          firstBaseUpdate: current.firstBaseUpdate,
          lastBaseUpdate: current.lastBaseUpdate,
          shared: current.shared,
          callbacks: null
        });
      }
      function createUpdate(lane) {
        return { lane, tag: 0, payload: null, callback: null, next: null };
      }
      function enqueueUpdate(fiber, update, lane) {
        var updateQueue = fiber.updateQueue;
        if (null === updateQueue) return null;
        updateQueue = updateQueue.shared;
        if (0 !== (executionContext & 2)) {
          var pending = updateQueue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          updateQueue.pending = update;
          update = getRootForUpdatedFiber(fiber);
          markUpdateLaneFromFiberToRoot(fiber, null, lane);
          return update;
        }
        enqueueUpdate$1(fiber, updateQueue, update, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function entangleTransitions(root2, fiber, lane) {
        fiber = fiber.updateQueue;
        if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
          var queueLanes = fiber.lanes;
          queueLanes &= root2.pendingLanes;
          lane |= queueLanes;
          fiber.lanes = lane;
          markRootEntangled(root2, lane);
        }
      }
      function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
        var queue = workInProgress2.updateQueue, current = workInProgress2.alternate;
        if (null !== current && (current = current.updateQueue, queue === current)) {
          var newFirst = null, newLast = null;
          queue = queue.firstBaseUpdate;
          if (null !== queue) {
            do {
              var clone = {
                lane: queue.lane,
                tag: queue.tag,
                payload: queue.payload,
                callback: null,
                next: null
              };
              null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
              queue = queue.next;
            } while (null !== queue);
            null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
          } else newFirst = newLast = capturedUpdate;
          queue = {
            baseState: current.baseState,
            firstBaseUpdate: newFirst,
            lastBaseUpdate: newLast,
            shared: current.shared,
            callbacks: current.callbacks
          };
          workInProgress2.updateQueue = queue;
          return;
        }
        workInProgress2 = queue.lastBaseUpdate;
        null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
        queue.lastBaseUpdate = capturedUpdate;
      }
      var didReadFromEntangledAsyncAction = false;
      function suspendIfUpdateReadFromEntangledAsyncAction() {
        if (didReadFromEntangledAsyncAction) {
          var entangledActionThenable = currentEntangledActionThenable;
          if (null !== entangledActionThenable) throw entangledActionThenable;
        }
      }
      function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes2) {
        didReadFromEntangledAsyncAction = false;
        var queue = workInProgress$jscomp$0.updateQueue;
        hasForceUpdate = false;
        var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
        if (null !== pendingQueue) {
          queue.shared.pending = null;
          var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
          lastPendingUpdate.next = null;
          null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
          lastBaseUpdate = lastPendingUpdate;
          var current = workInProgress$jscomp$0.alternate;
          null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
        }
        if (null !== firstBaseUpdate) {
          var newState = queue.baseState;
          lastBaseUpdate = 0;
          current = firstPendingUpdate = lastPendingUpdate = null;
          pendingQueue = firstBaseUpdate;
          do {
            var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
            if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
              0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
              null !== current && (current = current.next = {
                lane: 0,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: null,
                next: null
              });
              a: {
                var workInProgress2 = workInProgress$jscomp$0, update = pendingQueue;
                updateLane = props;
                var instance = instance$jscomp$0;
                switch (update.tag) {
                  case 1:
                    workInProgress2 = update.payload;
                    if ("function" === typeof workInProgress2) {
                      newState = workInProgress2.call(instance, newState, updateLane);
                      break a;
                    }
                    newState = workInProgress2;
                    break a;
                  case 3:
                    workInProgress2.flags = workInProgress2.flags & -65537 | 128;
                  case 0:
                    workInProgress2 = update.payload;
                    updateLane = "function" === typeof workInProgress2 ? workInProgress2.call(instance, newState, updateLane) : workInProgress2;
                    if (null === updateLane || void 0 === updateLane) break a;
                    newState = assign({}, newState, updateLane);
                    break a;
                  case 2:
                    hasForceUpdate = true;
                }
              }
              updateLane = pendingQueue.callback;
              null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
            } else
              isHiddenUpdate = {
                lane: updateLane,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: pendingQueue.callback,
                next: null
              }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
            pendingQueue = pendingQueue.next;
            if (null === pendingQueue)
              if (pendingQueue = queue.shared.pending, null === pendingQueue)
                break;
              else
                isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
          } while (1);
          null === current && (lastPendingUpdate = newState);
          queue.baseState = lastPendingUpdate;
          queue.firstBaseUpdate = firstPendingUpdate;
          queue.lastBaseUpdate = current;
          null === firstBaseUpdate && (queue.shared.lanes = 0);
          workInProgressRootSkippedLanes |= lastBaseUpdate;
          workInProgress$jscomp$0.lanes = lastBaseUpdate;
          workInProgress$jscomp$0.memoizedState = newState;
        }
      }
      function callCallback(callback, context) {
        if ("function" !== typeof callback)
          throw Error(formatProdErrorMessage(191, callback));
        callback.call(context);
      }
      function commitCallbacks(updateQueue, context) {
        var callbacks = updateQueue.callbacks;
        if (null !== callbacks)
          for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
            callCallback(callbacks[updateQueue], context);
      }
      var currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0);
      function pushHiddenContext(fiber, context) {
        fiber = entangledRenderLanes;
        push(prevEntangledRenderLanesCursor, fiber);
        push(currentTreeHiddenStackCursor, context);
        entangledRenderLanes = fiber | context.baseLanes;
      }
      function reuseHiddenContextOnStack() {
        push(prevEntangledRenderLanesCursor, entangledRenderLanes);
        push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
      }
      function popHiddenContext() {
        entangledRenderLanes = prevEntangledRenderLanesCursor.current;
        pop(currentTreeHiddenStackCursor);
        pop(prevEntangledRenderLanesCursor);
      }
      var suspenseHandlerStackCursor = createCursor(null), shellBoundary = null;
      function pushPrimaryTreeSuspenseHandler(handler) {
        var current = handler.alternate;
        push(suspenseStackCursor, suspenseStackCursor.current & 1);
        push(suspenseHandlerStackCursor, handler);
        null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
      }
      function pushDehydratedActivitySuspenseHandler(fiber) {
        push(suspenseStackCursor, suspenseStackCursor.current);
        push(suspenseHandlerStackCursor, fiber);
        null === shellBoundary && (shellBoundary = fiber);
      }
      function pushOffscreenSuspenseHandler(fiber) {
        22 === fiber.tag ? (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary && (shellBoundary = fiber)) : reuseSuspenseHandlerOnStack();
      }
      function reuseSuspenseHandlerOnStack() {
        push(suspenseStackCursor, suspenseStackCursor.current);
        push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
      }
      function popSuspenseHandler(fiber) {
        pop(suspenseHandlerStackCursor);
        shellBoundary === fiber && (shellBoundary = null);
        pop(suspenseStackCursor);
      }
      var suspenseStackCursor = createCursor(0);
      function findFirstSuspended(row) {
        for (var node = row; null !== node; ) {
          if (13 === node.tag) {
            var state = node.memoizedState;
            if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state)))
              return node;
          } else if (19 === node.tag && ("forwards" === node.memoizedProps.revealOrder || "backwards" === node.memoizedProps.revealOrder || "unstable_legacy-backwards" === node.memoizedProps.revealOrder || "together" === node.memoizedProps.revealOrder)) {
            if (0 !== (node.flags & 128)) return node;
          } else if (null !== node.child) {
            node.child.return = node;
            node = node.child;
            continue;
          }
          if (node === row) break;
          for (; null === node.sibling; ) {
            if (null === node.return || node.return === row) return null;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
        return null;
      }
      var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0;
      function throwInvalidHookError() {
        throw Error(formatProdErrorMessage(321));
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (null === prevDeps) return false;
        for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
          if (!objectIs(nextDeps[i], prevDeps[i])) return false;
        return true;
      }
      function renderWithHooks(current, workInProgress2, Component, props, secondArg, nextRenderLanes) {
        renderLanes = nextRenderLanes;
        currentlyRenderingFiber = workInProgress2;
        workInProgress2.memoizedState = null;
        workInProgress2.updateQueue = null;
        workInProgress2.lanes = 0;
        ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
        shouldDoubleInvokeUserFnsInHooksDEV = false;
        nextRenderLanes = Component(props, secondArg);
        shouldDoubleInvokeUserFnsInHooksDEV = false;
        didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(
          workInProgress2,
          Component,
          props,
          secondArg
        ));
        finishRenderingHooks(current);
        return nextRenderLanes;
      }
      function finishRenderingHooks(current) {
        ReactSharedInternals.H = ContextOnlyDispatcher;
        var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
        renderLanes = 0;
        workInProgressHook = currentHook = currentlyRenderingFiber = null;
        didScheduleRenderPhaseUpdate = false;
        thenableIndexCounter = 0;
        thenableState = null;
        if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
        null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
      }
      function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
        currentlyRenderingFiber = workInProgress2;
        var numberOfReRenders = 0;
        do {
          didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
          thenableIndexCounter = 0;
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
          numberOfReRenders += 1;
          workInProgressHook = currentHook = null;
          if (null != workInProgress2.updateQueue) {
            var children = workInProgress2.updateQueue;
            children.lastEffect = null;
            children.events = null;
            children.stores = null;
            null != children.memoCache && (children.memoCache.index = 0);
          }
          ReactSharedInternals.H = HooksDispatcherOnRerender;
          children = Component(props, secondArg);
        } while (didScheduleRenderPhaseUpdateDuringThisPass);
        return children;
      }
      function TransitionAwareHostComponent() {
        var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
        maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
        dispatcher = dispatcher.useState()[0];
        (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
        return maybeThenable;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = 0 !== localIdCounter;
        localIdCounter = 0;
        return didRenderIdHook;
      }
      function bailoutHooks(current, workInProgress2, lanes) {
        workInProgress2.updateQueue = current.updateQueue;
        workInProgress2.flags &= -2053;
        current.lanes &= ~lanes;
      }
      function resetHooksOnUnwind(workInProgress2) {
        if (didScheduleRenderPhaseUpdate) {
          for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
            var queue = workInProgress2.queue;
            null !== queue && (queue.pending = null);
            workInProgress2 = workInProgress2.next;
          }
          didScheduleRenderPhaseUpdate = false;
        }
        renderLanes = 0;
        workInProgressHook = currentHook = currentlyRenderingFiber = null;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        thenableIndexCounter = localIdCounter = 0;
        thenableState = null;
      }
      function mountWorkInProgressHook() {
        var hook = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null
        };
        null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
        return workInProgressHook;
      }
      function updateWorkInProgressHook() {
        if (null === currentHook) {
          var nextCurrentHook = currentlyRenderingFiber.alternate;
          nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
        } else nextCurrentHook = currentHook.next;
        var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
        if (null !== nextWorkInProgressHook)
          workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
        else {
          if (null === nextCurrentHook) {
            if (null === currentlyRenderingFiber.alternate)
              throw Error(formatProdErrorMessage(467));
            throw Error(formatProdErrorMessage(310));
          }
          currentHook = nextCurrentHook;
          nextCurrentHook = {
            memoizedState: currentHook.memoizedState,
            baseState: currentHook.baseState,
            baseQueue: currentHook.baseQueue,
            queue: currentHook.queue,
            next: null
          };
          null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
        }
        return workInProgressHook;
      }
      function createFunctionComponentUpdateQueue() {
        return { lastEffect: null, events: null, stores: null, memoCache: null };
      }
      function useThenable(thenable) {
        var index2 = thenableIndexCounter;
        thenableIndexCounter += 1;
        null === thenableState && (thenableState = []);
        thenable = trackUsedThenable(thenableState, thenable, index2);
        index2 = currentlyRenderingFiber;
        null === (null === workInProgressHook ? index2.memoizedState : workInProgressHook.next) && (index2 = index2.alternate, ReactSharedInternals.H = null === index2 || null === index2.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
        return thenable;
      }
      function use(usable) {
        if (null !== usable && "object" === typeof usable) {
          if ("function" === typeof usable.then) return useThenable(usable);
          if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
        }
        throw Error(formatProdErrorMessage(438, String(usable)));
      }
      function useMemoCache(size) {
        var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
        null !== updateQueue && (memoCache = updateQueue.memoCache);
        if (null == memoCache) {
          var current = currentlyRenderingFiber.alternate;
          null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
            data: current.data.map(function(array) {
              return array.slice();
            }),
            index: 0
          })));
        }
        null == memoCache && (memoCache = { data: [], index: 0 });
        null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
        updateQueue.memoCache = memoCache;
        updateQueue = memoCache.data[memoCache.index];
        if (void 0 === updateQueue)
          for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)
            updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
        memoCache.index++;
        return updateQueue;
      }
      function basicStateReducer(state, action) {
        return "function" === typeof action ? action(state) : action;
      }
      function updateReducer(reducer) {
        var hook = updateWorkInProgressHook();
        return updateReducerImpl(hook, currentHook, reducer);
      }
      function updateReducerImpl(hook, current, reducer) {
        var queue = hook.queue;
        if (null === queue) throw Error(formatProdErrorMessage(311));
        queue.lastRenderedReducer = reducer;
        var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
        if (null !== pendingQueue) {
          if (null !== baseQueue) {
            var baseFirst = baseQueue.next;
            baseQueue.next = pendingQueue.next;
            pendingQueue.next = baseFirst;
          }
          current.baseQueue = baseQueue = pendingQueue;
          queue.pending = null;
        }
        pendingQueue = hook.baseState;
        if (null === baseQueue) hook.memoizedState = pendingQueue;
        else {
          current = baseQueue.next;
          var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$60 = false;
          do {
            var updateLane = update.lane & -536870913;
            if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
              var revertLane = update.revertLane;
              if (0 === revertLane)
                null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                  lane: 0,
                  revertLane: 0,
                  gesture: null,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = true);
              else if ((renderLanes & revertLane) === revertLane) {
                update = update.next;
                revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = true);
                continue;
              } else
                updateLane = {
                  lane: 0,
                  revertLane: update.revertLane,
                  gesture: null,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
              updateLane = update.action;
              shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
              pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
            } else
              revertLane = {
                lane: updateLane,
                revertLane: update.revertLane,
                gesture: update.gesture,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
            update = update.next;
          } while (null !== update && update !== current);
          null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
          if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$60 && (reducer = currentEntangledActionThenable, null !== reducer)))
            throw reducer;
          hook.memoizedState = pendingQueue;
          hook.baseState = baseFirst;
          hook.baseQueue = newBaseQueueLast;
          queue.lastRenderedState = pendingQueue;
        }
        null === baseQueue && (queue.lanes = 0);
        return [hook.memoizedState, queue.dispatch];
      }
      function rerenderReducer(reducer) {
        var hook = updateWorkInProgressHook(), queue = hook.queue;
        if (null === queue) throw Error(formatProdErrorMessage(311));
        queue.lastRenderedReducer = reducer;
        var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
        if (null !== lastRenderPhaseUpdate) {
          queue.pending = null;
          var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
          do
            newState = reducer(newState, update.action), update = update.next;
          while (update !== lastRenderPhaseUpdate);
          objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
          hook.memoizedState = newState;
          null === hook.baseQueue && (hook.baseState = newState);
          queue.lastRenderedState = newState;
        }
        return [newState, dispatch];
      }
      function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
        if (isHydrating$jscomp$0) {
          if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
          getServerSnapshot = getServerSnapshot();
        } else getServerSnapshot = getSnapshot();
        var snapshotChanged = !objectIs(
          (currentHook || hook).memoizedState,
          getServerSnapshot
        );
        snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
        hook = hook.queue;
        updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe), [
          subscribe
        ]);
        if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
          fiber.flags |= 2048;
          pushSimpleEffect(
            9,
            { destroy: void 0 },
            updateStoreInstance.bind(
              null,
              fiber,
              hook,
              getServerSnapshot,
              getSnapshot
            ),
            null
          );
          if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
          isHydrating$jscomp$0 || 0 !== (renderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
        }
        return getServerSnapshot;
      }
      function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
        fiber.flags |= 16384;
        fiber = { getSnapshot, value: renderedSnapshot };
        getSnapshot = currentlyRenderingFiber.updateQueue;
        null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
      }
      function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
        inst.value = nextSnapshot;
        inst.getSnapshot = getSnapshot;
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      }
      function subscribeToStore(fiber, inst, subscribe) {
        return subscribe(function() {
          checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
        });
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function forceStoreRerender(fiber) {
        var root2 = enqueueConcurrentRenderForLane(fiber, 2);
        null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
      }
      function mountStateImpl(initialState) {
        var hook = mountWorkInProgressHook();
        if ("function" === typeof initialState) {
          var initialStateInitializer = initialState;
          initialState = initialStateInitializer();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              initialStateInitializer();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        }
        hook.memoizedState = hook.baseState = initialState;
        hook.queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialState
        };
        return hook;
      }
      function updateOptimisticImpl(hook, current, passthrough, reducer) {
        hook.baseState = passthrough;
        return updateReducerImpl(
          hook,
          currentHook,
          "function" === typeof reducer ? reducer : basicStateReducer
        );
      }
      function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
        if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
        fiber = actionQueue.action;
        if (null !== fiber) {
          var actionNode = {
            payload,
            action: fiber,
            next: null,
            isTransition: true,
            status: "pending",
            value: null,
            reason: null,
            listeners: [],
            then: function(listener) {
              actionNode.listeners.push(listener);
            }
          };
          null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
          setState(actionNode);
          setPendingState = actionQueue.pending;
          null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
        }
      }
      function runActionStateAction(actionQueue, node) {
        var action = node.action, payload = node.payload, prevState = actionQueue.state;
        if (node.isTransition) {
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          ReactSharedInternals.T = currentTransition;
          try {
            var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            handleActionReturnValue(actionQueue, node, returnValue);
          } catch (error) {
            onActionError(actionQueue, node, error);
          } finally {
            null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
          }
        } else
          try {
            prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, prevTransition);
          } catch (error$66) {
            onActionError(actionQueue, node, error$66);
          }
      }
      function handleActionReturnValue(actionQueue, node, returnValue) {
        null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(
          function(nextState) {
            onActionSuccess(actionQueue, node, nextState);
          },
          function(error) {
            return onActionError(actionQueue, node, error);
          }
        ) : onActionSuccess(actionQueue, node, returnValue);
      }
      function onActionSuccess(actionQueue, actionNode, nextState) {
        actionNode.status = "fulfilled";
        actionNode.value = nextState;
        notifyActionListeners(actionNode);
        actionQueue.state = nextState;
        actionNode = actionQueue.pending;
        null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
      }
      function onActionError(actionQueue, actionNode, error) {
        var last = actionQueue.pending;
        actionQueue.pending = null;
        if (null !== last) {
          last = last.next;
          do
            actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
          while (actionNode !== last);
        }
        actionQueue.action = null;
      }
      function notifyActionListeners(actionNode) {
        actionNode = actionNode.listeners;
        for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
      }
      function actionStateReducer(oldState, newState) {
        return newState;
      }
      function mountActionState(action, initialStateProp) {
        if (isHydrating) {
          var ssrFormState = workInProgressRoot.formState;
          if (null !== ssrFormState) {
            a: {
              var JSCompiler_inline_result = currentlyRenderingFiber;
              if (isHydrating) {
                if (nextHydratableInstance) {
                  b: {
                    var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
                    for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType; ) {
                      if (!inRootOrSingleton) {
                        JSCompiler_inline_result$jscomp$0 = null;
                        break b;
                      }
                      JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                        JSCompiler_inline_result$jscomp$0.nextSibling
                      );
                      if (null === JSCompiler_inline_result$jscomp$0) {
                        JSCompiler_inline_result$jscomp$0 = null;
                        break b;
                      }
                    }
                    inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
                    JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
                  }
                  if (JSCompiler_inline_result$jscomp$0) {
                    nextHydratableInstance = getNextHydratable(
                      JSCompiler_inline_result$jscomp$0.nextSibling
                    );
                    JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
                    break a;
                  }
                }
                throwOnHydrationMismatch(JSCompiler_inline_result);
              }
              JSCompiler_inline_result = false;
            }
            JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
          }
        }
        ssrFormState = mountWorkInProgressHook();
        ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
        JSCompiler_inline_result = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: actionStateReducer,
          lastRenderedState: initialStateProp
        };
        ssrFormState.queue = JSCompiler_inline_result;
        ssrFormState = dispatchSetState.bind(
          null,
          currentlyRenderingFiber,
          JSCompiler_inline_result
        );
        JSCompiler_inline_result.dispatch = ssrFormState;
        JSCompiler_inline_result = mountStateImpl(false);
        inRootOrSingleton = dispatchOptimisticSetState.bind(
          null,
          currentlyRenderingFiber,
          false,
          JSCompiler_inline_result.queue
        );
        JSCompiler_inline_result = mountWorkInProgressHook();
        JSCompiler_inline_result$jscomp$0 = {
          state: initialStateProp,
          dispatch: null,
          action,
          pending: null
        };
        JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
        ssrFormState = dispatchActionState.bind(
          null,
          currentlyRenderingFiber,
          JSCompiler_inline_result$jscomp$0,
          inRootOrSingleton,
          ssrFormState
        );
        JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
        JSCompiler_inline_result.memoizedState = action;
        return [initialStateProp, ssrFormState, false];
      }
      function updateActionState(action) {
        var stateHook = updateWorkInProgressHook();
        return updateActionStateImpl(stateHook, currentHook, action);
      }
      function updateActionStateImpl(stateHook, currentStateHook, action) {
        currentStateHook = updateReducerImpl(
          stateHook,
          currentStateHook,
          actionStateReducer
        )[0];
        stateHook = updateReducer(basicStateReducer)[0];
        if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
          try {
            var state = useThenable(currentStateHook);
          } catch (x) {
            if (x === SuspenseException) throw SuspenseActionException;
            throw x;
          }
        else state = currentStateHook;
        currentStateHook = updateWorkInProgressHook();
        var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
        action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
          9,
          { destroy: void 0 },
          actionStateActionEffect.bind(null, actionQueue, action),
          null
        ));
        return [state, dispatch, stateHook];
      }
      function actionStateActionEffect(actionQueue, action) {
        actionQueue.action = action;
      }
      function rerenderActionState(action) {
        var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
        if (null !== currentStateHook)
          return updateActionStateImpl(stateHook, currentStateHook, action);
        updateWorkInProgressHook();
        stateHook = stateHook.memoizedState;
        currentStateHook = updateWorkInProgressHook();
        var dispatch = currentStateHook.queue.dispatch;
        currentStateHook.memoizedState = action;
        return [stateHook, dispatch, false];
      }
      function pushSimpleEffect(tag, inst, create, deps) {
        tag = { tag, create, deps, inst, next: null };
        inst = currentlyRenderingFiber.updateQueue;
        null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
        create = inst.lastEffect;
        null === create ? inst.lastEffect = tag.next = tag : (deps = create.next, create.next = tag, tag.next = deps, inst.lastEffect = tag);
        return tag;
      }
      function updateRef() {
        return updateWorkInProgressHook().memoizedState;
      }
      function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = mountWorkInProgressHook();
        currentlyRenderingFiber.flags |= fiberFlags;
        hook.memoizedState = pushSimpleEffect(
          1 | hookFlags,
          { destroy: void 0 },
          create,
          void 0 === deps ? null : deps
        );
      }
      function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var inst = hook.memoizedState.inst;
        null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
          1 | hookFlags,
          inst,
          create,
          deps
        ));
      }
      function mountEffect(create, deps) {
        mountEffectImpl(8390656, 8, create, deps);
      }
      function updateEffect(create, deps) {
        updateEffectImpl(2048, 8, create, deps);
      }
      function useEffectEventImpl(payload) {
        currentlyRenderingFiber.flags |= 4;
        var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
        if (null === componentUpdateQueue)
          componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = componentUpdateQueue, componentUpdateQueue.events = [payload];
        else {
          var events = componentUpdateQueue.events;
          null === events ? componentUpdateQueue.events = [payload] : events.push(payload);
        }
      }
      function updateEvent(callback) {
        var ref = updateWorkInProgressHook().memoizedState;
        useEffectEventImpl({ ref, nextImpl: callback });
        return function() {
          if (0 !== (executionContext & 2)) throw Error(formatProdErrorMessage(440));
          return ref.impl.apply(void 0, arguments);
        };
      }
      function updateInsertionEffect(create, deps) {
        return updateEffectImpl(4, 2, create, deps);
      }
      function updateLayoutEffect(create, deps) {
        return updateEffectImpl(4, 4, create, deps);
      }
      function imperativeHandleEffect(create, ref) {
        if ("function" === typeof ref) {
          create = create();
          var refCleanup = ref(create);
          return function() {
            "function" === typeof refCleanup ? refCleanup() : ref(null);
          };
        }
        if (null !== ref && void 0 !== ref)
          return create = create(), ref.current = create, function() {
            ref.current = null;
          };
      }
      function updateImperativeHandle(ref, create, deps) {
        deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
        updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
      }
      function mountDebugValue() {
      }
      function updateCallback(callback, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1]))
          return prevState[0];
        hook.memoizedState = [callback, deps];
        return callback;
      }
      function updateMemo(nextCreate, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1]))
          return prevState[0];
        prevState = nextCreate();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            nextCreate();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        hook.memoizedState = [prevState, deps];
        return prevState;
      }
      function mountDeferredValueImpl(hook, value, initialValue) {
        if (void 0 === initialValue || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
          return hook.memoizedState = value;
        hook.memoizedState = initialValue;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return initialValue;
      }
      function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
        if (objectIs(value, prevValue)) return value;
        if (null !== currentTreeHiddenStackCursor.current)
          return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
        if (0 === (renderLanes & 42) || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
          return didReceiveUpdate = true, hook.memoizedState = value;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return prevValue;
      }
      function startTransition(fiber, queue, pendingState, finishedState, callback) {
        var previousPriority = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        dispatchOptimisticSetState(fiber, false, queue, pendingState);
        try {
          var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
            var thenableForFinishedState = chainThenableValue(
              returnValue,
              finishedState
            );
            dispatchSetStateInternal(
              fiber,
              queue,
              thenableForFinishedState,
              requestUpdateLane(fiber)
            );
          } else
            dispatchSetStateInternal(
              fiber,
              queue,
              finishedState,
              requestUpdateLane(fiber)
            );
        } catch (error) {
          dispatchSetStateInternal(
            fiber,
            queue,
            { then: function() {
            }, status: "rejected", reason: error },
            requestUpdateLane()
          );
        } finally {
          ReactDOMSharedInternals.p = previousPriority, null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
        }
      }
      function noop() {
      }
      function startHostTransition(formFiber, pendingState, action, formData) {
        if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
        var queue = ensureFormComponentIsStateful(formFiber).queue;
        startTransition(
          formFiber,
          queue,
          pendingState,
          sharedNotPendingObject,
          null === action ? noop : function() {
            requestFormReset$1(formFiber);
            return action(formData);
          }
        );
      }
      function ensureFormComponentIsStateful(formFiber) {
        var existingStateHook = formFiber.memoizedState;
        if (null !== existingStateHook) return existingStateHook;
        existingStateHook = {
          memoizedState: sharedNotPendingObject,
          baseState: sharedNotPendingObject,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: sharedNotPendingObject
          },
          next: null
        };
        var initialResetState = {};
        existingStateHook.next = {
          memoizedState: initialResetState,
          baseState: initialResetState,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialResetState
          },
          next: null
        };
        formFiber.memoizedState = existingStateHook;
        formFiber = formFiber.alternate;
        null !== formFiber && (formFiber.memoizedState = existingStateHook);
        return existingStateHook;
      }
      function requestFormReset$1(formFiber) {
        var stateHook = ensureFormComponentIsStateful(formFiber);
        null === stateHook.next && (stateHook = formFiber.alternate.memoizedState);
        dispatchSetStateInternal(
          formFiber,
          stateHook.next.queue,
          {},
          requestUpdateLane()
        );
      }
      function useHostTransitionStatus() {
        return readContext(HostTransitionContext);
      }
      function updateId() {
        return updateWorkInProgressHook().memoizedState;
      }
      function updateRefresh() {
        return updateWorkInProgressHook().memoizedState;
      }
      function refreshCache(fiber) {
        for (var provider = fiber.return; null !== provider; ) {
          switch (provider.tag) {
            case 24:
            case 3:
              var lane = requestUpdateLane();
              fiber = createUpdate(lane);
              var root$69 = enqueueUpdate(provider, fiber, lane);
              null !== root$69 && (scheduleUpdateOnFiber(root$69, provider, lane), entangleTransitions(root$69, provider, lane));
              provider = { cache: createCache() };
              fiber.payload = provider;
              return;
          }
          provider = provider.return;
        }
      }
      function dispatchReducerAction(fiber, queue, action) {
        var lane = requestUpdateLane();
        action = {
          lane,
          revertLane: 0,
          gesture: null,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
      }
      function dispatchSetState(fiber, queue, action) {
        var lane = requestUpdateLane();
        dispatchSetStateInternal(fiber, queue, action, lane);
      }
      function dispatchSetStateInternal(fiber, queue, action, lane) {
        var update = {
          lane,
          revertLane: 0,
          gesture: null,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
        else {
          var alternate = fiber.alternate;
          if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate))
            try {
              var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
              update.hasEagerState = true;
              update.eagerState = eagerState;
              if (objectIs(eagerState, currentState))
                return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
            } catch (error) {
            } finally {
            }
          action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
          if (null !== action)
            return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
        }
        return false;
      }
      function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
        action = {
          lane: 2,
          revertLane: requestTransitionLane(),
          gesture: null,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) {
          if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
        } else
          throwIfDuringRender = enqueueConcurrentHookUpdate(
            fiber,
            queue,
            action,
            2
          ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
      }
      function isRenderPhaseUpdate(fiber) {
        var alternate = fiber.alternate;
        return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
      }
      function enqueueRenderPhaseUpdate(queue, update) {
        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
        var pending = queue.pending;
        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
        queue.pending = update;
      }
      function entangleTransitionUpdate(root2, queue, lane) {
        if (0 !== (lane & 4194048)) {
          var queueLanes = queue.lanes;
          queueLanes &= root2.pendingLanes;
          lane |= queueLanes;
          queue.lanes = lane;
          markRootEntangled(root2, lane);
        }
      }
      var ContextOnlyDispatcher = {
        readContext,
        use,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useInsertionEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError,
        useDeferredValue: throwInvalidHookError,
        useTransition: throwInvalidHookError,
        useSyncExternalStore: throwInvalidHookError,
        useId: throwInvalidHookError,
        useHostTransitionStatus: throwInvalidHookError,
        useFormState: throwInvalidHookError,
        useActionState: throwInvalidHookError,
        useOptimistic: throwInvalidHookError,
        useMemoCache: throwInvalidHookError,
        useCacheRefresh: throwInvalidHookError
      };
      ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
      var HooksDispatcherOnMount = {
        readContext,
        use,
        useCallback: function(callback, deps) {
          mountWorkInProgressHook().memoizedState = [
            callback,
            void 0 === deps ? null : deps
          ];
          return callback;
        },
        useContext: readContext,
        useEffect: mountEffect,
        useImperativeHandle: function(ref, create, deps) {
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          mountEffectImpl(
            4194308,
            4,
            imperativeHandleEffect.bind(null, create, ref),
            deps
          );
        },
        useLayoutEffect: function(create, deps) {
          return mountEffectImpl(4194308, 4, create, deps);
        },
        useInsertionEffect: function(create, deps) {
          mountEffectImpl(4, 2, create, deps);
        },
        useMemo: function(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var nextValue = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [nextValue, deps];
          return nextValue;
        },
        useReducer: function(reducer, initialArg, init) {
          var hook = mountWorkInProgressHook();
          if (void 0 !== init) {
            var initialState = init(initialArg);
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                init(initialArg);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          } else initialState = initialArg;
          hook.memoizedState = hook.baseState = initialState;
          reducer = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState
          };
          hook.queue = reducer;
          reducer = reducer.dispatch = dispatchReducerAction.bind(
            null,
            currentlyRenderingFiber,
            reducer
          );
          return [hook.memoizedState, reducer];
        },
        useRef: function(initialValue) {
          var hook = mountWorkInProgressHook();
          initialValue = { current: initialValue };
          return hook.memoizedState = initialValue;
        },
        useState: function(initialState) {
          initialState = mountStateImpl(initialState);
          var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
          queue.dispatch = dispatch;
          return [initialState.memoizedState, dispatch];
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = mountWorkInProgressHook();
          return mountDeferredValueImpl(hook, value, initialValue);
        },
        useTransition: function() {
          var stateHook = mountStateImpl(false);
          stateHook = startTransition.bind(
            null,
            currentlyRenderingFiber,
            stateHook.queue,
            true,
            false
          );
          mountWorkInProgressHook().memoizedState = stateHook;
          return [false, stateHook];
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
          if (isHydrating) {
            if (void 0 === getServerSnapshot)
              throw Error(formatProdErrorMessage(407));
            getServerSnapshot = getServerSnapshot();
          } else {
            getServerSnapshot = getSnapshot();
            if (null === workInProgressRoot)
              throw Error(formatProdErrorMessage(349));
            0 !== (workInProgressRootRenderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
          }
          hook.memoizedState = getServerSnapshot;
          var inst = { value: getServerSnapshot, getSnapshot };
          hook.queue = inst;
          mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
            subscribe
          ]);
          fiber.flags |= 2048;
          pushSimpleEffect(
            9,
            { destroy: void 0 },
            updateStoreInstance.bind(
              null,
              fiber,
              inst,
              getServerSnapshot,
              getSnapshot
            ),
            null
          );
          return getServerSnapshot;
        },
        useId: function() {
          var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
          if (isHydrating) {
            var JSCompiler_inline_result = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
            identifierPrefix = "_" + identifierPrefix + "R_" + JSCompiler_inline_result;
            JSCompiler_inline_result = localIdCounter++;
            0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
            identifierPrefix += "_";
          } else
            JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "_" + identifierPrefix + "r_" + JSCompiler_inline_result.toString(32) + "_";
          return hook.memoizedState = identifierPrefix;
        },
        useHostTransitionStatus,
        useFormState: mountActionState,
        useActionState: mountActionState,
        useOptimistic: function(passthrough) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = hook.baseState = passthrough;
          var queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: null,
            lastRenderedState: null
          };
          hook.queue = queue;
          hook = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            true,
            queue
          );
          queue.dispatch = hook;
          return [passthrough, hook];
        },
        useMemoCache,
        useCacheRefresh: function() {
          return mountWorkInProgressHook().memoizedState = refreshCache.bind(
            null,
            currentlyRenderingFiber
          );
        },
        useEffectEvent: function(callback) {
          var hook = mountWorkInProgressHook(), ref = { impl: callback };
          hook.memoizedState = ref;
          return function() {
            if (0 !== (executionContext & 2))
              throw Error(formatProdErrorMessage(440));
            return ref.impl.apply(void 0, arguments);
          };
        }
      }, HooksDispatcherOnUpdate = {
        readContext,
        use,
        useCallback: updateCallback,
        useContext: readContext,
        useEffect: updateEffect,
        useImperativeHandle: updateImperativeHandle,
        useInsertionEffect: updateInsertionEffect,
        useLayoutEffect: updateLayoutEffect,
        useMemo: updateMemo,
        useReducer: updateReducer,
        useRef: updateRef,
        useState: function() {
          return updateReducer(basicStateReducer);
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        },
        useTransition: function() {
          var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        },
        useSyncExternalStore: updateSyncExternalStore,
        useId: updateId,
        useHostTransitionStatus,
        useFormState: updateActionState,
        useActionState: updateActionState,
        useOptimistic: function(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        },
        useMemoCache,
        useCacheRefresh: updateRefresh
      };
      HooksDispatcherOnUpdate.useEffectEvent = updateEvent;
      var HooksDispatcherOnRerender = {
        readContext,
        use,
        useCallback: updateCallback,
        useContext: readContext,
        useEffect: updateEffect,
        useImperativeHandle: updateImperativeHandle,
        useInsertionEffect: updateInsertionEffect,
        useLayoutEffect: updateLayoutEffect,
        useMemo: updateMemo,
        useReducer: rerenderReducer,
        useRef: updateRef,
        useState: function() {
          return rerenderReducer(basicStateReducer);
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        },
        useTransition: function() {
          var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        },
        useSyncExternalStore: updateSyncExternalStore,
        useId: updateId,
        useHostTransitionStatus,
        useFormState: rerenderActionState,
        useActionState: rerenderActionState,
        useOptimistic: function(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          if (null !== currentHook)
            return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
          hook.baseState = passthrough;
          return [passthrough, hook.queue.dispatch];
        },
        useMemoCache,
        useCacheRefresh: updateRefresh
      };
      HooksDispatcherOnRerender.useEffectEvent = updateEvent;
      function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
        ctor = workInProgress2.memoizedState;
        getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
        getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign({}, ctor, getDerivedStateFromProps);
        workInProgress2.memoizedState = getDerivedStateFromProps;
        0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = getDerivedStateFromProps);
      }
      var classComponentUpdater = {
        enqueueSetState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.payload = payload;
          void 0 !== callback && null !== callback && (update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        },
        enqueueReplaceState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.tag = 1;
          update.payload = payload;
          void 0 !== callback && null !== callback && (update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        },
        enqueueForceUpdate: function(inst, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.tag = 2;
          void 0 !== callback && null !== callback && (update.callback = callback);
          callback = enqueueUpdate(inst, update, lane);
          null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
        }
      };
      function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
        workInProgress2 = workInProgress2.stateNode;
        return "function" === typeof workInProgress2.shouldComponentUpdate ? workInProgress2.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
      }
      function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
        workInProgress2 = instance.state;
        "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
        "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
        instance.state !== workInProgress2 && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
      }
      function resolveClassComponentProps(Component, baseProps) {
        var newProps = baseProps;
        if ("ref" in baseProps) {
          newProps = {};
          for (var propName in baseProps)
            "ref" !== propName && (newProps[propName] = baseProps[propName]);
        }
        if (Component = Component.defaultProps) {
          newProps === baseProps && (newProps = assign({}, newProps));
          for (var propName$73 in Component)
            void 0 === newProps[propName$73] && (newProps[propName$73] = Component[propName$73]);
        }
        return newProps;
      }
      function defaultOnUncaughtError(error) {
        reportGlobalError(error);
      }
      function defaultOnCaughtError(error) {
        console.error(error);
      }
      function defaultOnRecoverableError(error) {
        reportGlobalError(error);
      }
      function logUncaughtError(root2, errorInfo) {
        try {
          var onUncaughtError = root2.onUncaughtError;
          onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
        } catch (e$74) {
          setTimeout(function() {
            throw e$74;
          });
        }
      }
      function logCaughtError(root2, boundary, errorInfo) {
        try {
          var onCaughtError = root2.onCaughtError;
          onCaughtError(errorInfo.value, {
            componentStack: errorInfo.stack,
            errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
          });
        } catch (e$75) {
          setTimeout(function() {
            throw e$75;
          });
        }
      }
      function createRootErrorUpdate(root2, errorInfo, lane) {
        lane = createUpdate(lane);
        lane.tag = 3;
        lane.payload = { element: null };
        lane.callback = function() {
          logUncaughtError(root2, errorInfo);
        };
        return lane;
      }
      function createClassErrorUpdate(lane) {
        lane = createUpdate(lane);
        lane.tag = 3;
        return lane;
      }
      function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
        if ("function" === typeof getDerivedStateFromError) {
          var error = errorInfo.value;
          update.payload = function() {
            return getDerivedStateFromError(error);
          };
          update.callback = function() {
            logCaughtError(root2, fiber, errorInfo);
          };
        }
        var inst = fiber.stateNode;
        null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
          logCaughtError(root2, fiber, errorInfo);
          "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
          var stack = errorInfo.stack;
          this.componentDidCatch(errorInfo.value, {
            componentStack: null !== stack ? stack : ""
          });
        });
      }
      function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
        sourceFiber.flags |= 32768;
        if (null !== value && "object" === typeof value && "function" === typeof value.then) {
          returnFiber = sourceFiber.alternate;
          null !== returnFiber && propagateParentContextChanges(
            returnFiber,
            sourceFiber,
            rootRenderLanes,
            true
          );
          sourceFiber = suspenseHandlerStackCursor.current;
          if (null !== sourceFiber) {
            switch (sourceFiber.tag) {
              case 31:
              case 13:
                return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
              case 22:
                return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                  transitions: null,
                  markerInstances: null,
                  retryQueue: /* @__PURE__ */ new Set([value])
                }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
            }
            throw Error(formatProdErrorMessage(435, sourceFiber.tag));
          }
          attachPingListener(root2, value, rootRenderLanes);
          renderDidSuspendDelayIfPossible();
          return false;
        }
        if (isHydrating)
          return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root2 = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root2, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), {
            cause: value
          }), queueHydrationError(
            createCapturedValueAtFiber(returnFiber, sourceFiber)
          )), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
            root2.stateNode,
            value,
            rootRenderLanes
          ), enqueueCapturedUpdate(root2, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false;
        var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
        wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
        null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
        4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
        if (null === returnFiber) return true;
        value = createCapturedValueAtFiber(value, sourceFiber);
        sourceFiber = returnFiber;
        do {
          switch (sourceFiber.tag) {
            case 3:
              return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(sourceFiber.stateNode, value, root2), enqueueCapturedUpdate(sourceFiber, root2), false;
            case 1:
              if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError))))
                return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                  rootRenderLanes,
                  root2,
                  sourceFiber,
                  value
                ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
          }
          sourceFiber = sourceFiber.return;
        } while (null !== sourceFiber);
        return false;
      }
      var SelectiveHydrationException = Error(formatProdErrorMessage(461)), didReceiveUpdate = false;
      function reconcileChildren(current, workInProgress2, nextChildren, renderLanes2) {
        workInProgress2.child = null === current ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
          workInProgress2,
          current.child,
          nextChildren,
          renderLanes2
        );
      }
      function updateForwardRef(current, workInProgress2, Component, nextProps, renderLanes2) {
        Component = Component.render;
        var ref = workInProgress2.ref;
        if ("ref" in nextProps) {
          var propsWithoutRef = {};
          for (var key in nextProps)
            "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
        } else propsWithoutRef = nextProps;
        prepareToReadContext(workInProgress2);
        nextProps = renderWithHooks(
          current,
          workInProgress2,
          Component,
          propsWithoutRef,
          ref,
          renderLanes2
        );
        key = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && key && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        return workInProgress2.child;
      }
      function updateMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        if (null === current) {
          var type = Component.type;
          if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
            return workInProgress2.tag = 15, workInProgress2.type = type, updateSimpleMemoComponent(
              current,
              workInProgress2,
              type,
              nextProps,
              renderLanes2
            );
          current = createFiberFromTypeAndProps(
            Component.type,
            null,
            nextProps,
            workInProgress2,
            workInProgress2.mode,
            renderLanes2
          );
          current.ref = workInProgress2.ref;
          current.return = workInProgress2;
          return workInProgress2.child = current;
        }
        type = current.child;
        if (!checkScheduledUpdateOrContext(current, renderLanes2)) {
          var prevProps = type.memoizedProps;
          Component = Component.compare;
          Component = null !== Component ? Component : shallowEqual;
          if (Component(prevProps, nextProps) && current.ref === workInProgress2.ref)
            return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        }
        workInProgress2.flags |= 1;
        current = createWorkInProgress(type, nextProps);
        current.ref = workInProgress2.ref;
        current.return = workInProgress2;
        return workInProgress2.child = current;
      }
      function updateSimpleMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        if (null !== current) {
          var prevProps = current.memoizedProps;
          if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress2.ref)
            if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes2))
              0 !== (current.flags & 131072) && (didReceiveUpdate = true);
            else
              return workInProgress2.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        }
        return updateFunctionComponent(
          current,
          workInProgress2,
          Component,
          nextProps,
          renderLanes2
        );
      }
      function updateOffscreenComponent(current, workInProgress2, renderLanes2, nextProps) {
        var nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;
        null === current && null === workInProgress2.stateNode && (workInProgress2.stateNode = {
          _visibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null
        });
        if ("hidden" === nextProps.mode) {
          if (0 !== (workInProgress2.flags & 128)) {
            prevState = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
            if (null !== current) {
              nextProps = workInProgress2.child = current.child;
              for (nextChildren = 0; null !== nextProps; )
                nextChildren = nextChildren | nextProps.lanes | nextProps.childLanes, nextProps = nextProps.sibling;
              nextProps = nextChildren & ~prevState;
            } else nextProps = 0, workInProgress2.child = null;
            return deferHiddenOffscreenComponent(
              current,
              workInProgress2,
              prevState,
              renderLanes2,
              nextProps
            );
          }
          if (0 !== (renderLanes2 & 536870912))
            workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current && pushTransition(
              workInProgress2,
              null !== prevState ? prevState.cachePool : null
            ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress2);
          else
            return nextProps = workInProgress2.lanes = 536870912, deferHiddenOffscreenComponent(
              current,
              workInProgress2,
              null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
              renderLanes2,
              nextProps
            );
        } else
          null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(), workInProgress2.memoizedState = null) : (null !== current && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack());
        reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function bailoutOffscreenComponent(current, workInProgress2) {
        null !== current && 22 === current.tag || null !== workInProgress2.stateNode || (workInProgress2.stateNode = {
          _visibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null
        });
        return workInProgress2.sibling;
      }
      function deferHiddenOffscreenComponent(current, workInProgress2, nextBaseLanes, renderLanes2, remainingChildLanes) {
        var JSCompiler_inline_result = peekCacheFromPool();
        JSCompiler_inline_result = null === JSCompiler_inline_result ? null : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
        workInProgress2.memoizedState = {
          baseLanes: nextBaseLanes,
          cachePool: JSCompiler_inline_result
        };
        null !== current && pushTransition(workInProgress2, null);
        reuseHiddenContextOnStack();
        pushOffscreenSuspenseHandler(workInProgress2);
        null !== current && propagateParentContextChanges(current, workInProgress2, renderLanes2, true);
        workInProgress2.childLanes = remainingChildLanes;
        return null;
      }
      function mountActivityChildren(workInProgress2, nextProps) {
        nextProps = mountWorkInProgressOffscreenFiber(
          { mode: nextProps.mode, children: nextProps.children },
          workInProgress2.mode
        );
        nextProps.ref = workInProgress2.ref;
        workInProgress2.child = nextProps;
        nextProps.return = workInProgress2;
        return nextProps;
      }
      function retryActivityComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
        reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
        current = mountActivityChildren(workInProgress2, workInProgress2.pendingProps);
        current.flags |= 2;
        popSuspenseHandler(workInProgress2);
        workInProgress2.memoizedState = null;
        return current;
      }
      function updateActivityComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, didSuspend = 0 !== (workInProgress2.flags & 128);
        workInProgress2.flags &= -129;
        if (null === current) {
          if (isHydrating) {
            if ("hidden" === nextProps.mode)
              return current = mountActivityChildren(workInProgress2, nextProps), workInProgress2.lanes = 536870912, bailoutOffscreenComponent(null, current);
            pushDehydratedActivitySuspenseHandler(workInProgress2);
            (current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(
              current,
              rootOrSingletonContext
            ), current = null !== current && "&" === current.data ? current : null, null !== current && (workInProgress2.memoizedState = {
              dehydrated: current,
              treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
              retryLane: 536870912,
              hydrationErrors: null
            }, renderLanes2 = createFiberFromDehydratedFragment(current), renderLanes2.return = workInProgress2, workInProgress2.child = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : current = null;
            if (null === current) throw throwOnHydrationMismatch(workInProgress2);
            workInProgress2.lanes = 536870912;
            return null;
          }
          return mountActivityChildren(workInProgress2, nextProps);
        }
        var prevState = current.memoizedState;
        if (null !== prevState) {
          var dehydrated = prevState.dehydrated;
          pushDehydratedActivitySuspenseHandler(workInProgress2);
          if (didSuspend)
            if (workInProgress2.flags & 256)
              workInProgress2.flags &= -257, workInProgress2 = retryActivityComponentWithoutHydrating(
                current,
                workInProgress2,
                renderLanes2
              );
            else if (null !== workInProgress2.memoizedState)
              workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null;
            else throw Error(formatProdErrorMessage(558));
          else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), didSuspend = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || didSuspend) {
            nextProps = workInProgressRoot;
            if (null !== nextProps && (dehydrated = getBumpedLaneForHydration(nextProps, renderLanes2), 0 !== dehydrated && dehydrated !== prevState.retryLane))
              throw prevState.retryLane = dehydrated, enqueueConcurrentRenderForLane(current, dehydrated), scheduleUpdateOnFiber(nextProps, current, dehydrated), SelectiveHydrationException;
            renderDidSuspendDelayIfPossible();
            workInProgress2 = retryActivityComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          } else
            current = prevState.treeContext, nextHydratableInstance = getNextHydratable(dehydrated.nextSibling), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && restoreSuspendedTreeContext(workInProgress2, current), workInProgress2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.flags |= 4096;
          return workInProgress2;
        }
        current = createWorkInProgress(current.child, {
          mode: nextProps.mode,
          children: nextProps.children
        });
        current.ref = workInProgress2.ref;
        workInProgress2.child = current;
        current.return = workInProgress2;
        return current;
      }
      function markRef(current, workInProgress2) {
        var ref = workInProgress2.ref;
        if (null === ref)
          null !== current && null !== current.ref && (workInProgress2.flags |= 4194816);
        else {
          if ("function" !== typeof ref && "object" !== typeof ref)
            throw Error(formatProdErrorMessage(284));
          if (null === current || current.ref !== ref)
            workInProgress2.flags |= 4194816;
        }
      }
      function updateFunctionComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        prepareToReadContext(workInProgress2);
        Component = renderWithHooks(
          current,
          workInProgress2,
          Component,
          nextProps,
          void 0,
          renderLanes2
        );
        nextProps = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, Component, renderLanes2);
        return workInProgress2.child;
      }
      function replayFunctionComponent(current, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
        prepareToReadContext(workInProgress2);
        workInProgress2.updateQueue = null;
        nextProps = renderWithHooksAgain(
          workInProgress2,
          Component,
          nextProps,
          secondArg
        );
        finishRenderingHooks(current);
        Component = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && Component && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        return workInProgress2.child;
      }
      function updateClassComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        prepareToReadContext(workInProgress2);
        if (null === workInProgress2.stateNode) {
          var context = emptyContextObject, contextType = Component.contextType;
          "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
          context = new Component(nextProps, context);
          workInProgress2.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
          context.updater = classComponentUpdater;
          workInProgress2.stateNode = context;
          context._reactInternals = workInProgress2;
          context = workInProgress2.stateNode;
          context.props = nextProps;
          context.state = workInProgress2.memoizedState;
          context.refs = {};
          initializeUpdateQueue(workInProgress2);
          contextType = Component.contextType;
          context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
          context.state = workInProgress2.memoizedState;
          contextType = Component.getDerivedStateFromProps;
          "function" === typeof contextType && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            contextType,
            nextProps
          ), context.state = workInProgress2.memoizedState);
          "function" === typeof Component.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress2, nextProps, context, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress2.memoizedState);
          "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308);
          nextProps = true;
        } else if (null === current) {
          context = workInProgress2.stateNode;
          var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
          context.props = oldProps;
          var oldContext = context.context, contextType$jscomp$0 = Component.contextType;
          contextType = emptyContextObject;
          "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
          var getDerivedStateFromProps = Component.getDerivedStateFromProps;
          contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
          unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
          contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(
            workInProgress2,
            context,
            nextProps,
            contextType
          );
          hasForceUpdate = false;
          var oldState = workInProgress2.memoizedState;
          context.state = oldState;
          processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
          suspendIfUpdateReadFromEntangledAsyncAction();
          oldContext = workInProgress2.memoizedState;
          unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            getDerivedStateFromProps,
            nextProps
          ), oldContext = workInProgress2.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(
            workInProgress2,
            Component,
            oldProps,
            nextProps,
            oldState,
            oldContext,
            contextType
          )) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), nextProps = false);
        } else {
          context = workInProgress2.stateNode;
          cloneUpdateQueue(current, workInProgress2);
          contextType = workInProgress2.memoizedProps;
          contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
          context.props = contextType$jscomp$0;
          getDerivedStateFromProps = workInProgress2.pendingProps;
          oldState = context.context;
          oldContext = Component.contextType;
          oldProps = emptyContextObject;
          "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
          unresolvedOldProps = Component.getDerivedStateFromProps;
          (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(
            workInProgress2,
            context,
            nextProps,
            oldProps
          );
          hasForceUpdate = false;
          oldState = workInProgress2.memoizedState;
          context.state = oldState;
          processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
          suspendIfUpdateReadFromEntangledAsyncAction();
          var newState = workInProgress2.memoizedState;
          contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            unresolvedOldProps,
            nextProps
          ), newState = workInProgress2.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(
            workInProgress2,
            Component,
            contextType$jscomp$0,
            nextProps,
            oldState,
            newState,
            oldProps
          ) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(
            nextProps,
            newState,
            oldProps
          )), "function" === typeof context.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), nextProps = false);
        }
        context = nextProps;
        markRef(current, workInProgress2);
        nextProps = 0 !== (workInProgress2.flags & 128);
        context || nextProps ? (context = workInProgress2.stateNode, Component = nextProps && "function" !== typeof Component.getDerivedStateFromError ? null : context.render(), workInProgress2.flags |= 1, null !== current && nextProps ? (workInProgress2.child = reconcileChildFibers(
          workInProgress2,
          current.child,
          null,
          renderLanes2
        ), workInProgress2.child = reconcileChildFibers(
          workInProgress2,
          null,
          Component,
          renderLanes2
        )) : reconcileChildren(current, workInProgress2, Component, renderLanes2), workInProgress2.memoizedState = context.state, current = workInProgress2.child) : current = bailoutOnAlreadyFinishedWork(
          current,
          workInProgress2,
          renderLanes2
        );
        return current;
      }
      function mountHostRootWithoutHydrating(current, workInProgress2, nextChildren, renderLanes2) {
        resetHydrationState();
        workInProgress2.flags |= 256;
        reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      var SUSPENDED_MARKER = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0,
        hydrationErrors: null
      };
      function mountSuspenseOffscreenState(renderLanes2) {
        return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
      }
      function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes2) {
        current = null !== current ? current.childLanes & ~renderLanes2 : 0;
        primaryTreeDidDefer && (current |= workInProgressDeferredLane);
        return current;
      }
      function updateSuspenseComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, showFallback = false, didSuspend = 0 !== (workInProgress2.flags & 128), JSCompiler_temp;
        (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
        JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
        JSCompiler_temp = 0 !== (workInProgress2.flags & 32);
        workInProgress2.flags &= -33;
        if (null === current) {
          if (isHydrating) {
            showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack();
            (current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(
              current,
              rootOrSingletonContext
            ), current = null !== current && "&" !== current.data ? current : null, null !== current && (workInProgress2.memoizedState = {
              dehydrated: current,
              treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
              retryLane: 536870912,
              hydrationErrors: null
            }, renderLanes2 = createFiberFromDehydratedFragment(current), renderLanes2.return = workInProgress2, workInProgress2.child = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : current = null;
            if (null === current) throw throwOnHydrationMismatch(workInProgress2);
            isSuspenseInstanceFallback(current) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912;
            return null;
          }
          var nextPrimaryChildren = nextProps.children;
          nextProps = nextProps.fallback;
          if (showFallback)
            return reuseSuspenseHandlerOnStack(), showFallback = workInProgress2.mode, nextPrimaryChildren = mountWorkInProgressOffscreenFiber(
              { mode: "hidden", children: nextPrimaryChildren },
              showFallback
            ), nextProps = createFiberFromFragment(
              nextProps,
              showFallback,
              renderLanes2,
              null
            ), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextPrimaryChildren.sibling = nextProps, workInProgress2.child = nextPrimaryChildren, nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(null, nextProps);
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
        }
        var prevState = current.memoizedState;
        if (null !== prevState && (nextPrimaryChildren = prevState.dehydrated, null !== nextPrimaryChildren)) {
          if (didSuspend)
            workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(), workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber(
              { mode: "visible", children: nextProps.children },
              showFallback
            ), nextPrimaryChildren = createFiberFromFragment(
              nextPrimaryChildren,
              showFallback,
              renderLanes2,
              null
            ), nextPrimaryChildren.flags |= 2, nextProps.return = workInProgress2, nextPrimaryChildren.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, reconcileChildFibers(
              workInProgress2,
              current.child,
              null,
              renderLanes2
            ), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = bailoutOffscreenComponent(null, nextProps));
          else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isSuspenseInstanceFallback(nextPrimaryChildren)) {
            JSCompiler_temp = nextPrimaryChildren.nextSibling && nextPrimaryChildren.nextSibling.dataset;
            if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
            JSCompiler_temp = digest;
            nextProps = Error(formatProdErrorMessage(419));
            nextProps.stack = "";
            nextProps.digest = JSCompiler_temp;
            queueHydrationError({ value: nextProps, source: null, stack: null });
            workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), JSCompiler_temp = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
            JSCompiler_temp = workInProgressRoot;
            if (null !== JSCompiler_temp && (nextProps = getBumpedLaneForHydration(JSCompiler_temp, renderLanes2), 0 !== nextProps && nextProps !== prevState.retryLane))
              throw prevState.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
            isSuspenseInstancePending(nextPrimaryChildren) || renderDidSuspendDelayIfPossible();
            workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          } else
            isSuspenseInstancePending(nextPrimaryChildren) ? (workInProgress2.flags |= 192, workInProgress2.child = current.child, workInProgress2 = null) : (current = prevState.treeContext, nextHydratableInstance = getNextHydratable(
              nextPrimaryChildren.nextSibling
            ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && restoreSuspendedTreeContext(workInProgress2, current), workInProgress2 = mountSuspensePrimaryChildren(
              workInProgress2,
              nextProps.children
            ), workInProgress2.flags |= 4096);
          return workInProgress2;
        }
        if (showFallback)
          return reuseSuspenseHandlerOnStack(), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, prevState = current.child, digest = prevState.sibling, nextProps = createWorkInProgress(prevState, {
            mode: "hidden",
            children: nextProps.children
          }), nextProps.subtreeFlags = prevState.subtreeFlags & 65011712, null !== digest ? nextPrimaryChildren = createWorkInProgress(
            digest,
            nextPrimaryChildren
          ) : (nextPrimaryChildren = createFiberFromFragment(
            nextPrimaryChildren,
            showFallback,
            renderLanes2,
            null
          ), nextPrimaryChildren.flags |= 2), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, bailoutOffscreenComponent(null, nextProps), nextProps = workInProgress2.child, nextPrimaryChildren = current.child.memoizedState, null === nextPrimaryChildren ? nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes2) : (showFallback = nextPrimaryChildren.cachePool, null !== showFallback ? (prevState = CacheContext._currentValue, showFallback = showFallback.parent !== prevState ? { parent: prevState, pool: prevState } : showFallback) : showFallback = getSuspendedCache(), nextPrimaryChildren = {
            baseLanes: nextPrimaryChildren.baseLanes | renderLanes2,
            cachePool: showFallback
          }), nextProps.memoizedState = nextPrimaryChildren, nextProps.childLanes = getRemainingWorkInPrimaryTree(
            current,
            JSCompiler_temp,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(current.child, nextProps);
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        renderLanes2 = current.child;
        current = renderLanes2.sibling;
        renderLanes2 = createWorkInProgress(renderLanes2, {
          mode: "visible",
          children: nextProps.children
        });
        renderLanes2.return = workInProgress2;
        renderLanes2.sibling = null;
        null !== current && (JSCompiler_temp = workInProgress2.deletions, null === JSCompiler_temp ? (workInProgress2.deletions = [current], workInProgress2.flags |= 16) : JSCompiler_temp.push(current));
        workInProgress2.child = renderLanes2;
        workInProgress2.memoizedState = null;
        return renderLanes2;
      }
      function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
        primaryChildren = mountWorkInProgressOffscreenFiber(
          { mode: "visible", children: primaryChildren },
          workInProgress2.mode
        );
        primaryChildren.return = workInProgress2;
        return workInProgress2.child = primaryChildren;
      }
      function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
        offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
        offscreenProps.lanes = 0;
        return offscreenProps;
      }
      function retrySuspenseComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
        reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
        current = mountSuspensePrimaryChildren(
          workInProgress2,
          workInProgress2.pendingProps.children
        );
        current.flags |= 2;
        workInProgress2.memoizedState = null;
        return current;
      }
      function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
        fiber.lanes |= renderLanes2;
        var alternate = fiber.alternate;
        null !== alternate && (alternate.lanes |= renderLanes2);
        scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
      }
      function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, treeForkCount2) {
        var renderState = workInProgress2.memoizedState;
        null === renderState ? workInProgress2.memoizedState = {
          isBackwards,
          rendering: null,
          renderingStartTime: 0,
          last: lastContentRow,
          tail,
          tailMode,
          treeForkCount: treeForkCount2
        } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode, renderState.treeForkCount = treeForkCount2);
      }
      function updateSuspenseListComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
        nextProps = nextProps.children;
        var suspenseContext = suspenseStackCursor.current, shouldForceFallback = 0 !== (suspenseContext & 2);
        shouldForceFallback ? (suspenseContext = suspenseContext & 1 | 2, workInProgress2.flags |= 128) : suspenseContext &= 1;
        push(suspenseStackCursor, suspenseContext);
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        nextProps = isHydrating ? treeForkCount : 0;
        if (!shouldForceFallback && null !== current && 0 !== (current.flags & 128))
          a: for (current = workInProgress2.child; null !== current; ) {
            if (13 === current.tag)
              null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
            else if (19 === current.tag)
              scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
            else if (null !== current.child) {
              current.child.return = current;
              current = current.child;
              continue;
            }
            if (current === workInProgress2) break a;
            for (; null === current.sibling; ) {
              if (null === current.return || current.return === workInProgress2)
                break a;
              current = current.return;
            }
            current.sibling.return = current.return;
            current = current.sibling;
          }
        switch (revealOrder) {
          case "forwards":
            renderLanes2 = workInProgress2.child;
            for (revealOrder = null; null !== renderLanes2; )
              current = renderLanes2.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
            renderLanes2 = revealOrder;
            null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
            initSuspenseListRenderState(
              workInProgress2,
              false,
              revealOrder,
              renderLanes2,
              tailMode,
              nextProps
            );
            break;
          case "backwards":
          case "unstable_legacy-backwards":
            renderLanes2 = null;
            revealOrder = workInProgress2.child;
            for (workInProgress2.child = null; null !== revealOrder; ) {
              current = revealOrder.alternate;
              if (null !== current && null === findFirstSuspended(current)) {
                workInProgress2.child = revealOrder;
                break;
              }
              current = revealOrder.sibling;
              revealOrder.sibling = renderLanes2;
              renderLanes2 = revealOrder;
              revealOrder = current;
            }
            initSuspenseListRenderState(
              workInProgress2,
              true,
              renderLanes2,
              null,
              tailMode,
              nextProps
            );
            break;
          case "together":
            initSuspenseListRenderState(
              workInProgress2,
              false,
              null,
              null,
              void 0,
              nextProps
            );
            break;
          default:
            workInProgress2.memoizedState = null;
        }
        return workInProgress2.child;
      }
      function bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2) {
        null !== current && (workInProgress2.dependencies = current.dependencies);
        workInProgressRootSkippedLanes |= workInProgress2.lanes;
        if (0 === (renderLanes2 & workInProgress2.childLanes))
          if (null !== current) {
            if (propagateParentContextChanges(
              current,
              workInProgress2,
              renderLanes2,
              false
            ), 0 === (renderLanes2 & workInProgress2.childLanes))
              return null;
          } else return null;
        if (null !== current && workInProgress2.child !== current.child)
          throw Error(formatProdErrorMessage(153));
        if (null !== workInProgress2.child) {
          current = workInProgress2.child;
          renderLanes2 = createWorkInProgress(current, current.pendingProps);
          workInProgress2.child = renderLanes2;
          for (renderLanes2.return = workInProgress2; null !== current.sibling; )
            current = current.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current, current.pendingProps), renderLanes2.return = workInProgress2;
          renderLanes2.sibling = null;
        }
        return workInProgress2.child;
      }
      function checkScheduledUpdateOrContext(current, renderLanes2) {
        if (0 !== (current.lanes & renderLanes2)) return true;
        current = current.dependencies;
        return null !== current && checkIfContextChanged(current) ? true : false;
      }
      function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress2, renderLanes2) {
        switch (workInProgress2.tag) {
          case 3:
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
            resetHydrationState();
            break;
          case 27:
          case 5:
            pushHostContext(workInProgress2);
            break;
          case 4:
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            break;
          case 10:
            pushProvider(
              workInProgress2,
              workInProgress2.type,
              workInProgress2.memoizedProps.value
            );
            break;
          case 31:
            if (null !== workInProgress2.memoizedState)
              return workInProgress2.flags |= 128, pushDehydratedActivitySuspenseHandler(workInProgress2), null;
            break;
          case 13:
            var state$102 = workInProgress2.memoizedState;
            if (null !== state$102) {
              if (null !== state$102.dehydrated)
                return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
              if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
                return updateSuspenseComponent(current, workInProgress2, renderLanes2);
              pushPrimaryTreeSuspenseHandler(workInProgress2);
              current = bailoutOnAlreadyFinishedWork(
                current,
                workInProgress2,
                renderLanes2
              );
              return null !== current ? current.sibling : null;
            }
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            break;
          case 19:
            var didSuspendBefore = 0 !== (current.flags & 128);
            state$102 = 0 !== (renderLanes2 & workInProgress2.childLanes);
            state$102 || (propagateParentContextChanges(
              current,
              workInProgress2,
              renderLanes2,
              false
            ), state$102 = 0 !== (renderLanes2 & workInProgress2.childLanes));
            if (didSuspendBefore) {
              if (state$102)
                return updateSuspenseListComponent(
                  current,
                  workInProgress2,
                  renderLanes2
                );
              workInProgress2.flags |= 128;
            }
            didSuspendBefore = workInProgress2.memoizedState;
            null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
            push(suspenseStackCursor, suspenseStackCursor.current);
            if (state$102) break;
            else return null;
          case 22:
            return workInProgress2.lanes = 0, updateOffscreenComponent(
              current,
              workInProgress2,
              renderLanes2,
              workInProgress2.pendingProps
            );
          case 24:
            pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
        }
        return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      }
      function beginWork(current, workInProgress2, renderLanes2) {
        if (null !== current)
          if (current.memoizedProps !== workInProgress2.pendingProps)
            didReceiveUpdate = true;
          else {
            if (!checkScheduledUpdateOrContext(current, renderLanes2) && 0 === (workInProgress2.flags & 128))
              return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
                current,
                workInProgress2,
                renderLanes2
              );
            didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
          }
        else
          didReceiveUpdate = false, isHydrating && 0 !== (workInProgress2.flags & 1048576) && pushTreeId(workInProgress2, treeForkCount, workInProgress2.index);
        workInProgress2.lanes = 0;
        switch (workInProgress2.tag) {
          case 16:
            a: {
              var props = workInProgress2.pendingProps;
              current = resolveLazy(workInProgress2.elementType);
              workInProgress2.type = current;
              if ("function" === typeof current)
                shouldConstruct(current) ? (props = resolveClassComponentProps(current, props), workInProgress2.tag = 1, workInProgress2 = updateClassComponent(
                  null,
                  workInProgress2,
                  current,
                  props,
                  renderLanes2
                )) : (workInProgress2.tag = 0, workInProgress2 = updateFunctionComponent(
                  null,
                  workInProgress2,
                  current,
                  props,
                  renderLanes2
                ));
              else {
                if (void 0 !== current && null !== current) {
                  var $$typeof = current.$$typeof;
                  if ($$typeof === REACT_FORWARD_REF_TYPE) {
                    workInProgress2.tag = 11;
                    workInProgress2 = updateForwardRef(
                      null,
                      workInProgress2,
                      current,
                      props,
                      renderLanes2
                    );
                    break a;
                  } else if ($$typeof === REACT_MEMO_TYPE) {
                    workInProgress2.tag = 14;
                    workInProgress2 = updateMemoComponent(
                      null,
                      workInProgress2,
                      current,
                      props,
                      renderLanes2
                    );
                    break a;
                  }
                }
                workInProgress2 = getComponentNameFromType(current) || current;
                throw Error(formatProdErrorMessage(306, workInProgress2, ""));
              }
            }
            return workInProgress2;
          case 0:
            return updateFunctionComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 1:
            return props = workInProgress2.type, $$typeof = resolveClassComponentProps(
              props,
              workInProgress2.pendingProps
            ), updateClassComponent(
              current,
              workInProgress2,
              props,
              $$typeof,
              renderLanes2
            );
          case 3:
            a: {
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              if (null === current) throw Error(formatProdErrorMessage(387));
              props = workInProgress2.pendingProps;
              var prevState = workInProgress2.memoizedState;
              $$typeof = prevState.element;
              cloneUpdateQueue(current, workInProgress2);
              processUpdateQueue(workInProgress2, props, null, renderLanes2);
              var nextState = workInProgress2.memoizedState;
              props = nextState.cache;
              pushProvider(workInProgress2, CacheContext, props);
              props !== prevState.cache && propagateContextChanges(
                workInProgress2,
                [CacheContext],
                renderLanes2,
                true
              );
              suspendIfUpdateReadFromEntangledAsyncAction();
              props = nextState.element;
              if (prevState.isDehydrated)
                if (prevState = {
                  element: props,
                  isDehydrated: false,
                  cache: nextState.cache
                }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                  workInProgress2 = mountHostRootWithoutHydrating(
                    current,
                    workInProgress2,
                    props,
                    renderLanes2
                  );
                  break a;
                } else if (props !== $$typeof) {
                  $$typeof = createCapturedValueAtFiber(
                    Error(formatProdErrorMessage(424)),
                    workInProgress2
                  );
                  queueHydrationError($$typeof);
                  workInProgress2 = mountHostRootWithoutHydrating(
                    current,
                    workInProgress2,
                    props,
                    renderLanes2
                  );
                  break a;
                } else {
                  current = workInProgress2.stateNode.containerInfo;
                  switch (current.nodeType) {
                    case 9:
                      current = current.body;
                      break;
                    default:
                      current = "HTML" === current.nodeName ? current.ownerDocument.body : current;
                  }
                  nextHydratableInstance = getNextHydratable(current.firstChild);
                  hydrationParentFiber = workInProgress2;
                  isHydrating = true;
                  hydrationErrors = null;
                  rootOrSingletonContext = true;
                  renderLanes2 = mountChildFibers(
                    workInProgress2,
                    null,
                    props,
                    renderLanes2
                  );
                  for (workInProgress2.child = renderLanes2; renderLanes2; )
                    renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
                }
              else {
                resetHydrationState();
                if (props === $$typeof) {
                  workInProgress2 = bailoutOnAlreadyFinishedWork(
                    current,
                    workInProgress2,
                    renderLanes2
                  );
                  break a;
                }
                reconcileChildren(current, workInProgress2, props, renderLanes2);
              }
              workInProgress2 = workInProgress2.child;
            }
            return workInProgress2;
          case 26:
            return markRef(current, workInProgress2), null === current ? (renderLanes2 = getResource(
              workInProgress2.type,
              null,
              workInProgress2.pendingProps,
              null
            )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current = workInProgress2.pendingProps, props = getOwnerDocumentFromRootContainer(
              rootInstanceStackCursor.current
            ).createElement(renderLanes2), props[internalInstanceKey] = workInProgress2, props[internalPropsKey] = current, setInitialProperties(props, renderLanes2, current), markNodeAsHoistable(props), workInProgress2.stateNode = props) : workInProgress2.memoizedState = getResource(
              workInProgress2.type,
              current.memoizedProps,
              workInProgress2.pendingProps,
              current.memoizedState
            ), null;
          case 27:
            return pushHostContext(workInProgress2), null === current && isHydrating && (props = workInProgress2.stateNode = resolveSingletonInstance(
              workInProgress2.type,
              workInProgress2.pendingProps,
              rootInstanceStackCursor.current
            ), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, $$typeof = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = $$typeof, nextHydratableInstance = getNextHydratable(props.firstChild)) : nextHydratableInstance = $$typeof), reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), markRef(current, workInProgress2), null === current && (workInProgress2.flags |= 4194304), workInProgress2.child;
          case 5:
            if (null === current && isHydrating) {
              if ($$typeof = props = nextHydratableInstance)
                props = canHydrateInstance(
                  props,
                  workInProgress2.type,
                  workInProgress2.pendingProps,
                  rootOrSingletonContext
                ), null !== props ? (workInProgress2.stateNode = props, hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(props.firstChild), rootOrSingletonContext = false, $$typeof = true) : $$typeof = false;
              $$typeof || throwOnHydrationMismatch(workInProgress2);
            }
            pushHostContext(workInProgress2);
            $$typeof = workInProgress2.type;
            prevState = workInProgress2.pendingProps;
            nextState = null !== current ? current.memoizedProps : null;
            props = prevState.children;
            shouldSetTextContent($$typeof, prevState) ? props = null : null !== nextState && shouldSetTextContent($$typeof, nextState) && (workInProgress2.flags |= 32);
            null !== workInProgress2.memoizedState && ($$typeof = renderWithHooks(
              current,
              workInProgress2,
              TransitionAwareHostComponent,
              null,
              null,
              renderLanes2
            ), HostTransitionContext._currentValue = $$typeof);
            markRef(current, workInProgress2);
            reconcileChildren(current, workInProgress2, props, renderLanes2);
            return workInProgress2.child;
          case 6:
            if (null === current && isHydrating) {
              if (current = renderLanes2 = nextHydratableInstance)
                renderLanes2 = canHydrateTextInstance(
                  renderLanes2,
                  workInProgress2.pendingProps,
                  rootOrSingletonContext
                ), null !== renderLanes2 ? (workInProgress2.stateNode = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, current = true) : current = false;
              current || throwOnHydrationMismatch(workInProgress2);
            }
            return null;
          case 13:
            return updateSuspenseComponent(current, workInProgress2, renderLanes2);
          case 4:
            return pushHostContainer(
              workInProgress2,
              workInProgress2.stateNode.containerInfo
            ), props = workInProgress2.pendingProps, null === current ? workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              null,
              props,
              renderLanes2
            ) : reconcileChildren(current, workInProgress2, props, renderLanes2), workInProgress2.child;
          case 11:
            return updateForwardRef(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 7:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps,
              renderLanes2
            ), workInProgress2.child;
          case 8:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 12:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 10:
            return props = workInProgress2.pendingProps, pushProvider(workInProgress2, workInProgress2.type, props.value), reconcileChildren(current, workInProgress2, props.children, renderLanes2), workInProgress2.child;
          case 9:
            return $$typeof = workInProgress2.type._context, props = workInProgress2.pendingProps.children, prepareToReadContext(workInProgress2), $$typeof = readContext($$typeof), props = props($$typeof), workInProgress2.flags |= 1, reconcileChildren(current, workInProgress2, props, renderLanes2), workInProgress2.child;
          case 14:
            return updateMemoComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 15:
            return updateSimpleMemoComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 19:
            return updateSuspenseListComponent(current, workInProgress2, renderLanes2);
          case 31:
            return updateActivityComponent(current, workInProgress2, renderLanes2);
          case 22:
            return updateOffscreenComponent(
              current,
              workInProgress2,
              renderLanes2,
              workInProgress2.pendingProps
            );
          case 24:
            return prepareToReadContext(workInProgress2), props = readContext(CacheContext), null === current ? ($$typeof = peekCacheFromPool(), null === $$typeof && ($$typeof = workInProgressRoot, prevState = createCache(), $$typeof.pooledCache = prevState, prevState.refCount++, null !== prevState && ($$typeof.pooledCacheLanes |= renderLanes2), $$typeof = prevState), workInProgress2.memoizedState = { parent: props, cache: $$typeof }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, $$typeof)) : (0 !== (current.lanes & renderLanes2) && (cloneUpdateQueue(current, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), $$typeof = current.memoizedState, prevState = workInProgress2.memoizedState, $$typeof.parent !== props ? ($$typeof = { parent: props, cache: props }, workInProgress2.memoizedState = $$typeof, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = $$typeof), pushProvider(workInProgress2, CacheContext, props)) : (props = prevState.cache, pushProvider(workInProgress2, CacheContext, props), props !== $$typeof.cache && propagateContextChanges(
              workInProgress2,
              [CacheContext],
              renderLanes2,
              true
            ))), reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 29:
            throw workInProgress2.pendingProps;
        }
        throw Error(formatProdErrorMessage(156, workInProgress2.tag));
      }
      function markUpdate(workInProgress2) {
        workInProgress2.flags |= 4;
      }
      function preloadInstanceAndSuspendIfNeeded(workInProgress2, type, oldProps, newProps, renderLanes2) {
        if (type = 0 !== (workInProgress2.mode & 32)) type = false;
        if (type) {
          if (workInProgress2.flags |= 16777216, (renderLanes2 & 335544128) === renderLanes2)
            if (workInProgress2.stateNode.complete) workInProgress2.flags |= 8192;
            else if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
            else
              throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
        } else workInProgress2.flags &= -16777217;
      }
      function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
        if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
          workInProgress2.flags &= -16777217;
        else if (workInProgress2.flags |= 16777216, !preloadResource(resource))
          if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
          else
            throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
      }
      function scheduleRetryEffect(workInProgress2, retryQueue) {
        null !== retryQueue && (workInProgress2.flags |= 4);
        workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
      }
      function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
        if (!isHydrating)
          switch (renderState.tailMode) {
            case "hidden":
              hasRenderedATailFallback = renderState.tail;
              for (var lastTailNode = null; null !== hasRenderedATailFallback; )
                null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
              null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
              break;
            case "collapsed":
              lastTailNode = renderState.tail;
              for (var lastTailNode$106 = null; null !== lastTailNode; )
                null !== lastTailNode.alternate && (lastTailNode$106 = lastTailNode), lastTailNode = lastTailNode.sibling;
              null === lastTailNode$106 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$106.sibling = null;
          }
      }
      function bubbleProperties(completedWork) {
        var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
        if (didBailout)
          for (var child$107 = completedWork.child; null !== child$107; )
            newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags & 65011712, subtreeFlags |= child$107.flags & 65011712, child$107.return = completedWork, child$107 = child$107.sibling;
        else
          for (child$107 = completedWork.child; null !== child$107; )
            newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags, subtreeFlags |= child$107.flags, child$107.return = completedWork, child$107 = child$107.sibling;
        completedWork.subtreeFlags |= subtreeFlags;
        completedWork.childLanes = newChildLanes;
        return didBailout;
      }
      function completeWork(current, workInProgress2, renderLanes2) {
        var newProps = workInProgress2.pendingProps;
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return bubbleProperties(workInProgress2), null;
          case 1:
            return bubbleProperties(workInProgress2), null;
          case 3:
            renderLanes2 = workInProgress2.stateNode;
            newProps = null;
            null !== current && (newProps = current.memoizedState.cache);
            workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
            popProvider(CacheContext);
            popHostContainer();
            renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
            if (null === current || null === current.child)
              popHydrationState(workInProgress2) ? markUpdate(workInProgress2) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
            bubbleProperties(workInProgress2);
            return null;
          case 26:
            var type = workInProgress2.type, nextResource = workInProgress2.memoizedState;
            null === current ? (markUpdate(workInProgress2), null !== nextResource ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
              workInProgress2,
              type,
              null,
              newProps,
              renderLanes2
            ))) : nextResource ? nextResource !== current.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current = current.memoizedProps, current !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
              workInProgress2,
              type,
              current,
              newProps,
              renderLanes2
            ));
            return null;
          case 27:
            popHostContext(workInProgress2);
            renderLanes2 = rootInstanceStackCursor.current;
            type = workInProgress2.type;
            if (null !== current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if (!newProps) {
                if (null === workInProgress2.stateNode)
                  throw Error(formatProdErrorMessage(166));
                bubbleProperties(workInProgress2);
                return null;
              }
              current = contextStackCursor.current;
              popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2) : (current = resolveSingletonInstance(type, newProps, renderLanes2), workInProgress2.stateNode = current, markUpdate(workInProgress2));
            }
            bubbleProperties(workInProgress2);
            return null;
          case 5:
            popHostContext(workInProgress2);
            type = workInProgress2.type;
            if (null !== current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if (!newProps) {
                if (null === workInProgress2.stateNode)
                  throw Error(formatProdErrorMessage(166));
                bubbleProperties(workInProgress2);
                return null;
              }
              nextResource = contextStackCursor.current;
              if (popHydrationState(workInProgress2))
                prepareToHydrateHostInstance(workInProgress2);
              else {
                var ownerDocument = getOwnerDocumentFromRootContainer(
                  rootInstanceStackCursor.current
                );
                switch (nextResource) {
                  case 1:
                    nextResource = ownerDocument.createElementNS(
                      "http://www.w3.org/2000/svg",
                      type
                    );
                    break;
                  case 2:
                    nextResource = ownerDocument.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      type
                    );
                    break;
                  default:
                    switch (type) {
                      case "svg":
                        nextResource = ownerDocument.createElementNS(
                          "http://www.w3.org/2000/svg",
                          type
                        );
                        break;
                      case "math":
                        nextResource = ownerDocument.createElementNS(
                          "http://www.w3.org/1998/Math/MathML",
                          type
                        );
                        break;
                      case "script":
                        nextResource = ownerDocument.createElement("div");
                        nextResource.innerHTML = "<script><\/script>";
                        nextResource = nextResource.removeChild(
                          nextResource.firstChild
                        );
                        break;
                      case "select":
                        nextResource = "string" === typeof newProps.is ? ownerDocument.createElement("select", {
                          is: newProps.is
                        }) : ownerDocument.createElement("select");
                        newProps.multiple ? nextResource.multiple = true : newProps.size && (nextResource.size = newProps.size);
                        break;
                      default:
                        nextResource = "string" === typeof newProps.is ? ownerDocument.createElement(type, { is: newProps.is }) : ownerDocument.createElement(type);
                    }
                }
                nextResource[internalInstanceKey] = workInProgress2;
                nextResource[internalPropsKey] = newProps;
                a: for (ownerDocument = workInProgress2.child; null !== ownerDocument; ) {
                  if (5 === ownerDocument.tag || 6 === ownerDocument.tag)
                    nextResource.appendChild(ownerDocument.stateNode);
                  else if (4 !== ownerDocument.tag && 27 !== ownerDocument.tag && null !== ownerDocument.child) {
                    ownerDocument.child.return = ownerDocument;
                    ownerDocument = ownerDocument.child;
                    continue;
                  }
                  if (ownerDocument === workInProgress2) break a;
                  for (; null === ownerDocument.sibling; ) {
                    if (null === ownerDocument.return || ownerDocument.return === workInProgress2)
                      break a;
                    ownerDocument = ownerDocument.return;
                  }
                  ownerDocument.sibling.return = ownerDocument.return;
                  ownerDocument = ownerDocument.sibling;
                }
                workInProgress2.stateNode = nextResource;
                a: switch (setInitialProperties(nextResource, type, newProps), type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    newProps = !!newProps.autoFocus;
                    break a;
                  case "img":
                    newProps = true;
                    break a;
                  default:
                    newProps = false;
                }
                newProps && markUpdate(workInProgress2);
              }
            }
            bubbleProperties(workInProgress2);
            preloadInstanceAndSuspendIfNeeded(
              workInProgress2,
              workInProgress2.type,
              null === current ? null : current.memoizedProps,
              workInProgress2.pendingProps,
              renderLanes2
            );
            return null;
          case 6:
            if (current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if ("string" !== typeof newProps && null === workInProgress2.stateNode)
                throw Error(formatProdErrorMessage(166));
              current = rootInstanceStackCursor.current;
              if (popHydrationState(workInProgress2)) {
                current = workInProgress2.stateNode;
                renderLanes2 = workInProgress2.memoizedProps;
                newProps = null;
                type = hydrationParentFiber;
                if (null !== type)
                  switch (type.tag) {
                    case 27:
                    case 5:
                      newProps = type.memoizedProps;
                  }
                current[internalInstanceKey] = workInProgress2;
                current = current.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes2) ? true : false;
                current || throwOnHydrationMismatch(workInProgress2, true);
              } else
                current = getOwnerDocumentFromRootContainer(current).createTextNode(
                  newProps
                ), current[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current;
            }
            bubbleProperties(workInProgress2);
            return null;
          case 31:
            renderLanes2 = workInProgress2.memoizedState;
            if (null === current || null !== current.memoizedState) {
              newProps = popHydrationState(workInProgress2);
              if (null !== renderLanes2) {
                if (null === current) {
                  if (!newProps) throw Error(formatProdErrorMessage(318));
                  current = workInProgress2.memoizedState;
                  current = null !== current ? current.dehydrated : null;
                  if (!current) throw Error(formatProdErrorMessage(557));
                  current[internalInstanceKey] = workInProgress2;
                } else
                  resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
                bubbleProperties(workInProgress2);
                current = false;
              } else
                renderLanes2 = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = renderLanes2), current = true;
              if (!current) {
                if (workInProgress2.flags & 256)
                  return popSuspenseHandler(workInProgress2), workInProgress2;
                popSuspenseHandler(workInProgress2);
                return null;
              }
              if (0 !== (workInProgress2.flags & 128))
                throw Error(formatProdErrorMessage(558));
            }
            bubbleProperties(workInProgress2);
            return null;
          case 13:
            newProps = workInProgress2.memoizedState;
            if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
              type = popHydrationState(workInProgress2);
              if (null !== newProps && null !== newProps.dehydrated) {
                if (null === current) {
                  if (!type) throw Error(formatProdErrorMessage(318));
                  type = workInProgress2.memoizedState;
                  type = null !== type ? type.dehydrated : null;
                  if (!type) throw Error(formatProdErrorMessage(317));
                  type[internalInstanceKey] = workInProgress2;
                } else
                  resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
                bubbleProperties(workInProgress2);
                type = false;
              } else
                type = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type), type = true;
              if (!type) {
                if (workInProgress2.flags & 256)
                  return popSuspenseHandler(workInProgress2), workInProgress2;
                popSuspenseHandler(workInProgress2);
                return null;
              }
            }
            popSuspenseHandler(workInProgress2);
            if (0 !== (workInProgress2.flags & 128))
              return workInProgress2.lanes = renderLanes2, workInProgress2;
            renderLanes2 = null !== newProps;
            current = null !== current && null !== current.memoizedState;
            renderLanes2 && (newProps = workInProgress2.child, type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool), nextResource = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (nextResource = newProps.memoizedState.cachePool.pool), nextResource !== type && (newProps.flags |= 2048));
            renderLanes2 !== current && renderLanes2 && (workInProgress2.child.flags |= 8192);
            scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
            bubbleProperties(workInProgress2);
            return null;
          case 4:
            return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
          case 10:
            return popProvider(workInProgress2.type), bubbleProperties(workInProgress2), null;
          case 19:
            pop(suspenseStackCursor);
            newProps = workInProgress2.memoizedState;
            if (null === newProps) return bubbleProperties(workInProgress2), null;
            type = 0 !== (workInProgress2.flags & 128);
            nextResource = newProps.rendering;
            if (null === nextResource)
              if (type) cutOffTailIfNeeded(newProps, false);
              else {
                if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128))
                  for (current = workInProgress2.child; null !== current; ) {
                    nextResource = findFirstSuspended(current);
                    if (null !== nextResource) {
                      workInProgress2.flags |= 128;
                      cutOffTailIfNeeded(newProps, false);
                      current = nextResource.updateQueue;
                      workInProgress2.updateQueue = current;
                      scheduleRetryEffect(workInProgress2, current);
                      workInProgress2.subtreeFlags = 0;
                      current = renderLanes2;
                      for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                        resetWorkInProgress(renderLanes2, current), renderLanes2 = renderLanes2.sibling;
                      push(
                        suspenseStackCursor,
                        suspenseStackCursor.current & 1 | 2
                      );
                      isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount);
                      return workInProgress2.child;
                    }
                    current = current.sibling;
                  }
                null !== newProps.tail && now() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
              }
            else {
              if (!type)
                if (current = findFirstSuspended(nextResource), null !== current) {
                  if (workInProgress2.flags |= 128, type = true, current = current.updateQueue, workInProgress2.updateQueue = current, scheduleRetryEffect(workInProgress2, current), cutOffTailIfNeeded(newProps, true), null === newProps.tail && "hidden" === newProps.tailMode && !nextResource.alternate && !isHydrating)
                    return bubbleProperties(workInProgress2), null;
                } else
                  2 * now() - newProps.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
              newProps.isBackwards ? (nextResource.sibling = workInProgress2.child, workInProgress2.child = nextResource) : (current = newProps.last, null !== current ? current.sibling = nextResource : workInProgress2.child = nextResource, newProps.last = nextResource);
            }
            if (null !== newProps.tail)
              return current = newProps.tail, newProps.rendering = current, newProps.tail = current.sibling, newProps.renderingStartTime = now(), current.sibling = null, renderLanes2 = suspenseStackCursor.current, push(
                suspenseStackCursor,
                type ? renderLanes2 & 1 | 2 : renderLanes2 & 1
              ), isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount), current;
            bubbleProperties(workInProgress2);
            return null;
          case 22:
          case 23:
            return popSuspenseHandler(workInProgress2), popHiddenContext(), newProps = null !== workInProgress2.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes2 = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current && pop(resumedCache), null;
          case 24:
            return renderLanes2 = null, null !== current && (renderLanes2 = current.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress2), null;
          case 25:
            return null;
          case 30:
            return null;
        }
        throw Error(formatProdErrorMessage(156, workInProgress2.tag));
      }
      function unwindWork(current, workInProgress2) {
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case 1:
            return current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 3:
            return popProvider(CacheContext), popHostContainer(), current = workInProgress2.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 26:
          case 27:
          case 5:
            return popHostContext(workInProgress2), null;
          case 31:
            if (null !== workInProgress2.memoizedState) {
              popSuspenseHandler(workInProgress2);
              if (null === workInProgress2.alternate)
                throw Error(formatProdErrorMessage(340));
              resetHydrationState();
            }
            current = workInProgress2.flags;
            return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 13:
            popSuspenseHandler(workInProgress2);
            current = workInProgress2.memoizedState;
            if (null !== current && null !== current.dehydrated) {
              if (null === workInProgress2.alternate)
                throw Error(formatProdErrorMessage(340));
              resetHydrationState();
            }
            current = workInProgress2.flags;
            return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 19:
            return pop(suspenseStackCursor), null;
          case 4:
            return popHostContainer(), null;
          case 10:
            return popProvider(workInProgress2.type), null;
          case 22:
          case 23:
            return popSuspenseHandler(workInProgress2), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 24:
            return popProvider(CacheContext), null;
          case 25:
            return null;
          default:
            return null;
        }
      }
      function unwindInterruptedWork(current, interruptedWork) {
        popTreeContext(interruptedWork);
        switch (interruptedWork.tag) {
          case 3:
            popProvider(CacheContext);
            popHostContainer();
            break;
          case 26:
          case 27:
          case 5:
            popHostContext(interruptedWork);
            break;
          case 4:
            popHostContainer();
            break;
          case 31:
            null !== interruptedWork.memoizedState && popSuspenseHandler(interruptedWork);
            break;
          case 13:
            popSuspenseHandler(interruptedWork);
            break;
          case 19:
            pop(suspenseStackCursor);
            break;
          case 10:
            popProvider(interruptedWork.type);
            break;
          case 22:
          case 23:
            popSuspenseHandler(interruptedWork);
            popHiddenContext();
            null !== current && pop(resumedCache);
            break;
          case 24:
            popProvider(CacheContext);
        }
      }
      function commitHookEffectListMount(flags, finishedWork) {
        try {
          var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue = firstEffect;
            do {
              if ((updateQueue.tag & flags) === flags) {
                lastEffect = void 0;
                var create = updateQueue.create, inst = updateQueue.inst;
                lastEffect = create();
                inst.destroy = lastEffect;
              }
              updateQueue = updateQueue.next;
            } while (updateQueue !== firstEffect);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
        try {
          var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue = firstEffect;
            do {
              if ((updateQueue.tag & flags) === flags) {
                var inst = updateQueue.inst, destroy = inst.destroy;
                if (void 0 !== destroy) {
                  inst.destroy = void 0;
                  lastEffect = finishedWork;
                  var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy;
                  try {
                    destroy_();
                  } catch (error) {
                    captureCommitPhaseError(
                      lastEffect,
                      nearestMountedAncestor,
                      error
                    );
                  }
                }
              }
              updateQueue = updateQueue.next;
            } while (updateQueue !== firstEffect);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitClassCallbacks(finishedWork) {
        var updateQueue = finishedWork.updateQueue;
        if (null !== updateQueue) {
          var instance = finishedWork.stateNode;
          try {
            commitCallbacks(updateQueue, instance);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }
      function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
        instance.props = resolveClassComponentProps(
          current.type,
          current.memoizedProps
        );
        instance.state = current.memoizedState;
        try {
          instance.componentWillUnmount();
        } catch (error) {
          captureCommitPhaseError(current, nearestMountedAncestor, error);
        }
      }
      function safelyAttachRef(current, nearestMountedAncestor) {
        try {
          var ref = current.ref;
          if (null !== ref) {
            switch (current.tag) {
              case 26:
              case 27:
              case 5:
                var instanceToUse = current.stateNode;
                break;
              case 30:
                instanceToUse = current.stateNode;
                break;
              default:
                instanceToUse = current.stateNode;
            }
            "function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
          }
        } catch (error) {
          captureCommitPhaseError(current, nearestMountedAncestor, error);
        }
      }
      function safelyDetachRef(current, nearestMountedAncestor) {
        var ref = current.ref, refCleanup = current.refCleanup;
        if (null !== ref)
          if ("function" === typeof refCleanup)
            try {
              refCleanup();
            } catch (error) {
              captureCommitPhaseError(current, nearestMountedAncestor, error);
            } finally {
              current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
            }
          else if ("function" === typeof ref)
            try {
              ref(null);
            } catch (error$140) {
              captureCommitPhaseError(current, nearestMountedAncestor, error$140);
            }
          else ref.current = null;
      }
      function commitHostMount(finishedWork) {
        var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
        try {
          a: switch (type) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              props.autoFocus && instance.focus();
              break a;
            case "img":
              props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHostUpdate(finishedWork, newProps, oldProps) {
        try {
          var domElement = finishedWork.stateNode;
          updateProperties(domElement, finishedWork.type, oldProps, newProps);
          domElement[internalPropsKey] = newProps;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function isHostParent(fiber) {
        return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
      }
      function getHostSibling(fiber) {
        a: for (; ; ) {
          for (; null === fiber.sibling; ) {
            if (null === fiber.return || isHostParent(fiber.return)) return null;
            fiber = fiber.return;
          }
          fiber.sibling.return = fiber.return;
          for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
            if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
            if (fiber.flags & 2) continue a;
            if (null === fiber.child || 4 === fiber.tag) continue a;
            else fiber.child.return = fiber, fiber = fiber.child;
          }
          if (!(fiber.flags & 2)) return fiber.stateNode;
        }
      }
      function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag)
          node = node.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
        else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
          for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
            insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
      }
      function insertOrAppendPlacementNode(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag)
          node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
        else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
          for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
            insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
      }
      function commitHostSingletonAcquisition(finishedWork) {
        var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
        try {
          for (var type = finishedWork.type, attributes = singleton.attributes; attributes.length; )
            singleton.removeAttributeNode(attributes[0]);
          setInitialProperties(singleton, type, props);
          singleton[internalInstanceKey] = finishedWork;
          singleton[internalPropsKey] = props;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null;
      function commitBeforeMutationEffects(root2, firstChild) {
        root2 = root2.containerInfo;
        eventsEnabled = _enabled;
        root2 = getActiveElementDeep(root2);
        if (hasSelectionCapabilities(root2)) {
          if ("selectionStart" in root2)
            var JSCompiler_temp = {
              start: root2.selectionStart,
              end: root2.selectionEnd
            };
          else
            a: {
              JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
              var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
              if (selection && 0 !== selection.rangeCount) {
                JSCompiler_temp = selection.anchorNode;
                var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
                selection = selection.focusOffset;
                try {
                  JSCompiler_temp.nodeType, focusNode.nodeType;
                } catch (e$20) {
                  JSCompiler_temp = null;
                  break a;
                }
                var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root2, parentNode = null;
                b: for (; ; ) {
                  for (var next; ; ) {
                    node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
                    node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
                    3 === node.nodeType && (length += node.nodeValue.length);
                    if (null === (next = node.firstChild)) break;
                    parentNode = node;
                    node = next;
                  }
                  for (; ; ) {
                    if (node === root2) break b;
                    parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                    parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                    if (null !== (next = node.nextSibling)) break;
                    node = parentNode;
                    parentNode = node.parentNode;
                  }
                  node = next;
                }
                JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
              } else JSCompiler_temp = null;
            }
          JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
        } else JSCompiler_temp = null;
        selectionInformation = { focusedElem: root2, selectionRange: JSCompiler_temp };
        _enabled = false;
        for (nextEffect = firstChild; null !== nextEffect; )
          if (firstChild = nextEffect, root2 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root2)
            root2.return = firstChild, nextEffect = root2;
          else
            for (; null !== nextEffect; ) {
              firstChild = nextEffect;
              focusNode = firstChild.alternate;
              root2 = firstChild.flags;
              switch (firstChild.tag) {
                case 0:
                  if (0 !== (root2 & 4) && (root2 = firstChild.updateQueue, root2 = null !== root2 ? root2.events : null, null !== root2))
                    for (JSCompiler_temp = 0; JSCompiler_temp < root2.length; JSCompiler_temp++)
                      anchorOffset = root2[JSCompiler_temp], anchorOffset.ref.impl = anchorOffset.nextImpl;
                  break;
                case 11:
                case 15:
                  break;
                case 1:
                  if (0 !== (root2 & 1024) && null !== focusNode) {
                    root2 = void 0;
                    JSCompiler_temp = firstChild;
                    anchorOffset = focusNode.memoizedProps;
                    focusNode = focusNode.memoizedState;
                    selection = JSCompiler_temp.stateNode;
                    try {
                      var resolvedPrevProps = resolveClassComponentProps(
                        JSCompiler_temp.type,
                        anchorOffset
                      );
                      root2 = selection.getSnapshotBeforeUpdate(
                        resolvedPrevProps,
                        focusNode
                      );
                      selection.__reactInternalSnapshotBeforeUpdate = root2;
                    } catch (error) {
                      captureCommitPhaseError(
                        JSCompiler_temp,
                        JSCompiler_temp.return,
                        error
                      );
                    }
                  }
                  break;
                case 3:
                  if (0 !== (root2 & 1024)) {
                    if (root2 = firstChild.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, 9 === JSCompiler_temp)
                      clearContainerSparingly(root2);
                    else if (1 === JSCompiler_temp)
                      switch (root2.nodeName) {
                        case "HEAD":
                        case "HTML":
                        case "BODY":
                          clearContainerSparingly(root2);
                          break;
                        default:
                          root2.textContent = "";
                      }
                  }
                  break;
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  if (0 !== (root2 & 1024)) throw Error(formatProdErrorMessage(163));
              }
              root2 = firstChild.sibling;
              if (null !== root2) {
                root2.return = firstChild.return;
                nextEffect = root2;
                break;
              }
              nextEffect = firstChild.return;
            }
      }
      function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitHookEffectListMount(5, finishedWork);
            break;
          case 1:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 4)
              if (finishedRoot = finishedWork.stateNode, null === current)
                try {
                  finishedRoot.componentDidMount();
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              else {
                var prevProps = resolveClassComponentProps(
                  finishedWork.type,
                  current.memoizedProps
                );
                current = current.memoizedState;
                try {
                  finishedRoot.componentDidUpdate(
                    prevProps,
                    current,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  );
                } catch (error$139) {
                  captureCommitPhaseError(
                    finishedWork,
                    finishedWork.return,
                    error$139
                  );
                }
              }
            flags & 64 && commitClassCallbacks(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 3:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 64 && (finishedRoot = finishedWork.updateQueue, null !== finishedRoot)) {
              current = null;
              if (null !== finishedWork.child)
                switch (finishedWork.child.tag) {
                  case 27:
                  case 5:
                    current = finishedWork.child.stateNode;
                    break;
                  case 1:
                    current = finishedWork.child.stateNode;
                }
              try {
                commitCallbacks(finishedRoot, current);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            break;
          case 27:
            null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
          case 26:
          case 5:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            null === current && flags & 4 && commitHostMount(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 12:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            break;
          case 31:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
            break;
          case 13:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
              null,
              finishedWork
            ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
            break;
          case 22:
            flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
            if (!flags) {
              current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
              prevProps = offscreenSubtreeIsHidden;
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = flags;
              (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                0 !== (finishedWork.subtreeFlags & 8772)
              ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              offscreenSubtreeIsHidden = prevProps;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            }
            break;
          case 30:
            break;
          default:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        }
      }
      function detachFiberAfterEffects(fiber) {
        var alternate = fiber.alternate;
        null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
        fiber.child = null;
        fiber.deletions = null;
        fiber.sibling = null;
        5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
        fiber.stateNode = null;
        fiber.return = null;
        fiber.dependencies = null;
        fiber.memoizedProps = null;
        fiber.memoizedState = null;
        fiber.pendingProps = null;
        fiber.stateNode = null;
        fiber.updateQueue = null;
      }
      var hostParent = null, hostParentIsContainer = false;
      function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
        for (parent = parent.child; null !== parent; )
          commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
      }
      function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
        if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
          try {
            injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
          } catch (err) {
          }
        switch (deletedFiber.tag) {
          case 26:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
            break;
          case 27:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
            isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            releaseSingletonInstance(deletedFiber.stateNode);
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            break;
          case 5:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          case 6:
            prevHostParent = hostParent;
            prevHostParentIsContainer = hostParentIsContainer;
            hostParent = null;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            if (null !== hostParent)
              if (hostParentIsContainer)
                try {
                  (9 === hostParent.nodeType ? hostParent.body : "HTML" === hostParent.nodeName ? hostParent.ownerDocument.body : hostParent).removeChild(deletedFiber.stateNode);
                } catch (error) {
                  captureCommitPhaseError(
                    deletedFiber,
                    nearestMountedAncestor,
                    error
                  );
                }
              else
                try {
                  hostParent.removeChild(deletedFiber.stateNode);
                } catch (error) {
                  captureCommitPhaseError(
                    deletedFiber,
                    nearestMountedAncestor,
                    error
                  );
                }
            break;
          case 18:
            null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearHydrationBoundary(
              9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
              deletedFiber.stateNode
            ), retryIfBlockedOn(finishedRoot)) : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
            break;
          case 4:
            prevHostParent = hostParent;
            prevHostParentIsContainer = hostParentIsContainer;
            hostParent = deletedFiber.stateNode.containerInfo;
            hostParentIsContainer = true;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
            offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 1:
            offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
              deletedFiber,
              nearestMountedAncestor,
              prevHostParent
            ));
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 21:
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 22:
            offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            offscreenSubtreeWasHidden = prevHostParent;
            break;
          default:
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
        }
      }
      function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
        if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot))) {
          finishedRoot = finishedRoot.dehydrated;
          try {
            retryIfBlockedOn(finishedRoot);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }
      function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
        if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
          try {
            retryIfBlockedOn(finishedRoot);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
      }
      function getRetryCache(finishedWork) {
        switch (finishedWork.tag) {
          case 31:
          case 13:
          case 19:
            var retryCache = finishedWork.stateNode;
            null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
            return retryCache;
          case 22:
            return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
          default:
            throw Error(formatProdErrorMessage(435, finishedWork.tag));
        }
      }
      function attachSuspenseRetryListeners(finishedWork, wakeables) {
        var retryCache = getRetryCache(finishedWork);
        wakeables.forEach(function(wakeable) {
          if (!retryCache.has(wakeable)) {
            retryCache.add(wakeable);
            var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
            wakeable.then(retry, retry);
          }
        });
      }
      function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
        var deletions = parentFiber.deletions;
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i], root2 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
            a: for (; null !== parent; ) {
              switch (parent.tag) {
                case 27:
                  if (isSingletonScope(parent.type)) {
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break a;
                  }
                  break;
                case 5:
                  hostParent = parent.stateNode;
                  hostParentIsContainer = false;
                  break a;
                case 3:
                case 4:
                  hostParent = parent.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  break a;
              }
              parent = parent.return;
            }
            if (null === hostParent) throw Error(formatProdErrorMessage(160));
            commitDeletionEffectsOnFiber(root2, returnFiber, childToDelete);
            hostParent = null;
            hostParentIsContainer = false;
            root2 = childToDelete.alternate;
            null !== root2 && (root2.return = null);
            childToDelete.return = null;
          }
        if (parentFiber.subtreeFlags & 13886)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
      }
      var currentHoistableRoot = null;
      function commitMutationEffectsOnFiber(finishedWork, root2) {
        var current = finishedWork.alternate, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
            break;
          case 1:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
            break;
          case 26:
            var hoistableRoot = currentHoistableRoot;
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            if (flags & 4) {
              var currentResource = null !== current ? current.memoizedState : null;
              flags = finishedWork.memoizedState;
              if (null === current)
                if (null === flags)
                  if (null === finishedWork.stateNode) {
                    a: {
                      flags = finishedWork.type;
                      current = finishedWork.memoizedProps;
                      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                      b: switch (flags) {
                        case "title":
                          currentResource = hoistableRoot.getElementsByTagName("title")[0];
                          if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop"))
                            currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(
                              currentResource,
                              hoistableRoot.querySelector("head > title")
                            );
                          setInitialProperties(currentResource, flags, current);
                          currentResource[internalInstanceKey] = finishedWork;
                          markNodeAsHoistable(currentResource);
                          flags = currentResource;
                          break a;
                        case "link":
                          var maybeNodes = getHydratableHoistableCache(
                            "link",
                            "href",
                            hoistableRoot
                          ).get(flags + (current.href || ""));
                          if (maybeNodes) {
                            for (var i = 0; i < maybeNodes.length; i++)
                              if (currentResource = maybeNodes[i], currentResource.getAttribute("href") === (null == current.href || "" === current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                                maybeNodes.splice(i, 1);
                                break b;
                              }
                          }
                          currentResource = hoistableRoot.createElement(flags);
                          setInitialProperties(currentResource, flags, current);
                          hoistableRoot.head.appendChild(currentResource);
                          break;
                        case "meta":
                          if (maybeNodes = getHydratableHoistableCache(
                            "meta",
                            "content",
                            hoistableRoot
                          ).get(flags + (current.content || ""))) {
                            for (i = 0; i < maybeNodes.length; i++)
                              if (currentResource = maybeNodes[i], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                                maybeNodes.splice(i, 1);
                                break b;
                              }
                          }
                          currentResource = hoistableRoot.createElement(flags);
                          setInitialProperties(currentResource, flags, current);
                          hoistableRoot.head.appendChild(currentResource);
                          break;
                        default:
                          throw Error(formatProdErrorMessage(468, flags));
                      }
                      currentResource[internalInstanceKey] = finishedWork;
                      markNodeAsHoistable(currentResource);
                      flags = currentResource;
                    }
                    finishedWork.stateNode = flags;
                  } else
                    mountHoistable(
                      hoistableRoot,
                      finishedWork.type,
                      finishedWork.stateNode
                    );
                else
                  finishedWork.stateNode = acquireResource(
                    hoistableRoot,
                    flags,
                    finishedWork.memoizedProps
                  );
              else
                currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(
                  hoistableRoot,
                  finishedWork.type,
                  finishedWork.stateNode
                ) : acquireResource(
                  hoistableRoot,
                  flags,
                  finishedWork.memoizedProps
                )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                  finishedWork,
                  finishedWork.memoizedProps,
                  current.memoizedProps
                );
            }
            break;
          case 27:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            null !== current && flags & 4 && commitHostUpdate(
              finishedWork,
              finishedWork.memoizedProps,
              current.memoizedProps
            );
            break;
          case 5:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            if (finishedWork.flags & 32) {
              hoistableRoot = finishedWork.stateNode;
              try {
                setTextContent(hoistableRoot, "");
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(
              finishedWork,
              hoistableRoot,
              null !== current ? current.memoizedProps : hoistableRoot
            ));
            flags & 1024 && (needsFormReset = true);
            break;
          case 6:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & 4) {
              if (null === finishedWork.stateNode)
                throw Error(formatProdErrorMessage(162));
              flags = finishedWork.memoizedProps;
              current = finishedWork.stateNode;
              try {
                current.nodeValue = flags;
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            break;
          case 3:
            tagCaches = null;
            hoistableRoot = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(root2.containerInfo);
            recursivelyTraverseMutationEffects(root2, finishedWork);
            currentHoistableRoot = hoistableRoot;
            commitReconciliationEffects(finishedWork);
            if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
              try {
                retryIfBlockedOn(root2.containerInfo);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
            break;
          case 4:
            flags = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(
              finishedWork.stateNode.containerInfo
            );
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            currentHoistableRoot = flags;
            break;
          case 12:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            break;
          case 31:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 13:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now());
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 22:
            hoistableRoot = null !== finishedWork.memoizedState;
            var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
            recursivelyTraverseMutationEffects(root2, finishedWork);
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
            commitReconciliationEffects(finishedWork);
            if (flags & 8192)
              a: for (root2 = finishedWork.stateNode, root2._visibility = hoistableRoot ? root2._visibility & -2 : root2._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root2 = finishedWork; ; ) {
                if (5 === root2.tag || 26 === root2.tag) {
                  if (null === current) {
                    wasHidden = current = root2;
                    try {
                      if (currentResource = wasHidden.stateNode, hoistableRoot)
                        maybeNodes = currentResource.style, "function" === typeof maybeNodes.setProperty ? maybeNodes.setProperty("display", "none", "important") : maybeNodes.display = "none";
                      else {
                        i = wasHidden.stateNode;
                        var styleProp = wasHidden.memoizedProps.style, display = void 0 !== styleProp && null !== styleProp && styleProp.hasOwnProperty("display") ? styleProp.display : null;
                        i.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
                      }
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if (6 === root2.tag) {
                  if (null === current) {
                    wasHidden = root2;
                    try {
                      wasHidden.stateNode.nodeValue = hoistableRoot ? "" : wasHidden.memoizedProps;
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if (18 === root2.tag) {
                  if (null === current) {
                    wasHidden = root2;
                    try {
                      var instance = wasHidden.stateNode;
                      hoistableRoot ? hideOrUnhideDehydratedBoundary(instance, true) : hideOrUnhideDehydratedBoundary(wasHidden.stateNode, false);
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if ((22 !== root2.tag && 23 !== root2.tag || null === root2.memoizedState || root2 === finishedWork) && null !== root2.child) {
                  root2.child.return = root2;
                  root2 = root2.child;
                  continue;
                }
                if (root2 === finishedWork) break a;
                for (; null === root2.sibling; ) {
                  if (null === root2.return || root2.return === finishedWork) break a;
                  current === root2 && (current = null);
                  root2 = root2.return;
                }
                current === root2 && (current = null);
                root2.sibling.return = root2.return;
                root2 = root2.sibling;
              }
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
            break;
          case 19:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 30:
            break;
          case 21:
            break;
          default:
            recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
        }
      }
      function commitReconciliationEffects(finishedWork) {
        var flags = finishedWork.flags;
        if (flags & 2) {
          try {
            for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
              if (isHostParent(parentFiber)) {
                hostParentFiber = parentFiber;
                break;
              }
              parentFiber = parentFiber.return;
            }
            if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
            switch (hostParentFiber.tag) {
              case 27:
                var parent = hostParentFiber.stateNode, before = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before, parent);
                break;
              case 5:
                var parent$141 = hostParentFiber.stateNode;
                hostParentFiber.flags & 32 && (setTextContent(parent$141, ""), hostParentFiber.flags &= -33);
                var before$142 = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before$142, parent$141);
                break;
              case 3:
              case 4:
                var parent$143 = hostParentFiber.stateNode.containerInfo, before$144 = getHostSibling(finishedWork);
                insertOrAppendPlacementNodeIntoContainer(
                  finishedWork,
                  before$144,
                  parent$143
                );
                break;
              default:
                throw Error(formatProdErrorMessage(161));
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
          finishedWork.flags &= -3;
        }
        flags & 4096 && (finishedWork.flags &= -4097);
      }
      function recursivelyResetForms(parentFiber) {
        if (parentFiber.subtreeFlags & 1024)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var fiber = parentFiber;
            recursivelyResetForms(fiber);
            5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
            parentFiber = parentFiber.sibling;
          }
      }
      function recursivelyTraverseLayoutEffects(root2, parentFiber) {
        if (parentFiber.subtreeFlags & 8772)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
      }
      function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedWork = parentFiber;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 1:
              safelyDetachRef(finishedWork, finishedWork.return);
              var instance = finishedWork.stateNode;
              "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
                finishedWork,
                finishedWork.return,
                instance
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 27:
              releaseSingletonInstance(finishedWork.stateNode);
            case 26:
            case 5:
              safelyDetachRef(finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 30:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            default:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              commitHookEffectListMount(4, finishedWork);
              break;
            case 1:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              current = finishedWork;
              finishedRoot = current.stateNode;
              if ("function" === typeof finishedRoot.componentDidMount)
                try {
                  finishedRoot.componentDidMount();
                } catch (error) {
                  captureCommitPhaseError(current, current.return, error);
                }
              current = finishedWork;
              finishedRoot = current.updateQueue;
              if (null !== finishedRoot) {
                var instance = current.stateNode;
                try {
                  var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
                  if (null !== hiddenCallbacks)
                    for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++)
                      callCallback(hiddenCallbacks[finishedRoot], instance);
                } catch (error) {
                  captureCommitPhaseError(current, current.return, error);
                }
              }
              includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 27:
              commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              break;
            case 31:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 13:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 30:
              break;
            default:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function commitOffscreenPassiveMountEffects(current, finishedWork) {
        var previousCache = null;
        null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
        current = null;
        null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
        current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
      }
      function commitCachePassiveMountEffect(current, finishedWork) {
        current = null;
        null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
        finishedWork = finishedWork.memoizedState.cache;
        finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
      }
      function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions) {
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitPassiveMountOnFiber(
              root2,
              parentFiber,
              committedLanes,
              committedTransitions
            ), parentFiber = parentFiber.sibling;
      }
      function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && commitHookEffectListMount(9, finishedWork);
            break;
          case 1:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 3:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
            break;
          case 12:
            if (flags & 2048) {
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              finishedRoot = finishedWork.stateNode;
              try {
                var _finishedWork$memoize2 = finishedWork.memoizedProps, id = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
                "function" === typeof onPostCommit && onPostCommit(
                  id,
                  null === finishedWork.alternate ? "mount" : "update",
                  finishedRoot.passiveEffectDuration,
                  -0
                );
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            } else
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
            break;
          case 31:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 13:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 23:
            break;
          case 22:
            _finishedWork$memoize2 = finishedWork.stateNode;
            id = finishedWork.alternate;
            null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            ) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            ) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              0 !== (finishedWork.subtreeFlags & 10256) || false
            ));
            flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
            break;
          case 24:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
        }
      }
      function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && (0 !== (parentFiber.subtreeFlags & 10256) || false);
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              commitHookEffectListMount(8, finishedWork);
              break;
            case 23:
              break;
            case 22:
              var instance = finishedWork.stateNode;
              null !== finishedWork.memoizedState ? instance._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              ) : (instance._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ));
              includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case 22:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                flags & 2048 && commitOffscreenPassiveMountEffects(
                  finishedWork.alternate,
                  finishedWork
                );
                break;
              case 24:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
                break;
              default:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
            }
            parentFiber = parentFiber.sibling;
          }
      }
      var suspenseyCommitFlag = 8192;
      function recursivelyAccumulateSuspenseyCommit(parentFiber, committedLanes, suspendedState) {
        if (parentFiber.subtreeFlags & suspenseyCommitFlag)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            accumulateSuspenseyCommitOnFiber(
              parentFiber,
              committedLanes,
              suspendedState
            ), parentFiber = parentFiber.sibling;
      }
      function accumulateSuspenseyCommitOnFiber(fiber, committedLanes, suspendedState) {
        switch (fiber.tag) {
          case 26:
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            );
            fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
              suspendedState,
              currentHoistableRoot,
              fiber.memoizedState,
              fiber.memoizedProps
            );
            break;
          case 5:
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            );
            break;
          case 3:
          case 4:
            var previousHoistableRoot = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            );
            currentHoistableRoot = previousHoistableRoot;
            break;
          case 22:
            null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            ), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            ));
            break;
          default:
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            );
        }
      }
      function detachAlternateSiblings(parentFiber) {
        var previousFiber = parentFiber.alternate;
        if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
          previousFiber.child = null;
          do
            previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
          while (null !== parentFiber);
        }
      }
      function recursivelyTraversePassiveUnmountEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i];
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                childToDelete,
                parentFiber
              );
            }
          detachAlternateSiblings(parentFiber);
        }
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
      }
      function commitPassiveUnmountOnFiber(finishedWork) {
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
            break;
          case 3:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          case 12:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          case 22:
            var instance = finishedWork.stateNode;
            null !== finishedWork.memoizedState && instance._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          default:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
        }
      }
      function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i];
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                childToDelete,
                parentFiber
              );
            }
          detachAlternateSiblings(parentFiber);
        }
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          deletions = parentFiber;
          switch (deletions.tag) {
            case 0:
            case 11:
            case 15:
              commitHookEffectListUnmount(8, deletions, deletions.return);
              recursivelyTraverseDisconnectPassiveEffects(deletions);
              break;
            case 22:
              i = deletions.stateNode;
              i._visibility & 2 && (i._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
              break;
            default:
              recursivelyTraverseDisconnectPassiveEffects(deletions);
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
        for (; null !== nextEffect; ) {
          var fiber = nextEffect;
          switch (fiber.tag) {
            case 0:
            case 11:
            case 15:
              commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
              break;
            case 23:
            case 22:
              if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
                var cache = fiber.memoizedState.cachePool.pool;
                null != cache && cache.refCount++;
              }
              break;
            case 24:
              releaseCache(fiber.memoizedState.cache);
          }
          cache = fiber.child;
          if (null !== cache) cache.return = fiber, nextEffect = cache;
          else
            a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
              cache = nextEffect;
              var sibling = cache.sibling, returnFiber = cache.return;
              detachFiberAfterEffects(cache);
              if (cache === fiber) {
                nextEffect = null;
                break a;
              }
              if (null !== sibling) {
                sibling.return = returnFiber;
                nextEffect = sibling;
                break a;
              }
              nextEffect = returnFiber;
            }
        }
      }
      var DefaultAsyncDispatcher = {
        getCacheForType: function(resourceType) {
          var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
          void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
          return cacheForType;
        },
        cacheSignal: function() {
          return readContext(CacheContext).controller.signal;
        }
      }, PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, executionContext = 0, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = 0, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, globalMostRecentTransitionTime = 0, workInProgressRootRenderTargetTime = Infinity, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, nestedUpdateCount = 0, rootWithNestedUpdates = null;
      function requestUpdateLane() {
        return 0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes ? workInProgressRootRenderLanes & -workInProgressRootRenderLanes : null !== ReactSharedInternals.T ? requestTransitionLane() : resolveUpdatePriority();
      }
      function requestDeferredLane() {
        if (0 === workInProgressDeferredLane)
          if (0 === (workInProgressRootRenderLanes & 536870912) || isHydrating) {
            var lane = nextTransitionDeferredLane;
            nextTransitionDeferredLane <<= 1;
            0 === (nextTransitionDeferredLane & 3932160) && (nextTransitionDeferredLane = 262144);
            workInProgressDeferredLane = lane;
          } else workInProgressDeferredLane = 536870912;
        lane = suspenseHandlerStackCursor.current;
        null !== lane && (lane.flags |= 32);
        return workInProgressDeferredLane;
      }
      function scheduleUpdateOnFiber(root2, fiber, lane) {
        if (root2 === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
          prepareFreshStack(root2, 0), markRootSuspended(
            root2,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          );
        markRootUpdated$1(root2, lane);
        if (0 === (executionContext & 2) || root2 !== workInProgressRoot)
          root2 === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(
            root2,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          )), ensureRootIsScheduled(root2);
      }
      function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
        var shouldTimeSlice = !forceSync && 0 === (lanes & 127) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
        do {
          if (0 === exitStatus) {
            workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
            break;
          } else {
            forceSync = root$jscomp$0.current.alternate;
            if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
              exitStatus = renderRootSync(root$jscomp$0, lanes, false);
              renderWasConcurrent = false;
              continue;
            }
            if (2 === exitStatus) {
              renderWasConcurrent = lanes;
              if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
                var JSCompiler_inline_result = 0;
              else
                JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
              if (0 !== JSCompiler_inline_result) {
                lanes = JSCompiler_inline_result;
                a: {
                  var root2 = root$jscomp$0;
                  exitStatus = workInProgressRootConcurrentErrors;
                  var wasRootDehydrated = root2.current.memoizedState.isDehydrated;
                  wasRootDehydrated && (prepareFreshStack(root2, JSCompiler_inline_result).flags |= 256);
                  JSCompiler_inline_result = renderRootSync(
                    root2,
                    JSCompiler_inline_result,
                    false
                  );
                  if (2 !== JSCompiler_inline_result) {
                    if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                      root2.errorRecoveryDisabledLanes |= renderWasConcurrent;
                      workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                      exitStatus = 4;
                      break a;
                    }
                    renderWasConcurrent = workInProgressRootRecoverableErrors;
                    workInProgressRootRecoverableErrors = exitStatus;
                    null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(
                      workInProgressRootRecoverableErrors,
                      renderWasConcurrent
                    ));
                  }
                  exitStatus = JSCompiler_inline_result;
                }
                renderWasConcurrent = false;
                if (2 !== exitStatus) continue;
              }
            }
            if (1 === exitStatus) {
              prepareFreshStack(root$jscomp$0, 0);
              markRootSuspended(root$jscomp$0, lanes, 0, true);
              break;
            }
            a: {
              shouldTimeSlice = root$jscomp$0;
              renderWasConcurrent = exitStatus;
              switch (renderWasConcurrent) {
                case 0:
                case 1:
                  throw Error(formatProdErrorMessage(345));
                case 4:
                  if ((lanes & 4194048) !== lanes) break;
                case 6:
                  markRootSuspended(
                    shouldTimeSlice,
                    lanes,
                    workInProgressDeferredLane,
                    !workInProgressRootDidSkipSuspendedSiblings
                  );
                  break a;
                case 2:
                  workInProgressRootRecoverableErrors = null;
                  break;
                case 3:
                case 5:
                  break;
                default:
                  throw Error(formatProdErrorMessage(329));
              }
              if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now(), 10 < exitStatus)) {
                markRootSuspended(
                  shouldTimeSlice,
                  lanes,
                  workInProgressDeferredLane,
                  !workInProgressRootDidSkipSuspendedSiblings
                );
                if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
                pendingEffectsLanes = lanes;
                shouldTimeSlice.timeoutHandle = scheduleTimeout(
                  commitRootWhenReady.bind(
                    null,
                    shouldTimeSlice,
                    forceSync,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    lanes,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    workInProgressRootDidSkipSuspendedSiblings,
                    renderWasConcurrent,
                    "Throttled",
                    -0,
                    0
                  ),
                  exitStatus
                );
                break a;
              }
              commitRootWhenReady(
                shouldTimeSlice,
                forceSync,
                workInProgressRootRecoverableErrors,
                workInProgressTransitions,
                workInProgressRootDidIncludeRecursiveRenderUpdate,
                lanes,
                workInProgressDeferredLane,
                workInProgressRootInterleavedUpdatedLanes,
                workInProgressSuspendedRetryLanes,
                workInProgressRootDidSkipSuspendedSiblings,
                renderWasConcurrent,
                null,
                -0,
                0
              );
            }
          }
          break;
        } while (1);
        ensureRootIsScheduled(root$jscomp$0);
      }
      function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
        root2.timeoutHandle = -1;
        suspendedCommitReason = finishedWork.subtreeFlags;
        if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
          suspendedCommitReason = {
            stylesheets: null,
            count: 0,
            imgCount: 0,
            imgBytes: 0,
            suspenseyImages: [],
            waitingForImages: true,
            waitingForViewTransition: false,
            unsuspend: noop$1
          };
          accumulateSuspenseyCommitOnFiber(
            finishedWork,
            lanes,
            suspendedCommitReason
          );
          var timeoutOffset = (lanes & 62914560) === lanes ? globalMostRecentFallbackTime - now() : (lanes & 4194048) === lanes ? globalMostRecentTransitionTime - now() : 0;
          timeoutOffset = waitForCommitToBeReady(
            suspendedCommitReason,
            timeoutOffset
          );
          if (null !== timeoutOffset) {
            pendingEffectsLanes = lanes;
            root2.cancelPendingCommit = timeoutOffset(
              commitRoot.bind(
                null,
                root2,
                finishedWork,
                lanes,
                recoverableErrors,
                transitions,
                didIncludeRenderPhaseUpdate,
                spawnedLane,
                updatedLanes,
                suspendedRetryLanes,
                exitStatus,
                suspendedCommitReason,
                null,
                completedRenderStartTime,
                completedRenderEndTime
              )
            );
            markRootSuspended(root2, lanes, spawnedLane, !didSkipSuspendedSiblings);
            return;
          }
        }
        commitRoot(
          root2,
          finishedWork,
          lanes,
          recoverableErrors,
          transitions,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes
        );
      }
      function isRenderConsistentWithExternalStores(finishedWork) {
        for (var node = finishedWork; ; ) {
          var tag = node.tag;
          if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
            for (var i = 0; i < tag.length; i++) {
              var check = tag[i], getSnapshot = check.getSnapshot;
              check = check.value;
              try {
                if (!objectIs(getSnapshot(), check)) return false;
              } catch (error) {
                return false;
              }
            }
          tag = node.child;
          if (node.subtreeFlags & 16384 && null !== tag)
            tag.return = node, node = tag;
          else {
            if (node === finishedWork) break;
            for (; null === node.sibling; ) {
              if (null === node.return || node.return === finishedWork) return true;
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
        return true;
      }
      function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
        suspendedLanes &= ~workInProgressRootPingedLanes;
        suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
        root2.suspendedLanes |= suspendedLanes;
        root2.pingedLanes &= ~suspendedLanes;
        didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
        didAttemptEntireTree = root2.expirationTimes;
        for (var lanes = suspendedLanes; 0 < lanes; ) {
          var index$6 = 31 - clz32(lanes), lane = 1 << index$6;
          didAttemptEntireTree[index$6] = -1;
          lanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
      }
      function flushSyncWork$1() {
        return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0), false) : true;
      }
      function resetWorkInProgressStack() {
        if (null !== workInProgress) {
          if (0 === workInProgressSuspendedReason)
            var interruptedWork = workInProgress.return;
          else
            interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
          for (; null !== interruptedWork; )
            unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
          workInProgress = null;
        }
      }
      function prepareFreshStack(root2, lanes) {
        var timeoutHandle = root2.timeoutHandle;
        -1 !== timeoutHandle && (root2.timeoutHandle = -1, cancelTimeout(timeoutHandle));
        timeoutHandle = root2.cancelPendingCommit;
        null !== timeoutHandle && (root2.cancelPendingCommit = null, timeoutHandle());
        pendingEffectsLanes = 0;
        resetWorkInProgressStack();
        workInProgressRoot = root2;
        workInProgress = timeoutHandle = createWorkInProgress(root2.current, null);
        workInProgressRootRenderLanes = lanes;
        workInProgressSuspendedReason = 0;
        workInProgressThrownValue = null;
        workInProgressRootDidSkipSuspendedSiblings = false;
        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
        workInProgressRootDidAttachPingListener = false;
        workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
        workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
        workInProgressRootDidIncludeRecursiveRenderUpdate = false;
        0 !== (lanes & 8) && (lanes |= lanes & 32);
        var allEntangledLanes = root2.entangledLanes;
        if (0 !== allEntangledLanes)
          for (root2 = root2.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
            var index$4 = 31 - clz32(allEntangledLanes), lane = 1 << index$4;
            lanes |= root2[index$4];
            allEntangledLanes &= ~lane;
          }
        entangledRenderLanes = lanes;
        finishQueueingConcurrentUpdates();
        return timeoutHandle;
      }
      function handleThrow(root2, thrownValue) {
        currentlyRenderingFiber = null;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
        workInProgressThrownValue = thrownValue;
        null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(
          root2,
          createCapturedValueAtFiber(thrownValue, root2.current)
        ));
      }
      function shouldRemainOnPreviousScreen() {
        var handler = suspenseHandlerStackCursor.current;
        return null === handler ? true : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null === shellBoundary ? true : false : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : false;
      }
      function pushDispatcher() {
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
      }
      function pushAsyncDispatcher() {
        var prevAsyncDispatcher = ReactSharedInternals.A;
        ReactSharedInternals.A = DefaultAsyncDispatcher;
        return prevAsyncDispatcher;
      }
      function renderDidSuspendDelayIfPossible() {
        workInProgressRootExitStatus = 4;
        workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
        0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
          workInProgressRoot,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        );
      }
      function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
        var prevExecutionContext = executionContext;
        executionContext |= 2;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes)
          workInProgressTransitions = null, prepareFreshStack(root2, lanes);
        lanes = false;
        var exitStatus = workInProgressRootExitStatus;
        a: do
          try {
            if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
              var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
              switch (workInProgressSuspendedReason) {
                case 8:
                  resetWorkInProgressStack();
                  exitStatus = 6;
                  break a;
                case 3:
                case 2:
                case 9:
                case 6:
                  null === suspenseHandlerStackCursor.current && (lanes = true);
                  var reason = workInProgressSuspendedReason;
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                  if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                    exitStatus = 0;
                    break a;
                  }
                  break;
                default:
                  reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
              }
            }
            workLoopSync();
            exitStatus = workInProgressRootExitStatus;
            break;
          } catch (thrownValue$165) {
            handleThrow(root2, thrownValue$165);
          }
        while (1);
        lanes && root2.shellSuspendCounter++;
        lastContextDependency = currentlyRenderingFiber$1 = null;
        executionContext = prevExecutionContext;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
        return exitStatus;
      }
      function workLoopSync() {
        for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
      }
      function renderRootConcurrent(root2, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= 2;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now() + 500, prepareFreshStack(root2, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
          root2,
          lanes
        );
        a: do
          try {
            if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
              lanes = workInProgress;
              var thrownValue = workInProgressThrownValue;
              b: switch (workInProgressSuspendedReason) {
                case 1:
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, lanes, thrownValue, 1);
                  break;
                case 2:
                case 9:
                  if (isThenableResolved(thrownValue)) {
                    workInProgressSuspendedReason = 0;
                    workInProgressThrownValue = null;
                    replaySuspendedUnitOfWork(lanes);
                    break;
                  }
                  lanes = function() {
                    2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason || workInProgressRoot !== root2 || (workInProgressSuspendedReason = 7);
                    ensureRootIsScheduled(root2);
                  };
                  thrownValue.then(lanes, lanes);
                  break a;
                case 3:
                  workInProgressSuspendedReason = 7;
                  break a;
                case 4:
                  workInProgressSuspendedReason = 5;
                  break a;
                case 7:
                  isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, lanes, thrownValue, 7));
                  break;
                case 5:
                  var resource = null;
                  switch (workInProgress.tag) {
                    case 26:
                      resource = workInProgress.memoizedState;
                    case 5:
                    case 27:
                      var hostFiber = workInProgress;
                      if (resource ? preloadResource(resource) : hostFiber.stateNode.complete) {
                        workInProgressSuspendedReason = 0;
                        workInProgressThrownValue = null;
                        var sibling = hostFiber.sibling;
                        if (null !== sibling) workInProgress = sibling;
                        else {
                          var returnFiber = hostFiber.return;
                          null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                        }
                        break b;
                      }
                  }
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, lanes, thrownValue, 5);
                  break;
                case 6:
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, lanes, thrownValue, 6);
                  break;
                case 8:
                  resetWorkInProgressStack();
                  workInProgressRootExitStatus = 6;
                  break a;
                default:
                  throw Error(formatProdErrorMessage(462));
              }
            }
            workLoopConcurrentByScheduler();
            break;
          } catch (thrownValue$167) {
            handleThrow(root2, thrownValue$167);
          }
        while (1);
        lastContextDependency = currentlyRenderingFiber$1 = null;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        executionContext = prevExecutionContext;
        if (null !== workInProgress) return 0;
        workInProgressRoot = null;
        workInProgressRootRenderLanes = 0;
        finishQueueingConcurrentUpdates();
        return workInProgressRootExitStatus;
      }
      function workLoopConcurrentByScheduler() {
        for (; null !== workInProgress && !shouldYield(); )
          performUnitOfWork(workInProgress);
      }
      function performUnitOfWork(unitOfWork) {
        var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
      }
      function replaySuspendedUnitOfWork(unitOfWork) {
        var next = unitOfWork;
        var current = next.alternate;
        switch (next.tag) {
          case 15:
          case 0:
            next = replayFunctionComponent(
              current,
              next,
              next.pendingProps,
              next.type,
              void 0,
              workInProgressRootRenderLanes
            );
            break;
          case 11:
            next = replayFunctionComponent(
              current,
              next,
              next.pendingProps,
              next.type.render,
              next.ref,
              workInProgressRootRenderLanes
            );
            break;
          case 5:
            resetHooksOnUnwind(next);
          default:
            unwindInterruptedWork(current, next), next = workInProgress = resetWorkInProgress(next, entangledRenderLanes), next = beginWork(current, next, entangledRenderLanes);
        }
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
      }
      function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
        lastContextDependency = currentlyRenderingFiber$1 = null;
        resetHooksOnUnwind(unitOfWork);
        thenableState$1 = null;
        thenableIndexCounter$1 = 0;
        var returnFiber = unitOfWork.return;
        try {
          if (throwException(
            root2,
            returnFiber,
            unitOfWork,
            thrownValue,
            workInProgressRootRenderLanes
          )) {
            workInProgressRootExitStatus = 1;
            logUncaughtError(
              root2,
              createCapturedValueAtFiber(thrownValue, root2.current)
            );
            workInProgress = null;
            return;
          }
        } catch (error) {
          if (null !== returnFiber) throw workInProgress = returnFiber, error;
          workInProgressRootExitStatus = 1;
          logUncaughtError(
            root2,
            createCapturedValueAtFiber(thrownValue, root2.current)
          );
          workInProgress = null;
          return;
        }
        if (unitOfWork.flags & 32768) {
          if (isHydrating || 1 === suspendedReason) root2 = true;
          else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
            root2 = false;
          else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
            suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
          unwindUnitOfWork(unitOfWork, root2);
        } else completeUnitOfWork(unitOfWork);
      }
      function completeUnitOfWork(unitOfWork) {
        var completedWork = unitOfWork;
        do {
          if (0 !== (completedWork.flags & 32768)) {
            unwindUnitOfWork(
              completedWork,
              workInProgressRootDidSkipSuspendedSiblings
            );
            return;
          }
          unitOfWork = completedWork.return;
          var next = completeWork(
            completedWork.alternate,
            completedWork,
            entangledRenderLanes
          );
          if (null !== next) {
            workInProgress = next;
            return;
          }
          completedWork = completedWork.sibling;
          if (null !== completedWork) {
            workInProgress = completedWork;
            return;
          }
          workInProgress = completedWork = unitOfWork;
        } while (null !== completedWork);
        0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
      }
      function unwindUnitOfWork(unitOfWork, skipSiblings) {
        do {
          var next = unwindWork(unitOfWork.alternate, unitOfWork);
          if (null !== next) {
            next.flags &= 32767;
            workInProgress = next;
            return;
          }
          next = unitOfWork.return;
          null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
          if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
            workInProgress = unitOfWork;
            return;
          }
          workInProgress = unitOfWork = next;
        } while (null !== unitOfWork);
        workInProgressRootExitStatus = 6;
        workInProgress = null;
      }
      function commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
        root2.cancelPendingCommit = null;
        do
          flushPendingEffects();
        while (0 !== pendingEffectsStatus);
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
        if (null !== finishedWork) {
          if (finishedWork === root2.current) throw Error(formatProdErrorMessage(177));
          didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
          didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
          markRootFinished(
            root2,
            lanes,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes
          );
          root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
          pendingFinishedWork = finishedWork;
          pendingEffectsRoot = root2;
          pendingEffectsLanes = lanes;
          pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
          pendingPassiveTransitions = transitions;
          pendingRecoverableErrors = recoverableErrors;
          0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root2.callbackNode = null, root2.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
            flushPassiveEffects();
            return null;
          })) : (root2.callbackNode = null, root2.callbackPriority = 0);
          recoverableErrors = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
            recoverableErrors = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            transitions = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            spawnedLane = executionContext;
            executionContext |= 4;
            try {
              commitBeforeMutationEffects(root2, finishedWork, lanes);
            } finally {
              executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
            }
          }
          pendingEffectsStatus = 1;
          flushMutationEffects();
          flushLayoutEffects();
          flushSpawnedWork();
        }
      }
      function flushMutationEffects() {
        if (1 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
            rootMutationHasEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            var prevExecutionContext = executionContext;
            executionContext |= 4;
            try {
              commitMutationEffectsOnFiber(finishedWork, root2);
              var priorSelectionInformation = selectionInformation, curFocusedElem = getActiveElementDeep(root2.containerInfo), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
              if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
                priorFocusedElem.ownerDocument.documentElement,
                priorFocusedElem
              )) {
                if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                  var start = priorSelectionRange.start, end = priorSelectionRange.end;
                  void 0 === end && (end = start);
                  if ("selectionStart" in priorFocusedElem)
                    priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
                      end,
                      priorFocusedElem.value.length
                    );
                  else {
                    var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
                    if (win.getSelection) {
                      var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                      !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                      var startMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        start$jscomp$0
                      ), endMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        end$jscomp$0
                      );
                      if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                        var range = doc.createRange();
                        range.setStart(startMarker.node, startMarker.offset);
                        selection.removeAllRanges();
                        start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                      }
                    }
                  }
                }
                doc = [];
                for (selection = priorFocusedElem; selection = selection.parentNode; )
                  1 === selection.nodeType && doc.push({
                    element: selection,
                    left: selection.scrollLeft,
                    top: selection.scrollTop
                  });
                "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
                for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
                  var info = doc[priorFocusedElem];
                  info.element.scrollLeft = info.left;
                  info.element.scrollTop = info.top;
                }
              }
              _enabled = !!eventsEnabled;
              selectionInformation = eventsEnabled = null;
            } finally {
              executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
            }
          }
          root2.current = finishedWork;
          pendingEffectsStatus = 2;
        }
      }
      function flushLayoutEffects() {
        if (2 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
          if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
            rootHasLayoutEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            var prevExecutionContext = executionContext;
            executionContext |= 4;
            try {
              commitLayoutEffectOnFiber(root2, finishedWork.alternate, finishedWork);
            } finally {
              executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
            }
          }
          pendingEffectsStatus = 3;
        }
      }
      function flushSpawnedWork() {
        if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          requestPaint();
          var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
          0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root2, root2.pendingLanes));
          var remainingLanes = root2.pendingLanes;
          0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
          lanesToEventPriority(lanes);
          finishedWork = finishedWork.stateNode;
          if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
            try {
              injectedHook.onCommitFiberRoot(
                rendererID,
                finishedWork,
                void 0,
                128 === (finishedWork.current.flags & 128)
              );
            } catch (err) {
            }
          if (null !== recoverableErrors) {
            finishedWork = ReactSharedInternals.T;
            remainingLanes = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            ReactSharedInternals.T = null;
            try {
              for (var onRecoverableError = root2.onRecoverableError, i = 0; i < recoverableErrors.length; i++) {
                var recoverableError = recoverableErrors[i];
                onRecoverableError(recoverableError.value, {
                  componentStack: recoverableError.stack
                });
              }
            } finally {
              ReactSharedInternals.T = finishedWork, ReactDOMSharedInternals.p = remainingLanes;
            }
          }
          0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
          ensureRootIsScheduled(root2);
          remainingLanes = root2.pendingLanes;
          0 !== (lanes & 261930) && 0 !== (remainingLanes & 42) ? root2 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root2) : nestedUpdateCount = 0;
          flushSyncWorkAcrossRoots_impl(0);
        }
      }
      function releaseRootPooledCache(root2, remainingLanes) {
        0 === (root2.pooledCacheLanes &= remainingLanes) && (remainingLanes = root2.pooledCache, null != remainingLanes && (root2.pooledCache = null, releaseCache(remainingLanes)));
      }
      function flushPendingEffects() {
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
        return flushPassiveEffects();
      }
      function flushPassiveEffects() {
        if (5 !== pendingEffectsStatus) return false;
        var root2 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
        pendingEffectsRemainingLanes = 0;
        var renderPriority = lanesToEventPriority(pendingEffectsLanes), prevTransition = ReactSharedInternals.T, previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
          ReactSharedInternals.T = null;
          renderPriority = pendingPassiveTransitions;
          pendingPassiveTransitions = null;
          var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
          pendingEffectsStatus = 0;
          pendingFinishedWork = pendingEffectsRoot = null;
          pendingEffectsLanes = 0;
          if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
          var prevExecutionContext = executionContext;
          executionContext |= 4;
          commitPassiveUnmountOnFiber(root$jscomp$0.current);
          commitPassiveMountOnFiber(
            root$jscomp$0,
            root$jscomp$0.current,
            lanes,
            renderPriority
          );
          executionContext = prevExecutionContext;
          flushSyncWorkAcrossRoots_impl(0, false);
          if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
            try {
              injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
            } catch (err) {
            }
          return true;
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root2, remainingLanes);
        }
      }
      function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
        sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
        rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
        null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
      }
      function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
        if (3 === sourceFiber.tag)
          captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
        else
          for (; null !== nearestMountedAncestor; ) {
            if (3 === nearestMountedAncestor.tag) {
              captureCommitPhaseErrorOnRoot(
                nearestMountedAncestor,
                sourceFiber,
                error
              );
              break;
            } else if (1 === nearestMountedAncestor.tag) {
              var instance = nearestMountedAncestor.stateNode;
              if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
                sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
                error = createClassErrorUpdate(2);
                instance = enqueueUpdate(nearestMountedAncestor, error, 2);
                null !== instance && (initializeClassErrorUpdate(
                  error,
                  instance,
                  nearestMountedAncestor,
                  sourceFiber
                ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
                break;
              }
            }
            nearestMountedAncestor = nearestMountedAncestor.return;
          }
      }
      function attachPingListener(root2, wakeable, lanes) {
        var pingCache = root2.pingCache;
        if (null === pingCache) {
          pingCache = root2.pingCache = new PossiblyWeakMap();
          var threadIDs = /* @__PURE__ */ new Set();
          pingCache.set(wakeable, threadIDs);
        } else
          threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
        threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root2 = pingSuspendedRoot.bind(null, root2, wakeable, lanes), wakeable.then(root2, root2));
      }
      function pingSuspendedRoot(root2, wakeable, pingedLanes) {
        var pingCache = root2.pingCache;
        null !== pingCache && pingCache.delete(wakeable);
        root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
        root2.warmLanes &= ~pingedLanes;
        workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
        ensureRootIsScheduled(root2);
      }
      function retryTimedOutBoundary(boundaryFiber, retryLane) {
        0 === retryLane && (retryLane = claimNextRetryLane());
        boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
        null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
      }
      function retryDehydratedSuspenseBoundary(boundaryFiber) {
        var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
        null !== suspenseState && (retryLane = suspenseState.retryLane);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function resolveRetryWakeable(boundaryFiber, wakeable) {
        var retryLane = 0;
        switch (boundaryFiber.tag) {
          case 31:
          case 13:
            var retryCache = boundaryFiber.stateNode;
            var suspenseState = boundaryFiber.memoizedState;
            null !== suspenseState && (retryLane = suspenseState.retryLane);
            break;
          case 19:
            retryCache = boundaryFiber.stateNode;
            break;
          case 22:
            retryCache = boundaryFiber.stateNode._retryCache;
            break;
          default:
            throw Error(formatProdErrorMessage(314));
        }
        null !== retryCache && retryCache.delete(wakeable);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function scheduleCallback$1(priorityLevel, callback) {
        return scheduleCallback$3(priorityLevel, callback);
      }
      var firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0;
      function ensureRootIsScheduled(root2) {
        root2 !== lastScheduledRoot && null === root2.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
        mightHavePendingSyncWork = true;
        didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
      }
      function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
        if (!isFlushingWork && mightHavePendingSyncWork) {
          isFlushingWork = true;
          do {
            var didPerformSomeWork = false;
            for (var root$170 = firstScheduledRoot; null !== root$170; ) {
              if (0 !== syncTransitionLanes) {
                var pendingLanes = root$170.pendingLanes;
                if (0 === pendingLanes) var JSCompiler_inline_result = 0;
                else {
                  var suspendedLanes = root$170.suspendedLanes, pingedLanes = root$170.pingedLanes;
                  JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                  JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                  JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
                }
                0 !== JSCompiler_inline_result && (didPerformSomeWork = true, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
              } else
                JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(
                  root$170,
                  root$170 === workInProgressRoot ? JSCompiler_inline_result : 0,
                  null !== root$170.cancelPendingCommit || -1 !== root$170.timeoutHandle
                ), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$170, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
              root$170 = root$170.next;
            }
          } while (didPerformSomeWork);
          isFlushingWork = false;
        }
      }
      function processRootScheduleInImmediateTask() {
        processRootScheduleInMicrotask();
      }
      function processRootScheduleInMicrotask() {
        mightHavePendingSyncWork = didScheduleMicrotask = false;
        var syncTransitionLanes = 0;
        0 !== currentEventTransitionLane && shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane);
        for (var currentTime = now(), prev = null, root2 = firstScheduledRoot; null !== root2; ) {
          var next = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
          if (0 === nextLanes)
            root2.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
          else if (prev = root2, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
            mightHavePendingSyncWork = true;
          root2 = next;
        }
        0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus || flushSyncWorkAcrossRoots_impl(syncTransitionLanes);
        0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);
      }
      function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
        for (var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = root2.pendingLanes & -62914561; 0 < lanes; ) {
          var index$5 = 31 - clz32(lanes), lane = 1 << index$5, expirationTime = expirationTimes[index$5];
          if (-1 === expirationTime) {
            if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
              expirationTimes[index$5] = computeExpirationTime(lane, currentTime);
          } else expirationTime <= currentTime && (root2.expiredLanes |= lane);
          lanes &= ~lane;
        }
        currentTime = workInProgressRoot;
        suspendedLanes = workInProgressRootRenderLanes;
        suspendedLanes = getNextLanes(
          root2,
          root2 === currentTime ? suspendedLanes : 0,
          null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
        );
        pingedLanes = root2.callbackNode;
        if (0 === suspendedLanes || root2 === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
          return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
        if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root2, suspendedLanes)) {
          currentTime = suspendedLanes & -suspendedLanes;
          if (currentTime === root2.callbackPriority) return currentTime;
          null !== pingedLanes && cancelCallback$1(pingedLanes);
          switch (lanesToEventPriority(suspendedLanes)) {
            case 2:
            case 8:
              suspendedLanes = UserBlockingPriority;
              break;
            case 32:
              suspendedLanes = NormalPriority$1;
              break;
            case 268435456:
              suspendedLanes = IdlePriority;
              break;
            default:
              suspendedLanes = NormalPriority$1;
          }
          pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
          suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
          root2.callbackPriority = currentTime;
          root2.callbackNode = suspendedLanes;
          return currentTime;
        }
        null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
        root2.callbackPriority = 2;
        root2.callbackNode = null;
        return 2;
      }
      function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
        if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
          return root2.callbackNode = null, root2.callbackPriority = 0, null;
        var originalCallbackNode = root2.callbackNode;
        if (flushPendingEffects() && root2.callbackNode !== originalCallbackNode)
          return null;
        var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
        workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
          root2,
          root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
          null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
        );
        if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
        performWorkOnRoot(root2, workInProgressRootRenderLanes$jscomp$0, didTimeout);
        scheduleTaskForRootDuringMicrotask(root2, now());
        return null != root2.callbackNode && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
      }
      function performSyncWorkOnRoot(root2, lanes) {
        if (flushPendingEffects()) return null;
        performWorkOnRoot(root2, lanes, true);
      }
      function scheduleImmediateRootScheduleTask() {
        scheduleMicrotask(function() {
          0 !== (executionContext & 6) ? scheduleCallback$3(
            ImmediatePriority,
            processRootScheduleInImmediateTask
          ) : processRootScheduleInMicrotask();
        });
      }
      function requestTransitionLane() {
        if (0 === currentEventTransitionLane) {
          var actionScopeLane = currentEntangledLane;
          0 === actionScopeLane && (actionScopeLane = nextTransitionUpdateLane, nextTransitionUpdateLane <<= 1, 0 === (nextTransitionUpdateLane & 261888) && (nextTransitionUpdateLane = 256));
          currentEventTransitionLane = actionScopeLane;
        }
        return currentEventTransitionLane;
      }
      function coerceFormActionProp(actionProp) {
        return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
      }
      function createFormDataWithSubmitter(form, submitter) {
        var temp = submitter.ownerDocument.createElement("input");
        temp.name = submitter.name;
        temp.value = submitter.value;
        form.id && temp.setAttribute("form", form.id);
        submitter.parentNode.insertBefore(temp, submitter);
        form = new FormData(form);
        temp.parentNode.removeChild(temp);
        return form;
      }
      function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
        if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
          var action = coerceFormActionProp(
            (nativeEventTarget[internalPropsKey] || null).action
          ), submitter = nativeEvent.submitter;
          submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
          var event = new SyntheticEvent(
            "action",
            "action",
            null,
            nativeEvent,
            nativeEventTarget
          );
          dispatchQueue.push({
            event,
            listeners: [
              {
                instance: null,
                listener: function() {
                  if (nativeEvent.defaultPrevented) {
                    if (0 !== currentEventTransitionLane) {
                      var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
                      startHostTransition(
                        maybeTargetInst,
                        {
                          pending: true,
                          data: formData,
                          method: nativeEventTarget.method,
                          action
                        },
                        null,
                        formData
                      );
                    }
                  } else
                    "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(
                      maybeTargetInst,
                      {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action
                      },
                      action,
                      formData
                    ));
                },
                currentTarget: nativeEventTarget
              }
            ]
          });
        }
      }
      for (var i$jscomp$inline_1577 = 0; i$jscomp$inline_1577 < simpleEventPluginEvents.length; i$jscomp$inline_1577++) {
        var eventName$jscomp$inline_1578 = simpleEventPluginEvents[i$jscomp$inline_1577], domEventName$jscomp$inline_1579 = eventName$jscomp$inline_1578.toLowerCase(), capitalizedEvent$jscomp$inline_1580 = eventName$jscomp$inline_1578[0].toUpperCase() + eventName$jscomp$inline_1578.slice(1);
        registerSimpleEvent(
          domEventName$jscomp$inline_1579,
          "on" + capitalizedEvent$jscomp$inline_1580
        );
      }
      registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
      registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
      registerSimpleEvent(ANIMATION_START, "onAnimationStart");
      registerSimpleEvent("dblclick", "onDoubleClick");
      registerSimpleEvent("focusin", "onFocus");
      registerSimpleEvent("focusout", "onBlur");
      registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
      registerSimpleEvent(TRANSITION_START, "onTransitionStart");
      registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
      registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
      registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
      registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
      registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
      registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
      registerTwoPhaseEvent(
        "onChange",
        "change click focusin focusout input keydown keyup selectionchange".split(" ")
      );
      registerTwoPhaseEvent(
        "onSelect",
        "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
          " "
        )
      );
      registerTwoPhaseEvent("onBeforeInput", [
        "compositionend",
        "keypress",
        "textInput",
        "paste"
      ]);
      registerTwoPhaseEvent(
        "onCompositionEnd",
        "compositionend focusout keydown keypress keyup mousedown".split(" ")
      );
      registerTwoPhaseEvent(
        "onCompositionStart",
        "compositionstart focusout keydown keypress keyup mousedown".split(" ")
      );
      registerTwoPhaseEvent(
        "onCompositionUpdate",
        "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
      );
      var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
        " "
      ), nonDelegatedEvents = new Set(
        "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
      );
      function processDispatchQueue(dispatchQueue, eventSystemFlags) {
        eventSystemFlags = 0 !== (eventSystemFlags & 4);
        for (var i = 0; i < dispatchQueue.length; i++) {
          var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event;
          _dispatchQueue$i = _dispatchQueue$i.listeners;
          a: {
            var previousInstance = void 0;
            if (eventSystemFlags)
              for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
                var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
                _dispatchListeners$i = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped())
                  break a;
                previousInstance = _dispatchListeners$i;
                event.currentTarget = currentTarget;
                try {
                  previousInstance(event);
                } catch (error) {
                  reportGlobalError(error);
                }
                event.currentTarget = null;
                previousInstance = instance;
              }
            else
              for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
                _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
                instance = _dispatchListeners$i.instance;
                currentTarget = _dispatchListeners$i.currentTarget;
                _dispatchListeners$i = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped())
                  break a;
                previousInstance = _dispatchListeners$i;
                event.currentTarget = currentTarget;
                try {
                  previousInstance(event);
                } catch (error) {
                  reportGlobalError(error);
                }
                event.currentTarget = null;
                previousInstance = instance;
              }
          }
        }
      }
      function listenToNonDelegatedEvent(domEventName, targetElement) {
        var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
        void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
        var listenerSetKey = domEventName + "__bubble";
        JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
      }
      function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
        var eventSystemFlags = 0;
        isCapturePhaseListener && (eventSystemFlags |= 4);
        addTrappedEventListener(
          target,
          domEventName,
          eventSystemFlags,
          isCapturePhaseListener
        );
      }
      var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
      function listenToAllSupportedEvents(rootContainerElement) {
        if (!rootContainerElement[listeningMarker]) {
          rootContainerElement[listeningMarker] = true;
          allNativeEvents.forEach(function(domEventName) {
            "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
          });
          var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
          null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
        }
      }
      function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
        switch (getEventPriority(domEventName)) {
          case 2:
            var listenerWrapper = dispatchDiscreteEvent;
            break;
          case 8:
            listenerWrapper = dispatchContinuousEvent;
            break;
          default:
            listenerWrapper = dispatchEvent;
        }
        eventSystemFlags = listenerWrapper.bind(
          null,
          domEventName,
          eventSystemFlags,
          targetContainer
        );
        listenerWrapper = void 0;
        !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
        isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          capture: true,
          passive: listenerWrapper
        }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          passive: listenerWrapper
        }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
      }
      function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
        var ancestorInst = targetInst$jscomp$0;
        if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
          a: for (; ; ) {
            if (null === targetInst$jscomp$0) return;
            var nodeTag = targetInst$jscomp$0.tag;
            if (3 === nodeTag || 4 === nodeTag) {
              var container = targetInst$jscomp$0.stateNode.containerInfo;
              if (container === targetContainer) break;
              if (4 === nodeTag)
                for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                  var grandTag = nodeTag.tag;
                  if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                    return;
                  nodeTag = nodeTag.return;
                }
              for (; null !== container; ) {
                nodeTag = getClosestInstanceFromNode(container);
                if (null === nodeTag) return;
                grandTag = nodeTag.tag;
                if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                  targetInst$jscomp$0 = ancestorInst = nodeTag;
                  continue a;
                }
                container = container.parentNode;
              }
            }
            targetInst$jscomp$0 = targetInst$jscomp$0.return;
          }
        batchedUpdates$1(function() {
          var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
          a: {
            var reactName = topLevelEventsToReactNames.get(domEventName);
            if (void 0 !== reactName) {
              var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
              switch (domEventName) {
                case "keypress":
                  if (0 === getEventCharCode(nativeEvent)) break a;
                case "keydown":
                case "keyup":
                  SyntheticEventCtor = SyntheticKeyboardEvent;
                  break;
                case "focusin":
                  reactEventType = "focus";
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "focusout":
                  reactEventType = "blur";
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "beforeblur":
                case "afterblur":
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "click":
                  if (2 === nativeEvent.button) break a;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  SyntheticEventCtor = SyntheticMouseEvent;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  SyntheticEventCtor = SyntheticDragEvent;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  SyntheticEventCtor = SyntheticTouchEvent;
                  break;
                case ANIMATION_END:
                case ANIMATION_ITERATION:
                case ANIMATION_START:
                  SyntheticEventCtor = SyntheticAnimationEvent;
                  break;
                case TRANSITION_END:
                  SyntheticEventCtor = SyntheticTransitionEvent;
                  break;
                case "scroll":
                case "scrollend":
                  SyntheticEventCtor = SyntheticUIEvent;
                  break;
                case "wheel":
                  SyntheticEventCtor = SyntheticWheelEvent;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  SyntheticEventCtor = SyntheticClipboardEvent;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  SyntheticEventCtor = SyntheticPointerEvent;
                  break;
                case "toggle":
                case "beforetoggle":
                  SyntheticEventCtor = SyntheticToggleEvent;
              }
              var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
              inCapturePhase = [];
              for (var instance = targetInst, lastHostComponent; null !== instance; ) {
                var _instance = instance;
                lastHostComponent = _instance.stateNode;
                _instance = _instance.tag;
                5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance, reactEventName), null != _instance && inCapturePhase.push(
                  createDispatchListener(instance, _instance, lastHostComponent)
                ));
                if (accumulateTargetOnly) break;
                instance = instance.return;
              }
              0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
                reactName,
                reactEventType,
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
            }
          }
          if (0 === (eventSystemFlags & 7)) {
            a: {
              reactName = "mouseover" === domEventName || "pointerover" === domEventName;
              SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
              if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
                break a;
              if (SyntheticEventCtor || reactName) {
                reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
                if (SyntheticEventCtor) {
                  if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                    reactEventType = null;
                } else SyntheticEventCtor = null, reactEventType = targetInst;
                if (SyntheticEventCtor !== reactEventType) {
                  inCapturePhase = SyntheticMouseEvent;
                  _instance = "onMouseLeave";
                  reactEventName = "onMouseEnter";
                  instance = "mouse";
                  if ("pointerout" === domEventName || "pointerover" === domEventName)
                    inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                  accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                  lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                  reactName = new inCapturePhase(
                    _instance,
                    instance + "leave",
                    SyntheticEventCtor,
                    nativeEvent,
                    nativeEventTarget
                  );
                  reactName.target = accumulateTargetOnly;
                  reactName.relatedTarget = lastHostComponent;
                  _instance = null;
                  getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                    reactEventName,
                    instance + "enter",
                    reactEventType,
                    nativeEvent,
                    nativeEventTarget
                  ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
                  accumulateTargetOnly = _instance;
                  if (SyntheticEventCtor && reactEventType)
                    b: {
                      inCapturePhase = getParent;
                      reactEventName = SyntheticEventCtor;
                      instance = reactEventType;
                      lastHostComponent = 0;
                      for (_instance = reactEventName; _instance; _instance = inCapturePhase(_instance))
                        lastHostComponent++;
                      _instance = 0;
                      for (var tempB = instance; tempB; tempB = inCapturePhase(tempB))
                        _instance++;
                      for (; 0 < lastHostComponent - _instance; )
                        reactEventName = inCapturePhase(reactEventName), lastHostComponent--;
                      for (; 0 < _instance - lastHostComponent; )
                        instance = inCapturePhase(instance), _instance--;
                      for (; lastHostComponent--; ) {
                        if (reactEventName === instance || null !== instance && reactEventName === instance.alternate) {
                          inCapturePhase = reactEventName;
                          break b;
                        }
                        reactEventName = inCapturePhase(reactEventName);
                        instance = inCapturePhase(instance);
                      }
                      inCapturePhase = null;
                    }
                  else inCapturePhase = null;
                  null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    reactName,
                    SyntheticEventCtor,
                    inCapturePhase,
                    false
                  );
                  null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    accumulateTargetOnly,
                    reactEventType,
                    inCapturePhase,
                    true
                  );
                }
              }
            }
            a: {
              reactName = targetInst ? getNodeFromInstance(targetInst) : window;
              SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
              if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
                var getTargetInstFunc = getTargetInstForChangeEvent;
              else if (isTextInputElement(reactName))
                if (isInputEventSupported)
                  getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                else {
                  getTargetInstFunc = getTargetInstForInputEventPolyfill;
                  var handleEventFunc = handleEventsForInputEventPolyfill;
                }
              else
                SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
              if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
                createAndAccumulateChangeEvent(
                  dispatchQueue,
                  getTargetInstFunc,
                  nativeEvent,
                  nativeEventTarget
                );
                break a;
              }
              handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
              "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
            }
            handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
            switch (domEventName) {
              case "focusin":
                if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                  activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
                break;
              case "focusout":
                lastSelection = activeElementInst = activeElement = null;
                break;
              case "mousedown":
                mouseDown = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                mouseDown = false;
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                break;
              case "selectionchange":
                if (skipSelectionChangeEvent) break;
              case "keydown":
              case "keyup":
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            }
            var fallbackData;
            if (canUseCompositionEvent)
              b: {
                switch (domEventName) {
                  case "compositionstart":
                    var eventType = "onCompositionStart";
                    break b;
                  case "compositionend":
                    eventType = "onCompositionEnd";
                    break b;
                  case "compositionupdate":
                    eventType = "onCompositionUpdate";
                    break b;
                }
                eventType = void 0;
              }
            else
              isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
            eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
              eventType,
              domEventName,
              null,
              nativeEvent,
              nativeEventTarget
            ), dispatchQueue.push({ event: eventType, listeners: handleEventFunc }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
            if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
              eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent(
                "onBeforeInput",
                "beforeinput",
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({
                event: handleEventFunc,
                listeners: eventType
              }), handleEventFunc.data = fallbackData);
            extractEvents$1(
              dispatchQueue,
              domEventName,
              targetInst,
              nativeEvent,
              nativeEventTarget
            );
          }
          processDispatchQueue(dispatchQueue, eventSystemFlags);
        });
      }
      function createDispatchListener(instance, listener, currentTarget) {
        return {
          instance,
          listener,
          currentTarget
        };
      }
      function accumulateTwoPhaseListeners(targetFiber, reactName) {
        for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
          var _instance2 = targetFiber, stateNode = _instance2.stateNode;
          _instance2 = _instance2.tag;
          5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners.unshift(
            createDispatchListener(targetFiber, _instance2, stateNode)
          ), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners.push(
            createDispatchListener(targetFiber, _instance2, stateNode)
          ));
          if (3 === targetFiber.tag) return listeners;
          targetFiber = targetFiber.return;
        }
        return [];
      }
      function getParent(inst) {
        if (null === inst) return null;
        do
          inst = inst.return;
        while (inst && 5 !== inst.tag && 27 !== inst.tag);
        return inst ? inst : null;
      }
      function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
        for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
          var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
          _instance3 = _instance3.tag;
          if (null !== alternate && alternate === common) break;
          5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
            createDispatchListener(target, stateNode, alternate)
          )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
            createDispatchListener(target, stateNode, alternate)
          )));
          target = target.return;
        }
        0 !== listeners.length && dispatchQueue.push({ event, listeners });
      }
      var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
      function normalizeMarkupForTextOrAttribute(markup) {
        return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
      }
      function checkForUnmatchedText(serverText, clientText) {
        clientText = normalizeMarkupForTextOrAttribute(clientText);
        return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
      }
      function setProp(domElement, tag, key, value, props, prevValue) {
        switch (key) {
          case "children":
            "string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
            break;
          case "className":
            setValueForKnownAttribute(domElement, "class", value);
            break;
          case "tabIndex":
            setValueForKnownAttribute(domElement, "tabindex", value);
            break;
          case "dir":
          case "role":
          case "viewBox":
          case "width":
          case "height":
            setValueForKnownAttribute(domElement, key, value);
            break;
          case "style":
            setValueForStyles(domElement, value, prevValue);
            break;
          case "data":
            if ("object" !== tag) {
              setValueForKnownAttribute(domElement, "data", value);
              break;
            }
          case "src":
          case "href":
            if ("" === value && ("a" !== tag || "href" !== key)) {
              domElement.removeAttribute(key);
              break;
            }
            if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
              domElement.removeAttribute(key);
              break;
            }
            value = sanitizeURL("" + value);
            domElement.setAttribute(key, value);
            break;
          case "action":
          case "formAction":
            if ("function" === typeof value) {
              domElement.setAttribute(
                key,
                "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
              );
              break;
            } else
              "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
                domElement,
                tag,
                "formEncType",
                props.formEncType,
                props,
                null
              ), setProp(
                domElement,
                tag,
                "formMethod",
                props.formMethod,
                props,
                null
              ), setProp(
                domElement,
                tag,
                "formTarget",
                props.formTarget,
                props,
                null
              )) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
            if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
              domElement.removeAttribute(key);
              break;
            }
            value = sanitizeURL("" + value);
            domElement.setAttribute(key, value);
            break;
          case "onClick":
            null != value && (domElement.onclick = noop$1);
            break;
          case "onScroll":
            null != value && listenToNonDelegatedEvent("scroll", domElement);
            break;
          case "onScrollEnd":
            null != value && listenToNonDelegatedEvent("scrollend", domElement);
            break;
          case "dangerouslySetInnerHTML":
            if (null != value) {
              if ("object" !== typeof value || !("__html" in value))
                throw Error(formatProdErrorMessage(61));
              key = value.__html;
              if (null != key) {
                if (null != props.children) throw Error(formatProdErrorMessage(60));
                domElement.innerHTML = key;
              }
            }
            break;
          case "multiple":
            domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
            break;
          case "muted":
            domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "ref":
            break;
          case "autoFocus":
            break;
          case "xlinkHref":
            if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
              domElement.removeAttribute("xlink:href");
              break;
            }
            key = sanitizeURL("" + value);
            domElement.setAttributeNS(
              "http://www.w3.org/1999/xlink",
              "xlink:href",
              key
            );
            break;
          case "contentEditable":
          case "spellCheck":
          case "draggable":
          case "value":
          case "autoReverse":
          case "externalResourcesRequired":
          case "focusable":
          case "preserveAlpha":
            null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
            break;
          case "inert":
          case "allowFullScreen":
          case "async":
          case "autoPlay":
          case "controls":
          case "default":
          case "defer":
          case "disabled":
          case "disablePictureInPicture":
          case "disableRemotePlayback":
          case "formNoValidate":
          case "hidden":
          case "loop":
          case "noModule":
          case "noValidate":
          case "open":
          case "playsInline":
          case "readOnly":
          case "required":
          case "reversed":
          case "scoped":
          case "seamless":
          case "itemScope":
            value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
            break;
          case "capture":
          case "download":
            true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
            break;
          case "cols":
          case "rows":
          case "size":
          case "span":
            null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
            break;
          case "rowSpan":
          case "start":
            null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
            break;
          case "popover":
            listenToNonDelegatedEvent("beforetoggle", domElement);
            listenToNonDelegatedEvent("toggle", domElement);
            setValueForAttribute(domElement, "popover", value);
            break;
          case "xlinkActuate":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:actuate",
              value
            );
            break;
          case "xlinkArcrole":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:arcrole",
              value
            );
            break;
          case "xlinkRole":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:role",
              value
            );
            break;
          case "xlinkShow":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:show",
              value
            );
            break;
          case "xlinkTitle":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:title",
              value
            );
            break;
          case "xlinkType":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:type",
              value
            );
            break;
          case "xmlBase":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:base",
              value
            );
            break;
          case "xmlLang":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:lang",
              value
            );
            break;
          case "xmlSpace":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:space",
              value
            );
            break;
          case "is":
            setValueForAttribute(domElement, "is", value);
            break;
          case "innerText":
          case "textContent":
            break;
          default:
            if (!(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1])
              key = aliases.get(key) || key, setValueForAttribute(domElement, key, value);
        }
      }
      function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
        switch (key) {
          case "style":
            setValueForStyles(domElement, value, prevValue);
            break;
          case "dangerouslySetInnerHTML":
            if (null != value) {
              if ("object" !== typeof value || !("__html" in value))
                throw Error(formatProdErrorMessage(61));
              key = value.__html;
              if (null != key) {
                if (null != props.children) throw Error(formatProdErrorMessage(60));
                domElement.innerHTML = key;
              }
            }
            break;
          case "children":
            "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
            break;
          case "onScroll":
            null != value && listenToNonDelegatedEvent("scroll", domElement);
            break;
          case "onScrollEnd":
            null != value && listenToNonDelegatedEvent("scrollend", domElement);
            break;
          case "onClick":
            null != value && (domElement.onclick = noop$1);
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "innerHTML":
          case "ref":
            break;
          case "innerText":
          case "textContent":
            break;
          default:
            if (!registrationNameDependencies.hasOwnProperty(key))
              a: {
                if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                  "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                  domElement.addEventListener(tag, value, props);
                  break a;
                }
                key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
              }
        }
      }
      function setInitialProperties(domElement, tag, props) {
        switch (tag) {
          case "div":
          case "span":
          case "svg":
          case "path":
          case "a":
          case "g":
          case "p":
          case "li":
            break;
          case "img":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            var hasSrc = false, hasSrcSet = false, propKey;
            for (propKey in props)
              if (props.hasOwnProperty(propKey)) {
                var propValue = props[propKey];
                if (null != propValue)
                  switch (propKey) {
                    case "src":
                      hasSrc = true;
                      break;
                    case "srcSet":
                      hasSrcSet = true;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(formatProdErrorMessage(137, tag));
                    default:
                      setProp(domElement, tag, propKey, propValue, props, null);
                  }
              }
            hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
            hasSrc && setProp(domElement, tag, "src", props.src, props, null);
            return;
          case "input":
            listenToNonDelegatedEvent("invalid", domElement);
            var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
            for (hasSrc in props)
              if (props.hasOwnProperty(hasSrc)) {
                var propValue$184 = props[hasSrc];
                if (null != propValue$184)
                  switch (hasSrc) {
                    case "name":
                      hasSrcSet = propValue$184;
                      break;
                    case "type":
                      propValue = propValue$184;
                      break;
                    case "checked":
                      checked = propValue$184;
                      break;
                    case "defaultChecked":
                      defaultChecked = propValue$184;
                      break;
                    case "value":
                      propKey = propValue$184;
                      break;
                    case "defaultValue":
                      defaultValue = propValue$184;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != propValue$184)
                        throw Error(formatProdErrorMessage(137, tag));
                      break;
                    default:
                      setProp(domElement, tag, hasSrc, propValue$184, props, null);
                  }
              }
            initInput(
              domElement,
              propKey,
              defaultValue,
              checked,
              defaultChecked,
              propValue,
              hasSrcSet,
              false
            );
            return;
          case "select":
            listenToNonDelegatedEvent("invalid", domElement);
            hasSrc = propValue = propKey = null;
            for (hasSrcSet in props)
              if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
                switch (hasSrcSet) {
                  case "value":
                    propKey = defaultValue;
                    break;
                  case "defaultValue":
                    propValue = defaultValue;
                    break;
                  case "multiple":
                    hasSrc = defaultValue;
                  default:
                    setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
                }
            tag = propKey;
            props = propValue;
            domElement.multiple = !!hasSrc;
            null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
            return;
          case "textarea":
            listenToNonDelegatedEvent("invalid", domElement);
            propKey = hasSrcSet = hasSrc = null;
            for (propValue in props)
              if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
                switch (propValue) {
                  case "value":
                    hasSrc = defaultValue;
                    break;
                  case "defaultValue":
                    hasSrcSet = defaultValue;
                    break;
                  case "children":
                    propKey = defaultValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    if (null != defaultValue) throw Error(formatProdErrorMessage(91));
                    break;
                  default:
                    setProp(domElement, tag, propValue, defaultValue, props, null);
                }
            initTextarea(domElement, hasSrc, hasSrcSet, propKey);
            return;
          case "option":
            for (checked in props)
              if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
                switch (checked) {
                  case "selected":
                    domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                    break;
                  default:
                    setProp(domElement, tag, checked, hasSrc, props, null);
                }
            return;
          case "dialog":
            listenToNonDelegatedEvent("beforetoggle", domElement);
            listenToNonDelegatedEvent("toggle", domElement);
            listenToNonDelegatedEvent("cancel", domElement);
            listenToNonDelegatedEvent("close", domElement);
            break;
          case "iframe":
          case "object":
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "video":
          case "audio":
            for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
              listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
            break;
          case "image":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", domElement);
            break;
          case "embed":
          case "source":
          case "link":
            listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
          case "area":
          case "base":
          case "br":
          case "col":
          case "hr":
          case "keygen":
          case "meta":
          case "param":
          case "track":
          case "wbr":
          case "menuitem":
            for (defaultChecked in props)
              if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
                switch (defaultChecked) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(formatProdErrorMessage(137, tag));
                  default:
                    setProp(domElement, tag, defaultChecked, hasSrc, props, null);
                }
            return;
          default:
            if (isCustomElement(tag)) {
              for (propValue$184 in props)
                props.hasOwnProperty(propValue$184) && (hasSrc = props[propValue$184], void 0 !== hasSrc && setPropOnCustomElement(
                  domElement,
                  tag,
                  propValue$184,
                  hasSrc,
                  props,
                  void 0
                ));
              return;
            }
        }
        for (defaultValue in props)
          props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
      }
      function updateProperties(domElement, tag, lastProps, nextProps) {
        switch (tag) {
          case "div":
          case "span":
          case "svg":
          case "path":
          case "a":
          case "g":
          case "p":
          case "li":
            break;
          case "input":
            var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
            for (propKey in lastProps) {
              var lastProp = lastProps[propKey];
              if (lastProps.hasOwnProperty(propKey) && null != lastProp)
                switch (propKey) {
                  case "checked":
                    break;
                  case "value":
                    break;
                  case "defaultValue":
                    lastDefaultValue = lastProp;
                  default:
                    nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
                }
            }
            for (var propKey$201 in nextProps) {
              var propKey = nextProps[propKey$201];
              lastProp = lastProps[propKey$201];
              if (nextProps.hasOwnProperty(propKey$201) && (null != propKey || null != lastProp))
                switch (propKey$201) {
                  case "type":
                    type = propKey;
                    break;
                  case "name":
                    name = propKey;
                    break;
                  case "checked":
                    checked = propKey;
                    break;
                  case "defaultChecked":
                    defaultChecked = propKey;
                    break;
                  case "value":
                    value = propKey;
                    break;
                  case "defaultValue":
                    defaultValue = propKey;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propKey)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    propKey !== lastProp && setProp(
                      domElement,
                      tag,
                      propKey$201,
                      propKey,
                      nextProps,
                      lastProp
                    );
                }
            }
            updateInput(
              domElement,
              value,
              defaultValue,
              lastDefaultValue,
              checked,
              defaultChecked,
              type,
              name
            );
            return;
          case "select":
            propKey = value = defaultValue = propKey$201 = null;
            for (type in lastProps)
              if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
                switch (type) {
                  case "value":
                    break;
                  case "multiple":
                    propKey = lastDefaultValue;
                  default:
                    nextProps.hasOwnProperty(type) || setProp(
                      domElement,
                      tag,
                      type,
                      null,
                      nextProps,
                      lastDefaultValue
                    );
                }
            for (name in nextProps)
              if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
                switch (name) {
                  case "value":
                    propKey$201 = type;
                    break;
                  case "defaultValue":
                    defaultValue = type;
                    break;
                  case "multiple":
                    value = type;
                  default:
                    type !== lastDefaultValue && setProp(
                      domElement,
                      tag,
                      name,
                      type,
                      nextProps,
                      lastDefaultValue
                    );
                }
            tag = defaultValue;
            lastProps = value;
            nextProps = propKey;
            null != propKey$201 ? updateOptions(domElement, !!lastProps, propKey$201, false) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
            return;
          case "textarea":
            propKey = propKey$201 = null;
            for (defaultValue in lastProps)
              if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
                switch (defaultValue) {
                  case "value":
                    break;
                  case "children":
                    break;
                  default:
                    setProp(domElement, tag, defaultValue, null, nextProps, name);
                }
            for (value in nextProps)
              if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
                switch (value) {
                  case "value":
                    propKey$201 = name;
                    break;
                  case "defaultValue":
                    propKey = name;
                    break;
                  case "children":
                    break;
                  case "dangerouslySetInnerHTML":
                    if (null != name) throw Error(formatProdErrorMessage(91));
                    break;
                  default:
                    name !== type && setProp(domElement, tag, value, name, nextProps, type);
                }
            updateTextarea(domElement, propKey$201, propKey);
            return;
          case "option":
            for (var propKey$217 in lastProps)
              if (propKey$201 = lastProps[propKey$217], lastProps.hasOwnProperty(propKey$217) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$217))
                switch (propKey$217) {
                  case "selected":
                    domElement.selected = false;
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      propKey$217,
                      null,
                      nextProps,
                      propKey$201
                    );
                }
            for (lastDefaultValue in nextProps)
              if (propKey$201 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$201 !== propKey && (null != propKey$201 || null != propKey))
                switch (lastDefaultValue) {
                  case "selected":
                    domElement.selected = propKey$201 && "function" !== typeof propKey$201 && "symbol" !== typeof propKey$201;
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      lastDefaultValue,
                      propKey$201,
                      nextProps,
                      propKey
                    );
                }
            return;
          case "img":
          case "link":
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "keygen":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
          case "menuitem":
            for (var propKey$222 in lastProps)
              propKey$201 = lastProps[propKey$222], lastProps.hasOwnProperty(propKey$222) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$222) && setProp(domElement, tag, propKey$222, null, nextProps, propKey$201);
            for (checked in nextProps)
              if (propKey$201 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$201 !== propKey && (null != propKey$201 || null != propKey))
                switch (checked) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propKey$201)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      checked,
                      propKey$201,
                      nextProps,
                      propKey
                    );
                }
            return;
          default:
            if (isCustomElement(tag)) {
              for (var propKey$227 in lastProps)
                propKey$201 = lastProps[propKey$227], lastProps.hasOwnProperty(propKey$227) && void 0 !== propKey$201 && !nextProps.hasOwnProperty(propKey$227) && setPropOnCustomElement(
                  domElement,
                  tag,
                  propKey$227,
                  void 0,
                  nextProps,
                  propKey$201
                );
              for (defaultChecked in nextProps)
                propKey$201 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$201 === propKey || void 0 === propKey$201 && void 0 === propKey || setPropOnCustomElement(
                  domElement,
                  tag,
                  defaultChecked,
                  propKey$201,
                  nextProps,
                  propKey
                );
              return;
            }
        }
        for (var propKey$232 in lastProps)
          propKey$201 = lastProps[propKey$232], lastProps.hasOwnProperty(propKey$232) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$232) && setProp(domElement, tag, propKey$232, null, nextProps, propKey$201);
        for (lastProp in nextProps)
          propKey$201 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$201 === propKey || null == propKey$201 && null == propKey || setProp(domElement, tag, lastProp, propKey$201, nextProps, propKey);
      }
      function isLikelyStaticResource(initiatorType) {
        switch (initiatorType) {
          case "css":
          case "script":
          case "font":
          case "img":
          case "image":
          case "input":
          case "link":
            return true;
          default:
            return false;
        }
      }
      function estimateBandwidth() {
        if ("function" === typeof performance.getEntriesByType) {
          for (var count = 0, bits = 0, resourceEntries = performance.getEntriesByType("resource"), i = 0; i < resourceEntries.length; i++) {
            var entry = resourceEntries[i], transferSize = entry.transferSize, initiatorType = entry.initiatorType, duration = entry.duration;
            if (transferSize && duration && isLikelyStaticResource(initiatorType)) {
              initiatorType = 0;
              duration = entry.responseEnd;
              for (i += 1; i < resourceEntries.length; i++) {
                var overlapEntry = resourceEntries[i], overlapStartTime = overlapEntry.startTime;
                if (overlapStartTime > duration) break;
                var overlapTransferSize = overlapEntry.transferSize, overlapInitiatorType = overlapEntry.initiatorType;
                overlapTransferSize && isLikelyStaticResource(overlapInitiatorType) && (overlapEntry = overlapEntry.responseEnd, initiatorType += overlapTransferSize * (overlapEntry < duration ? 1 : (duration - overlapStartTime) / (overlapEntry - overlapStartTime)));
              }
              --i;
              bits += 8 * (transferSize + initiatorType) / (entry.duration / 1e3);
              count++;
              if (10 < count) break;
            }
          }
          if (0 < count) return bits / count / 1e6;
        }
        return navigator.connection && (count = navigator.connection.downlink, "number" === typeof count) ? count : 5;
      }
      var eventsEnabled = null, selectionInformation = null;
      function getOwnerDocumentFromRootContainer(rootContainerElement) {
        return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
      }
      function getOwnHostContext(namespaceURI) {
        switch (namespaceURI) {
          case "http://www.w3.org/2000/svg":
            return 1;
          case "http://www.w3.org/1998/Math/MathML":
            return 2;
          default:
            return 0;
        }
      }
      function getChildHostContextProd(parentNamespace, type) {
        if (0 === parentNamespace)
          switch (type) {
            case "svg":
              return 1;
            case "math":
              return 2;
            default:
              return 0;
          }
        return 1 === parentNamespace && "foreignObject" === type ? 0 : parentNamespace;
      }
      function shouldSetTextContent(type, props) {
        return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
      }
      var currentPopstateTransitionEvent = null;
      function shouldAttemptEagerTransition() {
        var event = window.event;
        if (event && "popstate" === event.type) {
          if (event === currentPopstateTransitionEvent) return false;
          currentPopstateTransitionEvent = event;
          return true;
        }
        currentPopstateTransitionEvent = null;
        return false;
      }
      var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
        return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
      } : scheduleTimeout;
      function handleErrorInNextTick(error) {
        setTimeout(function() {
          throw error;
        });
      }
      function isSingletonScope(type) {
        return "head" === type;
      }
      function clearHydrationBoundary(parentInstance, hydrationInstance) {
        var node = hydrationInstance, depth = 0;
        do {
          var nextNode = node.nextSibling;
          parentInstance.removeChild(node);
          if (nextNode && 8 === nextNode.nodeType)
            if (node = nextNode.data, "/$" === node || "/&" === node) {
              if (0 === depth) {
                parentInstance.removeChild(nextNode);
                retryIfBlockedOn(hydrationInstance);
                return;
              }
              depth--;
            } else if ("$" === node || "$?" === node || "$~" === node || "$!" === node || "&" === node)
              depth++;
            else if ("html" === node)
              releaseSingletonInstance(parentInstance.ownerDocument.documentElement);
            else if ("head" === node) {
              node = parentInstance.ownerDocument.head;
              releaseSingletonInstance(node);
              for (var node$jscomp$0 = node.firstChild; node$jscomp$0; ) {
                var nextNode$jscomp$0 = node$jscomp$0.nextSibling, nodeName = node$jscomp$0.nodeName;
                node$jscomp$0[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === node$jscomp$0.rel.toLowerCase() || node.removeChild(node$jscomp$0);
                node$jscomp$0 = nextNode$jscomp$0;
              }
            } else
              "body" === node && releaseSingletonInstance(parentInstance.ownerDocument.body);
          node = nextNode;
        } while (node);
        retryIfBlockedOn(hydrationInstance);
      }
      function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden) {
        var node = suspenseInstance;
        suspenseInstance = 0;
        do {
          var nextNode = node.nextSibling;
          1 === node.nodeType ? isHidden ? (node._stashedDisplay = node.style.display, node.style.display = "none") : (node.style.display = node._stashedDisplay || "", "" === node.getAttribute("style") && node.removeAttribute("style")) : 3 === node.nodeType && (isHidden ? (node._stashedText = node.nodeValue, node.nodeValue = "") : node.nodeValue = node._stashedText || "");
          if (nextNode && 8 === nextNode.nodeType)
            if (node = nextNode.data, "/$" === node)
              if (0 === suspenseInstance) break;
              else suspenseInstance--;
            else
              "$" !== node && "$?" !== node && "$~" !== node && "$!" !== node || suspenseInstance++;
          node = nextNode;
        } while (node);
      }
      function clearContainerSparingly(container) {
        var nextNode = container.firstChild;
        nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
        for (; nextNode; ) {
          var node = nextNode;
          nextNode = nextNode.nextSibling;
          switch (node.nodeName) {
            case "HTML":
            case "HEAD":
            case "BODY":
              clearContainerSparingly(node);
              detachDeletedInstance(node);
              continue;
            case "SCRIPT":
            case "STYLE":
              continue;
            case "LINK":
              if ("stylesheet" === node.rel.toLowerCase()) continue;
          }
          container.removeChild(node);
        }
      }
      function canHydrateInstance(instance, type, props, inRootOrSingleton) {
        for (; 1 === instance.nodeType; ) {
          var anyProps = props;
          if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
            if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
              break;
          } else if (!inRootOrSingleton)
            if ("input" === type && "hidden" === instance.type) {
              var name = null == anyProps.name ? null : "" + anyProps.name;
              if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
                return instance;
            } else return instance;
          else if (!instance[internalHoistableMarker])
            switch (type) {
              case "meta":
                if (!instance.hasAttribute("itemprop")) break;
                return instance;
              case "link":
                name = instance.getAttribute("rel");
                if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                  break;
                else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                  break;
                return instance;
              case "style":
                if (instance.hasAttribute("data-precedence")) break;
                return instance;
              case "script":
                name = instance.getAttribute("src");
                if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                  break;
                return instance;
              default:
                return instance;
            }
          instance = getNextHydratable(instance.nextSibling);
          if (null === instance) break;
        }
        return null;
      }
      function canHydrateTextInstance(instance, text, inRootOrSingleton) {
        if ("" === text) return null;
        for (; 3 !== instance.nodeType; ) {
          if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
            return null;
          instance = getNextHydratable(instance.nextSibling);
          if (null === instance) return null;
        }
        return instance;
      }
      function canHydrateHydrationBoundary(instance, inRootOrSingleton) {
        for (; 8 !== instance.nodeType; ) {
          if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
            return null;
          instance = getNextHydratable(instance.nextSibling);
          if (null === instance) return null;
        }
        return instance;
      }
      function isSuspenseInstancePending(instance) {
        return "$?" === instance.data || "$~" === instance.data;
      }
      function isSuspenseInstanceFallback(instance) {
        return "$!" === instance.data || "$?" === instance.data && "loading" !== instance.ownerDocument.readyState;
      }
      function registerSuspenseInstanceRetry(instance, callback) {
        var ownerDocument = instance.ownerDocument;
        if ("$~" === instance.data) instance._reactRetry = callback;
        else if ("$?" !== instance.data || "loading" !== ownerDocument.readyState)
          callback();
        else {
          var listener = function() {
            callback();
            ownerDocument.removeEventListener("DOMContentLoaded", listener);
          };
          ownerDocument.addEventListener("DOMContentLoaded", listener);
          instance._reactRetry = listener;
        }
      }
      function getNextHydratable(node) {
        for (; null != node; node = node.nextSibling) {
          var nodeType = node.nodeType;
          if (1 === nodeType || 3 === nodeType) break;
          if (8 === nodeType) {
            nodeType = node.data;
            if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "$~" === nodeType || "&" === nodeType || "F!" === nodeType || "F" === nodeType)
              break;
            if ("/$" === nodeType || "/&" === nodeType) return null;
          }
        }
        return node;
      }
      var previousHydratableOnEnteringScopedSingleton = null;
      function getNextHydratableInstanceAfterHydrationBoundary(hydrationInstance) {
        hydrationInstance = hydrationInstance.nextSibling;
        for (var depth = 0; hydrationInstance; ) {
          if (8 === hydrationInstance.nodeType) {
            var data = hydrationInstance.data;
            if ("/$" === data || "/&" === data) {
              if (0 === depth)
                return getNextHydratable(hydrationInstance.nextSibling);
              depth--;
            } else
              "$" !== data && "$!" !== data && "$?" !== data && "$~" !== data && "&" !== data || depth++;
          }
          hydrationInstance = hydrationInstance.nextSibling;
        }
        return null;
      }
      function getParentHydrationBoundary(targetInstance) {
        targetInstance = targetInstance.previousSibling;
        for (var depth = 0; targetInstance; ) {
          if (8 === targetInstance.nodeType) {
            var data = targetInstance.data;
            if ("$" === data || "$!" === data || "$?" === data || "$~" === data || "&" === data) {
              if (0 === depth) return targetInstance;
              depth--;
            } else "/$" !== data && "/&" !== data || depth++;
          }
          targetInstance = targetInstance.previousSibling;
        }
        return null;
      }
      function resolveSingletonInstance(type, props, rootContainerInstance) {
        props = getOwnerDocumentFromRootContainer(rootContainerInstance);
        switch (type) {
          case "html":
            type = props.documentElement;
            if (!type) throw Error(formatProdErrorMessage(452));
            return type;
          case "head":
            type = props.head;
            if (!type) throw Error(formatProdErrorMessage(453));
            return type;
          case "body":
            type = props.body;
            if (!type) throw Error(formatProdErrorMessage(454));
            return type;
          default:
            throw Error(formatProdErrorMessage(451));
        }
      }
      function releaseSingletonInstance(instance) {
        for (var attributes = instance.attributes; attributes.length; )
          instance.removeAttributeNode(attributes[0]);
        detachDeletedInstance(instance);
      }
      var preloadPropsMap = /* @__PURE__ */ new Map(), preconnectsSet = /* @__PURE__ */ new Set();
      function getHoistableRoot(container) {
        return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
      }
      var previousDispatcher = ReactDOMSharedInternals.d;
      ReactDOMSharedInternals.d = {
        f: flushSyncWork,
        r: requestFormReset,
        D: prefetchDNS,
        C: preconnect,
        L: preload,
        m: preloadModule,
        X: preinitScript,
        S: preinitStyle,
        M: preinitModuleScript
      };
      function flushSyncWork() {
        var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
        return previousWasRendering || wasRendering;
      }
      function requestFormReset(form) {
        var formInst = getInstanceFromNode(form);
        null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
      }
      var globalDocument = "undefined" === typeof document ? null : document;
      function preconnectAs(rel, href, crossOrigin) {
        var ownerDocument = globalDocument;
        if (ownerDocument && "string" === typeof href && href) {
          var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
          limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
          "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
          preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
        }
      }
      function prefetchDNS(href) {
        previousDispatcher.D(href);
        preconnectAs("dns-prefetch", href, null);
      }
      function preconnect(href, crossOrigin) {
        previousDispatcher.C(href, crossOrigin);
        preconnectAs("preconnect", href, crossOrigin);
      }
      function preload(href, as, options2) {
        previousDispatcher.L(href, as, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href && as) {
          var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
          "image" === as ? options2 && options2.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
            options2.imageSrcSet
          ) + '"]', "string" === typeof options2.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
            options2.imageSizes
          ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
          var key = preloadSelector;
          switch (as) {
            case "style":
              key = getStyleKey(href);
              break;
            case "script":
              key = getScriptKey(href);
          }
          preloadPropsMap.has(key) || (href = assign(
            {
              rel: "preload",
              href: "image" === as && options2 && options2.imageSrcSet ? void 0 : href,
              as
            },
            options2
          ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
        }
      }
      function preloadModule(href, options2) {
        previousDispatcher.m(href, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var as = options2 && "string" === typeof options2.as ? options2.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
          switch (as) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              key = getScriptKey(href);
          }
          if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options2), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
            switch (as) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script":
                if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                  return;
            }
            as = ownerDocument.createElement("link");
            setInitialProperties(as, "link", href);
            markNodeAsHoistable(as);
            ownerDocument.head.appendChild(as);
          }
        }
      }
      function preinitStyle(href, precedence, options2) {
        previousDispatcher.S(href, precedence, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
          precedence = precedence || "default";
          var resource = styles.get(key);
          if (!resource) {
            var state = { loading: 0, preload: null };
            if (resource = ownerDocument.querySelector(
              getStylesheetSelectorFromKey(key)
            ))
              state.loading = 5;
            else {
              href = assign(
                { rel: "stylesheet", href, "data-precedence": precedence },
                options2
              );
              (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options2);
              var link = resource = ownerDocument.createElement("link");
              markNodeAsHoistable(link);
              setInitialProperties(link, "link", href);
              link._p = new Promise(function(resolve, reject) {
                link.onload = resolve;
                link.onerror = reject;
              });
              link.addEventListener("load", function() {
                state.loading |= 1;
              });
              link.addEventListener("error", function() {
                state.loading |= 2;
              });
              state.loading |= 4;
              insertStylesheet(resource, precedence, ownerDocument);
            }
            resource = {
              type: "stylesheet",
              instance: resource,
              count: 1,
              state
            };
            styles.set(key, resource);
          }
        }
      }
      function preinitScript(src, options2) {
        previousDispatcher.X(src, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
          resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      }
      function preinitModuleScript(src, options2) {
        previousDispatcher.M(src, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
          resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true, type: "module" }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      }
      function getResource(type, currentProps, pendingProps, currentResource) {
        var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
        if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
        switch (type) {
          case "meta":
          case "title":
            return null;
          case "style":
            return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
              type: "style",
              instance: null,
              count: 0,
              state: null
            }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
          case "link":
            if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
              type = getStyleKey(pendingProps.href);
              var styles$243 = getResourcesFromRoot(
                JSCompiler_inline_result
              ).hoistableStyles, resource$244 = styles$243.get(type);
              resource$244 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$244 = {
                type: "stylesheet",
                instance: null,
                count: 0,
                state: { loading: 0, preload: null }
              }, styles$243.set(type, resource$244), (styles$243 = JSCompiler_inline_result.querySelector(
                getStylesheetSelectorFromKey(type)
              )) && !styles$243._p && (resource$244.instance = styles$243, resource$244.state.loading = 5), preloadPropsMap.has(type) || (pendingProps = {
                rel: "preload",
                as: "style",
                href: pendingProps.href,
                crossOrigin: pendingProps.crossOrigin,
                integrity: pendingProps.integrity,
                media: pendingProps.media,
                hrefLang: pendingProps.hrefLang,
                referrerPolicy: pendingProps.referrerPolicy
              }, preloadPropsMap.set(type, pendingProps), styles$243 || preloadStylesheet(
                JSCompiler_inline_result,
                type,
                pendingProps,
                resource$244.state
              )));
              if (currentProps && null === currentResource)
                throw Error(formatProdErrorMessage(528, ""));
              return resource$244;
            }
            if (currentProps && null !== currentResource)
              throw Error(formatProdErrorMessage(529, ""));
            return null;
          case "script":
            return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
              type: "script",
              instance: null,
              count: 0,
              state: null
            }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
          default:
            throw Error(formatProdErrorMessage(444, type));
        }
      }
      function getStyleKey(href) {
        return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
      }
      function getStylesheetSelectorFromKey(key) {
        return 'link[rel="stylesheet"][' + key + "]";
      }
      function stylesheetPropsFromRawProps(rawProps) {
        return assign({}, rawProps, {
          "data-precedence": rawProps.precedence,
          precedence: null
        });
      }
      function preloadStylesheet(ownerDocument, key, preloadProps, state) {
        ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = 1 : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
          return state.loading |= 1;
        }), key.addEventListener("error", function() {
          return state.loading |= 2;
        }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
      }
      function getScriptKey(src) {
        return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
      }
      function getScriptSelectorFromKey(key) {
        return "script[async]" + key;
      }
      function acquireResource(hoistableRoot, resource, props) {
        resource.count++;
        if (null === resource.instance)
          switch (resource.type) {
            case "style":
              var instance = hoistableRoot.querySelector(
                'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
              );
              if (instance)
                return resource.instance = instance, markNodeAsHoistable(instance), instance;
              var styleProps = assign({}, props, {
                "data-href": props.href,
                "data-precedence": props.precedence,
                href: null,
                precedence: null
              });
              instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
                "style"
              );
              markNodeAsHoistable(instance);
              setInitialProperties(instance, "style", styleProps);
              insertStylesheet(instance, props.precedence, hoistableRoot);
              return resource.instance = instance;
            case "stylesheet":
              styleProps = getStyleKey(props.href);
              var instance$249 = hoistableRoot.querySelector(
                getStylesheetSelectorFromKey(styleProps)
              );
              if (instance$249)
                return resource.state.loading |= 4, resource.instance = instance$249, markNodeAsHoistable(instance$249), instance$249;
              instance = stylesheetPropsFromRawProps(props);
              (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
              instance$249 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
              markNodeAsHoistable(instance$249);
              var linkInstance = instance$249;
              linkInstance._p = new Promise(function(resolve, reject) {
                linkInstance.onload = resolve;
                linkInstance.onerror = reject;
              });
              setInitialProperties(instance$249, "link", instance);
              resource.state.loading |= 4;
              insertStylesheet(instance$249, props.precedence, hoistableRoot);
              return resource.instance = instance$249;
            case "script":
              instance$249 = getScriptKey(props.src);
              if (styleProps = hoistableRoot.querySelector(
                getScriptSelectorFromKey(instance$249)
              ))
                return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
              instance = props;
              if (styleProps = preloadPropsMap.get(instance$249))
                instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
              hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
              styleProps = hoistableRoot.createElement("script");
              markNodeAsHoistable(styleProps);
              setInitialProperties(styleProps, "link", instance);
              hoistableRoot.head.appendChild(styleProps);
              return resource.instance = styleProps;
            case "void":
              return null;
            default:
              throw Error(formatProdErrorMessage(443, resource.type));
          }
        else
          "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance = resource.instance, resource.state.loading |= 4, insertStylesheet(instance, props.precedence, hoistableRoot));
        return resource.instance;
      }
      function insertStylesheet(instance, precedence, root2) {
        for (var nodes = root2.querySelectorAll(
          'link[rel="stylesheet"][data-precedence],style[data-precedence]'
        ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          if (node.dataset.precedence === precedence) prior = node;
          else if (prior !== last) break;
        }
        prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root2.nodeType ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
      }
      function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
        null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
        null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
        null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
      }
      function adoptPreloadPropsForScript(scriptProps, preloadProps) {
        null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
        null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
        null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
      }
      var tagCaches = null;
      function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
        if (null === tagCaches) {
          var cache = /* @__PURE__ */ new Map();
          var caches = tagCaches = /* @__PURE__ */ new Map();
          caches.set(ownerDocument, cache);
        } else
          caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
        if (cache.has(type)) return cache;
        cache.set(type, null);
        ownerDocument = ownerDocument.getElementsByTagName(type);
        for (caches = 0; caches < ownerDocument.length; caches++) {
          var node = ownerDocument[caches];
          if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node.namespaceURI) {
            var nodeKey = node.getAttribute(keyAttribute) || "";
            nodeKey = type + nodeKey;
            var existing = cache.get(nodeKey);
            existing ? existing.push(node) : cache.set(nodeKey, [node]);
          }
        }
        return cache;
      }
      function mountHoistable(hoistableRoot, type, instance) {
        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
        hoistableRoot.head.insertBefore(
          instance,
          "title" === type ? hoistableRoot.querySelector("head > title") : null
        );
      }
      function isHostHoistableType(type, props, hostContext) {
        if (1 === hostContext || null != props.itemProp) return false;
        switch (type) {
          case "meta":
          case "title":
            return true;
          case "style":
            if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href)
              break;
            return true;
          case "link":
            if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError)
              break;
            switch (props.rel) {
              case "stylesheet":
                return type = props.disabled, "string" === typeof props.precedence && null == type;
              default:
                return true;
            }
          case "script":
            if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src)
              return true;
        }
        return false;
      }
      function preloadResource(resource) {
        return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? false : true;
      }
      function suspendResource(state, hoistableRoot, resource, props) {
        if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
          if (null === resource.instance) {
            var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
              getStylesheetSelectorFromKey(key)
            );
            if (instance) {
              hoistableRoot = instance._p;
              null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
              resource.state.loading |= 4;
              resource.instance = instance;
              markNodeAsHoistable(instance);
              return;
            }
            instance = hoistableRoot.ownerDocument || hoistableRoot;
            props = stylesheetPropsFromRawProps(props);
            (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
            instance = instance.createElement("link");
            markNodeAsHoistable(instance);
            var linkInstance = instance;
            linkInstance._p = new Promise(function(resolve, reject) {
              linkInstance.onload = resolve;
              linkInstance.onerror = reject;
            });
            setInitialProperties(instance, "link", props);
            resource.instance = instance;
          }
          null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
          state.stylesheets.set(resource, hoistableRoot);
          (hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
        }
      }
      var estimatedBytesWithinLimit = 0;
      function waitForCommitToBeReady(state, timeoutOffset) {
        state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
        return 0 < state.count || 0 < state.imgCount ? function(commit) {
          var stylesheetTimer = setTimeout(function() {
            state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
            if (state.unsuspend) {
              var unsuspend = state.unsuspend;
              state.unsuspend = null;
              unsuspend();
            }
          }, 6e4 + timeoutOffset);
          0 < state.imgBytes && 0 === estimatedBytesWithinLimit && (estimatedBytesWithinLimit = 62500 * estimateBandwidth());
          var imgTimer = setTimeout(
            function() {
              state.waitingForImages = false;
              if (0 === state.count && (state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets), state.unsuspend)) {
                var unsuspend = state.unsuspend;
                state.unsuspend = null;
                unsuspend();
              }
            },
            (state.imgBytes > estimatedBytesWithinLimit ? 50 : 800) + timeoutOffset
          );
          state.unsuspend = commit;
          return function() {
            state.unsuspend = null;
            clearTimeout(stylesheetTimer);
            clearTimeout(imgTimer);
          };
        } : null;
      }
      function onUnsuspend() {
        this.count--;
        if (0 === this.count && (0 === this.imgCount || !this.waitingForImages)) {
          if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
          else if (this.unsuspend) {
            var unsuspend = this.unsuspend;
            this.unsuspend = null;
            unsuspend();
          }
        }
      }
      var precedencesByRoot = null;
      function insertSuspendedStylesheets(state, resources) {
        state.stylesheets = null;
        null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
      }
      function insertStylesheetIntoRoot(root2, resource) {
        if (!(resource.state.loading & 4)) {
          var precedences = precedencesByRoot.get(root2);
          if (precedences) var last = precedences.get(null);
          else {
            precedences = /* @__PURE__ */ new Map();
            precedencesByRoot.set(root2, precedences);
            for (var nodes = root2.querySelectorAll(
              "link[data-precedence],style[data-precedence]"
            ), i = 0; i < nodes.length; i++) {
              var node = nodes[i];
              if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
                precedences.set(node.dataset.precedence, node), last = node;
            }
            last && precedences.set(null, last);
          }
          nodes = resource.instance;
          node = nodes.getAttribute("data-precedence");
          i = precedences.get(node) || last;
          i === last && precedences.set(null, nodes);
          precedences.set(node, nodes);
          this.count++;
          last = onUnsuspend.bind(this);
          nodes.addEventListener("load", last);
          nodes.addEventListener("error", last);
          i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root2 = 9 === root2.nodeType ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
          resource.state.loading |= 4;
        }
      }
      var HostTransitionContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Provider: null,
        Consumer: null,
        _currentValue: sharedNotPendingObject,
        _currentValue2: sharedNotPendingObject,
        _threadCount: 0
      };
      function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState) {
        this.tag = 1;
        this.containerInfo = containerInfo;
        this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = -1;
        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
        this.callbackPriority = 0;
        this.expirationTimes = createLaneMap(-1);
        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
        this.entanglements = createLaneMap(0);
        this.hiddenUpdates = createLaneMap(null);
        this.identifierPrefix = identifierPrefix;
        this.onUncaughtError = onUncaughtError;
        this.onCaughtError = onCaughtError;
        this.onRecoverableError = onRecoverableError;
        this.pooledCache = null;
        this.pooledCacheLanes = 0;
        this.formState = formState;
        this.incompleteTransitions = /* @__PURE__ */ new Map();
      }
      function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator) {
        containerInfo = new FiberRootNode(
          containerInfo,
          tag,
          hydrate,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          onDefaultTransitionIndicator,
          formState
        );
        tag = 1;
        true === isStrictMode && (tag |= 24);
        isStrictMode = createFiberImplClass(3, null, null, tag);
        containerInfo.current = isStrictMode;
        isStrictMode.stateNode = containerInfo;
        tag = createCache();
        tag.refCount++;
        containerInfo.pooledCache = tag;
        tag.refCount++;
        isStrictMode.memoizedState = {
          element: initialChildren,
          isDehydrated: hydrate,
          cache: tag
        };
        initializeUpdateQueue(isStrictMode);
        return containerInfo;
      }
      function getContextForSubtree(parentComponent) {
        if (!parentComponent) return emptyContextObject;
        parentComponent = emptyContextObject;
        return parentComponent;
      }
      function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
        parentComponent = getContextForSubtree(parentComponent);
        null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
        container = createUpdate(lane);
        container.payload = { element };
        callback = void 0 === callback ? null : callback;
        null !== callback && (container.callback = callback);
        element = enqueueUpdate(rootFiber, container, lane);
        null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
      }
      function markRetryLaneImpl(fiber, retryLane) {
        fiber = fiber.memoizedState;
        if (null !== fiber && null !== fiber.dehydrated) {
          var a = fiber.retryLane;
          fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
        }
      }
      function markRetryLaneIfNotHydrated(fiber, retryLane) {
        markRetryLaneImpl(fiber, retryLane);
        (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
      }
      function attemptContinuousHydration(fiber) {
        if (13 === fiber.tag || 31 === fiber.tag) {
          var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
          null !== root2 && scheduleUpdateOnFiber(root2, fiber, 67108864);
          markRetryLaneIfNotHydrated(fiber, 67108864);
        }
      }
      function attemptHydrationAtCurrentPriority(fiber) {
        if (13 === fiber.tag || 31 === fiber.tag) {
          var lane = requestUpdateLane();
          lane = getBumpedLaneForHydrationByLane(lane);
          var root2 = enqueueConcurrentRenderForLane(fiber, lane);
          null !== root2 && scheduleUpdateOnFiber(root2, fiber, lane);
          markRetryLaneIfNotHydrated(fiber, lane);
        }
      }
      var _enabled = true;
      function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
        var prevTransition = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 2, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
        var prevTransition = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 8, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (_enabled) {
          var blockedOn = findInstanceBlockingEvent(nativeEvent);
          if (null === blockedOn)
            dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              return_targetInst,
              targetContainer
            ), clearIfContinuousEvent(domEventName, nativeEvent);
          else if (queueIfContinuousEvent(
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ))
            nativeEvent.stopPropagation();
          else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
            for (; null !== blockedOn; ) {
              var fiber = getInstanceFromNode(blockedOn);
              if (null !== fiber)
                switch (fiber.tag) {
                  case 3:
                    fiber = fiber.stateNode;
                    if (fiber.current.memoizedState.isDehydrated) {
                      var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                      if (0 !== lanes) {
                        var root2 = fiber;
                        root2.pendingLanes |= 2;
                        for (root2.entangledLanes |= 2; lanes; ) {
                          var lane = 1 << 31 - clz32(lanes);
                          root2.entanglements[1] |= lane;
                          lanes &= ~lane;
                        }
                        ensureRootIsScheduled(fiber);
                        0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0));
                      }
                    }
                    break;
                  case 31:
                  case 13:
                    root2 = enqueueConcurrentRenderForLane(fiber, 2), null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
                }
              fiber = findInstanceBlockingEvent(nativeEvent);
              null === fiber && dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                return_targetInst,
                targetContainer
              );
              if (fiber === blockedOn) break;
              blockedOn = fiber;
            }
            null !== blockedOn && nativeEvent.stopPropagation();
          } else
            dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              null,
              targetContainer
            );
        }
      }
      function findInstanceBlockingEvent(nativeEvent) {
        nativeEvent = getEventTarget(nativeEvent);
        return findInstanceBlockingTarget(nativeEvent);
      }
      var return_targetInst = null;
      function findInstanceBlockingTarget(targetNode) {
        return_targetInst = null;
        targetNode = getClosestInstanceFromNode(targetNode);
        if (null !== targetNode) {
          var nearestMounted = getNearestMountedFiber(targetNode);
          if (null === nearestMounted) targetNode = null;
          else {
            var tag = nearestMounted.tag;
            if (13 === tag) {
              targetNode = getSuspenseInstanceFromFiber(nearestMounted);
              if (null !== targetNode) return targetNode;
              targetNode = null;
            } else if (31 === tag) {
              targetNode = getActivityInstanceFromFiber(nearestMounted);
              if (null !== targetNode) return targetNode;
              targetNode = null;
            } else if (3 === tag) {
              if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
                return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
              targetNode = null;
            } else nearestMounted !== targetNode && (targetNode = null);
          }
        }
        return_targetInst = targetNode;
        return null;
      }
      function getEventPriority(domEventName) {
        switch (domEventName) {
          case "beforetoggle":
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "toggle":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return 2;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return 8;
          case "message":
            switch (getCurrentPriorityLevel()) {
              case ImmediatePriority:
                return 2;
              case UserBlockingPriority:
                return 8;
              case NormalPriority$1:
              case LowPriority:
                return 32;
              case IdlePriority:
                return 268435456;
              default:
                return 32;
            }
          default:
            return 32;
        }
      }
      var hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
        " "
      );
      function clearIfContinuousEvent(domEventName, nativeEvent) {
        switch (domEventName) {
          case "focusin":
          case "focusout":
            queuedFocus = null;
            break;
          case "dragenter":
          case "dragleave":
            queuedDrag = null;
            break;
          case "mouseover":
          case "mouseout":
            queuedMouse = null;
            break;
          case "pointerover":
          case "pointerout":
            queuedPointers.delete(nativeEvent.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            queuedPointerCaptures.delete(nativeEvent.pointerId);
        }
      }
      function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
          return existingQueuedEvent = {
            blockedOn,
            domEventName,
            eventSystemFlags,
            nativeEvent,
            targetContainers: [targetContainer]
          }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
        existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
        blockedOn = existingQueuedEvent.targetContainers;
        null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
        return existingQueuedEvent;
      }
      function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        switch (domEventName) {
          case "focusin":
            return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedFocus,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "dragenter":
            return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedDrag,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "mouseover":
            return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedMouse,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "pointerover":
            var pointerId = nativeEvent.pointerId;
            queuedPointers.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointers.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )
            );
            return true;
          case "gotpointercapture":
            return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointerCaptures.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )
            ), true;
        }
        return false;
      }
      function attemptExplicitHydrationTarget(queuedTarget) {
        var targetInst = getClosestInstanceFromNode(queuedTarget.target);
        if (null !== targetInst) {
          var nearestMounted = getNearestMountedFiber(targetInst);
          if (null !== nearestMounted) {
            if (targetInst = nearestMounted.tag, 13 === targetInst) {
              if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
                queuedTarget.blockedOn = targetInst;
                runWithPriority(queuedTarget.priority, function() {
                  attemptHydrationAtCurrentPriority(nearestMounted);
                });
                return;
              }
            } else if (31 === targetInst) {
              if (targetInst = getActivityInstanceFromFiber(nearestMounted), null !== targetInst) {
                queuedTarget.blockedOn = targetInst;
                runWithPriority(queuedTarget.priority, function() {
                  attemptHydrationAtCurrentPriority(nearestMounted);
                });
                return;
              }
            } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
              queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
              return;
            }
          }
        }
        queuedTarget.blockedOn = null;
      }
      function attemptReplayContinuousQueuedEvent(queuedEvent) {
        if (null !== queuedEvent.blockedOn) return false;
        for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
          var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
          if (null === nextBlockedOn) {
            nextBlockedOn = queuedEvent.nativeEvent;
            var nativeEventClone = new nextBlockedOn.constructor(
              nextBlockedOn.type,
              nextBlockedOn
            );
            currentReplayingEvent = nativeEventClone;
            nextBlockedOn.target.dispatchEvent(nativeEventClone);
            currentReplayingEvent = null;
          } else
            return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
          targetContainers.shift();
        }
        return true;
      }
      function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
        attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
      }
      function replayUnblockedEvents() {
        hasScheduledReplayAttempt = false;
        null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
        null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
        null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
        queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
        queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
      }
      function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
        queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
          Scheduler.unstable_NormalPriority,
          replayUnblockedEvents
        )));
      }
      var lastScheduledReplayQueue = null;
      function scheduleReplayQueueIfNeeded(formReplayingQueue) {
        lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
          Scheduler.unstable_NormalPriority,
          function() {
            lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
            for (var i = 0; i < formReplayingQueue.length; i += 3) {
              var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
              if ("function" !== typeof submitterOrAction)
                if (null === findInstanceBlockingTarget(submitterOrAction || form))
                  continue;
                else break;
              var formInst = getInstanceFromNode(form);
              null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, startHostTransition(
                formInst,
                {
                  pending: true,
                  data: formData,
                  method: form.method,
                  action: submitterOrAction
                },
                submitterOrAction,
                formData
              ));
            }
          }
        ));
      }
      function retryIfBlockedOn(unblocked) {
        function unblock(queuedEvent) {
          return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
        }
        null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
        null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
        null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
        queuedPointers.forEach(unblock);
        queuedPointerCaptures.forEach(unblock);
        for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
          var queuedTarget = queuedExplicitHydrationTargets[i];
          queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
        }
        for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn); )
          attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
        i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
        if (null != i)
          for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
            var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
            if ("function" === typeof submitterOrAction)
              formProps || scheduleReplayQueueIfNeeded(i);
            else if (formProps) {
              var action = null;
              if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
                if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                  action = formProps.formAction;
                else {
                  if (null !== findInstanceBlockingTarget(form)) continue;
                }
              else action = formProps.action;
              "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
              scheduleReplayQueueIfNeeded(i);
            }
          }
      }
      function defaultOnDefaultTransitionIndicator() {
        function handleNavigate(event) {
          event.canIntercept && "react-transition" === event.info && event.intercept({
            handler: function() {
              return new Promise(function(resolve) {
                return pendingResolve = resolve;
              });
            },
            focusReset: "manual",
            scroll: "manual"
          });
        }
        function handleNavigateComplete() {
          null !== pendingResolve && (pendingResolve(), pendingResolve = null);
          isCancelled || setTimeout(startFakeNavigation, 20);
        }
        function startFakeNavigation() {
          if (!isCancelled && !navigation.transition) {
            var currentEntry = navigation.currentEntry;
            currentEntry && null != currentEntry.url && navigation.navigate(currentEntry.url, {
              state: currentEntry.getState(),
              info: "react-transition",
              history: "replace"
            });
          }
        }
        if ("object" === typeof navigation) {
          var isCancelled = false, pendingResolve = null;
          navigation.addEventListener("navigate", handleNavigate);
          navigation.addEventListener("navigatesuccess", handleNavigateComplete);
          navigation.addEventListener("navigateerror", handleNavigateComplete);
          setTimeout(startFakeNavigation, 100);
          return function() {
            isCancelled = true;
            navigation.removeEventListener("navigate", handleNavigate);
            navigation.removeEventListener("navigatesuccess", handleNavigateComplete);
            navigation.removeEventListener("navigateerror", handleNavigateComplete);
            null !== pendingResolve && (pendingResolve(), pendingResolve = null);
          };
        }
      }
      function ReactDOMRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
        var root2 = this._internalRoot;
        if (null === root2) throw Error(formatProdErrorMessage(409));
        var current = root2.current, lane = requestUpdateLane();
        updateContainerImpl(current, lane, children, root2, null, null);
      };
      ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
        var root2 = this._internalRoot;
        if (null !== root2) {
          this._internalRoot = null;
          var container = root2.containerInfo;
          updateContainerImpl(root2.current, 2, null, root2, null, null);
          flushSyncWork$1();
          container[internalContainerInstanceKey] = null;
        }
      };
      function ReactDOMHydrationRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
        if (target) {
          var updatePriority = resolveUpdatePriority();
          target = { blockedOn: null, target, priority: updatePriority };
          for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++) ;
          queuedExplicitHydrationTargets.splice(i, 0, target);
          0 === i && attemptExplicitHydrationTarget(target);
        }
      };
      var isomorphicReactPackageVersion$jscomp$inline_1840 = React2.version;
      if ("19.2.0" !== isomorphicReactPackageVersion$jscomp$inline_1840)
        throw Error(
          formatProdErrorMessage(
            527,
            isomorphicReactPackageVersion$jscomp$inline_1840,
            "19.2.0"
          )
        );
      ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
        var fiber = componentOrElement._reactInternals;
        if (void 0 === fiber) {
          if ("function" === typeof componentOrElement.render)
            throw Error(formatProdErrorMessage(188));
          componentOrElement = Object.keys(componentOrElement).join(",");
          throw Error(formatProdErrorMessage(268, componentOrElement));
        }
        componentOrElement = findCurrentFiberUsingSlowPath(fiber);
        componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
        componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
        return componentOrElement;
      };
      var internals$jscomp$inline_2347 = {
        bundleType: 0,
        version: "19.2.0",
        rendererPackageName: "react-dom",
        currentDispatcherRef: ReactSharedInternals,
        reconcilerVersion: "19.2.0"
      };
      if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        var hook$jscomp$inline_2348 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!hook$jscomp$inline_2348.isDisabled && hook$jscomp$inline_2348.supportsFiber)
          try {
            rendererID = hook$jscomp$inline_2348.inject(
              internals$jscomp$inline_2347
            ), injectedHook = hook$jscomp$inline_2348;
          } catch (err) {
          }
      }
      reactDomClient_production.createRoot = function(container, options2) {
        if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
        var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError;
        null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError));
        options2 = createFiberRoot(
          container,
          1,
          false,
          null,
          null,
          isStrictMode,
          identifierPrefix,
          null,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          defaultOnDefaultTransitionIndicator
        );
        container[internalContainerInstanceKey] = options2.current;
        listenToAllSupportedEvents(container);
        return new ReactDOMRoot(options2);
      };
      reactDomClient_production.hydrateRoot = function(container, initialChildren, options2) {
        if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
        var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, formState = null;
        null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.formState && (formState = options2.formState));
        initialChildren = createFiberRoot(
          container,
          1,
          true,
          initialChildren,
          null != options2 ? options2 : null,
          isStrictMode,
          identifierPrefix,
          formState,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          defaultOnDefaultTransitionIndicator
        );
        initialChildren.context = getContextForSubtree(null);
        options2 = initialChildren.current;
        isStrictMode = requestUpdateLane();
        isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
        identifierPrefix = createUpdate(isStrictMode);
        identifierPrefix.callback = null;
        enqueueUpdate(options2, identifierPrefix, isStrictMode);
        options2 = isStrictMode;
        initialChildren.current.lanes = options2;
        markRootUpdated$1(initialChildren, options2);
        ensureRootIsScheduled(initialChildren);
        container[internalContainerInstanceKey] = initialChildren.current;
        listenToAllSupportedEvents(container);
        return new ReactDOMHydrationRoot(initialChildren);
      };
      reactDomClient_production.version = "19.2.0";
      return reactDomClient_production;
    }
    var hasRequiredClient;
    function requireClient() {
      if (hasRequiredClient) return client.exports;
      hasRequiredClient = 1;
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      {
        checkDCE();
        client.exports = requireReactDomClient_production();
      }
      return client.exports;
    }
    var clientExports = requireClient();
    const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(clientExports);
    /**
     * react-router v7.9.6
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    var PopStateEventType = "popstate";
    function createHashHistory(options = {}) {
      function createHashLocation(window2, globalHistory) {
        let {
          pathname = "/",
          search = "",
          hash = ""
        } = parsePath(window2.location.hash.substring(1));
        if (!pathname.startsWith("/") && !pathname.startsWith(".")) {
          pathname = "/" + pathname;
        }
        return createLocation(
          "",
          { pathname, search, hash },
          // state defaults to `null` because `window.history.state` does
          globalHistory.state && globalHistory.state.usr || null,
          globalHistory.state && globalHistory.state.key || "default"
        );
      }
      function createHashHref(window2, to) {
        let base = window2.document.querySelector("base");
        let href = "";
        if (base && base.getAttribute("href")) {
          let url = window2.location.href;
          let hashIndex = url.indexOf("#");
          href = hashIndex === -1 ? url : url.slice(0, hashIndex);
        }
        return href + "#" + (typeof to === "string" ? to : createPath(to));
      }
      function validateHashLocation(location, to) {
        warning(
          location.pathname.charAt(0) === "/",
          `relative pathnames are not supported in hash history.push(${JSON.stringify(
            to
          )})`
        );
      }
      return getUrlBasedHistory(
        createHashLocation,
        createHashHref,
        validateHashLocation,
        options
      );
    }
    function invariant(value, message) {
      if (value === false || value === null || typeof value === "undefined") {
        throw new Error(message);
      }
    }
    function warning(cond, message) {
      if (!cond) {
        if (typeof console !== "undefined") console.warn(message);
        try {
          throw new Error(message);
        } catch (e) {
        }
      }
    }
    function createKey() {
      return Math.random().toString(36).substring(2, 10);
    }
    function getHistoryState(location, index) {
      return {
        usr: location.state,
        key: location.key,
        idx: index
      };
    }
    function createLocation(current, to, state = null, key) {
      let location = __spreadProps(__spreadValues({
        pathname: typeof current === "string" ? current : current.pathname,
        search: "",
        hash: ""
      }, typeof to === "string" ? parsePath(to) : to), {
        state,
        // TODO: This could be cleaned up.  push/replace should probably just take
        // full Locations now and avoid the need to run through this flow at all
        // But that's a pretty big refactor to the current test suite so going to
        // keep as is for the time being and just let any incoming keys take precedence
        key: to && to.key || key || createKey()
      });
      return location;
    }
    function createPath({
      pathname = "/",
      search = "",
      hash = ""
    }) {
      if (search && search !== "?")
        pathname += search.charAt(0) === "?" ? search : "?" + search;
      if (hash && hash !== "#")
        pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
      return pathname;
    }
    function parsePath(path) {
      let parsedPath = {};
      if (path) {
        let hashIndex = path.indexOf("#");
        if (hashIndex >= 0) {
          parsedPath.hash = path.substring(hashIndex);
          path = path.substring(0, hashIndex);
        }
        let searchIndex = path.indexOf("?");
        if (searchIndex >= 0) {
          parsedPath.search = path.substring(searchIndex);
          path = path.substring(0, searchIndex);
        }
        if (path) {
          parsedPath.pathname = path;
        }
      }
      return parsedPath;
    }
    function getUrlBasedHistory(getLocation, createHref2, validateLocation, options = {}) {
      let { window: window2 = document.defaultView, v5Compat = false } = options;
      let globalHistory = window2.history;
      let action = "POP";
      let listener = null;
      let index = getIndex();
      if (index == null) {
        index = 0;
        globalHistory.replaceState(__spreadProps(__spreadValues({}, globalHistory.state), { idx: index }), "");
      }
      function getIndex() {
        let state = globalHistory.state || { idx: null };
        return state.idx;
      }
      function handlePop() {
        action = "POP";
        let nextIndex = getIndex();
        let delta = nextIndex == null ? null : nextIndex - index;
        index = nextIndex;
        if (listener) {
          listener({ action, location: history.location, delta });
        }
      }
      function push(to, state) {
        action = "PUSH";
        let location = createLocation(history.location, to, state);
        if (validateLocation) validateLocation(location, to);
        index = getIndex() + 1;
        let historyState = getHistoryState(location, index);
        let url = history.createHref(location);
        try {
          globalHistory.pushState(historyState, "", url);
        } catch (error) {
          if (error instanceof DOMException && error.name === "DataCloneError") {
            throw error;
          }
          window2.location.assign(url);
        }
        if (v5Compat && listener) {
          listener({ action, location: history.location, delta: 1 });
        }
      }
      function replace2(to, state) {
        action = "REPLACE";
        let location = createLocation(history.location, to, state);
        if (validateLocation) validateLocation(location, to);
        index = getIndex();
        let historyState = getHistoryState(location, index);
        let url = history.createHref(location);
        globalHistory.replaceState(historyState, "", url);
        if (v5Compat && listener) {
          listener({ action, location: history.location, delta: 0 });
        }
      }
      function createURL(to) {
        return createBrowserURLImpl(to);
      }
      let history = {
        get action() {
          return action;
        },
        get location() {
          return getLocation(window2, globalHistory);
        },
        listen(fn) {
          if (listener) {
            throw new Error("A history only accepts one active listener");
          }
          window2.addEventListener(PopStateEventType, handlePop);
          listener = fn;
          return () => {
            window2.removeEventListener(PopStateEventType, handlePop);
            listener = null;
          };
        },
        createHref(to) {
          return createHref2(window2, to);
        },
        createURL,
        encodeLocation(to) {
          let url = createURL(to);
          return {
            pathname: url.pathname,
            search: url.search,
            hash: url.hash
          };
        },
        push,
        replace: replace2,
        go(n) {
          return globalHistory.go(n);
        }
      };
      return history;
    }
    function createBrowserURLImpl(to, isAbsolute = false) {
      let base = "http://localhost";
      if (typeof window !== "undefined") {
        base = window.location.origin !== "null" ? window.location.origin : window.location.href;
      }
      invariant(base, "No window.location.(origin|href) available to create URL");
      let href = typeof to === "string" ? to : createPath(to);
      href = href.replace(/ $/, "%20");
      if (!isAbsolute && href.startsWith("//")) {
        href = base + href;
      }
      return new URL(href, base);
    }
    function matchRoutes(routes, locationArg, basename = "/") {
      return matchRoutesImpl(routes, locationArg, basename, false);
    }
    function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
      let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
      let pathname = stripBasename(location.pathname || "/", basename);
      if (pathname == null) {
        return null;
      }
      let branches = flattenRoutes(routes);
      rankRouteBranches(branches);
      let matches = null;
      for (let i = 0; matches == null && i < branches.length; ++i) {
        let decoded = decodePath(pathname);
        matches = matchRouteBranch(
          branches[i],
          decoded,
          allowPartial
        );
      }
      return matches;
    }
    function flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = "", _hasParentOptionalSegments = false) {
      let flattenRoute = (route, index, hasParentOptionalSegments = _hasParentOptionalSegments, relativePath) => {
        let meta = {
          relativePath: relativePath === void 0 ? route.path || "" : relativePath,
          caseSensitive: route.caseSensitive === true,
          childrenIndex: index,
          route
        };
        if (meta.relativePath.startsWith("/")) {
          if (!meta.relativePath.startsWith(parentPath) && hasParentOptionalSegments) {
            return;
          }
          invariant(
            meta.relativePath.startsWith(parentPath),
            `Absolute route path "${meta.relativePath}" nested under path "${parentPath}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
          );
          meta.relativePath = meta.relativePath.slice(parentPath.length);
        }
        let path = joinPaths([parentPath, meta.relativePath]);
        let routesMeta = parentsMeta.concat(meta);
        if (route.children && route.children.length > 0) {
          invariant(
            // Our types know better, but runtime JS may not!
            // @ts-expect-error
            route.index !== true,
            `Index routes must not have child routes. Please remove all child routes from route path "${path}".`
          );
          flattenRoutes(
            route.children,
            branches,
            routesMeta,
            path,
            hasParentOptionalSegments
          );
        }
        if (route.path == null && !route.index) {
          return;
        }
        branches.push({
          path,
          score: computeScore(path, route.index),
          routesMeta
        });
      };
      routes.forEach((route, index) => {
        var _a;
        if (route.path === "" || !((_a = route.path) == null ? void 0 : _a.includes("?"))) {
          flattenRoute(route, index);
        } else {
          for (let exploded of explodeOptionalSegments(route.path)) {
            flattenRoute(route, index, true, exploded);
          }
        }
      });
      return branches;
    }
    function explodeOptionalSegments(path) {
      let segments = path.split("/");
      if (segments.length === 0) return [];
      let [first, ...rest] = segments;
      let isOptional = first.endsWith("?");
      let required = first.replace(/\?$/, "");
      if (rest.length === 0) {
        return isOptional ? [required, ""] : [required];
      }
      let restExploded = explodeOptionalSegments(rest.join("/"));
      let result = [];
      result.push(
        ...restExploded.map(
          (subpath) => subpath === "" ? required : [required, subpath].join("/")
        )
      );
      if (isOptional) {
        result.push(...restExploded);
      }
      return result.map(
        (exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded
      );
    }
    function rankRouteBranches(branches) {
      branches.sort(
        (a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(
          a.routesMeta.map((meta) => meta.childrenIndex),
          b.routesMeta.map((meta) => meta.childrenIndex)
        )
      );
    }
    var paramRe = /^:[\w-]+$/;
    var dynamicSegmentValue = 3;
    var indexRouteValue = 2;
    var emptySegmentValue = 1;
    var staticSegmentValue = 10;
    var splatPenalty = -2;
    var isSplat = (s) => s === "*";
    function computeScore(path, index) {
      let segments = path.split("/");
      let initialScore = segments.length;
      if (segments.some(isSplat)) {
        initialScore += splatPenalty;
      }
      if (index) {
        initialScore += indexRouteValue;
      }
      return segments.filter((s) => !isSplat(s)).reduce(
        (score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue),
        initialScore
      );
    }
    function compareIndexes(a, b) {
      let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
      return siblings ? (
        // If two routes are siblings, we should try to match the earlier sibling
        // first. This allows people to have fine-grained control over the matching
        // behavior by simply putting routes with identical paths in the order they
        // want them tried.
        a[a.length - 1] - b[b.length - 1]
      ) : (
        // Otherwise, it doesn't really make sense to rank non-siblings by index,
        // so they sort equally.
        0
      );
    }
    function matchRouteBranch(branch, pathname, allowPartial = false) {
      let { routesMeta } = branch;
      let matchedParams = {};
      let matchedPathname = "/";
      let matches = [];
      for (let i = 0; i < routesMeta.length; ++i) {
        let meta = routesMeta[i];
        let end = i === routesMeta.length - 1;
        let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
        let match = matchPath(
          { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },
          remainingPathname
        );
        let route = meta.route;
        if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
          match = matchPath(
            {
              path: meta.relativePath,
              caseSensitive: meta.caseSensitive,
              end: false
            },
            remainingPathname
          );
        }
        if (!match) {
          return null;
        }
        Object.assign(matchedParams, match.params);
        matches.push({
          // TODO: Can this as be avoided?
          params: matchedParams,
          pathname: joinPaths([matchedPathname, match.pathname]),
          pathnameBase: normalizePathname(
            joinPaths([matchedPathname, match.pathnameBase])
          ),
          route
        });
        if (match.pathnameBase !== "/") {
          matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
        }
      }
      return matches;
    }
    function matchPath(pattern, pathname) {
      if (typeof pattern === "string") {
        pattern = { path: pattern, caseSensitive: false, end: true };
      }
      let [matcher, compiledParams] = compilePath(
        pattern.path,
        pattern.caseSensitive,
        pattern.end
      );
      let match = pathname.match(matcher);
      if (!match) return null;
      let matchedPathname = match[0];
      let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
      let captureGroups = match.slice(1);
      let params = compiledParams.reduce(
        (memo2, { paramName, isOptional }, index) => {
          if (paramName === "*") {
            let splatValue = captureGroups[index] || "";
            pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
          }
          const value = captureGroups[index];
          if (isOptional && !value) {
            memo2[paramName] = void 0;
          } else {
            memo2[paramName] = (value || "").replace(/%2F/g, "/");
          }
          return memo2;
        },
        {}
      );
      return {
        params,
        pathname: matchedPathname,
        pathnameBase,
        pattern
      };
    }
    function compilePath(path, caseSensitive = false, end = true) {
      warning(
        path === "*" || !path.endsWith("*") || path.endsWith("/*"),
        `Route path "${path}" will be treated as if it were "${path.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${path.replace(/\*$/, "/*")}".`
      );
      let params = [];
      let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
        /\/:([\w-]+)(\?)?/g,
        (_, paramName, isOptional) => {
          params.push({ paramName, isOptional: isOptional != null });
          return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
        }
      ).replace(/\/([\w-]+)\?(\/|$)/g, "(/$1)?$2");
      if (path.endsWith("*")) {
        params.push({ paramName: "*" });
        regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
      } else if (end) {
        regexpSource += "\\/*$";
      } else if (path !== "" && path !== "/") {
        regexpSource += "(?:(?=\\/|$))";
      } else ;
      let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
      return [matcher, params];
    }
    function decodePath(value) {
      try {
        return value.split("/").map((v) => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
      } catch (error) {
        warning(
          false,
          `The URL path "${value}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`
        );
        return value;
      }
    }
    function stripBasename(pathname, basename) {
      if (basename === "/") return pathname;
      if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
        return null;
      }
      let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
      let nextChar = pathname.charAt(startIndex);
      if (nextChar && nextChar !== "/") {
        return null;
      }
      return pathname.slice(startIndex) || "/";
    }
    var ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
    var isAbsoluteUrl = (url) => ABSOLUTE_URL_REGEX.test(url);
    function resolvePath(to, fromPathname = "/") {
      let {
        pathname: toPathname,
        search = "",
        hash = ""
      } = typeof to === "string" ? parsePath(to) : to;
      let pathname;
      if (toPathname) {
        if (isAbsoluteUrl(toPathname)) {
          pathname = toPathname;
        } else {
          if (toPathname.includes("//")) {
            let oldPathname = toPathname;
            toPathname = toPathname.replace(/\/\/+/g, "/");
            warning(
              false,
              `Pathnames cannot have embedded double slashes - normalizing ${oldPathname} -> ${toPathname}`
            );
          }
          if (toPathname.startsWith("/")) {
            pathname = resolvePathname(toPathname.substring(1), "/");
          } else {
            pathname = resolvePathname(toPathname, fromPathname);
          }
        }
      } else {
        pathname = fromPathname;
      }
      return {
        pathname,
        search: normalizeSearch(search),
        hash: normalizeHash(hash)
      };
    }
    function resolvePathname(relativePath, fromPathname) {
      let segments = fromPathname.replace(/\/+$/, "").split("/");
      let relativeSegments = relativePath.split("/");
      relativeSegments.forEach((segment) => {
        if (segment === "..") {
          if (segments.length > 1) segments.pop();
        } else if (segment !== ".") {
          segments.push(segment);
        }
      });
      return segments.length > 1 ? segments.join("/") : "/";
    }
    function getInvalidPathError(char, field, dest, path) {
      return `Cannot include a '${char}' character in a manually specified \`to.${field}\` field [${JSON.stringify(
        path
      )}].  Please separate it out to the \`to.${dest}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
    }
    function getPathContributingMatches(matches) {
      return matches.filter(
        (match, index) => index === 0 || match.route.path && match.route.path.length > 0
      );
    }
    function getResolveToMatches(matches) {
      let pathMatches = getPathContributingMatches(matches);
      return pathMatches.map(
        (match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase
      );
    }
    function resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {
      let to;
      if (typeof toArg === "string") {
        to = parsePath(toArg);
      } else {
        to = __spreadValues({}, toArg);
        invariant(
          !to.pathname || !to.pathname.includes("?"),
          getInvalidPathError("?", "pathname", "search", to)
        );
        invariant(
          !to.pathname || !to.pathname.includes("#"),
          getInvalidPathError("#", "pathname", "hash", to)
        );
        invariant(
          !to.search || !to.search.includes("#"),
          getInvalidPathError("#", "search", "hash", to)
        );
      }
      let isEmptyPath = toArg === "" || to.pathname === "";
      let toPathname = isEmptyPath ? "/" : to.pathname;
      let from;
      if (toPathname == null) {
        from = locationPathname;
      } else {
        let routePathnameIndex = routePathnames.length - 1;
        if (!isPathRelative && toPathname.startsWith("..")) {
          let toSegments = toPathname.split("/");
          while (toSegments[0] === "..") {
            toSegments.shift();
            routePathnameIndex -= 1;
          }
          to.pathname = toSegments.join("/");
        }
        from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
      }
      let path = resolvePath(to, from);
      let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
      let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
      if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
        path.pathname += "/";
      }
      return path;
    }
    var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
    var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
    var normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
    var normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
    function isRouteErrorResponse(error) {
      return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
    }
    Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
    var validMutationMethodsArr = [
      "POST",
      "PUT",
      "PATCH",
      "DELETE"
    ];
    new Set(
      validMutationMethodsArr
    );
    var validRequestMethodsArr = [
      "GET",
      ...validMutationMethodsArr
    ];
    new Set(validRequestMethodsArr);
    var DataRouterContext = reactExports.createContext(null);
    DataRouterContext.displayName = "DataRouter";
    var DataRouterStateContext = reactExports.createContext(null);
    DataRouterStateContext.displayName = "DataRouterState";
    reactExports.createContext(false);
    var ViewTransitionContext = reactExports.createContext({
      isTransitioning: false
    });
    ViewTransitionContext.displayName = "ViewTransition";
    var FetchersContext = reactExports.createContext(
      /* @__PURE__ */ new Map()
    );
    FetchersContext.displayName = "Fetchers";
    var AwaitContext = reactExports.createContext(null);
    AwaitContext.displayName = "Await";
    var NavigationContext = reactExports.createContext(
      null
    );
    NavigationContext.displayName = "Navigation";
    var LocationContext = reactExports.createContext(
      null
    );
    LocationContext.displayName = "Location";
    var RouteContext = reactExports.createContext({
      outlet: null,
      matches: [],
      isDataRoute: false
    });
    RouteContext.displayName = "Route";
    var RouteErrorContext = reactExports.createContext(null);
    RouteErrorContext.displayName = "RouteError";
    function useHref(to, { relative } = {}) {
      invariant(
        useInRouterContext(),
        // TODO: This error is probably because they somehow have 2 versions of the
        // router loaded. We can help them understand how to avoid that.
        `useHref() may be used only in the context of a <Router> component.`
      );
      let { basename, navigator: navigator2 } = reactExports.useContext(NavigationContext);
      let { hash, pathname, search } = useResolvedPath(to, { relative });
      let joinedPathname = pathname;
      if (basename !== "/") {
        joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
      }
      return navigator2.createHref({ pathname: joinedPathname, search, hash });
    }
    function useInRouterContext() {
      return reactExports.useContext(LocationContext) != null;
    }
    function useLocation() {
      invariant(
        useInRouterContext(),
        // TODO: This error is probably because they somehow have 2 versions of the
        // router loaded. We can help them understand how to avoid that.
        `useLocation() may be used only in the context of a <Router> component.`
      );
      return reactExports.useContext(LocationContext).location;
    }
    var navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;
    function useIsomorphicLayoutEffect(cb) {
      let isStatic = reactExports.useContext(NavigationContext).static;
      if (!isStatic) {
        reactExports.useLayoutEffect(cb);
      }
    }
    function useNavigate() {
      let { isDataRoute } = reactExports.useContext(RouteContext);
      return isDataRoute ? useNavigateStable() : useNavigateUnstable();
    }
    function useNavigateUnstable() {
      invariant(
        useInRouterContext(),
        // TODO: This error is probably because they somehow have 2 versions of the
        // router loaded. We can help them understand how to avoid that.
        `useNavigate() may be used only in the context of a <Router> component.`
      );
      let dataRouterContext = reactExports.useContext(DataRouterContext);
      let { basename, navigator: navigator2 } = reactExports.useContext(NavigationContext);
      let { matches } = reactExports.useContext(RouteContext);
      let { pathname: locationPathname } = useLocation();
      let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
      let activeRef = reactExports.useRef(false);
      useIsomorphicLayoutEffect(() => {
        activeRef.current = true;
      });
      let navigate = reactExports.useCallback(
        (to, options = {}) => {
          warning(activeRef.current, navigateEffectWarning);
          if (!activeRef.current) return;
          if (typeof to === "number") {
            navigator2.go(to);
            return;
          }
          let path = resolveTo(
            to,
            JSON.parse(routePathnamesJson),
            locationPathname,
            options.relative === "path"
          );
          if (dataRouterContext == null && basename !== "/") {
            path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
          }
          (!!options.replace ? navigator2.replace : navigator2.push)(
            path,
            options.state,
            options
          );
        },
        [
          basename,
          navigator2,
          routePathnamesJson,
          locationPathname,
          dataRouterContext
        ]
      );
      return navigate;
    }
    reactExports.createContext(null);
    function useResolvedPath(to, { relative } = {}) {
      let { matches } = reactExports.useContext(RouteContext);
      let { pathname: locationPathname } = useLocation();
      let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
      return reactExports.useMemo(
        () => resolveTo(
          to,
          JSON.parse(routePathnamesJson),
          locationPathname,
          relative === "path"
        ),
        [to, routePathnamesJson, locationPathname, relative]
      );
    }
    function useRoutes(routes, locationArg) {
      return useRoutesImpl(routes, locationArg);
    }
    function useRoutesImpl(routes, locationArg, dataRouterState, unstable_onError, future) {
      var _a;
      invariant(
        useInRouterContext(),
        // TODO: This error is probably because they somehow have 2 versions of the
        // router loaded. We can help them understand how to avoid that.
        `useRoutes() may be used only in the context of a <Router> component.`
      );
      let { navigator: navigator2 } = reactExports.useContext(NavigationContext);
      let { matches: parentMatches } = reactExports.useContext(RouteContext);
      let routeMatch = parentMatches[parentMatches.length - 1];
      let parentParams = routeMatch ? routeMatch.params : {};
      let parentPathname = routeMatch ? routeMatch.pathname : "/";
      let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
      let parentRoute = routeMatch && routeMatch.route;
      {
        let parentPath = parentRoute && parentRoute.path || "";
        warningOnce(
          parentPathname,
          !parentRoute || parentPath.endsWith("*") || parentPath.endsWith("*?"),
          `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${parentPathname}" (under <Route path="${parentPath}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${parentPath}"> to <Route path="${parentPath === "/" ? "*" : `${parentPath}/*`}">.`
        );
      }
      let locationFromContext = useLocation();
      let location;
      if (locationArg) {
        let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
        invariant(
          parentPathnameBase === "/" || ((_a = parsedLocationArg.pathname) == null ? void 0 : _a.startsWith(parentPathnameBase)),
          `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${parentPathnameBase}" but pathname "${parsedLocationArg.pathname}" was given in the \`location\` prop.`
        );
        location = parsedLocationArg;
      } else {
        location = locationFromContext;
      }
      let pathname = location.pathname || "/";
      let remainingPathname = pathname;
      if (parentPathnameBase !== "/") {
        let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
        let segments = pathname.replace(/^\//, "").split("/");
        remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
      }
      let matches = matchRoutes(routes, { pathname: remainingPathname });
      {
        warning(
          parentRoute || matches != null,
          `No routes matched location "${location.pathname}${location.search}${location.hash}" `
        );
        warning(
          matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0,
          `Matched leaf route at location "${location.pathname}${location.search}${location.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
        );
      }
      let renderedMatches = _renderMatches(
        matches && matches.map(
          (match) => Object.assign({}, match, {
            params: Object.assign({}, parentParams, match.params),
            pathname: joinPaths([
              parentPathnameBase,
              // Re-encode pathnames that were decoded inside matchRoutes.
              // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
              // `new URL()` internally and we need to prevent it from treating
              // them as separators
              navigator2.encodeLocation ? navigator2.encodeLocation(
                match.pathname.replace(/\?/g, "%3F").replace(/#/g, "%23")
              ).pathname : match.pathname
            ]),
            pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
              parentPathnameBase,
              // Re-encode pathnames that were decoded inside matchRoutes
              // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
              // `new URL()` internally and we need to prevent it from treating
              // them as separators
              navigator2.encodeLocation ? navigator2.encodeLocation(
                match.pathnameBase.replace(/\?/g, "%3F").replace(/#/g, "%23")
              ).pathname : match.pathnameBase
            ])
          })
        ),
        parentMatches,
        dataRouterState,
        unstable_onError,
        future
      );
      if (locationArg && renderedMatches) {
        return /* @__PURE__ */ reactExports.createElement(
          LocationContext.Provider,
          {
            value: {
              location: __spreadValues({
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default"
              }, location),
              navigationType: "POP"
              /* Pop */
            }
          },
          renderedMatches
        );
      }
      return renderedMatches;
    }
    function DefaultErrorComponent() {
      let error = useRouteError();
      let message = isRouteErrorResponse(error) ? `${error.status} ${error.statusText}` : error instanceof Error ? error.message : JSON.stringify(error);
      let stack = error instanceof Error ? error.stack : null;
      let lightgrey = "rgba(200,200,200, 0.5)";
      let preStyles = { padding: "0.5rem", backgroundColor: lightgrey };
      let codeStyles = { padding: "2px 4px", backgroundColor: lightgrey };
      let devInfo = null;
      {
        console.error(
          "Error handled by React Router default ErrorBoundary:",
          error
        );
        devInfo = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("p", null, " Hey developer "), /* @__PURE__ */ reactExports.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ reactExports.createElement("code", { style: codeStyles }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ reactExports.createElement("code", { style: codeStyles }, "errorElement"), " prop on your route."));
      }
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", { style: { fontStyle: "italic" } }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", { style: preStyles }, stack) : null, devInfo);
    }
    var defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
    var RenderErrorBoundary = class extends reactExports.Component {
      constructor(props) {
        super(props);
        this.state = {
          location: props.location,
          revalidation: props.revalidation,
          error: props.error
        };
      }
      static getDerivedStateFromError(error) {
        return { error };
      }
      static getDerivedStateFromProps(props, state) {
        if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
          return {
            error: props.error,
            location: props.location,
            revalidation: props.revalidation
          };
        }
        return {
          error: props.error !== void 0 ? props.error : state.error,
          location: state.location,
          revalidation: props.revalidation || state.revalidation
        };
      }
      componentDidCatch(error, errorInfo) {
        if (this.props.onError) {
          this.props.onError(error, errorInfo);
        } else {
          console.error(
            "React Router caught the following error during render",
            error
          );
        }
      }
      render() {
        return this.state.error !== void 0 ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, { value: this.props.routeContext }, /* @__PURE__ */ reactExports.createElement(
          RouteErrorContext.Provider,
          {
            value: this.state.error,
            children: this.props.component
          }
        )) : this.props.children;
      }
    };
    function RenderedRoute({ routeContext, match, children }) {
      let dataRouterContext = reactExports.useContext(DataRouterContext);
      if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
        dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
      }
      return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, { value: routeContext }, children);
    }
    function _renderMatches(matches, parentMatches = [], dataRouterState = null, unstable_onError = null, future = null) {
      if (matches == null) {
        if (!dataRouterState) {
          return null;
        }
        if (dataRouterState.errors) {
          matches = dataRouterState.matches;
        } else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
          matches = dataRouterState.matches;
        } else {
          return null;
        }
      }
      let renderedMatches = matches;
      let errors = dataRouterState == null ? void 0 : dataRouterState.errors;
      if (errors != null) {
        let errorIndex = renderedMatches.findIndex(
          (m) => m.route.id && (errors == null ? void 0 : errors[m.route.id]) !== void 0
        );
        invariant(
          errorIndex >= 0,
          `Could not find a matching route for errors on route IDs: ${Object.keys(
            errors
          ).join(",")}`
        );
        renderedMatches = renderedMatches.slice(
          0,
          Math.min(renderedMatches.length, errorIndex + 1)
        );
      }
      let renderFallback = false;
      let fallbackIndex = -1;
      if (dataRouterState) {
        for (let i = 0; i < renderedMatches.length; i++) {
          let match = renderedMatches[i];
          if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
            fallbackIndex = i;
          }
          if (match.route.id) {
            let { loaderData, errors: errors2 } = dataRouterState;
            let needsToRunLoader = match.route.loader && !loaderData.hasOwnProperty(match.route.id) && (!errors2 || errors2[match.route.id] === void 0);
            if (match.route.lazy || needsToRunLoader) {
              renderFallback = true;
              if (fallbackIndex >= 0) {
                renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
              } else {
                renderedMatches = [renderedMatches[0]];
              }
              break;
            }
          }
        }
      }
      let onError = dataRouterState && unstable_onError ? (error, errorInfo) => {
        var _a, _b, _c;
        unstable_onError(error, {
          location: dataRouterState.location,
          params: (_c = (_b = (_a = dataRouterState.matches) == null ? void 0 : _a[0]) == null ? void 0 : _b.params) != null ? _c : {},
          errorInfo
        });
      } : void 0;
      return renderedMatches.reduceRight(
        (outlet, match, index) => {
          let error;
          let shouldRenderHydrateFallback = false;
          let errorElement = null;
          let hydrateFallbackElement = null;
          if (dataRouterState) {
            error = errors && match.route.id ? errors[match.route.id] : void 0;
            errorElement = match.route.errorElement || defaultErrorElement;
            if (renderFallback) {
              if (fallbackIndex < 0 && index === 0) {
                warningOnce(
                  "route-fallback",
                  false,
                  "No `HydrateFallback` element provided to render during initial hydration"
                );
                shouldRenderHydrateFallback = true;
                hydrateFallbackElement = null;
              } else if (fallbackIndex === index) {
                shouldRenderHydrateFallback = true;
                hydrateFallbackElement = match.route.hydrateFallbackElement || null;
              }
            }
          }
          let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));
          let getChildren = () => {
            let children;
            if (error) {
              children = errorElement;
            } else if (shouldRenderHydrateFallback) {
              children = hydrateFallbackElement;
            } else if (match.route.Component) {
              children = /* @__PURE__ */ reactExports.createElement(match.route.Component, null);
            } else if (match.route.element) {
              children = match.route.element;
            } else {
              children = outlet;
            }
            return /* @__PURE__ */ reactExports.createElement(
              RenderedRoute,
              {
                match,
                routeContext: {
                  outlet,
                  matches: matches2,
                  isDataRoute: dataRouterState != null
                },
                children
              }
            );
          };
          return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */ reactExports.createElement(
            RenderErrorBoundary,
            {
              location: dataRouterState.location,
              revalidation: dataRouterState.revalidation,
              component: errorElement,
              error,
              children: getChildren(),
              routeContext: { outlet: null, matches: matches2, isDataRoute: true },
              onError
            }
          ) : getChildren();
        },
        null
      );
    }
    function getDataRouterConsoleError(hookName) {
      return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
    }
    function useDataRouterContext(hookName) {
      let ctx = reactExports.useContext(DataRouterContext);
      invariant(ctx, getDataRouterConsoleError(hookName));
      return ctx;
    }
    function useDataRouterState(hookName) {
      let state = reactExports.useContext(DataRouterStateContext);
      invariant(state, getDataRouterConsoleError(hookName));
      return state;
    }
    function useRouteContext(hookName) {
      let route = reactExports.useContext(RouteContext);
      invariant(route, getDataRouterConsoleError(hookName));
      return route;
    }
    function useCurrentRouteId(hookName) {
      let route = useRouteContext(hookName);
      let thisRoute = route.matches[route.matches.length - 1];
      invariant(
        thisRoute.route.id,
        `${hookName} can only be used on routes that contain a unique "id"`
      );
      return thisRoute.route.id;
    }
    function useRouteId() {
      return useCurrentRouteId(
        "useRouteId"
        /* UseRouteId */
      );
    }
    function useRouteError() {
      var _a;
      let error = reactExports.useContext(RouteErrorContext);
      let state = useDataRouterState(
        "useRouteError"
        /* UseRouteError */
      );
      let routeId = useCurrentRouteId(
        "useRouteError"
        /* UseRouteError */
      );
      if (error !== void 0) {
        return error;
      }
      return (_a = state.errors) == null ? void 0 : _a[routeId];
    }
    function useNavigateStable() {
      let { router } = useDataRouterContext(
        "useNavigate"
        /* UseNavigateStable */
      );
      let id = useCurrentRouteId(
        "useNavigate"
        /* UseNavigateStable */
      );
      let activeRef = reactExports.useRef(false);
      useIsomorphicLayoutEffect(() => {
        activeRef.current = true;
      });
      let navigate = reactExports.useCallback(
        (_0, ..._1) => __async(null, [_0, ..._1], function* (to, options = {}) {
          warning(activeRef.current, navigateEffectWarning);
          if (!activeRef.current) return;
          if (typeof to === "number") {
            router.navigate(to);
          } else {
            yield router.navigate(to, __spreadValues({ fromRouteId: id }, options));
          }
        }),
        [router, id]
      );
      return navigate;
    }
    var alreadyWarned = {};
    function warningOnce(key, cond, message) {
      if (!cond && !alreadyWarned[key]) {
        alreadyWarned[key] = true;
        warning(false, message);
      }
    }
    reactExports.memo(DataRoutes);
    function DataRoutes({
      routes,
      future,
      state,
      unstable_onError
    }) {
      return useRoutesImpl(routes, void 0, state, unstable_onError, future);
    }
    function Route(props) {
      invariant(
        false,
        `A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.`
      );
    }
    function Router({
      basename: basenameProp = "/",
      children = null,
      location: locationProp,
      navigationType = "POP",
      navigator: navigator2,
      static: staticProp = false
    }) {
      invariant(
        !useInRouterContext(),
        `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`
      );
      let basename = basenameProp.replace(/^\/*/, "/");
      let navigationContext = reactExports.useMemo(
        () => ({
          basename,
          navigator: navigator2,
          static: staticProp,
          future: {}
        }),
        [basename, navigator2, staticProp]
      );
      if (typeof locationProp === "string") {
        locationProp = parsePath(locationProp);
      }
      let {
        pathname = "/",
        search = "",
        hash = "",
        state = null,
        key = "default"
      } = locationProp;
      let locationContext = reactExports.useMemo(() => {
        let trailingPathname = stripBasename(pathname, basename);
        if (trailingPathname == null) {
          return null;
        }
        return {
          location: {
            pathname: trailingPathname,
            search,
            hash,
            state,
            key
          },
          navigationType
        };
      }, [basename, pathname, search, hash, state, key, navigationType]);
      warning(
        locationContext != null,
        `<Router basename="${basename}"> is not able to match the URL "${pathname}${search}${hash}" because it does not start with the basename, so the <Router> won't render anything.`
      );
      if (locationContext == null) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, { value: navigationContext }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, { children, value: locationContext }));
    }
    function Routes({
      children,
      location
    }) {
      return useRoutes(createRoutesFromChildren(children), location);
    }
    function createRoutesFromChildren(children, parentPath = []) {
      let routes = [];
      reactExports.Children.forEach(children, (element, index) => {
        if (!reactExports.isValidElement(element)) {
          return;
        }
        let treePath = [...parentPath, index];
        if (element.type === reactExports.Fragment) {
          routes.push.apply(
            routes,
            createRoutesFromChildren(element.props.children, treePath)
          );
          return;
        }
        invariant(
          element.type === Route,
          `[${typeof element.type === "string" ? element.type : element.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`
        );
        invariant(
          !element.props.index || !element.props.children,
          "An index route cannot have child routes."
        );
        let route = {
          id: element.props.id || treePath.join("-"),
          caseSensitive: element.props.caseSensitive,
          element: element.props.element,
          Component: element.props.Component,
          index: element.props.index,
          path: element.props.path,
          middleware: element.props.middleware,
          loader: element.props.loader,
          action: element.props.action,
          hydrateFallbackElement: element.props.hydrateFallbackElement,
          HydrateFallback: element.props.HydrateFallback,
          errorElement: element.props.errorElement,
          ErrorBoundary: element.props.ErrorBoundary,
          hasErrorBoundary: element.props.hasErrorBoundary === true || element.props.ErrorBoundary != null || element.props.errorElement != null,
          shouldRevalidate: element.props.shouldRevalidate,
          handle: element.props.handle,
          lazy: element.props.lazy
        };
        if (element.props.children) {
          route.children = createRoutesFromChildren(
            element.props.children,
            treePath
          );
        }
        routes.push(route);
      });
      return routes;
    }
    var defaultMethod = "get";
    var defaultEncType = "application/x-www-form-urlencoded";
    function isHtmlElement(object) {
      return object != null && typeof object.tagName === "string";
    }
    function isButtonElement(object) {
      return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
    }
    function isFormElement(object) {
      return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
    }
    function isInputElement(object) {
      return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
    }
    function isModifiedEvent(event) {
      return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
    }
    function shouldProcessLinkClick(event, target) {
      return event.button === 0 && // Ignore everything but left clicks
      (!target || target === "_self") && // Let browser handle "target=_blank" etc.
      !isModifiedEvent(event);
    }
    var _formDataSupportsSubmitter = null;
    function isFormDataSubmitterSupported() {
      if (_formDataSupportsSubmitter === null) {
        try {
          new FormData(
            document.createElement("form"),
            // @ts-expect-error if FormData supports the submitter parameter, this will throw
            0
          );
          _formDataSupportsSubmitter = false;
        } catch (e) {
          _formDataSupportsSubmitter = true;
        }
      }
      return _formDataSupportsSubmitter;
    }
    var supportedFormEncTypes = /* @__PURE__ */ new Set([
      "application/x-www-form-urlencoded",
      "multipart/form-data",
      "text/plain"
    ]);
    function getFormEncType(encType) {
      if (encType != null && !supportedFormEncTypes.has(encType)) {
        warning(
          false,
          `"${encType}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${defaultEncType}"`
        );
        return null;
      }
      return encType;
    }
    function getFormSubmissionInfo(target, basename) {
      let method;
      let action;
      let encType;
      let formData;
      let body;
      if (isFormElement(target)) {
        let attr = target.getAttribute("action");
        action = attr ? stripBasename(attr, basename) : null;
        method = target.getAttribute("method") || defaultMethod;
        encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
        formData = new FormData(target);
      } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
        let form = target.form;
        if (form == null) {
          throw new Error(
            `Cannot submit a <button> or <input type="submit"> without a <form>`
          );
        }
        let attr = target.getAttribute("formaction") || form.getAttribute("action");
        action = attr ? stripBasename(attr, basename) : null;
        method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
        encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
        formData = new FormData(form, target);
        if (!isFormDataSubmitterSupported()) {
          let { name, type, value } = target;
          if (type === "image") {
            let prefix = name ? `${name}.` : "";
            formData.append(`${prefix}x`, "0");
            formData.append(`${prefix}y`, "0");
          } else if (name) {
            formData.append(name, value);
          }
        }
      } else if (isHtmlElement(target)) {
        throw new Error(
          `Cannot submit element that is not <form>, <button>, or <input type="submit|image">`
        );
      } else {
        method = defaultMethod;
        action = null;
        encType = defaultEncType;
        body = target;
      }
      if (formData && encType === "text/plain") {
        body = formData;
        formData = void 0;
      }
      return { action, method: method.toLowerCase(), encType, formData, body };
    }
    Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
    function invariant2(value, message) {
      if (value === false || value === null || typeof value === "undefined") {
        throw new Error(message);
      }
    }
    function singleFetchUrl(reqUrl, basename, extension) {
      let url = typeof reqUrl === "string" ? new URL(
        reqUrl,
        // This can be called during the SSR flow via PrefetchPageLinksImpl so
        // don't assume window is available
        typeof window === "undefined" ? "server://singlefetch/" : window.location.origin
      ) : reqUrl;
      if (url.pathname === "/") {
        url.pathname = `_root.${extension}`;
      } else if (basename && stripBasename(url.pathname, basename) === "/") {
        url.pathname = `${basename.replace(/\/$/, "")}/_root.${extension}`;
      } else {
        url.pathname = `${url.pathname.replace(/\/$/, "")}.${extension}`;
      }
      return url;
    }
    function loadRouteModule(route, routeModulesCache) {
      return __async(this, null, function* () {
        if (route.id in routeModulesCache) {
          return routeModulesCache[route.id];
        }
        try {
          let routeModule = yield import(
            /* @vite-ignore */
            /* webpackIgnore: true */
            route.module
          );
          routeModulesCache[route.id] = routeModule;
          return routeModule;
        } catch (error) {
          console.error(
            `Error loading route module \`${route.module}\`, reloading page...`
          );
          console.error(error);
          if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode && // @ts-expect-error
          void 0) ;
          window.location.reload();
          return new Promise(() => {
          });
        }
      });
    }
    function isHtmlLinkDescriptor(object) {
      if (object == null) {
        return false;
      }
      if (object.href == null) {
        return object.rel === "preload" && typeof object.imageSrcSet === "string" && typeof object.imageSizes === "string";
      }
      return typeof object.rel === "string" && typeof object.href === "string";
    }
    function getKeyedPrefetchLinks(matches, manifest, routeModules) {
      return __async(this, null, function* () {
        let links = yield Promise.all(
          matches.map((match) => __async(null, null, function* () {
            let route = manifest.routes[match.route.id];
            if (route) {
              let mod = yield loadRouteModule(route, routeModules);
              return mod.links ? mod.links() : [];
            }
            return [];
          }))
        );
        return dedupeLinkDescriptors(
          links.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map(
            (link) => link.rel === "stylesheet" ? __spreadProps(__spreadValues({}, link), { rel: "prefetch", as: "style" }) : __spreadProps(__spreadValues({}, link), { rel: "prefetch" })
          )
        );
      });
    }
    function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {
      let isNew = (match, index) => {
        if (!currentMatches[index]) return true;
        return match.route.id !== currentMatches[index].route.id;
      };
      let matchPathChanged = (match, index) => {
        var _a;
        return (
          // param change, /users/123 -> /users/456
          currentMatches[index].pathname !== match.pathname || // splat param changed, which is not present in match.path
          // e.g. /files/images/avatar.jpg -> files/finances.xls
          ((_a = currentMatches[index].route.path) == null ? void 0 : _a.endsWith("*")) && currentMatches[index].params["*"] !== match.params["*"]
        );
      };
      if (mode === "assets") {
        return nextMatches.filter(
          (match, index) => isNew(match, index) || matchPathChanged(match, index)
        );
      }
      if (mode === "data") {
        return nextMatches.filter((match, index) => {
          var _a;
          let manifestRoute = manifest.routes[match.route.id];
          if (!manifestRoute || !manifestRoute.hasLoader) {
            return false;
          }
          if (isNew(match, index) || matchPathChanged(match, index)) {
            return true;
          }
          if (match.route.shouldRevalidate) {
            let routeChoice = match.route.shouldRevalidate({
              currentUrl: new URL(
                location.pathname + location.search + location.hash,
                window.origin
              ),
              currentParams: ((_a = currentMatches[0]) == null ? void 0 : _a.params) || {},
              nextUrl: new URL(page, window.origin),
              nextParams: match.params,
              defaultShouldRevalidate: true
            });
            if (typeof routeChoice === "boolean") {
              return routeChoice;
            }
          }
          return true;
        });
      }
      return [];
    }
    function getModuleLinkHrefs(matches, manifest, { includeHydrateFallback } = {}) {
      return dedupeHrefs(
        matches.map((match) => {
          let route = manifest.routes[match.route.id];
          if (!route) return [];
          let hrefs = [route.module];
          if (route.clientActionModule) {
            hrefs = hrefs.concat(route.clientActionModule);
          }
          if (route.clientLoaderModule) {
            hrefs = hrefs.concat(route.clientLoaderModule);
          }
          if (includeHydrateFallback && route.hydrateFallbackModule) {
            hrefs = hrefs.concat(route.hydrateFallbackModule);
          }
          if (route.imports) {
            hrefs = hrefs.concat(route.imports);
          }
          return hrefs;
        }).flat(1)
      );
    }
    function dedupeHrefs(hrefs) {
      return [...new Set(hrefs)];
    }
    function sortKeys(obj) {
      let sorted = {};
      let keys = Object.keys(obj).sort();
      for (let key of keys) {
        sorted[key] = obj[key];
      }
      return sorted;
    }
    function dedupeLinkDescriptors(descriptors, preloads) {
      let set = /* @__PURE__ */ new Set();
      new Set(preloads);
      return descriptors.reduce((deduped, descriptor) => {
        let key = JSON.stringify(sortKeys(descriptor));
        if (!set.has(key)) {
          set.add(key);
          deduped.push({ key, link: descriptor });
        }
        return deduped;
      }, []);
    }
    function useDataRouterContext2() {
      let context = reactExports.useContext(DataRouterContext);
      invariant2(
        context,
        "You must render this element inside a <DataRouterContext.Provider> element"
      );
      return context;
    }
    function useDataRouterStateContext() {
      let context = reactExports.useContext(DataRouterStateContext);
      invariant2(
        context,
        "You must render this element inside a <DataRouterStateContext.Provider> element"
      );
      return context;
    }
    var FrameworkContext = reactExports.createContext(void 0);
    FrameworkContext.displayName = "FrameworkContext";
    function useFrameworkContext() {
      let context = reactExports.useContext(FrameworkContext);
      invariant2(
        context,
        "You must render this element inside a <HydratedRouter> element"
      );
      return context;
    }
    function usePrefetchBehavior(prefetch, theirElementProps) {
      let frameworkContext = reactExports.useContext(FrameworkContext);
      let [maybePrefetch, setMaybePrefetch] = reactExports.useState(false);
      let [shouldPrefetch, setShouldPrefetch] = reactExports.useState(false);
      let { onFocus, onBlur, onMouseEnter, onMouseLeave, onTouchStart } = theirElementProps;
      let ref = reactExports.useRef(null);
      reactExports.useEffect(() => {
        if (prefetch === "render") {
          setShouldPrefetch(true);
        }
        if (prefetch === "viewport") {
          let callback = (entries) => {
            entries.forEach((entry) => {
              setShouldPrefetch(entry.isIntersecting);
            });
          };
          let observer = new IntersectionObserver(callback, { threshold: 0.5 });
          if (ref.current) observer.observe(ref.current);
          return () => {
            observer.disconnect();
          };
        }
      }, [prefetch]);
      reactExports.useEffect(() => {
        if (maybePrefetch) {
          let id = setTimeout(() => {
            setShouldPrefetch(true);
          }, 100);
          return () => {
            clearTimeout(id);
          };
        }
      }, [maybePrefetch]);
      let setIntent = () => {
        setMaybePrefetch(true);
      };
      let cancelIntent = () => {
        setMaybePrefetch(false);
        setShouldPrefetch(false);
      };
      if (!frameworkContext) {
        return [false, ref, {}];
      }
      if (prefetch !== "intent") {
        return [shouldPrefetch, ref, {}];
      }
      return [
        shouldPrefetch,
        ref,
        {
          onFocus: composeEventHandlers(onFocus, setIntent),
          onBlur: composeEventHandlers(onBlur, cancelIntent),
          onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
          onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
          onTouchStart: composeEventHandlers(onTouchStart, setIntent)
        }
      ];
    }
    function composeEventHandlers(theirHandler, ourHandler) {
      return (event) => {
        theirHandler && theirHandler(event);
        if (!event.defaultPrevented) {
          ourHandler(event);
        }
      };
    }
    function PrefetchPageLinks(_a) {
      var _b = _a, { page } = _b, linkProps = __objRest(_b, ["page"]);
      let { router } = useDataRouterContext2();
      let matches = reactExports.useMemo(
        () => matchRoutes(router.routes, page, router.basename),
        [router.routes, page, router.basename]
      );
      if (!matches) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(PrefetchPageLinksImpl, __spreadValues({ page, matches }, linkProps));
    }
    function useKeyedPrefetchLinks(matches) {
      let { manifest, routeModules } = useFrameworkContext();
      let [keyedPrefetchLinks, setKeyedPrefetchLinks] = reactExports.useState([]);
      reactExports.useEffect(() => {
        let interrupted = false;
        void getKeyedPrefetchLinks(matches, manifest, routeModules).then(
          (links) => {
            if (!interrupted) {
              setKeyedPrefetchLinks(links);
            }
          }
        );
        return () => {
          interrupted = true;
        };
      }, [matches, manifest, routeModules]);
      return keyedPrefetchLinks;
    }
    function PrefetchPageLinksImpl(_c) {
      var _d = _c, {
        page,
        matches: nextMatches
      } = _d, linkProps = __objRest(_d, [
        "page",
        "matches"
      ]);
      let location = useLocation();
      let { manifest, routeModules } = useFrameworkContext();
      let { basename } = useDataRouterContext2();
      let { loaderData, matches } = useDataRouterStateContext();
      let newMatchesForData = reactExports.useMemo(
        () => getNewMatchesForLinks(
          page,
          nextMatches,
          matches,
          manifest,
          location,
          "data"
        ),
        [page, nextMatches, matches, manifest, location]
      );
      let newMatchesForAssets = reactExports.useMemo(
        () => getNewMatchesForLinks(
          page,
          nextMatches,
          matches,
          manifest,
          location,
          "assets"
        ),
        [page, nextMatches, matches, manifest, location]
      );
      let dataHrefs = reactExports.useMemo(() => {
        if (page === location.pathname + location.search + location.hash) {
          return [];
        }
        let routesParams = /* @__PURE__ */ new Set();
        let foundOptOutRoute = false;
        nextMatches.forEach((m) => {
          var _a;
          let manifestRoute = manifest.routes[m.route.id];
          if (!manifestRoute || !manifestRoute.hasLoader) {
            return;
          }
          if (!newMatchesForData.some((m2) => m2.route.id === m.route.id) && m.route.id in loaderData && ((_a = routeModules[m.route.id]) == null ? void 0 : _a.shouldRevalidate)) {
            foundOptOutRoute = true;
          } else if (manifestRoute.hasClientLoader) {
            foundOptOutRoute = true;
          } else {
            routesParams.add(m.route.id);
          }
        });
        if (routesParams.size === 0) {
          return [];
        }
        let url = singleFetchUrl(page, basename, "data");
        if (foundOptOutRoute && routesParams.size > 0) {
          url.searchParams.set(
            "_routes",
            nextMatches.filter((m) => routesParams.has(m.route.id)).map((m) => m.route.id).join(",")
          );
        }
        return [url.pathname + url.search];
      }, [
        basename,
        loaderData,
        location,
        manifest,
        newMatchesForData,
        nextMatches,
        page,
        routeModules
      ]);
      let moduleHrefs = reactExports.useMemo(
        () => getModuleLinkHrefs(newMatchesForAssets, manifest),
        [newMatchesForAssets, manifest]
      );
      let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ reactExports.createElement("link", __spreadValues({ key: href, rel: "prefetch", as: "fetch", href }, linkProps))), moduleHrefs.map((href) => /* @__PURE__ */ reactExports.createElement("link", __spreadValues({ key: href, rel: "modulepreload", href }, linkProps))), keyedPrefetchLinks.map(({ key, link }) => (
        // these don't spread `linkProps` because they are full link descriptors
        // already with their own props
        /* @__PURE__ */ reactExports.createElement("link", __spreadValues({ key, nonce: linkProps.nonce }, link))
      )));
    }
    function mergeRefs(...refs) {
      return (value) => {
        refs.forEach((ref) => {
          if (typeof ref === "function") {
            ref(value);
          } else if (ref != null) {
            ref.current = value;
          }
        });
      };
    }
    var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    try {
      if (isBrowser) {
        window.__reactRouterVersion = // @ts-expect-error
        "7.9.6";
      }
    } catch (e) {
    }
    function HashRouter({ basename, children, window: window2 }) {
      let historyRef = reactExports.useRef();
      if (historyRef.current == null) {
        historyRef.current = createHashHistory({ window: window2, v5Compat: true });
      }
      let history = historyRef.current;
      let [state, setStateImpl] = reactExports.useState({
        action: history.action,
        location: history.location
      });
      let setState = reactExports.useCallback(
        (newState) => {
          reactExports.startTransition(() => setStateImpl(newState));
        },
        [setStateImpl]
      );
      reactExports.useLayoutEffect(() => history.listen(setState), [history, setState]);
      return /* @__PURE__ */ reactExports.createElement(
        Router,
        {
          basename,
          children,
          location: state.location,
          navigationType: state.action,
          navigator: history
        }
      );
    }
    var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
    var Link = reactExports.forwardRef(
      function LinkWithRef(_e, forwardedRef) {
        var _f = _e, {
          onClick,
          discover = "render",
          prefetch = "none",
          relative,
          reloadDocument,
          replace: replace2,
          state,
          target,
          to,
          preventScrollReset,
          viewTransition
        } = _f, rest = __objRest(_f, [
          "onClick",
          "discover",
          "prefetch",
          "relative",
          "reloadDocument",
          "replace",
          "state",
          "target",
          "to",
          "preventScrollReset",
          "viewTransition"
        ]);
        let { basename } = reactExports.useContext(NavigationContext);
        let isAbsolute = typeof to === "string" && ABSOLUTE_URL_REGEX2.test(to);
        let absoluteHref;
        let isExternal = false;
        if (typeof to === "string" && isAbsolute) {
          absoluteHref = to;
          if (isBrowser) {
            try {
              let currentUrl = new URL(window.location.href);
              let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
              let path = stripBasename(targetUrl.pathname, basename);
              if (targetUrl.origin === currentUrl.origin && path != null) {
                to = path + targetUrl.search + targetUrl.hash;
              } else {
                isExternal = true;
              }
            } catch (e) {
              warning(
                false,
                `<Link to="${to}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
              );
            }
          }
        }
        let href = useHref(to, { relative });
        let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(
          prefetch,
          rest
        );
        let internalOnClick = useLinkClickHandler(to, {
          replace: replace2,
          state,
          target,
          preventScrollReset,
          relative,
          viewTransition
        });
        function handleClick(event) {
          if (onClick) onClick(event);
          if (!event.defaultPrevented) {
            internalOnClick(event);
          }
        }
        let link = (
          // eslint-disable-next-line jsx-a11y/anchor-has-content
          /* @__PURE__ */ reactExports.createElement(
            "a",
            __spreadProps(__spreadValues(__spreadValues({}, rest), prefetchHandlers), {
              href: absoluteHref || href,
              onClick: isExternal || reloadDocument ? onClick : handleClick,
              ref: mergeRefs(forwardedRef, prefetchRef),
              target,
              "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
            })
          )
        );
        return shouldPrefetch && !isAbsolute ? /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, link, /* @__PURE__ */ reactExports.createElement(PrefetchPageLinks, { page: href })) : link;
      }
    );
    Link.displayName = "Link";
    var NavLink = reactExports.forwardRef(
      function NavLinkWithRef(_g, ref) {
        var _h = _g, {
          "aria-current": ariaCurrentProp = "page",
          caseSensitive = false,
          className: classNameProp = "",
          end = false,
          style: styleProp,
          to,
          viewTransition,
          children
        } = _h, rest = __objRest(_h, [
          "aria-current",
          "caseSensitive",
          "className",
          "end",
          "style",
          "to",
          "viewTransition",
          "children"
        ]);
        let path = useResolvedPath(to, { relative: rest.relative });
        let location = useLocation();
        let routerState = reactExports.useContext(DataRouterStateContext);
        let { navigator: navigator2, basename } = reactExports.useContext(NavigationContext);
        let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static
        // eslint-disable-next-line react-hooks/rules-of-hooks
        useViewTransitionState(path) && viewTransition === true;
        let toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path).pathname : path.pathname;
        let locationPathname = location.pathname;
        let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
        if (!caseSensitive) {
          locationPathname = locationPathname.toLowerCase();
          nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
          toPathname = toPathname.toLowerCase();
        }
        if (nextLocationPathname && basename) {
          nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;
        }
        const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
        let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
        let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
        let renderProps = {
          isActive,
          isPending,
          isTransitioning
        };
        let ariaCurrent = isActive ? ariaCurrentProp : void 0;
        let className;
        if (typeof classNameProp === "function") {
          className = classNameProp(renderProps);
        } else {
          className = [
            classNameProp,
            isActive ? "active" : null,
            isPending ? "pending" : null,
            isTransitioning ? "transitioning" : null
          ].filter(Boolean).join(" ");
        }
        let style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
        return /* @__PURE__ */ reactExports.createElement(
          Link,
          __spreadProps(__spreadValues({}, rest), {
            "aria-current": ariaCurrent,
            className,
            ref,
            style,
            to,
            viewTransition
          }),
          typeof children === "function" ? children(renderProps) : children
        );
      }
    );
    NavLink.displayName = "NavLink";
    var Form = reactExports.forwardRef(
      (_i, forwardedRef) => {
        var _j = _i, {
          discover = "render",
          fetcherKey,
          navigate,
          reloadDocument,
          replace: replace2,
          state,
          method = defaultMethod,
          action,
          onSubmit,
          relative,
          preventScrollReset,
          viewTransition
        } = _j, props = __objRest(_j, [
          "discover",
          "fetcherKey",
          "navigate",
          "reloadDocument",
          "replace",
          "state",
          "method",
          "action",
          "onSubmit",
          "relative",
          "preventScrollReset",
          "viewTransition"
        ]);
        let submit = useSubmit();
        let formAction = useFormAction(action, { relative });
        let formMethod = method.toLowerCase() === "get" ? "get" : "post";
        let isAbsolute = typeof action === "string" && ABSOLUTE_URL_REGEX2.test(action);
        let submitHandler = (event) => {
          onSubmit && onSubmit(event);
          if (event.defaultPrevented) return;
          event.preventDefault();
          let submitter = event.nativeEvent.submitter;
          let submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;
          submit(submitter || event.currentTarget, {
            fetcherKey,
            method: submitMethod,
            navigate,
            replace: replace2,
            state,
            relative,
            preventScrollReset,
            viewTransition
          });
        };
        return /* @__PURE__ */ reactExports.createElement(
          "form",
          __spreadProps(__spreadValues({
            ref: forwardedRef,
            method: formMethod,
            action: formAction,
            onSubmit: reloadDocument ? onSubmit : submitHandler
          }, props), {
            "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
          })
        );
      }
    );
    Form.displayName = "Form";
    function getDataRouterConsoleError2(hookName) {
      return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
    }
    function useDataRouterContext3(hookName) {
      let ctx = reactExports.useContext(DataRouterContext);
      invariant(ctx, getDataRouterConsoleError2(hookName));
      return ctx;
    }
    function useLinkClickHandler(to, {
      target,
      replace: replaceProp,
      state,
      preventScrollReset,
      relative,
      viewTransition
    } = {}) {
      let navigate = useNavigate();
      let location = useLocation();
      let path = useResolvedPath(to, { relative });
      return reactExports.useCallback(
        (event) => {
          if (shouldProcessLinkClick(event, target)) {
            event.preventDefault();
            let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
            navigate(to, {
              replace: replace2,
              state,
              preventScrollReset,
              relative,
              viewTransition
            });
          }
        },
        [
          location,
          navigate,
          path,
          replaceProp,
          state,
          target,
          to,
          preventScrollReset,
          relative,
          viewTransition
        ]
      );
    }
    var fetcherId = 0;
    var getUniqueFetcherId = () => `__${String(++fetcherId)}__`;
    function useSubmit() {
      let { router } = useDataRouterContext3(
        "useSubmit"
        /* UseSubmit */
      );
      let { basename } = reactExports.useContext(NavigationContext);
      let currentRouteId = useRouteId();
      return reactExports.useCallback(
        (_0, ..._1) => __async(null, [_0, ..._1], function* (target, options = {}) {
          let { action, method, encType, formData, body } = getFormSubmissionInfo(
            target,
            basename
          );
          if (options.navigate === false) {
            let key = options.fetcherKey || getUniqueFetcherId();
            yield router.fetch(key, currentRouteId, options.action || action, {
              preventScrollReset: options.preventScrollReset,
              formData,
              body,
              formMethod: options.method || method,
              formEncType: options.encType || encType,
              flushSync: options.flushSync
            });
          } else {
            yield router.navigate(options.action || action, {
              preventScrollReset: options.preventScrollReset,
              formData,
              body,
              formMethod: options.method || method,
              formEncType: options.encType || encType,
              replace: options.replace,
              state: options.state,
              fromRouteId: currentRouteId,
              flushSync: options.flushSync,
              viewTransition: options.viewTransition
            });
          }
        }),
        [router, basename, currentRouteId]
      );
    }
    function useFormAction(action, { relative } = {}) {
      let { basename } = reactExports.useContext(NavigationContext);
      let routeContext = reactExports.useContext(RouteContext);
      invariant(routeContext, "useFormAction must be used inside a RouteContext");
      let [match] = routeContext.matches.slice(-1);
      let path = __spreadValues({}, useResolvedPath(action ? action : ".", { relative }));
      let location = useLocation();
      if (action == null) {
        path.search = location.search;
        let params = new URLSearchParams(path.search);
        let indexValues = params.getAll("index");
        let hasNakedIndexParam = indexValues.some((v) => v === "");
        if (hasNakedIndexParam) {
          params.delete("index");
          indexValues.filter((v) => v).forEach((v) => params.append("index", v));
          let qs = params.toString();
          path.search = qs ? `?${qs}` : "";
        }
      }
      if ((!action || action === ".") && match.route.index) {
        path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
      }
      if (basename !== "/") {
        path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
      }
      return createPath(path);
    }
    function useViewTransitionState(to, { relative } = {}) {
      let vtContext = reactExports.useContext(ViewTransitionContext);
      invariant(
        vtContext != null,
        "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
      );
      let { basename } = useDataRouterContext3(
        "useViewTransitionState"
        /* useViewTransitionState */
      );
      let path = useResolvedPath(to, { relative });
      if (!vtContext.isTransitioning) {
        return false;
      }
      let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
      let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
      return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
    }
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
    const toCamelCase = (string) => string.replace(
      /^([A-Z])|[\s-_]+(\w)/g,
      (match, p1, p2) => p2 ? p2.toUpperCase() : p1.toLowerCase()
    );
    const toPascalCase = (string) => {
      const camelCase = toCamelCase(string);
      return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
    };
    const mergeClasses = (...classes) => classes.filter((className, index, array) => {
      return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index;
    }).join(" ").trim();
    const hasA11yProp = (props) => {
      for (const prop in props) {
        if (prop.startsWith("aria-") || prop === "role" || prop === "title") {
          return true;
        }
      }
    };
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    var defaultAttributes = {
      xmlns: "http://www.w3.org/2000/svg",
      width: 24,
      height: 24,
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: 2,
      strokeLinecap: "round",
      strokeLinejoin: "round"
    };
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Icon = reactExports.forwardRef(
      (_k, ref) => {
        var _l = _k, {
          color = "currentColor",
          size = 24,
          strokeWidth = 2,
          absoluteStrokeWidth,
          className = "",
          children,
          iconNode
        } = _l, rest = __objRest(_l, [
          "color",
          "size",
          "strokeWidth",
          "absoluteStrokeWidth",
          "className",
          "children",
          "iconNode"
        ]);
        return reactExports.createElement(
          "svg",
          __spreadValues(__spreadValues(__spreadProps(__spreadValues({
            ref
          }, defaultAttributes), {
            width: size,
            height: size,
            stroke: color,
            strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
            className: mergeClasses("lucide", className)
          }), !children && !hasA11yProp(rest) && { "aria-hidden": "true" }), rest),
          [
            ...iconNode.map(([tag, attrs]) => reactExports.createElement(tag, attrs)),
            ...Array.isArray(children) ? children : [children]
          ]
        );
      }
    );
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const createLucideIcon = (iconName, iconNode) => {
      const Component = reactExports.forwardRef(
        (_a, ref) => {
          var _b = _a, { className } = _b, props = __objRest(_b, ["className"]);
          return reactExports.createElement(Icon, __spreadValues({
            ref,
            iconNode,
            className: mergeClasses(
              `lucide-${toKebabCase(toPascalCase(iconName))}`,
              `lucide-${iconName}`,
              className
            )
          }, props));
        }
      );
      Component.displayName = toPascalCase(iconName);
      return Component;
    };
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$w = [
      [
        "path",
        {
          d: "M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2",
          key: "169zse"
        }
      ]
    ];
    const Activity = createLucideIcon("activity", __iconNode$w);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$v = [
      ["path", { d: "M5 12h14", key: "1ays0h" }],
      ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]
    ];
    const ArrowRight = createLucideIcon("arrow-right", __iconNode$v);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$u = [
      ["path", { d: "M12 7v14", key: "1akyts" }],
      [
        "path",
        {
          d: "M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z",
          key: "ruj8y"
        }
      ]
    ];
    const BookOpen = createLucideIcon("book-open", __iconNode$u);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$t = [["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]];
    const ChevronRight = createLucideIcon("chevron-right", __iconNode$t);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$s = [
      ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
      ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }],
      ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]
    ];
    const CircleAlert = createLucideIcon("circle-alert", __iconNode$s);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$r = [
      ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
      ["path", { d: "m16 12-4-4-4 4", key: "177agl" }],
      ["path", { d: "M12 16V8", key: "1sbj14" }]
    ];
    const CircleArrowUp = createLucideIcon("circle-arrow-up", __iconNode$r);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$q = [
      ["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }],
      ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
    ];
    const CircleCheckBig = createLucideIcon("circle-check-big", __iconNode$q);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$p = [
      ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
      ["path", { d: "m9 12 2 2 4-4", key: "dzmm74" }]
    ];
    const CircleCheck = createLucideIcon("circle-check", __iconNode$p);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$o = [
      ["path", { d: "M12 20v2", key: "1lh1kg" }],
      ["path", { d: "M12 2v2", key: "tus03m" }],
      ["path", { d: "M17 20v2", key: "1rnc9c" }],
      ["path", { d: "M17 2v2", key: "11trls" }],
      ["path", { d: "M2 12h2", key: "1t8f8n" }],
      ["path", { d: "M2 17h2", key: "7oei6x" }],
      ["path", { d: "M2 7h2", key: "asdhe0" }],
      ["path", { d: "M20 12h2", key: "1q8mjw" }],
      ["path", { d: "M20 17h2", key: "1fpfkl" }],
      ["path", { d: "M20 7h2", key: "1o8tra" }],
      ["path", { d: "M7 20v2", key: "4gnj0m" }],
      ["path", { d: "M7 2v2", key: "1i4yhu" }],
      ["rect", { x: "4", y: "4", width: "16", height: "16", rx: "2", key: "1vbyd7" }],
      ["rect", { x: "8", y: "8", width: "8", height: "8", rx: "1", key: "z9xiuo" }]
    ];
    const Cpu = createLucideIcon("cpu", __iconNode$o);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$n = [
      ["path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "1357e3" }],
      ["path", { d: "M3 3v5h5", key: "1xhq8a" }],
      ["path", { d: "M12 7v5l4 2", key: "1fdv2h" }]
    ];
    const History = createLucideIcon("history", __iconNode$n);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$m = [
      ["path", { d: "m15.5 7.5 2.3 2.3a1 1 0 0 0 1.4 0l2.1-2.1a1 1 0 0 0 0-1.4L19 4", key: "g0fldk" }],
      ["path", { d: "m21 2-9.6 9.6", key: "1j0ho8" }],
      ["circle", { cx: "7.5", cy: "15.5", r: "5.5", key: "yqb3hr" }]
    ];
    const Key = createLucideIcon("key", __iconNode$m);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$l = [
      ["rect", { width: "7", height: "9", x: "3", y: "3", rx: "1", key: "10lvy0" }],
      ["rect", { width: "7", height: "5", x: "14", y: "3", rx: "1", key: "16une8" }],
      ["rect", { width: "7", height: "9", x: "14", y: "12", rx: "1", key: "1hutg5" }],
      ["rect", { width: "7", height: "5", x: "3", y: "16", rx: "1", key: "ldoo1y" }]
    ];
    const LayoutDashboard = createLucideIcon("layout-dashboard", __iconNode$l);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$k = [["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]];
    const LoaderCircle = createLucideIcon("loader-circle", __iconNode$k);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$j = [
      ["path", { d: "m16 17 5-5-5-5", key: "1bji2h" }],
      ["path", { d: "M21 12H9", key: "dn1m92" }],
      ["path", { d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4", key: "1uf3rs" }]
    ];
    const LogOut = createLucideIcon("log-out", __iconNode$j);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$i = [
      ["path", { d: "M12 19v3", key: "npa21l" }],
      ["path", { d: "M19 10v2a7 7 0 0 1-14 0v-2", key: "1vc78b" }],
      ["rect", { x: "9", y: "2", width: "6", height: "13", rx: "3", key: "s6n7sd" }]
    ];
    const Mic = createLucideIcon("mic", __iconNode$i);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$h = [
      [
        "path",
        {
          d: "M20.985 12.486a9 9 0 1 1-9.473-9.472c.405-.022.617.46.402.803a6 6 0 0 0 8.268 8.268c.344-.215.825-.004.803.401",
          key: "kfwtm"
        }
      ]
    ];
    const Moon = createLucideIcon("moon", __iconNode$h);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$g = [
      [
        "path",
        {
          d: "M15.707 21.293a1 1 0 0 1-1.414 0l-1.586-1.586a1 1 0 0 1 0-1.414l5.586-5.586a1 1 0 0 1 1.414 0l1.586 1.586a1 1 0 0 1 0 1.414z",
          key: "nt11vn"
        }
      ],
      [
        "path",
        {
          d: "m18 13-1.375-6.874a1 1 0 0 0-.746-.776L3.235 2.028a1 1 0 0 0-1.207 1.207L5.35 15.879a1 1 0 0 0 .776.746L13 18",
          key: "15qc1e"
        }
      ],
      ["path", { d: "m2.3 2.3 7.286 7.286", key: "1wuzzi" }],
      ["circle", { cx: "11", cy: "11", r: "2", key: "xmgehs" }]
    ];
    const PenTool = createLucideIcon("pen-tool", __iconNode$g);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$f = [
      [
        "path",
        {
          d: "M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z",
          key: "10ikf1"
        }
      ]
    ];
    const Play = createLucideIcon("play", __iconNode$f);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$e = [
      ["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8", key: "v9h5vc" }],
      ["path", { d: "M21 3v5h-5", key: "1q7to0" }],
      ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16", key: "3uifl3" }],
      ["path", { d: "M8 16H3v5", key: "1cv678" }]
    ];
    const RefreshCw = createLucideIcon("refresh-cw", __iconNode$e);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$d = [
      ["path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "1357e3" }],
      ["path", { d: "M3 3v5h5", key: "1xhq8a" }]
    ];
    const RotateCcw = createLucideIcon("rotate-ccw", __iconNode$d);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$c = [
      [
        "path",
        {
          d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",
          key: "1ffxy3"
        }
      ],
      ["path", { d: "m21.854 2.147-10.94 10.939", key: "12cjpa" }]
    ];
    const Send = createLucideIcon("send", __iconNode$c);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$b = [
      [
        "path",
        {
          d: "M11.017 2.814a1 1 0 0 1 1.966 0l1.051 5.558a2 2 0 0 0 1.594 1.594l5.558 1.051a1 1 0 0 1 0 1.966l-5.558 1.051a2 2 0 0 0-1.594 1.594l-1.051 5.558a1 1 0 0 1-1.966 0l-1.051-5.558a2 2 0 0 0-1.594-1.594l-5.558-1.051a1 1 0 0 1 0-1.966l5.558-1.051a2 2 0 0 0 1.594-1.594z",
          key: "1s2grr"
        }
      ],
      ["path", { d: "M20 2v4", key: "1rf3ol" }],
      ["path", { d: "M22 4h-4", key: "gwowj6" }],
      ["circle", { cx: "4", cy: "20", r: "2", key: "6kqj1y" }]
    ];
    const Sparkles = createLucideIcon("sparkles", __iconNode$b);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$a = [
      ["circle", { cx: "12", cy: "12", r: "4", key: "4exip2" }],
      ["path", { d: "M12 2v2", key: "tus03m" }],
      ["path", { d: "M12 20v2", key: "1lh1kg" }],
      ["path", { d: "m4.93 4.93 1.41 1.41", key: "149t6j" }],
      ["path", { d: "m17.66 17.66 1.41 1.41", key: "ptbguv" }],
      ["path", { d: "M2 12h2", key: "1t8f8n" }],
      ["path", { d: "M20 12h2", key: "1q8mjw" }],
      ["path", { d: "m6.34 17.66-1.41 1.41", key: "1m8zz5" }],
      ["path", { d: "m19.07 4.93-1.41 1.41", key: "1shlcs" }]
    ];
    const Sun = createLucideIcon("sun", __iconNode$a);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$9 = [
      ["line", { x1: "10", x2: "14", y1: "2", y2: "2", key: "14vaq8" }],
      ["line", { x1: "12", x2: "15", y1: "14", y2: "11", key: "17fdiu" }],
      ["circle", { cx: "12", cy: "14", r: "8", key: "1e1u0o" }]
    ];
    const Timer = createLucideIcon("timer", __iconNode$9);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$8 = [
      ["path", { d: "M10 11v6", key: "nco0om" }],
      ["path", { d: "M14 11v6", key: "outv1u" }],
      ["path", { d: "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6", key: "miytrc" }],
      ["path", { d: "M3 6h18", key: "d0wm0j" }],
      ["path", { d: "M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2", key: "e791ji" }]
    ];
    const Trash2 = createLucideIcon("trash-2", __iconNode$8);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$7 = [
      [
        "path",
        {
          d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
          key: "wmoenq"
        }
      ],
      ["path", { d: "M12 9v4", key: "juzpu7" }],
      ["path", { d: "M12 17h.01", key: "p32p05" }]
    ];
    const TriangleAlert = createLucideIcon("triangle-alert", __iconNode$7);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$6 = [
      ["path", { d: "M10 14.66v1.626a2 2 0 0 1-.976 1.696A5 5 0 0 0 7 21.978", key: "1n3hpd" }],
      ["path", { d: "M14 14.66v1.626a2 2 0 0 0 .976 1.696A5 5 0 0 1 17 21.978", key: "rfe1zi" }],
      ["path", { d: "M18 9h1.5a1 1 0 0 0 0-5H18", key: "7xy6bh" }],
      ["path", { d: "M4 22h16", key: "57wxv0" }],
      ["path", { d: "M6 9a6 6 0 0 0 12 0V3a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1z", key: "1mhfuq" }],
      ["path", { d: "M6 9H4.5a1 1 0 0 1 0-5H6", key: "tex48p" }]
    ];
    const Trophy = createLucideIcon("trophy", __iconNode$6);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$5 = [
      ["path", { d: "M12 3v12", key: "1x0j5s" }],
      ["path", { d: "m17 8-5-5-5 5", key: "7q97r8" }],
      ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }]
    ];
    const Upload = createLucideIcon("upload", __iconNode$5);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$4 = [
      ["path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2", key: "975kel" }],
      ["circle", { cx: "12", cy: "7", r: "4", key: "17ys0d" }]
    ];
    const User = createLucideIcon("user", __iconNode$4);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$3 = [
      [
        "path",
        {
          d: "m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5",
          key: "ftymec"
        }
      ],
      ["rect", { x: "2", y: "6", width: "14", height: "12", rx: "2", key: "158x01" }]
    ];
    const Video = createLucideIcon("video", __iconNode$3);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$2 = [
      [
        "path",
        {
          d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z",
          key: "uqj9uw"
        }
      ],
      ["path", { d: "M16 9a5 5 0 0 1 0 6", key: "1q6k2b" }],
      ["path", { d: "M19.364 18.364a9 9 0 0 0 0-12.728", key: "ijwkga" }]
    ];
    const Volume2 = createLucideIcon("volume-2", __iconNode$2);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$1 = [
      [
        "path",
        {
          d: "m21.64 3.64-1.28-1.28a1.21 1.21 0 0 0-1.72 0L2.36 18.64a1.21 1.21 0 0 0 0 1.72l1.28 1.28a1.2 1.2 0 0 0 1.72 0L21.64 5.36a1.2 1.2 0 0 0 0-1.72",
          key: "ul74o6"
        }
      ],
      ["path", { d: "m14 7 3 3", key: "1r5n42" }],
      ["path", { d: "M5 6v4", key: "ilb8ba" }],
      ["path", { d: "M19 14v4", key: "blhpug" }],
      ["path", { d: "M10 2v2", key: "7u0qdc" }],
      ["path", { d: "M7 8H3", key: "zfb6yr" }],
      ["path", { d: "M21 16h-4", key: "1cnmox" }],
      ["path", { d: "M11 3H9", key: "1obp7u" }]
    ];
    const WandSparkles = createLucideIcon("wand-sparkles", __iconNode$1);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode = [
      [
        "path",
        {
          d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",
          key: "1xq2db"
        }
      ]
    ];
    const Zap = createLucideIcon("zap", __iconNode);
    const logo3d = "data:image/png;base64,/9j/4AAQSkZJRgABAQEBLAEsAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wAARCAQABAADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD+Gd0ELgEbUAZhEowSC4UEsrKwOMAFzkEEufSMHzAgjdSqkbps8RZaM7AShAbJBYZJBGVJGVWzujuYc3EZREz8hOSY9gZ2XAZgRuzhsBdwbkAYI4Ve2byQI4WVnCgHcCkYHzmNtpMmRuViHCYYbVfn6S7to7ppNaPmly8veyWy0fbRaM+DUk/iUoz5lB63il7qurq7uku9tHonrWkSFc9dxYOmAuPLQq5ZSDwmBuPdiEVSAGYWYzHJGZCSUzuIBdQgKAgEBtq7Sw5Y44GNwIAbDdRNBDM0bBXDQhdqSP1WMqSwJfduL4ILLjBLDJL/ACI08u3XAWQMDhkbh0QPjCnflipAGcYIU5yKpWim42s0nZd5Wta3R3a1tu/QJP3lCakrNJN7WTSltstE7edrvW0iAxwQGM+cWKxkxqudpIIKkFkCxoCpVVAycPxtJsLne4kAUhsISwYuoAO8tu27mKsFAADEkYWqCQpCyTRxMnlhhtycuNxlaRAzLtJQs245+XcoADENeWVZUWVCxVs7AcZOApYsArrkAHcBnIOQBuyKXM0ovR32/wC3Yq12k7Wa6vpqc9SMbXj76d/fad0200tHZWWnW+99hwBkOcY25ZeAS+MDOScFmHI4AKsQ2XANHAZQiZBUlh8pIIKg7cNuDEcruYk54BBFQJNiFHmSOBgfnVtoVACqghjuJJXaWUgnJIKgA4mjkhdQ4lRlJIViwKjAUjgjBI3AMmDjGRkYq1ey1WuqV9U1y6tb7aW6a9ERyyTb5W0mota8rsk3Zr1u+vZqyDcGjJYghGJf5TsRAu5gPLVlDrgllJB43YIOBDb3EVzCk8JcpuKpI0YiLEBd/wArgFjjcNwIGAVJA+YRbFZ5XhlEcbKzkqWlVpSpw+3dgKQ6gnDbiAB8m5WmjuYjEqyPGjhSphYIGzGoibAU4SRmbKj5SQfmJIyJvLRX6tW1+JctrN222tyu7tyvvrKC5U1GcpNxd037qavZxtd+vM0rWabaJpnEcTuVL4Y4TY7bm+UhUUKxJYbuAecZDZ4ACsqx7X3gxjKgENuwC6SJGSyOAdpweD8pPADV5I2JQRw+ZJlCQZGjWJiMph12hwSDl1y37xcHaADHIjSIsTXC2YOyYtbuHclWwYIiyqVU8nLOVZgAMDO13aumm4/C9N7NddFdXj11aV721UacWoe9aXM03zXa0W8Vdt6JvRX2eliJctcxwE3TIHmb7SXWKM7GVfJwdgwS5ErEbvmAwAqir+6OIxRM+UYLGjv1MjkDZI+9uuHIO1sjGcDOK8zbSE3MpEiIX3uQ6bjgBNzFgxAUEna65XoV2uU+YrwTxqY96jG1kVo1Iw/VXG1sDOACMq3JzSV1ez1aSV7rZKyk93a2rd/vWms25qLabhFe8ld9V7y/LR2S03erQ0bL5QkJbzsMWUHBVwWdicI0ZGEGQcYAChs1cMiplGIBHzMBlvl+XsrN8xYtgqGBORjGCGLIjoXilDpxHkEAYTbyQV3Ls3BgWAB9m+URyo5jfytnmKhdWkAKHOwEbto5IwcK2Bu4+XbgipJ62srbdktNb7XvZ7JNPda480ZSSd4pSV+a1uZ8qu/Ll6NW8+9bdIlqJJrlHkaRpXcR4YIXVhDhSr9UdWAj4KgltiZp2osradeMqkh7d9pUgqqlRjG0EEEAMqsBtzkHBqWdkgt5JjC8myIIYo15fk5CqdyhRtYl8h1QM+CwOadzOZtKuXZTD5kBHkyAGQbljyzKBkqC2UYlQF42gACk29U3tDu3dKyT5kmr3u/Vu7ex10U3VoTjFOPtorm0ik7xuoxT3t5W7WVmPtFU2VvGHTJtYmDD7yMEyQuAgG7d8in5hjKsNoBWQQzyCB1WZoHExzJKgVvlwvPzGRslgpJBJG3kGi1ExtbURoFjW1hZ3f8AhACABYzkhiMqrAhCzYUBuKlMBTBgco6kCUSLIwdF4YvkkbmRBgqAdq8AEvVKzS0vH3VLsrKLWjsm77c3q7WJqPlq1bytJ1G42aundLVxd9U2klrra2lyH7TGk0SsyrGyqPNZdv77AAiPzK20rGxI2MCQDnOBV5ZV2jD8HYMMSfvEbQDtwpywKhicg5zjpArwyzBVZPMhVRtKFBsJQIGVlJLqX+VQSEc/KFPFWSmNylQSi/Lu5HUbcA7RuIzhRgbeh6ApJrmle6b5tNWtIrXV2knZNaXs9dSW4+7eLUktea/lLazWqdtfwFQcNlc8ZHC5VfkYnqOOrYwCzcghRlkXLMQgO7pvIHzY28YJHUbt20dQANpAIgnuPJCAiR1aRIyIv3hDNj52yMgLt5IbIHHUHFXUNUg0+APIA0pjAhgOFMhDALIx2sVtw23D4DE/Ku5iNo2ktbJr4m+kU0treTtpd638qjTqVJJQhOTnKyas1pyttrWytbe1k9basdqeo2+nwh5GV55EPkwdWdsD96/7suIUZtshypbBjUF8Y53T9Nkv3fVNUBDuzPFBIuxWTaJElKtHgQpgCKLkDIDKyFqdYWdxPcLq+qFJZHdTDalo0mUYXZJ5cq5RVA220eCA+Nx3EluogBjjwjSSb13RiQkFFbC+Q7KxUBPlwoQZJIA2HFZpOpJTkvdTTjvfdPml1d3qtTunKGEpypUbSrSSjVqq6s2lzQhbZK6UnfV367UJhZWpM7xxRi42RMY9rFS7bl8zOFRVTADp9xUBT938hhjUvNcsXieNZpBCyOhZz5aiNG2xhWjRS+GGBKzHk7sCzM8bqInEjI8rwAFSIgFVs+c5U4Zd24yKMouZAyMVFSJFg4jjA2QsEcFigRSRHhSZA7HCq2QiuoPzAhRTSbeluWOqUVb3lbVtaW72Sberd9ubn91J3c52s5e8tHFxaemt7rdp30t0aUn3RutxiJI8PAYQySPlSG3qRICQcAhtqk5xjmoDNIgdpkfckhjxGIyxRYziXlnOHxulBACRlWABCE2YUxEjuzySbBukcEMx2jcoA+4AUUgMqtsI3huaiuZUtY3lZWk3Eb1BTKmZggkCnG0KM+Z0J5PJJNN/Du0t278z0s46O+y2a76XQRl70YWUneMY2SjrpdXVnZpvWV3b5Jkbs0aK6ypKEVjHsU8t5YBbywAI3ycDaUUKACQc0vDsSGDNkMY/MJVXYoSMKqnKhgFO4hD8p6ALRlaCVxE7zLbrbTSqIykT3SuGUKrJtkXCLuAK8kDgdC6xYPYW5hd4wiFtzEvIsoJV0coThQTEix43BVVBwQDEZNtRtpZNX+Jtctr3bVtrJu3lY2lTtFy1T5opxs3aMlzL3m372nRbLVrYTbKDKrL5uD5i5CRh7VA8ZVl818BRyu5A5LfvD8oNNs5LaEGNJPNuAfMkICneAiboy6oI18nJUnGBtUbsA4usH5G5kR0YptjZSC4DGEHAkJO5sgMwkU/KVwpNZIltpZDGXQSs0cZUt5UKybXdmZ2IaJ2JZ/lB5VSM7lYlBxcXum0tXqk+X3Va197PdeTtccZqUWpe7ZRaXRtNdb7bvR8ra3u7p8rCONZC4ZC0W8KIy4R2AcfNt+UFQuRjbIMAAsq1DrH/AB7WzSAruvLLbgjBxIWOcEjduAyRkbQvHJIlinWQ3CmJ1NoUfeEDpIQy5eJmVV8pfmZgCchlcEYJNfVnRre2VGD5vbH5gBsGPmyN20qDuYEqCqv8uWY4qW4+zqNSbVrJLo4pLr0831u9iqCkq1FNcrU076PSXLOL+T7u/ey1NsNkgHoXOCApyMqQMkEHK9DgAgkYDc00kl1wAADxk8sCB8zBtoCn5lzgju3IzUUcgbO5h5qSmMjaVCyAINyggmRMZYueOB0Kkichhhs9MDAyMjCDlmPBIzk5AOCAAxAG3a7vfz1v1/prpf0517suXS99d3po016pea3tbdonLAhCckluQeAN4IbhjjJABwSWycbiawtOH+ioAcKWu+VAJyZXGNidiTkgkcDjC5FbbyJAjzSAiNBuYpHuAACg5yPlAx8xB27crnLYOPYJM1nGu5Qn+kswBLAHznG4FAqgrhQ7qCyglSpJUU77LZO90mr20elnv/wFfQ7KSksPUctHKrRSvf7MZ7LRtpu7vo9+ppWxZbe2UsJGW3hJdeQWEe1jlyWyQTzyOCCBuJqRlLYBI4Csv3eVIBIY9ATyMbSWyeSTio7VQLW0ck4EEI+ffkjYuOMgjc23GBwAckkEVMTtOGycMyhh97GAQVbgjDAEsVU8BiecVKu1H0iuvRLbu7GUk+aTa3lJp6JN99Pv833RX5yQEABXcrllwzHA2hCAwGASS3LKcdScZViAbvUUO5iJlKjAPJ34B3YyGYqAPlGwcfdC1sqrFWGF5ChgVB+XAOcDODjODnLEknIaqCr/AKdqAB2Hda/MABn93nG1csW7/eXkAjJHLsndp3s+/fdWutttnbf11pa068X0pxaetlarT+XW9vwLP3XGc7iQQVO0hMgN8x4IfkHuxJDY5xQslxC+M5Fxd7gQOCLmTPGMEAcZ6gEghQOb4ZTKiKRvAWQqSSRGcBiSVyQzcbehXPQqc0bbPktnaVa4uiSo5A+1yKAdvQnB+UrlQcnKstTf3lvtJKyu3dwTSXZ9Xp06e8lFNUpau7lC3nZSem+tnrpbvsWvlUsVHGRjvjpt+UEHhTjkjDH05owoJI+YcHcNnJCqTkY7DIbnIydpOclwVVJH3unHpnaMZXA3LjJBJUbhyRxTTjC8Ek9gfQA44zzgEAc9eQAeH2/rt6fjrvYSeqSS3d/Nrl19Vbd72bVmyPKgcc/dAyAS33eQBwTyWB5IxnjijAGzIG0lSAME/wAPA2lgcAZYg8Z3A7Rik8xGKsDtLqQqSBVZsMEO4HJGG5yRkg7RuNH3ATyoC/Ny3AABLEg4IwDgdcEZ+Ukh76tq3dvbay/FP0sO77WvbrrvHfvv11dtkOICjcfukAbBgscYPODgnuSTgDnBGAWhRnBGNxDDgHGQAB1AIJOAOSxwBgAmo45UZEdTlGHGB944Q5CBRyvPDAYAJIwRlzuscZLH5BtLHcSQxKgLgBhkg4I9srnmnpZdls0lv7ra9P8AgW8nqnZrqklaz1adut3100ut+ytjJA+9uAJ5JIG3PUBmz1b5QMAq2CDSrtIwAdx2jnB6BQQoODwOG4O0YUA84jCyM2VfLDJZAqlQ+E+6YzkIOmSQQeQGByQRt1eQZwMEKfmB2knJ3jGMj5Qu4HAIOTSu3ZWSSSXyVnrrve76667WQ7bNW0SdrNbW0tbRd/zvukTCQI2WCmRkJ6AsCo3DKqSr7TlwCTxwcZFnIFhZqAcLNqCgn5hkXZOF3dhwCQcPgBcU1Y1iVI0xsVQQo3YUnZnG44LEk4zkFmIGAfmjSVprWGMgqsV1qJDFQDlplb5SSCFIJBwPlYOOoGTZpN6uL1fV80L/AI/8NfQTV1eLvGM1dNbWjJXstdG99Vf7hjfMSFyNuDnIbKggNjJBJ3fxBeuABuyabgHLAN8uOvOCFXIGAdpxwOhByMnK1JlicBQGUhQAMkjgZ+YlhzwOCeADk81G7eWCd6h3AijXcIwZWAUKchRtJJBBfg5GSQKfVdG+r0d7bq7Sva680Ne9p36b66frb8PIjZcE5BA3BeEGSDhW4Y5YlkAKgbjwAowMs8vClQT1ABG4ncR97gYA24LHIOAMAAtQTKShREdUUl8ZVmwoy8bMDj5UVQSSSXIIABJb5YbfJ5sih9jlE8sIrAqCFwPlBYMkigAgYUHaS1Cd3azetr91ZPybVlb17WNUrPV20VrXu7W7dvno3Z6CxlZDujIONysq87GXbkMoxtKD7oZvkICgNg4Gj25G0t8gOflz82ByoOARktgkgljxzmnKUjOwsitIm8Jgx7jhAXcEMgI38A5yAdpDcU12DbBvwWVZRliA6kpgAldrFsEMfusvQjnAneyupK8V/wBvNLS7d7vs3ruu5ST2Wi01dnZadVfbXW2uy1aTjJjZmBbO07UPy7efLywLBckdWONnIy6yEAp5eXDKzAIWyuzO48EAyLh3XDDBJG0kL1yQo37Y3K+W7bcruzHtKx87sOQN23eGIBZVAyVDK4DDCQO5VE2MpDNGx+UozDIBK4X7qjaSpBIyCtE9E/su2y0s1fv1a27dNS63V7uPa+uiW10+ln0V7bK6qARg4JJAU7V3DGxSoXeCGJY8N6YUgYo3AthcY+QMGKjaW2ZLHBZQOgAyyk7c7TuLQwCsrq/l55ZeGUnyiu5VY7AQwyvLZYMnY1G1xHAuSGPf5Fc7gAo+ckbeg5bI3cYAJNPms73Wl/0stddm1rrtYcddFfV9U5btXl36KzeitdW6uREXcFyxZmG07CF4BULyPkJUERnBOcqV2qaceWTbhSdo27hl1bPJY4wS+0nChWU7SSDym9TmNGUkENjK8K21Tg7WX5gwTaCPmxzlRgyI1JJLYO0ckEDqFfeDuGOSV5PfkihKLVtLpp300eja0TStq72VuyL5lbW7b5Xa9nb3Um73atptZp2em4MwXJYEAsVOFwpG5AMsxKhMcF9wIG3GcYaNOd21kbcSxJVWITCsoDxkxg8sqEkfKzMw+faF3FCqlSwlYIxKrleFwSxyNjAYXC7gc4AAOHjy4wAihA524UFVZvl5ZtyoRkZOcrs5HzHaVZxd/NJ2dtW4y03TUmlbrZPS7aLStpumtG7STS5b37tarspNvW1k0xqQFcNgYYBcqSQMByYwwP8AAdpJXAJGHJqG5IEE4UMcxSAc/LtwApXcAWKjglWOUON6sTUrJvj2sQjjq0WRypzhWVmOxdm0qV4LKMgHcEmXFvNgZBikJ3A/LhAdoyTs7ZJwFOWUNvGEndu6totb6vRWTVrJq2l77rSzuaUl+9p6ttSitXfW8W9ba9029ba6tJxxf8e0AH3vKiOSVUFuerHdychiTxgZIGCTJjaBkHnaBkAZztBwOcjkk8kDqDnpHBkw22DuKwQk4wAoIU7cLn5zkEFmwdpA+QlanVQCfnONqsepGfkxwCNu3HIUnKfdGTSjfS61sldbppR93fVNtp7rS2uxU9Kk720b087rtp5O+/TawwgLt9SwXoWJLbSMBSBxzg8MoOASGxS88hdpXg8lWAxsyc8BsgkYGQD06KKVV2jgA8gMDksqnBDgDG0ZHBGcfd4IpGBUASZByMAMQNp2leRktjo7AgncAVORV26bK3uq1v5e2kZddWn311J10136vVfZVvK3Xa+u/VgyVDKo2sc8EY/hyDkbs8kgejc9TS7lzuIYgYU7cNtICk5UEYKqe54JwMjmlIPABPQsoLYVeVBVVUkkEjC8jJHJK52plcDHTg9wu4bCFG7o5PUjJIwBgk0krWSVndvfuktrWbfe0VbRdhrTo97NaK92rqzfre3k2NOAFZlIYHaR8pYAhQDkkcHnJOeD82MYowo+rEDoCATgHIwAQT8wIOccLk5oLY4yxUgj5hk/w5bnewK8YUkMCBnth4HAAxgYJOASr/L948lSQOeCvAx6Ck5XbetlZ9dLq/Nu9X6dLdhpJK/S2+qdvd13bun9/e1hFCk4OBzjeACP4OfUHggNyTkgY4yc5wccfLk4xtGN3AG4gHPUggn5hjFKOgYDGRgg5JX7p8wn5TgdsZOfU9V+VinVyVHfA3DaTlQd3yjBOcnPQsDgT5du+q6Nafj56FW077J6K6fu633drX1un6bgABAAJLDuBkHgAEBs5wBuwQdp+U85E0duJR50pMdrCQskmFJZmCgQwg8tNIA21TwgDM7AAsHRwGUGR28u2RsuxGCzYX91EoXmeQdFHy8M5IQE0yeUzlAgWKGPaIoFywj3A7mbGA8rFctK2XbAAyFVFLXXWy6fNW+S009Fa2wnZ2V2t20rW+Hsr6JapJtLpdMfJceY2yMCKGMbYIgoKxRs2WZiCu6VmO95cHe4DEBVGyoMBmaMBkY4ywG7BUYAwRtIIGHDHhyF++cRyDawGMhiTkcjBx04A2D15y2ejZpuSc5ByfUkDlgBk4BxnpwBnG4hjijmbd3vq3LW68um+jtp1101qN0rJdrv3dG5RWi195eV+id1dMKhQoUltpJLrtGTwCBgYwCCM4x1wcA0FcnnC4BGTjnpnLHBLHsccscHBABFYg/dxkBeQfb5j64IJ5BPAJJ5pxG1gMZb7hAPXGMD5SQ3ABGPmx36kK7Uurur9OiSt0eyt03+a1jpp5xV9LbQve6stNLabW0Y5ULLuG0gYBHGc9CcbTkcbWyOAcAMeKefK8oImQzENISvK4j3hSqkMwJbJyDjBbcMUwEFSpABPz5A7/LtDMccdwOjYAI6Aqh2sMDcXRwEJyCSQTnPQ5Ock5BPGTmntreztZtab2+Wtra+nmaLl1etklpotPdVrJaX0er7dRCFdlCsqsvV2C7CMxgkklsuST/dyMYAAJDJI0ABQknOMFAOGUE5bleWGVA25wRgqA1SIWTBXBIYBTtzg4UEBVzlSANy5JXPXBNOfZtUKrh32yM0iopMirgRoMgqMFR8xYDGFZTTjZwbbT5tdd3dxte2j2tppquuo7KzabulG3p7ut09L2btd9NNCo3UD1z85wM4KjHYcjuBzhgACMh3l5wWx0BAI5wSoPXbznKnAzjIznOVUE9OCOp4I5CjuAegGC358mnDAwpZvm2n1OQRweuATwQMHBOOOKndtPW71T0s7JO9339Vs2yRgC88HcDg5OBwVGSOD/eGTyD1HNMcDCKq/elAkfjMYVQ54OAWPQLnIUsADkATnAY5OQFyx4GSQo2nknnGASWJBwCflFRqoGVAwoHoRjGAcEbs45PTJCg5DDNJq9lpa123o1qla9+qvd3d/JXtSVrJbPW+r5bWa36X83ZcrtsxgAjXJJbHCfKvOcYGNwBD4J9QScEYxSDG0EEgErkHl8nbn5R8y9fkbI+XO1SpqQdCHXKhiUzjIc7cNk4BBI3YwoDDLHJ5du3AfLgFVBBGAwwo3cAhsg5DDGOwG45e60fRK1pc3KnH9UvPt2bVrq7e8b735fdenZ+d+lklfSPHB24AJIG7kkcMT8o4IAOAc87jgjFRYBUKQCoyEACKdrbeSVAGSG5yc5JZcNnM+0qwGWYBPu4YLuYKOVTOAB824szBcEcZACpJ+YgHAK4BAzlSpJGT84GDgEHcMDcDhpX6bWtazurp6J3+7srrWzC1vPTpyrRqNktNNHZ7WunbRp1RklhzvRiWzhcKGX7pGNwJHzAYLY+ZQoNSKF3u6qGLrvLhsgttQsqkAbSxALJuwgIBXaCBKzDG5y2CwUttOG9Mk55P3fuhvu7uFGV2Dqm0eY24hQSrburbcbeflw2BnGF46ylqldSas01e6Wmyberu9rXu9eo0r63Tslo7ra2iWt+a2/uprt0aAVA3BSSuWGBlRgHAGDjaASASSScrx0btyVK4JAzkjnnghQDkZBycjGScZPIfkgAdscgfN8vykgr0Vm6ZBwARjIyAineqnJUr8ozgFRwShC4Ocbhg9Dk/drRRstG0tHrJX6ea9dlstrlrT5eV73srvTe99fNdRu373PHZRjccYwMZJxhumMckDGakj+Y5H3epA+bkBem3JySTzhuGOS2QKZnCqcsMttwODn5c5OOcdSMkqD6tmpGDZAXbjHOVOCPlHBGACQfvdWGSBkYostNNdH08nd210s9d0kh6PRpeen9X2W/b1GgKgG5vlYk5O3hiV4I4AwwO4EthvXgCpcDbPb5+YMtyOMkD/VnO7pzjORwc8AknN/nHA4Bxg85U4yV6YwDjPVeh65qpPkz2wztXy7gkccA+WMYGRnOCcEZ6ggA0pc3Lotb03ppe84ei+HVWs7PR3bY+sXpe6V+qs07rz7b69FZFmCMeZN0yLG4JBIDLh4yDxjk4UjLcDleCArG4G4dOCOFIPTjOQME5HocEA7uRPBGd91tbKjT7okFvu/vo9o4XgHd90MCoHB2hsx4BIHIcHORwOq5wDglWL4JUbWIA4ZQaqzcmvOUrN+cOnZrrqvLqZUX+9ra9YXSd/sx15d1a2ut0+jV2Xoix0vUCVP8ArbAHAzwJWAyWHJyOuQwwRjhmOZJIQrAdGHLYBxyD0X5jyHBG7JGQDjrrQOp0zUl25bdZMX255E4GMuwByFwuSCeQzFgc5TnAOeCScdc7jtXO49zn5Tg/e7VUruMdHdU46NXfxPS2u29rbq99EFO3NWT/AOfl1fu6VP8APW3yT6lidR5Gl5Chv7PjY7ShBzPcAEYXjgYPJxgEnAyKRDjC4DZXJ5VSPufKAGzuOTsweOSM521aY74rL5if9CRMtuIwbifgBQVA3AsecjBLcZxXcjciMGILAZJUDkp8xZiw57kdQQQDtOJSfLB26R0aV2uVLfezV9Oi16uxh1ajGMnZ802uqs6jb1s99bWtpo9hVB2KUwxxg8L6KdgAJOcMSOSCCQNxJpvy7mwOduMHBKksAT8uCOoG7JGDjHFP2BiARj7o789ABhTtHJ/hIyp6kkUhUFCQOBKAAC5AyycbcD5WPTBxhWzgZFNaJaNWV7rpbbZ2e77r5Nt9Nlpe2ummml42T0Wu3bXRWukmnbtYLk4OG5XIyACw+6SM/KCcY6HPaMRruJGMgHd/EdwwR8qtuweBgk4PToWM7YUnjlsBRtUgYAxuBG3OCOQwLbsqM4zGWVGUdcLsyAuAflKK6g/eGckDJGcgHAoaajb0890lZ7Ky13b0stGkGjSel9LrRq11ey7rS+l0vKzImOMs3yFpFwDtTaxwV3ckYIOTuwGwCMNtFABXAwDuBOSMKuNuTk++WXCtjJY5+YmYdGBwVGcDBOFGBnIO3qoYFcYxj7xyzANoC+nGTuIOFXIO4sCQMnI/ug7COaXK73T3VttLJq+jVrau1rJr5ILP0V/wTStre/MrLptpo7tp4PJBAIXgBj0XB+U8MFGcbsAdAetMkDbOqJyvzEKQ3K4BJzuLHaxCrggYHLA1KvHHPIXsCTkp8gAI2nAzltwBbIAXimmMSqR0KvkKpUsjBc8hBnk4zyMjGCAppPdxa9L2SWsEm27pXb0SaWl7pCSTva17p377a63s9lba/fpHnaCVjLguVABwBnkMAqkjndsIGcllO7GBMJCAplUKRtHIUAMCBgkscSZySCDycAZ6MUIXKEszxgDOV+8u3a2WbcNoY7idpPXsMOCCYEBHT5gScKGaRQCfvjgYypwSegbLAUJPRp6N30s73cW79b3s9Wtb6j36rpy2SercbJK72u/6sPLKQQvzAEnIxlfusFYrnoBnbtG4nGAGLBCchNo4+VQTt9UJ2htpJByATwpO3JUg0ix4UuSTIEIUA4BYqpCrkRkPhPmY9QSOpOJIw7HoEOxVdctnAC4Chs5cqTna4CkBVNLW7TfS2qvpdJJb9NdL+q2G3sr72330adn5+T62EhgILkjcCCE2gfKQV2gkEA4IG5cdeSS2MTwhdwVdowdhGWZsgoOdpDFRyAd6kYOck1HI4T5UyBhQSVTYAQrbeQoL/KQCuQCDzuXh8aRzBHBdSF6gheQF+/ksjAnoSCTyGyRmla6aWsWkno97XfN5pqXXbfW9qSvZWvsle7vt31++zeuh20MHkPcbZRK8rbwdjgNHGjqAFdtpZwgfBO0ltgG5VAgs9spkcLJGqBo0LSR7XniEbNIsY27VGVSNWXDHaq5ySskEpkjDDyw0nyR8KPl2jKbNzHJ8ws0ZwVJKhsKAaVxHIrTsX8xT5awRKuwRxRtG7T/I4QMUIzK28soJRiQdsO1o8jvZvR2d1a61s2m32W7XofncE5SnCbSfupOzWySSV9E+jeiSu0n10bdVjdEdlEzlG2Og4YeWUaJNoG1SzEYCsXJORt3VVuZpXJbYAEuI4AyIBKY1bMrDa6nJYghgp3sTGEBBy1lCPJfhzO7xvE5ZwIUb5j+7VnyCAozhlkQjcCVcK0dwGkggIYSmKSEqE3qCSMEF0GQ6AIdzgkEuwOWGB3cXGyTVtFqmrxSd0297uyT19IsuCXtYuUm4tKLclZRfxPTd2Widtns9EbIYlSxJ5QHIX5s7Rzj58bQwDAEkcIDtxupypIG2RRlS21Q6qoBhwu5whkC7jkEcHgnaARgrbxyWsUvmSs++R5GZt5UIAGZVBJcAKrlznDYzzzmCxurS7jlWEt5sbOZRKqh1ClQpAwx8vcFUgfKGGBtwQ13TSTcYSbW8tbXjayf3px2V+1jGCcXUlBe0hBpcyVleT1uui7N32T00JbuFmSNVBWEp80e1trOFZQ5VnYFVKgknLtwWO4ZFRTDECXTaV/c7FUqCcKnAVm2FnxtLYG1SVztIq1Ndm3t0kuUPMkauqbW2gkbXK43hcBsnGSdwTJNRgRyPKpZWVgJv4VMbbEZGDgELsLcgMwUj5Sxwamyd7W5nbVp6XSte6srffe+jSRrT51D301FOV2no2mr6t6vVb6ytZIdHGkUlrgcvE8ILyIQsj4kjU/NwBuygAVhgg4CnFh4Ua4aQx+dIIH3srso8ouxGQqhASWBLpyoDqVBZ3R3Kxo0iCYRlBjbwrEKqSh3cA7R8pZiDyGHAIEyuiqPKMRGBuUgMwG1PmwhO3avymM5EbYGNrKRaino2tGkk15JLV2SejSbd3bWxhKrKNpR5usW7qzTklvq3dPd6O2m7u1lZLc+UGlYRFk+625wASpZgcqCjZK5DAYGOahs/MmiRpmDOG35Py/vAEwCAz48shl3Y2PwRwF3WkMhYiRV2EBlZQu5kBCgSqfugrvbAG4k/Kc8FJoYLgMkiBioZt6yFd2DkBCmM8klwCoO0A8qSK3acW2kkrXaTfurrfRvXRWs+1r5wajeEtG2pOcbS2srKzStrdra9lskiOYCWBmUFwEYBEYZLBWYtvAUEIzKSjEkk4YjgGjaxGWRcKyi3TDtljvBZCsQ3ITuQEiQA8gfNlQMWzDCEnRCqRP0dGZg3ChRsJJTLFd2SJMjj5WJMFi0fmzwqrkLDsfJdYSygJI2SS4fLbc4GFVcEuDmOVSlHm0TWnVaWvra/d3eiSSejNoaU6nLdpaptWaTsrtXadnZaOzs0009bAmbqkIMUhSLzYijRKXEby5VcBiqllwCCCrHOAKSKKUBlfcpSdmEhYuGwRg4AYFNpIYLtUkLtUY5bb+RapFDCzvG8xLMWLsrSBWO4tgRj5ipQr1zKpJJFXJzPsT7N5KvvjLLIAyLCoYkg8KXCgbQTkDnG9mrRKPK3tZRutNNtrW2ej1XV6mbfLNQhyqMpX5521s1rK7ly7pWu+m61KltLdM8/nQRRwhttttfMshXPmeayggDERZRtU4IU54LZ1/bNFY3mZmlj8uQokm8FUkaMfeY4bkEKCCoBPyozDdovF5ZQIj/NvLHIAMrGXymADL5ina20Ej+Fd7PtQxaijvps0zoUkWEPxgBcNFvUr87bnUB2479VyanRxkndtRbTWvSNovS1lst7Wd9jqov9/RlBwUJVKUeWK091xu1pu3q2n713orBbCQWVjLCxciO3MigMY3hKAMCVZV2xhDlQBhixYtwA68nlicQrA86OuEkQxqWkdtjptO9soqu4AIIC4JIUA0bL7TZaass3myN5UflW67nCxusfyEsEZElWN2LguU5BIPB1yzFI1ZikpjQyA7SV+UAKQuT/ABSfNkkbiDyAxL80LJyhJqHnbSKTTel9G7XsrLpe5XjavN2hOCqVNbvdNO7s73jotVyu7VkrspxeVDPbQo+FSKXlgzB/3uCzOjBCRucqrYwwUAFShN5x8oQbvmAbdlgQBsJzjgfKCDjJPBXCnAq7WNztERUKrPFIwQjyw2XRQwWRXba7SLlmAbG0hAQt9fwafEZpgZXZD5NqCQZcOuJGJXKQoxAU43NwihnJFCaSu5NW36K3upWd/LWyWl92jNRlVqQpwi5VHFO2j3kpXetkraO+itfRrWvqF7Dp9sksp3Oy7YINwLXEgwQSCMiFSSJHbOSAuDIyg4llp8krNq+qtiZnDQQEIFiB2tE8qPuCIoICQqCVHLK0h5t2FhPcXJ1LUSk1w6lobWQhVt41/eRsYtreXswwjiXmMkNzIRjTeV32p5jWwyrlwBKLhUlbBVZcEK3DKAhJQNyG2LWNnJqU1e1uSOl38OsndLZ6a23tfc7XOOHh7GjJOo7KvW7Ldwg9GlqlKS3aVtFZSi3Vpd53LLhJFx5hzMCShG0gbvmI2AbWUjacgEQzMwt3kgnihdSpMkgDIuxh5kblwQokwgQbiQchSG5ECxTOtwlyzRRo2yHGFcbfKKTPJuaUoxV2VCeGO0ZXcaVUtp47vTyCEBLSL5jCPcixhDDli7chn2scuVOeB82ju01HRyTUU5NPm0eqXTRXa00Tsc/KoSjOU3NRlGcrRUkleN73eu7VtdbbaoYt5byXMdtbNFK+wpIiIMRmFod0qO5QOwJOwIWxghzsxiVtpZ4hIN8okljRgzO5RlKvs+VQEYYfGQyqCMfOCCxgSNZI4inkgbHjJLHYd7glXUyrK6qWLhirMxA6EVbp547mzuktZJlaOSFlQnfEshSQFCV2oVJJl3htqnOCDuE3lFNyUbtx2TWjaTdrbLX9LK6NEqc5xjScknCV3Jq7n9m99FdpJLUnSWWERxTyieadwivHCI1CFUOWLlY027GG9yAWJB2bCaSeZnhl8sg7Vdd48pyUjZRMZEYqCxVm2gsCSSemWqOK6z5ZmKAXEbxpJCqgRSNIVaCeVyFVslDujTrlkyvymSURKFlOJDhI98MSkxlsyNIG3eUdqkhmOXLMCwDkIy5ly+7dK61+0lJRs73e6beisnfbUahy1E3BczfN7tlFtNaLRbNJeqfRCpIJ0WaKTMLBEJKtypAycuJPKCnCs2WyF3BSpAMe+28xCuNoJVHiXETFnRgpICRpkyZk3B1VdpIPKU/yklLqULJCvkR7WU7zjBOyMBh/rCEbccSZcNkkB0SMF+421TnaWJ3xxhREzAKQFCtwR827JIDcPSi9LOzbtez+bWyTvrZXv5aA3GL3lvdRTsrO1lezXu6+S1Tv0ZFBFEj7/MkYuXEjOGdwwBiMbb0fygI1ypGflDEK3ChnMedq+aZlYRrAqE78KEhlLblXA2tu2glyhDEEsLSShlWVMNn5VBJkLkDcQFwCH5IU8fKVY/L8tUZI5PODM5WBTIxjg4YiMKA9w6PFkuYnLrgOuFaLa1GqVobysk7KzSa3vvdP8Xowg+ebdS17L3btNNLTa9np5pavaxBbgMxlhkPlPJMl5azEucnLyzQeWzGPaiRMUAGCTljG25k1XCW9sWQqi6jamEbEXEa5KcZIBAO4qP3QUqxUMzGp3D/ZlmdFnki2OI02hGjUgysZdyAShZAsrMrAIo3ISRuZrGfslmQ4Ba8tBglcj5GAVlAIVhuOVGBg9SOmaX7uSav7qlZPu1dJLRWs7peez1NqblOvSdnq3Fu937tmk7b6P3W3e2ibSNgrtZj8rFuOCT0PXAGfutjjBBAY/uwRTRtYgAkjHPIBzwBuDAnJAxgEjGDgkLtfyCMdScnJIP6Z5BOA44XONpBzSZbGVcbckAKchmUqXUBQGRVBII3ZQnkYreMbWV+ut2ntb111a10e2+i473Sbu1ZLzd+/p36LbzjfZsfzEBjEbK6svBQL8+5mIBXHCkghcBjnth20CTWVsFdk8v7dKqhncyKJXxG+CqgK671HTd3OQK3yisMMAVdduznOGQKFBwWAweRz83zjJxnHsC4tLZPLQFkuN7tyEVrlgSxc/OGJOzIGOu7eBlOF4ptXWq0dusWr9d7NLqmztoylGg3F2kq8Hq9Pgl33e/8AW2hAqiC3yfmFrAWK7ixPkDJIXcQTkcbmwzEHJyTIeu4AENlsAE44G4Ejpt2jgnhsYOCQFVFjS3jQ/IlpbIAwYk4RNqnZhMfI2GThm6AEkFvPCKuDwQDyNny9RzzyARwHI5IOaNoLV6qN+1rQ206u1ravZ76w3rJ3upN2e+zV0+i2b3vd7NbtG0MpYsOm3kYDErw3RFUn5QehyAqkYBpIVF7qOQNuYAyryMmE88A9cHacAK4z05q4SFYbgSuedse5lLFNrhSAFUbgCScA8rtA5qwbDf6iNpJJtsAANw0Bz8wO1iVBJOMk4xz1pJtNbLReSvJdN/R/ma0n+7xG38Jb+VWnrv0dt/8AgqSLzi8u8RbRKBD5W7eIsqoMpyuSGX+AEbiDtOSwp2QXyMqGGLm4IL5YsRdSqE2swBYjdlipU9MFgSdJcNMNwYncFG0ADAZNrNkgfMSWU7Rk4ULwDVK0wbfbxgT3TFvlDZW6nAHyDJBA55ySc9dzVCTbj580dH3dOz76Peyv21sJS/dyto1KFraW0av21sr9b97k+0EsBgDAPzHd2HC44Yk5B4wf94AVG6cxnzUUMJEKEDMjbAUbcWDpswThSSQMDBqUYJOcgEjBwQf4Qck8nryvHXOM4NQyM0kbPG/lspVo5BGXw6lcHYNu4SAnJKsHBBPAGaso6N3uovpr8L0urNXu1ZvpeyRMdZJO6Tsr2XZem2j2stH3ZDcMYIpJpHJVCCAA8bPznyQWWQ5kYqu0FVUqTkgklwYNCG2GJtgfZIAWjXC/K4VizHBxn2wwxg05VjjjjiLIzsqsWLBtz4X94d+4jlgUTdubaoGCBteUy/Q5IYK33gQSeSW74O1cbQcbcAkAJLbVpWXW/vaOzle9ldX16Xtta7xSS3lGW70TheNtPTXve1tURwkSfv0lyHVEQcj7rKQQq7Sj85Y5JCgc4OSrJuGGBIwMqRwvHBAAHzAtndn5cHgcASBTnK8MSARg5OSHJI4HcZwAScc4OQgB3EZABYNgYAJIQbckDrgA7RtO3jDBSBXt8+V9vsvZNu9l2187qxfW6+7fRctr9Lq7ei19RiqN0hHPzhjjcT90KSeOhBBXqBzkn5cOX5VwCGJXA6kqQFGCVOwbh0ByOhU8lakVSSWPEZOAXbAY4UjglWwoA25wFIHXOKaVwMEnqoXGAcnaduVz25cDO0HoM/MJW1fm3p0Vraa3vdadfTZXTto76X301jda79O/fzI94AJwAo/iOBgZQZYqCcDqQVHAOMAnLYgjWtqwUGN3vz5iAFWUXABQMQgB+XcFHmMu7edvmAGVog2Y2Xd1G3qHU4HJyDz2XsOSAw21ZCpBpVnGrABbjVV8olhhTPEBw5cHpgyKQFUfLzuIlptp3suV976OKs76Waeq16qy6DlHlhZNyc0rPRKPLN3b11vZ23ad1d6PMEituVTuUcE/Moydv3ONxznGVJ2nONw4prNFKXhbEjRhWeNiVKnC7WACBm+9nI4OApJyTVoDJGTtOM8D16ADIHJO0EL8zBRkdTWddykoWjcA7T8zSAIAcY4DbgAmG7kkkckPd/Fvukv8OiV9k9OvS3S2kbJpO6e9/wDwF3equru9rLTTYXDZO5Rjay/d3M5G1VIyQWCjAYjDAgZHrEr7DvkKoqsAsmBgplQrDBYhnO7nABAOcEMKlDLg7CjYVkYBsYICHheu5FJLEtkFVAzu4YHQu0JZGkxvKcNIQcMpbC5BBfcxyQvGMsVNCet3JLZJW1TVvS++umuu73pXdrpX0u1e9vdulfXbdvvf1hQpC28bhG8jBydsgSQtuLKC27ZtVQVVDkpkYOMtilcJlULIJHMZwFLRsQyzMGYl1IHIJUNyCp4q2T8xySDsODwWJIwBgjk4OOPlzgg7hUMnmFH2qWKKyhWGRtUrnOSo3clUKYyS2RnJLtomnJdbJPbSzUUm99El91rl8yejs2+VNvZWt0tdXvZuzatsRLCqtIAzfPuJ3l2wCVCg7W2ZBGPLU7d3KkE4pkyFUVFkEbgxtG7ZJMceDISzgAHChQxI3fKCcqDVlTvZzsZY4wyqX2EttCk/KFHyghsAFstjaXDZWtFhG8uSUvcSbkyxKociNQnmkkADdhWUAyDBYZVTRo9mknbV6Wu1prqnbtt36Oo3ve6bi1JptO12ktbtJJW7X0XVjTHE0kcyYjljClFVipaNWBEbxrJkjkfvFLYEYzjAIV02O5OVZ0DkliETKYERG5lwW2MoKYJC57BJGjEmDIDlEVlcNIjKybthVsA7NxPLj5ioDEEZMVx5ggfylUkHKqUJJQFCxUOyMrLkbdpz1Y7SchcnKm2ktLq2t3yq11pZtW0Xn01LTfuxuraLsls1/esvPTflb1Y5SyiNThpApDscqd4YKzMCSQrYVfmTlgAwBwxmBKgEKcFAuAvJIKg5w2OeCAfmGDjcu7DELP8ANkr8uEDBSZQVWTZypUABmB2uVdgRkZAMdxuEZISSQsUUBGWNmYlBuLPkoIwCrlSCgwQVA301ok1tFapu/Ns9VZvstU1e/W9yOrfR81nZ21bV1s7pJO/RW3eibxgn5WXjcrY6nlWc4AVioU542kEbVPymkUOZGjdCMoGDgKSYwyqFIZiQWLna4ClmypKtim/vGEcvlfIQnmxFv3iYHUuXwV2pwm1sLIDIucbpZAqKZWZjglQMsUJ+XKqo2qVJYuwJDBSGPpRbdttpJNW6r3em+2mqXpdJlpOOjkk9UrN635Lp/K2nVbOyVo8lvmIyysqsjAlnxjc6lihkYMjqCoDAZDK2DTLhv3cwZWyI5AF3KC6IAS5PAYg4YHAAU5IDttM6tuyrAI0a7CQyrGWwAkgIZi+4OQ2DnruwGUmu7KYrghkDqkqMm0HayRrkgAnau7ATB2k8MMfMBLvu46p+mra62T0a6JaF0U/awTtZSV7JWunFJdbpXsnppGzdyK3Aa3tS2Y/kVXQtId4VztOBgYO0NnOdxAztGKshV6MdoyQCQAFYbedoPygnaCBkZO5TkDKw8W8Cg7gIYifk29jlV5BztyBhvUrnIyKoL4y3GWV+TgEhsYK5KBeoGR2U5GSJPZXu0pJ+dkubrfRbJ767uzqV5Tly2Su2mr6Nu2q8mlrfe76DSGO0HY2EJJJOSAUCyMGYbgCCRtIcqvzBsAqY2DcwGWUFSpUAq3IBXO0EYJPO47cgL0qQA4AYEgEBAWfAXAy2Buwf4sHGAwUZ3OaApJKCRQT8wyVy4UrtKgKVUkEkEHBGQDnJD1d9NHqraNrR2a/9t1drO9gtZLRWdrtJ2tp9y9LfIhAwCoIBUhjhwu4rt44C845wBtIymM5ITgEnJ++dq4I2jqWy+WCAgZUjCjaMZ5LjtJwwfBAQYX5VYbeeQuUGCynOUGWBYnFO2leo8zcF3MuCORgHA+ViQCQC+WYFgCMlDTdu+11fyjd69dLaW662uLa3W7T7O3u7a6ba+e2txoTDYWPltu7OeSm0lgeAC4+ZSvQEjkdW4VcseAp3IAVTK5BULjdyeNpA+YDaeSAZVwdyE8Bt2SuAcFQBxxsYMM4IAKgDaQu0UAYbAIBKdzjOATx8zAEHAABHqGUChL7PKktLWte1o+Sa082utlqNNvR3u0npv9lLWy0S010XZMa3zBQFJ5BBA+9tKqQM5IGSSegb7pxxU8FuZsvITHahh5jspGSxUiKIkDNw4JMaEgbQSTtVjTooAy+fMfLtogFlkxl3yABDAu0s1wwywySmEMjHaAS2e5ecxRCNY44MiCMKf3ZVwCWclTJLN8rPIRksoC+WEQK4r4W3ZvbdX2S0Vmt7t3u1sluVFP7ra2ta3Lon1ffXpfpZpczCSRQg8qOIbYYBllj4GQ4JUNOz7TJKR87RgYTCKtbPXggHcw64JzjByScZ5AyeQoPzChtzMXJLMSCx5yCccdznBUDpnADHODSHcG2nqwAOR90ZHILDcfYg5K9MBeZlr9/XeytbbpZK1nZdrb3Z6JrtZKzb0Vr76+cbN3dncRzkAngg4yQWJzx8wyGwD04AJwCM1Ew5JXI+oGSPwBIx2BOeuSf4ZQpyF4+XoScgLxgZ+bPI4PQnA64pihg+49Mg7SGYLnGMA8rjkjOeuSeCShpO94rpZpaN6x6u17WvFLV26oOAAMZBOOeSWwMZII2lf4RnPcZywpWB5yBgdSflAACZJwMHAOeDkdsdA8grtIC54K9AQSFyMDII59efpkB5L4AVmDKMMOzYAA+Zyct245GRjaGFUkmtXt2S20S6r/L0vrtFRi47N2VtPeTSje19X81rdX21gGTngAqQScgE7duQM+hx82ADgggNyHCMlhucAMCS2GAX7mF+UfxHIOQf76gDApwQFVZSRjGQQQSRs6HliOSCxJ2ng9RTGbZhlDAMVB254DYYkMTjCjkg/MDwFORuGno2r3d73eq0ur66pXfTT0B3e91ytNbRt30T6apt7/cPRnjYyIpkLDZhASFJ2ZUKu0BkIDAFugXaWG6nSlkKwuq4VAVZUTJBCsPmB4UlWyv3gQCuN5UEKkJKSxGOAobB2FlBO7lSwJwNwUgDBKkhi0EYzksrAcEM3z5453Ahsk8Ng7eeSOT7KTt72q1SStZ/Nu19X5LQtaJNPRpNNdLuNndvyu/R2TsRnaQM/XPJyCV+8w9eepHUHhhtpPlCk5ACg7txyAAQMjAycdf7wAyeCcu2sQA4G5SCWH8K5QDnLEqSQcgYJB3A80pAB3EKVb5TnJALKBgqCMgbsjJIOPlJANTbTyesfJK29tbdbdU+2gRT0tdN67b25dWtLu2lmnfZLe0WUJ4IJAyPnU4DFQCBhjzuGQuQVPB9RS+YwwBVg7O+5cwqhXlkIQ5YZPzEdWKkAYDzGCwzGrGMgozAN22xspUgvtYqUzuHDAnLAVCz4kQENh8lWx8qFnC7WZvu8DHyjjOOeFpWUE0+6V9tnGzs99PN6Ju6sLe1m1ftbR6Nu1tLarptrsSZK5zgMAxXG0lsbQQSNwAJBBbhWHA2sAKaFG2Nw2WIbeCGw52BgzYYAiIjCgqGBwT0JqUFscsMjacYLMFbAOMZBQl9wBXgEDgAU3aN+d2XKqHU7vlI2nKqNoAIwOh+Y4PyEk2o3SV29tJXvurXSer2s9n5dRbq973W1720/rTf0XvMwV8xSGGQWzjIAVowCPmIDYB3DsBu6YBPkDEKcgkgfNkAnbxnOAcbQwPyjqSecKACxyMYypAJIckpkEgbdzZYcAjJyBnoqqzZzHsXBULwSoCoBnPIXd1XYTkDIIzUpWa21XS7T0i1bS2qfLe11uraMpfjZd97rtZbNXu07re9mMXBChlVXJwYyVbK5jJbjl9+MkEDjOCR8wkIBGA+AB8p3bRnjAH93H8a7vTJ60zacr825SuGjKEAOcYCMMAB9nzcknLAk7sCQAAsFDYBJx83U4O0bMBSMD5kzwcnuKaum115b+dkk29NE+vTrZaFrSy7tbvW+l/lrd66J69xhIjwSMbVXcP9ncDuIcgAgnqeccnuaTIx8wwr4xg4+9t29OqYxkg8nuFJAdtCnGQw+T7xDDog68/kAAeg+YE00puBVTzncOMhUyDjLZyOwwCAMggADNa6a66WWyvaN+q7W23jZLs1t21V7vRfDokkr6dFu2NyQOSu1c7hgZJypxjJPIGSC2QSFGc5pyqTyCScZH8WM44HUgeh79OoK0qrt5AJyAXAZiASRnrg55HXB5+XP3aTDFRsABIGFIOOAMkgAYOegVhnB7fdav5J667dY2TW2ielr77JldL9NOumv+dun+Q7ngHBZTySpx8uzqMrnGPvHpjJy3AqzjFxbBQeY58ZI55jzkHjAPQE9cbiKtIM4Bxx8obAJ425HBJYZBwxJyMcs2Kq3D4ngwTuEdwCAucH90TnBwACMHJ4OM5AKmW2oqWnxQ92zt8UE9el0k/TVJLY2dt9V072ut11uujvdeRpWpIa6HJ/4l91n7x6ywnPbIwN2e2dzYCmoCMNk845wPlJGF7DJbaM5PC9S38JFm3GwXmCNv8AZs5wBn/lvDkHGTlS3Ukgk5AKsRULFowflJDEIR1IztOD0GQQxJDBhnjKACr1u+y1131ktrPW1u6du+iMKN/a1rr7VPTovchtpaz21fl0ZchJ/szUgxVTusdh4HJuSCNzbidy7CSUwygAlCBnJfzEGH2s5HzOAAvUfKUKlssAXxj5wSQpJw2pHtSw1BGUuHForEABeLhiG+RgrLwSqOf4i0Q5YLkyjAYKzFQSHDFic7iAMKQEJzjgFVBAXKnapNNxi/7istk9dNLb72a6Xv5ummpV/wDr7dea9nSWm/Xbl6a23LbpiDTwFKsbFGBKjL7rm6IcOMBifvLlcvjDEqOYAoLEKcRhQeqFiQVJXOGwFAUsx4XIAbaz4syPm3047kYjTkGEC7k/0i424JDjOdoLDEa8nGSGaupJPynIYAn5TyCw3LwFAIGAMEtkhkwCVBFNJWs0lGztbpFxbadr66tJ3kl1V1eHv7JXTvzStra9p6eS6W267N6t2qcZYDcpY8gt5g2joCFHcMOSAcx9gGPMiOFJALkbB853ghPu5J5yMAFdvqcipAAxIwQpYAgnAKYwpDDGBg4DEcdCc81GIo0YuqlpF2hSSzhceWTsVlDKQOCckgcEHjJLmvHltZ6yb7Jq3bV6W11V1a5svst2vpfXXZNdU3rfv0vdjgCI0U99u4DJBI2bhg/eABJJIGMEcKTUbHG4EHBI2jocAxkZ2gkbRjcQcD75YglalQHLMNzFVw4OQqqMMSBgErggBuVUDBJBxTNgyeSeARwQo+6PunCYQ53EAgj7rAZxXxJq3Vc3lZqzS9dU1fT5p0lt5JfLbTW76X1V/NdYwOpYZyoUY2qCSq4JySCMnLEbeDuJKNkL5Y6jpt3Mp5BYEHDhSMbiQV5LAsMEA4p6Ksfy4JL4Zscgj5SinoqgkKUAJ25JGVAAiYkbn5BRkYYwQyYjD/xDcD90MMHI5J3ZpN2tzbWvZauySs9UvS1lukrNCXbpZellbW+jvo7P0a0WimN1w0fzEImFLccFSylSVKkKB0/vZ6YNOZeV5bZwrADadw28MAcYAUgjaTySMgkUze2GCFhhhuVsSNjcAQc5IBYADnAwysRnlxaRl3YAAxkY4A4DZJDEMuMnJwpPJYZ3J9W1tZXb1tdJXjzJtrdXtsr9bNWbv3e33ar0aSafy7OZYwzONyqxQgAg4OdpBKuMyEM5PruwSSyqVQoHQrjGCoyEA3FMDBzxkHhcKCy78kEAiAxyO/mkn5QNudxZUBBV0BI+Y9M5PU5AyMPBfY4b5isgTPCsy5ALHncMgFi2FP8AC+FwxUVf7OiWjk9dOXR3tZt6W11fqgSS8r7XbX8q1vZJrW+ju3a9tSTCuzYB+aPB+Y4Ksy5KFlJPUDswwAAetNKPHgR5dWYb1bLbM4BdCSBkkfKMYBJBJxkuZZHwI5FiY7AzBQw2kg4XgsJB1DBvmyMc5IYyABIjukd2A3EkADdGPMkyWGM8HBB+YErkZI1q7LaKtLVLXlslq762aWqbvK62HZvz1Xa+jj0vt3VtXqloSllaSOFcFnVXBAX5F3A7skfeY527SQWBUDceZ0X5kUliNy4wMMCduGBO3I6ADORzk7uRXZAxM+QZljCpgbgdoD/LtbaobBUMSF2d8nKXLXcwiaRVEgZSQmAgGUAUcs2/oW5A4IPIwZimuZNavVPdJJJXbbdnrol9nbyE/eTXwr1u9nfyX3216anTQR2oDRCArNIV8yJGK/Kq4R18suWVBIGIPCsrMFOBRIHi2w28a+blvLjY5JjGN0zl4yuBwoJIXBCE4By2Zpo2ULGLs+QRFOZEUqWVmMbxsZFK/K4AQAsCACMbxFYCRZDJcSb7hwoOSoAjIUKkaYSTEZBDlVXdtZQpGGrJNcyhy8rlZyfLbkSaTV3eLb2vte1rRufntm4e2bcraxTfM5NW36xStrfXVLsTbIEmCvGSdyyREynylZcq+9t0mN78hCAGyqkAsQUhkH2iVYYWjRULl5QTGTKFdY41fywhLAunUsPuY5DTveRxTrbOxU3LFgQg24JXO/cqrGSpAQl8bmDMRlQKNrBOHnBuXkgMsiwI0bMynMRTzGJBCLtBEYYo/XbhHLGzShFWbtJ2SeiSSffrqknfzCKc4Nz91umnBScmpaxV4qKdnunsrJq7ZauXmCxRwxEmTy4zHjzGbc43lQMAKAhMhHIJC85Khv8AZ7xyNLHMitIInndVKE7dyyiIRcMjbULBkOCoYjsbaW5DLczN584i+U7FUR4YlvLQBdrMPlduc8nrsIdNv8uNVIUSKfNwRkABD5aEcqXCnaS/XcCSopqnfWWnWMb7ba9Eube+6Tdm1qZxqOCVOHKk7c7SXLJu2iT2UVt1vdrozMupjEoVWAZpY1RHYEiRiCrs53oFB8xjkccEk8irkccduqRD5XZBje5PmM4UEBeSxZiBjCqyouRuDExNAjKykBokJVSpkBXJJ3MyllDR7w7ccHPJOMw2bJNICA7pEj7JiwCSSHYS6O4VyURggXByVBbb96hX5rStd6RS31a5rNbptW5tNk3bY2klKmrXUY+9NaatqFle3u6rRR11bSRdgN0kywMzSxHzHa4AZHijVwEUhywwADtG0YDYjYspqYJHC7lIyHZi5ZRxIxIGCxcg7iw+Ujy8ckHDYrNNFEwuBvJcqrMNpKhm3EfMwKIm1iCwYuoC5xndbdYrmIbQJEZSVKHhmC8tlBjBEhDAMSTxk4BNJ9OZXWqT1S/W/onrvdb8803yys1Bpc3JrrdO8lqr3s2lprd3Ika4M4eGWGSz2r5kQj/eRttDOFmXAZgVDFSVUK7ZXndV0MuBltqsgcIAqlUG1SFABwSRkqTxkAk7sDMjlSC8m+bKSJFOq7STNI3yNJErvyqv2CgkZ2sRtIsMJJ0R1Z4mYRyJycBEYknaqhmOcMC3TADR9TThLe13Lmdr3fLZxta97dkujbskFSHM4p8qjypc1knLSD1S+0np3dn0uKAwOUG4yOW8tizYUtGQSAMDKsQGAJUsFAIG417B1El0WHP2mQrIseFypQFCWIBbGNqghCBkksBm0gj80qzgtsBZT8pOfLA3M3AI4LbCoIICk5Kkhki5SJNu1mYsAAjyEKGVCybmd2IXYQB1HykAl21jqrJvS65umiX2XZtvW602e4pJQlFRk01G3MlZXcd9nvbS179kSwoIlcthCHd3U7SdqkMXJ2sxUEZVSu0dCcElUhdpo3d0aJQ5CFsAyLhGWQkhWRZBuxwNzcEjBAqrK10vmKjxKH2vHMNruoUl+E2s6ksQWyApIyGI31M7CAIJGd4V2Idg/wBVK5VQuC+CpC5UL3BIPOGabj5LRNapNJJq6VtdbNJaatIiab+K3tW46PXl2vaztqtd3orJX1J5HiLQBipkyvkoRvkBXZyAY+Sudw3FRjngj5qGpyo2n3+MlxAWlRWI2liOW8sEE+hH3QpZhtBqeZ5muYWQqYljmeV8AjJ+VYwyoGA3DIIbG4MegGMvUYr1be/lZ1eCVGAURBGhRjCm5xvAkwoyhJkbCkB1ySycmk7RtZWut3pF3bvonbT1aV1qdODo/v6DclFqcHa7WqqRdl0u007u10utzVs28y0tpAgA+zRqA6gtlVCBCAXIcMQQGw3PXcRUF9DkRzI6xSW+W2NuETRscyQlXZYyWYptJByCwBHzBl0uO3NraXMUTwP9liUY3hZeCXfYJCJN4BZWBUbRsI+UFrMgSV3jKuIyWQgsB5hACqwL5bAJZl3fKcBWJwM6KF4XlvZWSW7SVm9NVe19LLTbQmr+7xVVLZVJpp20XNFST1s+ZN21u2YMuorZLJNMiSPKvmQqpKhzncYXyGQRR4ZpGVhgsAjMWAZLGxmupv7V1L5pSwaCGSIhUXAKNNGThNigiGEcRqd5LOzERW9j9ouzeXU6zyW8EE6xCIlN8jz+VkkYEUUa4xwPNYM25VQDp1FxG2DiRWVmT5cEgE/K3z7F+UhUC54I8vIZlrCEeZ/vHeKaaWmq91K7V++tuy7WO2s44eHsqTSqzgnUqW1ScU+SHVaO7vZ3sl5VLmEN5A8xot8pIA8wmUNHI2zAdQu3ccbSEG3O4LzUMUuECzuokR3timCA52jDGTMiK03JIPJDA4yocrP5wa1ZImY+YTIwY4tUYo7TRAFIwuEZG/1m7Lg5VMSRXXnL5SQorq24lpWQRwunzBpRGrMeYpQoDDYjsykBcCn1a1tZNWvfSC01T20XZu+nXkgnywg2tU7SvFcrT12enNrdW7LZD5ElQM0f750Ykxu7iN0Zt+5ZVZVDIvmKvloCoyWUYpFlkjaJCysZU/fHdGGhCiNWcJsVnGcRh9jAj7uRgF8QmMK/afKEwIaVYwuwsDsVO7b3x+8+Vwz5+Zt3A9vEXWfaUmjDAS7nZ1I3t5bHKjYzABsHKpxgqWpNNJON0tHro4rR6qzs2tOj06DTi24ys/iXNFN8zslHVtXS3vo0++qcX2qOcZR13gsI4pAqiSVIzIVaMxopBDfIzOgbG5ioIFZq3Ee9EVp/tF7beWbcBRBBIreWG+STcqFsiN8s5KAvlCIxqoWaFTMmyRtqup2YUAIqqxJZm3J8xJyxwVZnVVIVuIxJ80hCRqFUY81FZXIGEVQFwo3g7jjcxLcVPLJtNu1tdI9JW395tdV3V720V9KbhG8VFtu8b860aatd6XV+VtrVPS9iqto26AvLIwhjCCPLLGZklDrcSEBA7ELuAKbiPlzwALP2dU3CFREcu4OW2mRzjqTnDAjA5BCqQQ/NLHIxzvQBsB3YMrjC4UgOXwWABYHGCDyNykAWWMlhGwZsYAAXcd+DhcqGDgsQwXITkrk8DRQUUnFNO6fvc3N9lX1T0vey308mS51HpKzS/laUXd+V07Xvf7lYjCgyNMcgqrQhQxCom8MABhDvYFmxuLowHzEACoLlZnWVIsiWIqYZgRGkgDKWVirjL4ifBJCZVgcnBFrzUJ8thno/yBcK+FK+YCAQcvuc/exyoJBNTDbnBPzhCR0KkkE4yOSTkNsxtbAHYkJR6RbTabdnZapdPuT21tra96UmpRbV1GyimtElbpfr933JlIjEkcRJ3yDLEHYsMaMhcIChj4dV8slizlichlFTM7qrqqSD51jLN5SohPyCT59xIRRlsZxkY3HFPYliroQACPOyAzPHksUJJQjJCsoIzgEgbTipGy6vkuAysq4YgnOCASoLKT1YA/dyeCeC3xWaVtU7eS1d336bNvRWuw505J2Wq1s9nok76dLPtfXqUwPLLNEN0jSNK0YZmMzRh9xUOyopdSAoIyrHhTyRQ1NmuLKzby5I831qBGxKzZyylioAJAJJVjtJQA4Gc1tRpg5By7hWZwzMXIH8DbSwUKQG9z95RgHP1jesFu2cbtQs+DnB+/t5JGSO3IyoA4HBmSvF9FZ6JJRu2tfJdGm+1jahO9ane/Mpr3r20sk7u2vlez3TehdhV0jAkl86Tc5d9ioSC+4Kqg5BQqgLFWdic5BOakQqPmVRGMMx2qEBJOd/BUFiSBllwSChycZMKJOAcHAOCdpYspA5wvC42qGwpwVBHDPfb8pK4CELhgOQu0DknJOTjOMNwCN5BrVKyirW21TbbXuWvu+i6p9NbK+Dbbd+u9rJdXsk7pem2zGKqgLjnJ6ncRj5QSQNowMdBxzwSKybQA2kPzg4F1gIeAonkwfkU5ByckDHbG7JXXbDKcZKkNlVzyGUglcnIUEjjHyDPHXbk6ehOnwBCHkCT7VZg4Z/MmJRidoBXAIJ4wOD0NJ6qzu+W/Mr7LS633b96SsvW9zrp2WGm72l7eirv+Vxq26q+uib0+40yyvHEzIUJigIB++qmFVUEvycHkgqCBtweCQ1sAArlegXgHH3TzjOezMvJJwUyrcoNyx25cFG+zWysnA2MYVY7lVmJYYODuJUnA3fMacoGducNksATkAcbQcYAOCR8oKnnaUU4I0mo3Tvo9N7Wjf1tez3T+SZgtJPX7TSttuuunbTrpp1TYqbS6xqfnJZyCWJPGBkEALkcL8q5wR05pxMovtR+6OLbA2sScQEYBAHQMMYHHJbaFOLrxqyMmWVZEK4RirgHABXgFTlsgkkjOV5zilCmy+v1CsQy24DEAkI0KIQ28suCqgEgA/KDyvAcL6q6Satd6q+nRLf7+u9mzppWdOvdybdKLdtlarR2fW9tNE1q+a92XFZRIjrgBXKbmGCpGMgg4bgKMksSv8ADnkjNtmCQjc4KNcXgBOQgJvpVByMqhO4bVO7cGJGQCtaTr5S/KMuCgCgqMk8ncCCDkDBJI5IYEKeM2zTzrW3ZtwKT3M2xflDE3cw2uAQSo+/gSE7hxjIFQ9GlveKfROz9m9XtZX06X6bCgk4ScnZc8b2XZSt0Xq9d9ehNNElxE0cgfBK8phWXB+SQMOOW2n5jzhSVAORGEikMbBmka3bylkLvuLIpDmTbyZCWzyxY4LH5fuzmQQo0s7fIpUq6qxbYpVfnwX/AHhOGYFSSow4+XIRANpkiBVZiJmIZmIMgILA7SM4KnYFznk4FVa7V17ySVnZS3VlZt9bu7T6pCvaN9rO6eusrJSu2l079UyDy44z5C/Ksfl3DBpSGC+YUL7mHzZBQAZIUJnAAqwqjLtjBYs4yzkBWCEAZX5lxk4zhch8gGmpaRBmkWNXkZj875kYoefLR2wFjzhgBgZ4DAFg1jdnKqTgLzkFuCeADgYX0J4ABByM0lGWmlrb2vJpKyV1Z79Fa7s9tLKTWyu9ldrro7aNq109732W5C2AQMNhgAwDnhiV5OOSccqGweMDK8FSCQF4GQpB4GfuY2kMxJIAJ4wwOBtPJGQ4LMQVLbhgEDAwMZOFTAHzEAqM4UgbgTcFUscgYBbJyT90/KAGUsB24IAycDiiN0ko2vpbo1bld9EtXFdXZrfzaurW3drtW7q6fXt1Sf33aeSQu4fMoOSRkhlClF5dgGG3awO0cAEkYikaONkHzAzExqCWYMx2/MV+RVX5SQTwuMYIqWQO8bKHK7kyvlldyuAuwblKnB2hXAYsxyF75jjRikasWYjaXLD5vMGAWf5mAA+YHbjBBIOTwJa2tvbzSd4206NarW+9raplRStfRarTW92o6/prrrro9Zg2MAcj+LPOSNoIJIHB7YwCMngA5kaKGLTbUopEst5qbSh2yysGVDwgCiMKVKqwGHYtwrEmFCTgHYFHIzlpBgIWMmSr8HJwVBVQCW4LVJFj7BAAHLG81FiPnOB5qqVRsBSCAzBducfMeAVDdrxVrtXTu+zgvs2bXTvvaxNmuVxbVpq6tbm92SVtE7rZN9ddCsysoO3cRvJyS3BJwFJ5HAydv3RgEEA4LFcyBWUbPm+ZtoPHy5dQTlcHgli5I65JUmQN5jSRBGWOEgtKwVFkZmT91CGG8jqGLBcEMqsXUoW+WN5GCSFKgFiSSAMPgrkqQOh3ZHA6AmY6272Wva7j+K7/AHPvuko+bT0fq07er3aT20VtSB2WHczALuOBGkZzIm5WbarFh/FuDtgBeuOcxF4C8Qk2CaQDYQyF2VyrqI2jJ+c71JDkglRyyhcWlKuu/wC4w3LiQKGwVAYnGMK3JLhvmHBAUCohEodl8oZZ2kEu1QWdgApDMd28jjOVXcvAVl4fr2VvXRrbrbbeztcqLjbW7a0suu1rNJpJbPW8rrQjG1SEw2/eSo6ZRSoUo2WDKuMsCFRmXcqhwTTiCX2ADLEOSSGBGAGAJPAbJCkAkjKk55DyG3b2KmMRM2zy/mDBiSzO3Lq2ACuCxwxxg5NW4uViiLRlZdskalFIwFfbvBIjZkC8bm+6mQoyXQqJ2Svsn22Ss2t2mt3a3yV2VGPNZJXTSvpdJt216LXolZd9S0xYtjnG3LnJO7AHQ4YjaGJOOVIyd3LVmrOkheMSnZvJLgqUw3lkLvk2sWJPzbGZGXIDKM06GCeR5JZbh/LkQskIDbNrbQqEBYwroFWQsrNvc7ARsJaaWHyxEsKYzIkZUIT5cbYdlCBwmSVUoNpLlVwpAyRu/dR2u78zS5dtVa+7fr2aLgowlGF221GN02or4el23bR22a1vpckOTh28wEYkGVdiqLlSrqHG4bVU5D7nOOGYBqaVUAu+HKscZKqXiYFQzKQx+RAQxCg4O7bkEiOJ1QEo7ygS/Zwzo+JG+XJZnbaEQg4wcoxYIWQZa0Mbjt+VQgzkZ6FQGZVAAznAYZ6HscFwtrpe2qd7faTtrotE+l7eSBppO9t9Fa/8r6uyVtU7NvRbXK2FiVYwojVGAVTv2hM5dnOMhWYoWBXaRxggkkO1SHZlLOmxSG2qN23lgAFVSpUNuOTgFWyStT4YZMYyWAPJLqMldwYEAE9RjcDhWALAYFYylGjV438uQhfNBjIEuExGUIGEKguvHBwAud2S606RXKnZ6Xbj11S0ej387aCWqvbWz1uv7snZ/K+mr22uiM4ieNESRy0hWR1y6ooKgStvwpO4FQ3zZQtjG3m4BySB94kA4LDsv3gCAH3NxkEbs5JAJrYk3l127GDvt2gMCSqt5UgK+YWZV3IAVAO0BsYpwjZ5onJlRVV38sOAs7kqwEm0IB8mDgE5BXBVtwUTaTja+qVrJJaxSfMte71XRK0kaNx0S10vKzes2o2dk1rqkrJb6t2dpy6tyuQFVgc/MSc5IAKgsAT98ccZAG7IrzKoglDIxMiSE4Q7m+VSd7bgpQDrnC4Iwc9Z8lMgEv8AP5a53rtEhAQZLDkDeqspGCu0khjlrRsyMi5G5Nw3D7uI2DKPlIAOcGLkODuG05JcbN7qyV7dmlHve2j0d76dNi6CUatPqnKL0bd3o36Waavftpy2IoCv2eAdf3EQGFZAo4GTjcCMbfL7ggZyuRSlMZCk4Uk7W2qQowNu7JJQHBGz5QVywUEgJAu+CAoOltHyTuRgAQVKFlGGLdSojYgLw2CJAuz7oBZwSXEhKq/lqWYrkLvdc4jD8grgkEClBcrV9Uktd9Wo9vVu10+l09VU0ueajZ++1Zp2tpe7tbRO9m7v4U9UwBCnLKw4CkZIJyqclV2nKjJAbltqHOCMMwSCeHALA4IQsnyYBOwsoA6bT8u7AG1Vw87SVCMHO4IygsNoZVbaV5O7aPnZMhSQQTkZQfOwK7xtVSTlQCFYcKQfugHHzKwO0dwMuMde6vFbNxvpq7JXvdpa7qzs93Z77Wto9bO6sl12t0TsktW9WLGo645I2dCVwR8pyAAwGQVJIAO4EDJpQMqFAGWIVlIBOQY/uDcAfvEKDyG3Yx3cql/MwCTliu4dAWXAOcDJOOcDOCCQwxS8EK2Cdp2HBKE5C8k7SWPAAbgHPOc5Ak09V2Vv/AUrtd91vZ6pdQfW77JPv8O7d1qtr3XVpdWryAAAdiMAyjOfLK4OA3IQjJwM7hjqFNWY4l2+fPmO3jVVeTAy0mQUhhGCTM4GMniOPmThXzJbW3mF52OIIAZZ2HOyNdhwCAcMxyFBIXdyWwQRVNw9wQ7LHHboTHb25+ZoEKocyDgec/BklIBAACERoqqK+jlrf0391ttqzeumtm3tuxR1dk1o9W7eTUXtbV+V1q+gkszNt2kLGgUR2uA0UMRAZslGAeVtoLSMu7thUAVYTtbClOFATJKqOCODhsbQw4GAScFT0FKwQ4C8D5cEZIBXBOAOMcsWwcDgAYJCm0SZ3E7eCeM7gdpA6ZODjgYHc7TV21jbSSsm9W9GtVtZWbXKrPSyvubWVtEklr5p6K9t3f162va4wgYAVTncGaTjlflGQd2dxfOMZGBjn5syhQWYqQx2EsrAAgAAllLt1znkZAIJCkYqIK3RnywIOQoUfwjGT1I6DOFYYAxllLxneu35SGwcsEyBtXOQM5BIUcj5SPYVKi01dJLfd7Kzeza2s9W9nqkkXDslpFq7u+vKlpez6bq+7T6kTKMewHJI4U+h9sdcZyemTnLFIA5XduOQOeOAB3+8DyAMY685NTeWwByxIUHGBgcbRktjLKCThgpwcBuVqMEHkr8oxnjlTx0GQOoyF5JBJBJGDMeju42u39nVWsu/XdrysLld0rdV837t1pzLqt91o10G9flAbk464GAAMkgkBsZPB9AowDTgS2F27RtAyScNt2nGTkgnkcDrweSMOwOmcDcvYEgHaSQeAxAOePYcHgqYyrMBk5wynaRvBCBXxjcF453bSecDOMQk0m7Xva+u2zjZtpaWS7WS72NFdNPmvblunZ30hZvVt6aX2fk9xS2wIAg+YNuA5GAvyk5QkZxgAZODtCtUJwTgfd25ypB7rhTkDA6ZBySOnqXbeGDtkgZJyc/wg5DZ7cnrnuMAmlweu3tgnbk4XHYHOcemCAScGnq7ea/K2jt2676LtYtWd00mrpP+7s1Z3eq3trfdaW5XxkqrFdm4qwVz6YAIXe3DNt4OMYOGB4wmRjD7ypyw2jkOWU8k7VKg43A5x2wOqx7gdoyrHGD0JO5RgHk5OcFQpBxyAeaYSQARyBtDYVhycnJB53Y4cZ5IUHG3jR6RjJ6baXWu1m1dbrbv8gurKL2ulbo/5nZWbfm4/Dp00E3EkcjcMHk84Kg5CcFPu8jsBgFWxTeBkbe2OpIBJx0GRhTz64x04Jd8pwN/GA7EnBUBlwCMH5juwVUkr8xDbSWMcjFVJXazsVESZBDsSOxwAFGTyynAIGTgmG0nFtO3K9bp6JxvZWfpr3tboVKSsnZXS10bvflt1vs9PO6V9AdVYFGO3quR82MAbSCWU4yo3YwuTjILMaai4bBARhjbnBcRDYdxkJfdgkEsxDZxuLFd4nQbnAAIOB1A2kqVHXJ6kHjOW5AAOCEVQgk2LtYnkgnLZVV5OV4BGAqqc8gng5Vk9Ulbo77rTdrbW7eqtf0J1ai42tvfd/Z0s7OzvdW0Ts3frGBEhDBFQsxUsq4ypw2Wbcoxjh8HPTOQNpXaSxcgjYoXABCsMqcnaBn5SQNpPAyQQCC8RhUCR8kMpCsN4UEruKbmBVmJUgcFTnCt1DF4Zl5b5mPdWAPlntlRgEHCgkbgw2n5aaurK1rtaaq+i2fldvbTbVqyd7aNW6rdPVrtbbrp5KztY2sAuSudyhQcEkEDaN78ErtPU4IJwSTijHXB5CncuCOSRzwNoPzMVPJHfkYMSSxzyPGA5aMtlyF2DBCnaxG4nO4qCFZ2BKkEVKSQvyn0UkFiVHyqXZiTlhyAw2++Kad7tPS7St5NX5bavW+9lu3ZMcXrvtay6JK2iV7u9umv3pJpyBjG3BVVLBVUdMEgA8jJyQW5JJBBALF3KSufNQuRuUYKoCowxzsJXjKrxggqCKkBjI3A5G0pgbhuB2lSEAXdkEYOeGOMkcETLSMXYMWVcLtC7doU5VM5DHkMzKRwSCVJNHVNK6dtrWvp/hWui6+l9CtJWkraNXvs17rWzSvdpNb2WmqVgbCSMbwFJXBBVVG0huAcrgk44PGV5puMlVKsOAQxAPmE7CFyzHA6AHvwOo4Uu24KMYbrnOBnG4H7ozwQAN3UEZDbSsbKFI54JByRkZKnIOGwDkA4BXOMHg5vTbS9l0S1srrzbXRadL2sWrJ7232+VtL7qy69nbYjUK4KltuCRh2BzgjAVm+YAHj7uV4HdTSjIclSPLC9TyzMMA7QcYUY4OCec7j8wDwB0xn5fwKgKF5KcgZJB54ByQcGmqTIqMNykknk/O3CZUkpkIzMSCxLMpyCOKm+qS/zt8O3+F27u+t7fEr2buk+yvZvZ/L8dGh+3AIwFGAw+VQSW24XcD948Dg4PYg8VUnDfaIeBuMNwSpycANGSQTgE4xySCejDANWXbzDhht2MduSVJYbQwYtjgnOBj5uj5IBFadVNzbcsg2XBZgSeAUJIblt3UE4Jx1G4DJO9uj96Gl0nZyj5bX7Madmpb6q33ro9H6ef36dpGzi+xKoaPTZnbJbBBuIsBQMA5zkoxCgDngHEOcEEYYnG7qSpLITkZ+XaOVXl1YBQSNxNm0LKb/Bwr6ZcKeHYDM8LLg5yFGPkbJAzgVUCvkjOYypCjBwpOwrkjYdoyAByM7lJyStVHezurNp6rRXT0u72tpsr9E2Y0ta+IT7ws7N3fs4u11522bvtrexciDCxvBszn7MxJUZA8/kth8EZI2FQdhyxARjnJnAcHlgQrDdwGBDA4IABAyAWXODxgMqgVrKyJY33Dkv9lBbDlATcAK+MBANmRncGX5QFZSwrMkZVV1JDBQfMXKg4wDgBQxJ2kk7RtGc5AfIc7cq1SfL0Vr2aXTRJ66PS9l6aw+Kr199XXR+5T6rqtdtNHuiZlCQaaDuUPYRYYlmG1rm5O0DAO0AkYGcN83IGRA+WJO3JVsMOXZlUIclTggttwWUYySwAxV+bP2XSSCFP9nBcMhOAb27A+8OQcgBBncAQqhsmqG9SVOWwMREFhtDYX7yk7iMZBUneCBwwGBMLpQVvijGz0TTtTtunrba11G/e9nQlzUU92pzXp+86dnbe+381xSTuZlwAFO0DIyqgHLblOVIAwc8rjeeA1NVnVVDSIzMQrMQAGz5Y2HnIdcYAxk5PJyaeRnbuH3cR5IBZ8EZB3EsVwCBgEv0Pz4poi3Byw29XHzN8o25DKeCFLYGzBydpJD4q93pd7LVvutPPe19PVdNVpa6fR2sk90kr913bWj2etnYUgAhlCn5e4O0rkfKATuGCI8DGPmwcsG9Rkg4yFByxB3KoUHG4ZPLEHBBXG7GAFAILN/E+FYZkUAnCnJOS2AE3MWDq2DlgSCY+98q46FmHygEqygIDsycKThSCCSCG+SjvZK+3ftb7+vlsO3bbSyTs0vdXTTz02T87pNh2hByOD3ZcsoVt2DxyeQAwB5XAwagICDcMDaVJLFnyAqg5ynGWxzgq4PG5goNggHIZfvDp8zbshSSMc4BJIBbjgj+7QpUEDduICryDnaVGD8xLYAA2OOoAB5waTjdqzTStpbZ6a+Sb92yte100x6XWj0SXfto7fJ63tvchJJJBRsKCFOBkqCoDs3Q4O3JALYIz+8AVl2jIYMdx2ll6qW+TKNhlUluCmzcRlgoPBMykEAk7mIIAGN2ABkFtuTkAsAQDnGcqAajjUmMFuVJGxSFDqoVQEOPLxkAjC855Uk8UWekbt31Wtv5dXrbvbRaOzejbLXVlo2tOnTbZ27dbfiOLRNKgdQzRAOu3aoJLDjHys7cEfTK5JHAWHnEjJPlhsHeVbkZUZ438ABeSF5yCOVkR3VRvZAqocYZnO1xtyyqrYYHb8pzuPJLEAxwEsjmaMphwgzgFsBQCxYsxy2MgZDE5OGG1pVnJxaeunMlZ7J2Wut24pNtNO9gfyTe27vor7a7dHbVOyurChX3uhG2P5QOVMj5KgbWBwFyHHA3AnhhkYmXywQpG5sBSckkj5dwfbxxwTncMfdGM0oAY7MOAEIOPkjYABQUfG5ickjkLuBPVeFSNkGxMsNmTv3EkqQSN+7aWKqApJGOcDnkjB3eqaT0bv5bX0WsbPba+quNK6XdWb1/wu2jd9Wl3te9tx6RgIFz3B3E5GSR90ZxwM4UDBGHzngqjSxsrMSQrKBtALgHaP4sKxJx0+ZmwGxjJjeLeEcDDx4dSDnleSpAZQS3ACgYwMEYzTliSVkL+YrIw2sG2lRu3ZA3gsQMAE8grhskg03KThKyvr0aTaSWuiVrK+nl0aYa6W30t03t6dOuvfU3pWYpbJvKwiYGUMRuOciIk4jYJuUljuXIJ4ztRppbeOeN2csHV90E0TSZUFmAMbZIMbSHoZCNyllbAAStPOmyRSXZAFj+VDuKSLIB5rk7NiqQXKkAZGDt2inwT28G1mTbE6sY4yDcGLCplZAXd1BI+UFMrlT8wzu4W4pyUn7slaV9vspbX0001V3rfdr4NxkopxVpJ2Vmk27pt3Td29nfTl3XRaEcUNvCsIK4KKwLvHuYbVDOzvuBX5FYqp2LxjBwVfCyvI8shAJYKoJ+UIxDLJldqBmLKAEyDldwVjzFCIZYYZkjbEqsoBBWUo2FaPEYG1Tv3hmwGDhvnQjMgsrZ0VipQoCo+eTch3ht7EHG5CQQpw4xkDaONo393ltbSy1Td0mtem99k9raO65JOLvz86m5uMm43lum1o9tVtur9N7hZlMQdHIkUjziAyx7VVyGBAKs6rlSANzEfIQpaqQkuXbKeWpRzGikbz8jRqzMF+Ts2/IDgkj/AFbEtJaSPORukRpIy4CxyNlAGjijaU8szMqsdzc5fDEMKsspRyyAkFgGJ3Yw21uFJBHQKAVLqTkgrxVP3lF6pN30a2uk9Vs93y3ur3SsZx5acuVqLmlpJ8yu9Ndmk7aa6bO+5AbeIJIJEdjKvzZYFpCY/uKAwAXIDDB4IQHByRSgQW4jtw0YWIu8e2NuAJCFR+d4faoLuQTtXDnIzWnOWXYqOFZwFDMACAHUFsFDhzkgKvLYIBUg7c2RnZoolf5VOZY2tyEfa6KUQqN+QVV5ssADld24qGbTg1tuo+S5ktH7yat1TW3Rq5rSnKcJJ25Za2bdk47O6t2ta2ie2mkiyJcs6F2hLAgx7NobcCpwBncBvc+XkMigjKkqxSGAmMxuyx+XOq4Vn+ZEXaAFRj5ZcrjILZZwAAByGPypJ5ZSmwgGNkChijYR96AMwlZ0UZ2jbzuJAGZEMMwjlSQ7QGZCoYlXX5yHGMkJvG8gkg7VA2cUrXerTd9nZu10k7N36dLeaRTnGMbRb5fdd7Xjze62r/Fu3ey1+8syW0Muxy5ieNgYZVL7o8Zz1IDbS+Sh24OAoIwRM+6GEGOJrgjYrom1S3C5clh821VIYKNoB2tgZxk3cLSOmTKoeQjyxuRTlQVlYmUDcBtYKSc7dihgWrYtzmFArFiqqCSWypKoNxcE7mKNllBOSQSAM1pBXbXuqzupN6PSLfKrX5vNp7WsrMwnG0KcnLnSlzKFmmldaJp333s9r2W5WeJUKIoLZnJUcDI3Luw0ZPyghMJyoPGW6CZY0jRiJWIkdiQScI8hXdsXcGVCRhiSzAAEHlWL5kBkifLKwRvnw24szBlKEkKp3Nt+8S4G1SQcACBsEhl/dBcFmABcAZ+516IRwUAGecYTiknqr3803dR3WiSWlr7tOysmS5+5FczV09nu1JWXV2Se2ml9hjuMHyh58irErW6yAsBuRWd22qF8sMASSpKnPOMiGRo08uCSXDTZjiQAZkcBSWRVVlBjDODtJOFG1gcAWAEQhtvlmTlmKjLMSoYszMGO7IZUYD/Vj5j1priItG5WMvGzFPM5kTdkEx527N2cAdSRtIBOQK15J2V7W06cy1u7W0d7vS6XzalBNL3rK7vde0eit3tFSSuuqvq3e0axtsdncySYAwAw3FQCiKMplGwQy4BIADEtvYw3qLJplx1U/ZXIjyN6EBSQwUOWyQSpzuAJwSQc3lI3N8oA5AyPUqdufmbJ3AYwMHoSM5p6iTFp96xJJkt3IVgxwCFyMAjAQngfwll2gqSAaWk0+VWavvr7t76WV115dLq62NsM74ijzK7dam7W92zcFZJedpaWs9XqixZskWn2uWUKLSEswUDAJAJUHbvwMrgDdgMSRggPDIcEfdIJ+UjBX5W3A8jBOcDjryMgGksEBtLI8hfs0OTgJlDHyCSGOM/KxAw3UnlTUlxh5WKjCghQFUgZUhVJAKgZALAbVILZ69NLqMYq+skrcq1t7u93a+lkr6XvrYitd4qro7e1qSburWUvPbW6td69Gc1ptwTMLfymcy21oFZkLKqIbhXR5DIm0MFPlAglnXuxOdouIoy75WPje6oN0ZdlCJ8x2FV+8cEtnlVYE1hWMKTF/MjVw1haqGJdFSJzeb2Jj3ZkAIcZC8gLwOa2Vj8uLygzlQjbjJtkyQWRfnJYBNhCxoQeEVRgqM4RbS5m1smtO3Lutu7buk9r6tLvxqp+3vtLlpxl0i7Qhre972tFXXe+91AzgMxikSTMytKpXzFtkKlZFJBBjMZcGMoiKC5y4BNSW8q3Sh4pPMiyYgoLr5rrtI3KxWUbQxVn38sxOBGNqxzW0cm2XBDMzCQYdmljm5kSYgqS5CgmQrvESpySHqUo0CBYUUMvljYFITyl+RmO1gDwse9+A2AcjnbUbt+8otaybu3e8U7rVWW9lrte2hzTcOWKjJuTa3sla6umla6a1T00XfVxMzXBR0kMFxGVBjmVGAXc3Lg4+SVgFWQEsEyoXkmmqJwUMrQMrMPNVFZQHG3AVnKqQF3S43MwLFMlQop0kC3H2iK5VXjGBCgwHjURnljGWZZAzkqGOMkKAy4KpOhiiAjRzEgVWJJHyAMpbJJwygbXfaSSRlcjhRjq5Pb1V73indN221u7bq5ScbKMdG904xs9FtP4pPXSLXlrdWdmOUeW5WZVOFJAAZyyFCuAASABhd2MjI6YqQl1BYsojDKhHzKRuK8ljkDAOw4ycAA5JC1WjZJEAV1lQs0AYOcfIeQAACWVvmwOedq72b5ZvLRdq7Qp4VQS4QqCoQEg/Mdqg7trbjx8rBcUne60a0as9FtbRJ3dvd31u7WuTazXxJp7Wi/e03TaUezdtLfe2RnAYrG0jx7PJAC5kMhBBJPA+VWOMZYHOVLHESRMyKzksyES7FLLgldzoThjyUJGDtTBTszU4FZFLL8pU+VyN7buGMnyncEVlDArg8cBSMhyHC5LFiAIslipOFXdgZY/KQcs3zbcFiQQSct311tFaaa8vW7s3o+llaOm5pzyik7KMlK+9nZJPXe8OmiS1tva6AorIVIwzqhCbiBvbePkJb5QeSwJwPmHA2iw6kbcBAoVt7HqRxgRMoC87MfMeccADrCz7dhJJTCg8kbcuGAGARnLBkIOSRkHJVg4SCTG0FSDuYY+YAAEtgDegZMkHaCejActRZ692laytdNxt2/LW7uyXq0/J6PZpWSTtd2tpu1tfbWQMQx4wu4qCQM7wBtxuY4XOM57kEZxSo6sNw4O4INpG8Y2cbhwCOOegHJHIwqyxsvmK3+sXYpKAkYAYuUGGBBGFwORhgdvV+07VVSp3KrEAAKeARg8jJwN2AOc4xzgsn21SXzfLru23rzOy7rW4ua710d7NLRXurpeS21+5rRtRVVjy5Uk5y2B1AO1VOF+VTknkEnAKnFZWsr/AKPbBSctqFsAf7oIlyp2BlBwQSATyNx44rW3DO4MuMbGxjsMZHAGMAAE7hhgcYPOTqoEsdmVfg6paqEDYyWWTGQgKoQOSD8wPQgMwEyv7Npbba2ercW3f4tbb69ErvU3wztXpuT0Vru7s7RVnqmt7prS+r2L9tJG6FI5Ucw7YpfmLujKqhlcED5i2SGKjJGDjjMvBIUFTkgkgY5G1QMHnI6HA9iMkGnbVBYxois7AuVTBZsn5nC7VY8YO7JUDAATmmhNuQykDLZUEAcMuSNueMcKW6AjcSuCNErK7eseXuv5Xezv2Xa+2rIlJN3V0m7pO17217K1726WewJt3g8Ag4yThc4AHLZPJ4yQ3QhlLLg5On4W0i2jaALhsgltxM83GABgDLbvQYOc4zsBSACpAGRnK7iPwAznHIUk+pPBNZOnsGtFZicg3PlkoABiaUKFBODncxQhduFJIBG6jVPo2420u9+Wyd9b6pJO72sla5vT1oTS6VaT3ur8sla/n0VvzLzh2EDSAAm3tiy/MwLtCh6/e3fdA3DKnII65ABwABjpwcEHgHGFIzjnnhev3TipZDIWhY5ZjDa52AkHdbxAYICq2QNu7jp8wDECmqFBJ7lSQgYjoFPAwMYPAPc4I+XctF3ZfE3bvs7J9FpLRd23u9VbJtJvVWUk7rezcUtbtq3lZ30V7WTPlwdpJYgnbkgDO3oRlcYBK4IODwQGNVogF1C/2Hlvsgx8pwfKYYyMAnqM5IU+inizkYXOcD7wAOeCvQA8Ak4UbiAGyAULCqSSF9QvvLIcAWjPhVyFVGViwViOdwIcbstv424AErcytZ+63tJPVO1ku17/AHbO500F+7xFna1OKvzbL2tLVtN9Fa60dm0y+oJZADnJxgqWCn5TtdVAHAAx827PI+Xis2yUG3K5ChJLkls7Q+LmUgAbmZf+A43qMDHzEaCsrOkfJ3HcMMgV9pC7fMBOHLbhkcYAPGFFULQJDZl2dVSOa7BLFioU3cqgjgrubJC4XhmIwcms7e8uVtWTvqtG3C13a7s9VZ2SaZMNYO3Rwte3XrovX5aW0u7LBYkaQt8q/MwHzlUXJKhDu3EAnCkZB+YE/LmrbtIYkaQeWxBJRlCsY+Csn3nI3qBucgFRlSqkFROkkcqmRJQ6/eDKQRu25CgEfKxUnKqCcEdQwFSlck9VG3jAbBwAOAW5YHkYyuASAWyFpJNpt8y0btq3zOO8mlFvXbpaSvdoG1Zxs+a+re6do39L63btsu6vBudpDGY32osf74kAMG2kquQMOuHdupwr5UY20ya5dFyiCXYwVwGVCiEDdIGdSSVAOSPlBPID53TooDOEyDJulIJJCsyBWBLEKAT0UjjqP3nFRzWyzhAWdAg3fKTkNsYRuwygGCx3bs/KQwAO3DknJa3baTiuiTa12toraqzdru+7cXBNX269baJ7b633VtlbTds02xF3yiBS0YjdVV3O4piMFV+VjhicEqQCAVX5qI5FbGEdN0ZkIddpVdwIZdxO9WA3DJLAZ3AKpxJ5cjJGGZvMTBLouQJAWAIR8sXY4BcgnrkDkKbWyzKQE5BzvHycncrEnaeiB+gUjcpUVKutejdtPPl63itPtWStdJdLCcbaN3Tv8m1a60ve2t2rOy8iOQsEIDIjkoqPNlkA+VtxUKQxRFL/ACn5cZH8QCLErlQzZKxjDAKm9go2hiuOCVJygCupI+/84kZo40WUHerARoFyWld2UKqrtxliDgsAAASSQSwVDIAN8YQlQQoKsUJ2BUkYcAgjGFHA+UHk07pu6ur8tlqmn7t9LWt1elrWs9NHdqKa2vu7XbfLtd3sku9vNvVKgQkFQv3vmwrEEgpgjc2QA3CnB2HIxkg1KWjhsbYyGONZLvUliDbAXdrmNNufujd0GVC5GQcghUVclQyjDbDuGFG5sKFZj6Dk4GGODnHR3lk6ZZhpQGjv9SlRQqseJyEEhkXkFXbYFcFwCrLglhVmm2l00UlHrydW735r63v1WiQm1eLbveor9XrBu63/ADdtGlZMgdMnb1wVYcnZwSV4P3j8/YAOwAYAAZr7cysRKpCL5f2dSoiSQeWwZgCrMWZWUAHhsjkfK1gvGW2Bs8nlTyuQpwXYfK53AjknADJ84IpmFOWOAVbduK4DOoxznq3JBwuMDZkMBSSV0tNd076PRtXXRWdk76rq9tU7bp6pL11Sf32euney6N2FkzIhjYBCyFgdvAIJI3FvlVhkg4/iUiqx3l9jJsQEEyMylmb90WiVH2lVAJLgncvBG4lgtpz8quAWTKjauRhTtw2GJBYknCnBUNk5BzUOFDEhWOUcyAN8pYsCHBjxgkFFRjGSRkkkMApJLRW2tdtapadbavS/XZ9NBwk76pPSzs3f7Ot+mi0WqV29Ekxp3NnagVv4Hba0bExjmNSSSSRhc5RlLfMCDVR7aJTCQTE0J3BI2Cq4/drslHmYf50yrZAAURdTubSRSBsyDxlQpbIHy5BGAF44AYKrYBVgNxqOQFcZODlBlhyMlSHbgsCpbkk5ycEEDBOW6V+vKnG3drSyaV7pdUrKzvuXGTTTi7aJapPZpa66+SaSeltd60KhkVvuuG5Xc2UcFywZVeQ7TkgLuGc7eVAJR7fJcPKrxkERp5bLIpxGA5dSHwGHJG5ix2o2NyCwuUGNmVILk7VHzEoSx2kKxOSwXAIZiQyjio3iSY7m3IYwyRusoUqMZVlAKrt9CSASQDyAWpLSKeiWi0sndxum1t2bTd79Cot33tF6N6u+sd7atadHtpdMbsVGMSyFsIzEdHj+WMAb2wmCCCFYls/PnJ5j2lVG3LqitlyodnXK4BYlwHC7V3MuwkqSuAtTRw+VCqRKflGSXLEsFGxmdhhnBZVA+XpgHoKhlSE+WsrquWRlJYw8MyBTtxubczoMHcGClScpgS3ZK8lppZt21StdvRK11o7Wul2b5rtWd1otk3dcq0S09fkn1ICrqgjkE10A0efKVhIQ2AN6swGyEoQz+WOGGcEDMgBaSAllVVBldS6iQ5VUh5C5wpYbgScMGALAA0u9HVH8udSZ1jddyxyCMlS0oZiHZD3yRtiJRgWIFSTYCl8PIyYEYU4VGVsZAGI9oUnIWQbBlmJY5MpuWnRWlZ3V7Wb33fure73vqrt7NXXvSbVo2Vr722jHRXW3Nfo9SvCImLrtdZfMLSJISjOHKHMe0sxiZmDDJOOQTtBw9AkUaq7K7MQm9uGldguF3MzFXUfKCRjjjJ6TIWcOHVkIcwjB3lgm3EisnzNySwUsv3gQW4poMj7lYnar/KfmGCg+WRgF3qxypOCQ3HAGDQou11ZqK7JLVxVrabJLXRb3W6LTb6J2s3azvpurtNp6K701V9LczZkDL5cmQNh+7xlUI6NtUDLBtxY7XAIAD7sQjCtKF3EBZE6kKAEUoq4DF22D5HXqgO9iQHFlT95sBcFcKQxcruUowfBJ+8FBZfn+VCuSDVRl85Z3RgpjSSIphVZHEYVSY9jFUIRyHYq5bCDagG+ktb6313Vls+W2zf3WSextQ5vawSsrSi3s42fLsr363216JNOTLcGW1tWIxtjjLAhRv2BhtYMwIV+F3KRknDBXAAsxhSNo24VQSSQQu1YiGUOSyA4ypdSxII6/M0UMKtb22wKdkcUhVlGDjezblIRuuArZO7A3ZbaVmCDnJO/c3l5ZsgZHJYguSo54TaFGSBzlpqPLazbil2tpFOystHqle2qb33dRpym7u0pPVcqerW6tbdttXbutHdsYQqxr8xTcyq2RISSgXO4AA8gklzyQMYyaDGCATnOFZSGBDqNp4IBIDHH3OW2gkBiMSGMHbkDom3IZQMbc4wzHywHLENjPADYANEiZAUkqnl5UBWJLKV+UngqjbQWZTtww7induLb7JO973aitb90m3ZrRX6WJva19dOuummzet9133a2ZBh2LAqhQqOwLlvlQIzcHejDftAGRkEfLkPcD5VPYLjJORg5RSHbJY/KAdpzyflYHAYw5BYMJRIHjId/lyMKQoJ4JYZUsSzZySFOHEqiHeCQX52oBjcARndgAAD5hkHK5PXNJJrXtZpvV3stbveN0+nTS7H5aX7aa7Le+/X7+7NO0JbStZzExKR2YZst5eGvERg6sQHBwrFgMkuS23vjORub5T911K4cYIO7AUF1Ug8ow4Qdc/MB0Nsjp4f1rIDbrjT9zYySPtCBgdg3ABgQG3YKk5yOmF8kgyqgMMxYKjcCChb5VIYhWOFfDOgA6sdxpbxb25dOyb6qKS0T+LdfcrRh2nKtvpUtZJWd4Um3fu227u+y7EIGwAlg2SARySSMAKOAAvop5X5hnHU3EkkkqSQCOhxkcAA4wAACwx1yeeKc4beQ3J256rgDC5JAypIckNtzwDzwRTSCBljg8YwM7jhTkZz0PVlKnnncMYHF93FXeur0ai9NLu2t9buW73Om9kne1radUrK783ZO/W/XXQcZjUblJwCCD83AXGW5YgAZK5JOQwDZpjHAKnkZyevQYBJJ4OeDnvgEkYDUZVwTnK52l1ORuwOAODnnJyQF6elOAxyFzu6kg54GM9umQMDoecYFS7uXut6JON9X9nW/yvdX2t5ju3a3VR819l633V7Pqr35dbDwS3BbJ+WMguc+WcE9zkcDIYHoONq8RYOTx3OMbckbiVOdvf/dODkElqciszAIrHJwACVzuAAGcAcDBGAdwBAzuwVIOSpXncQQchsAYOfl3D5jzzgHgn5eCysrq7827r7/5uyUrtJPXQtXtHmV9Ya3svspPb7KVla+qd9dRmRgZGTkFzxtIGBxnJGDwcAlsgAcBqMltoLZKghQcsfm2g4OduNwBGcnnsRzLtBO0DkkK3HyAk9SOuQOPvYHzD7oFRlCuUODgDJBQjnHAbs3JAwAhwQOeaTTu9NNEktL7a9tE2vTp0D3ktLLmsk9nZWdtVLu/RXdu7PRQrEnjrnJ4B4yDjJHzZx2BNCDLBFUndgLkAZyVP8R24H3Rzgg/ICCKeo4POcYHGeR8pyQcfQnjAz1PzUpRlRmDpEcAhiAzbsKSBtXILYAQg5G7d8vG5xjrd30t2eiUdV0t0vvtqutLba1ktFs/h21aS8uiu7qzGqi5G5gUXAJUKCFJAY7mAUqu3uTzjrgCo4wm0uG3BJmji3Mu5l+XbvHmOBgpkEgB1LEHOFEj4PJBPO0qQPmQZB3swfJZiDzliCQQxXFKzMA6gACQZcYIEkgUrxziJgrbvlxgEgkliaGrtaOyT67t8rs7vW3+droae3S0rat6Nq6uldbbfPyTjQ4cqN2cEg+mQvGCuCSc7AR0BA+6VKttZfnOBleRuQE/KAflHLZb7px25OBSKhLNgjA3MSCw67W9CcYwHOcHHBBwTH/q9zSKMKQEKjJkViNzDcx5Gxm3EZIHPQqRXSs1JXWj1Vlpvte1n28tGDlaKSt0T1T/AJb/AAtRfL0el1pZttt6tvLYBDKpbcQMFTg/KGCsd5yAx67drBWAFKQo+QctgOOWaQqNpJ2lC43ZUDoMgc5Kmkw7A8BpFCsh3bkcAZKn51+c7CFbhckM3JALYVKIC0hkDcF2ilLBnVV8sszMQqMAcEkrneDtNS1JyjFLT+a3XTa176Le9uzatYv5pq13p1sn8klfe++66yAhtojweMFQBw2AR8m0kdVycfIcquCAwh2xhXONpDGU5JKkhUbapzjaSG3qMgAKeNrVPgbgFONoCuyqwLKrABfkODksrI2QWz17gzs+UZwSWxwFQkDKkDdgjOSFI3quVUfdBbm0dlbW/b4XbXVJXWl7FXbabWuiSTXl89l5N9dVYjO5tgDGOPG8KNu9zlSoYjHyMFPBc8YJAba1RylthYKzquwEjC4TILMFc4JXbgk/Llhn5smnEBWUCN3A4JLrgOIxIqlXIRnYErhWwVJABJ2GRN+1maIQseVUsrE7kyWXC52YP3QN5BGMFSpI6rTql59r7+7t9zas9dHFpaXu0knvbRxfu6LTdW9bbOzSRwo3HDHGDu25Kk9DjHbBOR94dDSOoUhtmWByjBivOVx93dwxAPBwTljgYw7eEkRGXJfIBXJjLFgGUszMVkLBygABIGMEjNKwyQASuMMG+YhQuPlOMKNwJ3DBTORkHFUttWrq146Jp+7bdvvpq20/QtS6J6ta9tlftfzXe+9kMIUjHC7UO4ZU5K7WwQMlWIP3sHg4AUYxH95Qm4lCAQVGeRtCsWwrY7sqncwy5IBUifiQ4AIUqQR8xznZgnkHaeQckErnkAU3aAMsqgcIh3Al2dYzkhhhck54PI4bDL8zs+l1s9raXh+l1r0dlfpTei87W/Nrtr697XZGnzplgT8wwxJQnYAMsQTIQW4ZQVyNrDLDloUNkK2QjEoTuGVVY8KxdgXDDAXjBPOAWxVhyEQIo4YqhHIA2+XhhgcL1YEnIOOqqKTaQFUEtsCqGLMoIO0j5cAdCSpGAclicnKpct0la636t9uvldLX5WQK/XdOz0as9Hpf5fmIqsGbcCxOXGASdr7CF3N1IbpkYBbbjcDVWckXVr8p4S4/h43ZTuCANvXOPlGS+Qcm6Q6Eq371mOAwADD5QXznPyLtJcEE5OR1JqrcErcWoUBjtmDkhSSgeHeww4IwowMkk9DxnCnblTavaUNNG780dL66vbe2o9mnvZry6rz69vLrsalusZW+MnDDT52jdSF2sJoskjcrSAg45xkljw3Sl8mVVmKtkSICwJYHYQR8zEsxBx0QnnIkziZZhm4iwxL6fP8AdxwokgJLggKGOGIYkqrABm5K00xIGOdmfLYbchSm4q4jXao5OVwpOGwGJAxWmjb16u7SV09LX0s7fKzvptbKkr1qzd9ZR5dLrWMV0XR6W2vpbqWoWLafqSsgDA2RZmVeAlyEOd5BZtzgo4VRuJDgDIGbIiDcAqqSGzhRkgnLBwGGQWAO05IIAHygEakL7LC9Kr5gkFmhJyUDC55LoWCjuCS6lGycsC1ZVxuEbbIy/PzA7cAE7iSBjcoCFQVbOGUNnspxTir6+72V932W3fum7+VxdpVlbVVEru1n+7papbLs13u+97t3EEtNKDKVY6ahUbgAT9qu+eC+S5+bHA4B+Uhi1F1OFVT97a20MhyQVHQooywGQc8KWUEnBF6YsbfSjtJH9mxDj5AMXl2FIxu4JBXJOBkngBQa+whyN5LEl1yzdyNoH3RgDB2quGLbkPelBq0X/g1StdWjbRLpd3du900rtYa6pa789SV9mr1G+21nfZ3ab3RXZGb5VUBmKqflIXIC8BeHUggAnPy7geTkiNS+3b90o6/KRhgcrkBgGIzwRk8ZIPzEtVjGHP3w4RCRtACn5RkHBHAXhdwchs8ZJprfMwy+AY8j5D94YCggAEsqgMzcbeSpG/jS1uivrbdu91vfr/dV7aXXRdKSstEtNV31Sejbd+yXV6q405BZWILNgPgEISNoxtBUfLj7rfPuPAx1PlGAWBYbV27CCD8pUFuoPIIzkqud23PCqPlVgGGTgEktgNty23DZHoo2tkjBzilK5IUEqwG9nGASQVGCTyWcrgkccFTg5os1f+VNb38t436+S63t0R89NrO/Xlt2+d776u2giqAAu8bncYIUNwMZQAHbgfKMYG5gGHzE4aYkZAojJKAPliQwZQOCQcFSQgRTgArtHBOFVlbBwQQRjBBPmZXgFgCVyOvcjawDDbSpweclsjkHG7heckHI3DJBOcdWwTS3V/w0621fl87avbq1ey1SS7a30XzS/PuQGQqcqoAZwpDkkkArwqbi20FQpYuSvQ5xVtFLRqc4JAYBsALjB2kDcMqMnac4BUgkkkxvGQV5CIwAyq8sdwBwoz7ZOFIzkErjbIB0ABGABg4IOdp4AGDgjIBGM/MSxIwraq22i20Wivo/Nvro7dLMGtNdNle9mr273vf1V9NyJ/mEe1yoQltpyS+0gbRkoMZ+YqzHeAflLAEQmORpxKZCuGwIwHUeXhRnbvAwSNpyWkAxuYjgTBWUBnLSOZFJIU/dONpySpwCAG3A5baScggv8xfMKjO9UypG0hlGOckHcxJIbrwD8xcDMWi7N6SvFp8y+LTS92teVPRvT7wvdrRq9vSyS3s7aW2va66J3BZAkohIThQ0Zwg2rkcMSWJbgZ45LbMk4JFKlmI+Zc+Z94bkOQABu4PA6qm0kkfeyKdF5cqiRQcucOHTDkfKSCAoYZPPXcQARwoURPuUDKFiH+QqpUsBtGMjnO4gggYJ5YAlmD1stE9mraNpctnKyS+6Lb0ttpV9Oj0tfey0s7LXrvrpppYmjKsX3lPMVjuA6xqApw33SNx2jcUHIw3IBa0nlF48gBt3HIHPy5J3DIwpAZsfNjB/hJoQwtzMzBpJGUv8zsdpCDyyhPy52/MGByeCGJNaYiBZC3ABUKRhcqMHkgcMO+DkYOcYAKjflu1q7tLe9kt++j1130vZWairbRvtpJ23afpbs2na9m77alqC6LCRGzW7bl3IrMW2qWV/nZyjORgtxuJDKhADOe3ScbZEaORJAAFZkZTHu3bFAYEMJHUKC5VmYEkGs2WS5F6zx4gVckLJykqmY4XY6M4UKT5cJYEBQxBYAO+6knhX7TbsJIVMaTnGQQ5DGRFdiw+cMu9VADldhYjB41UiouPLzdHo3dJpJ2um+W/W1t+x8G6VTmTU4xcrNavSTSVl5tXtps0nrZLeQQCXfHuEQgMICKEgEiu5GV/vKEO0gkj5cYGAGlQ5DM2wlc7TkBCSrKVVCNw4yp+Ygt02n5aU01zAqYhL22I3kZMKydxhDmJ1HlscgAOxBG0kmpzMQyyMrL+6XCEgD5tuNpUH95gq2AckHkAAhd1Zp7XSVk7pbJJrVrdaLVdrnL7OceWW+iSd7uys7Su9G3vpe1++i2NsIY5ZnZZp53Z5n5IYnaUQKTtBTuo53E4OCuGPPdyXDQwJtlD4HEefLzF+8aRid5IwFRSpK8EkMpp6NcoqtHD5gASTyRI6EZKK5BbggrkrgfKWw2QrA2Hkdo8qAJphgI7xgibYrEEBG3BAPm5wQAMq54FDljazgopOXL8TV47OyTk5NJ6vW7dmwcpc/PKMKjm7JuSduVL7PSMUlZpbaXuPm80xQrGuScRshUoyh9qGXcXBOGVtuSw67gBxWdcLOyRpZuYrmF13JkeZ5apG0hkO1jsDbGCk/Mok3c4qdjMFjilQSyPMqrNEB5TkEruAwxKqI8kqi8PtZQU5Ftlt5/O2yGZ1KyjJYSsZFJlAXhCxbCkRgFQFTIPym+i025ne0krxdou++ivrZa6WuwhJ07OTi5K7grcyk9E78zsktteuy6pJoTFOkxaVxtWOJQHEKOG+d8O4K8IC5kVsbh8uApq1bQLCv+s80TEFiygq3CDEYUkKwwew+Yg5wcU+KSKZy0E6vKHcSYLsuxSC6NGwUkhsOFLEYwCTytZOpG/glgFtE5xcEC6jGNyjGI3hSJ3ZQqBm+TOG5QgE0OSguZJyVrpxd9W482ibTSb9O7WwQ5qz9i5KMrJSUrK6XLJNRdkr32Tu9b366r2Mb+YrtuYMZN5VwyIo+QKSCpUE/wCrEYU4YZAbdVy3iiijVEGI0XJDM0jA/KXY8ZDEZIQxnHBxkAHIe8maCH7PFJG9xNGI2lCzGFY0jLyyRALNhmYMgOF2jgYBxYspZHQ+dvjX5TGJSAzS7Yi5YO8rgF2LRggLsYknaQQ1KLatHpve3SLVr6PSzfRv7llOE/ZtymlFNx5FJO3K4q7Sdkuis2vk0Pa4uFLGW3QL56rGoKO5gG5Fm++o3Ky4bcgUHkqvNTrcBypZkOP3Y2pwG3hcSchNxJLsuS3O8b85AVkEo8slxLHlyF+VGJ+byy3yHejZWNADzu3MQA1ea58ma3iWIfOfljITeCTGdyYydqF2IITdy6qFzzVnGzldttatJ2S5WmrNLW9tfTvYUVP3VFJ2urNrS0dZKzeln11W6aZcnLvtjC7sSKx67VVWAwWAHGSCCpUEg8pnlux3P3y2CrkbWUMNoJDDqXBA2qSNvIbotIEJkMryNI6ZxgbI4x8m4bEYliwByWJOWI4INSkFV7sWG4qQSMlgeBkAEAZ46dcFRgu6cm5aJ26Ws9L2TWqT6fnYzvyOKjK7W7T6u19Xvo9eit5kAhAlaVSVbYVByxBAPHyZwpxgAfMXwfXinqDK1le7AGb7O24YO1crwdoHAA9GG0g8uWC1ogMi7JArNkNlWwHyoK7QoPGBtONuQQxxtasm9hlhsL9t7Sb45GAxny43KFsu7YIYAkcME2ArtIyymnFNRV1JNrRbW1tvpo9XurPbV9OGalXo8ztJVKSim9WuZXStZ6X3a222TNGy2i1tHJMey1t2AXYhZggwCoJYkkhsbtpAHc76k+6zkAMGZi25c7TnIwCWIGDlW3E4x1HArWhEVvYp8xU2sABHzqpKK43AbVGQWcDJbHzIu0sDZOGIKqMA8tjJIBUD7p5XODnlWAHI+Wrg00ut7ctlfW0Xqnf0v0V09WZ101XqtaxlVm72b050pWWuu6elrXu9NcPSmGdigNm1scghWLZe6UDAZckncRjqDtJBIFaDiNm3uoyokRSDjKFl/eKyoNzKxGM5bJAAyoxl6aRKswGY9lraI0oIAX5r0ggkM2HIUFhtzgsMOAToyIWijXcYipil3qZWJaLhk3AgqSVACEnBGXJJIGaT5Numj2T1jdPTTybt2OvGJfWG9rqG+6Tpxvp52Ttvvew9CrFi8T+aGeTBKgbEXCuC4VhzkscdcAYxgo7ISoG7mLBAKkZYZw+3HDbiAiZBBCgL2X5lYlF3FiAApZiu/K+WwZyHUbSwzkFjhSD0gfzwGaOOParYBd1IwdoMm0qrBQVbBDAIR907jilZLvorXSfu6X6JJpLpbfR63OflUmrvlTtu2ktErXu099r28rq7YdqSI8aN87CORlDbQCQ6uxfaCynAY5IQqM4OQS6h86OUqWVt26EplhlSrxgMhj+VsZdMhSAoJVc7Xj/R1fasjAFQVBAYMSocfJujCDALJnkMHHByrlSYrywDmP8AeRrgjJGVC+WMKSuNzkk5UDcM0JaWlomldJOzvypu6s3dP7tr6XtPlcJKWsXZPq7SWtulu7s+lkQgSAKGVYyF82RIwG+4qYjAVQ42qdu8kEMGAypYiTzipUyow3INvCAgBgu0k5bIKkk4wFXkAgFmCFUaWVDnz2UyFixG9FZQ4UsDGThSEAJxjDEcK8uoZU9QgZcKFyGRtzkhS5AYDMZ+QFV+iTtd6rqlunblS0tu1q0vlfq5Si3/ADJK99m5e620m9LO9rbpdNSJCg3M7MZgTGP3gCgfKoEe0qrAjIaTGCu/k5bDI5IXeYx7sxKu9gECZYIdiMQONw3OMFlGcZABMzR5LEtjLMxLcBuRhAoDKMhsfL1HQE80mXBCeWCX3NnhUXJQFSCiqzMVBUHAPyLkFiod2knbRW1et9IrTbrsr7Ja6WV3jqnrKys72itn1vey1S0UXe7A7BuRo2L5LluF2dFjBbeFAQhmCAeaQA8Z6AGEaUOSzgIuxt67ZJMoQCTtJVV2AYO18MGYMpNO2HG9d4BPluoDDeucsxIKqr4wgZRlfl2kjACcxRqQryRxt5ZIBBIB3KcM3Q7SXJ+8RuBX5iUk9V9nR3W+nLZNWd21q7q+9tG2TvbVXenbtd6pWV7fDprunsivKZSEKCADgEHe8iqrsikqu1RtYLgtzlhnJFWPMOFxE4UoQWAUCMblBGG5YbnKgk5BOVJzioQQiBCpZhllClSD8gcFSPkVOqoCCCSMHl8w2rpO+wq4mik3SFsJiRQoITblZIychRkHOeqjNF2ml3tu76aX2V1t3VnbVbuklaU7aJJXS+Wrvd30utW2tNdHbG5QTnJ3Ap8xJ42gDBUEgZ5ByFYHPPWtdxoY7VzgSDUrMhGZsNksOFAAwAfm3Ak4IOQQFtsu9xhgGGGJBIzypwue5POQcYLAjcKrX5xHYgBj/wATGzB2klRy/I5DEE5OT8oxgZBwHNWi21tGKsrNrSGqXTq9dN7dSqUn7Smu703Wttev4p63301tZG5mI6cndubAIXBOcDOc44yuAOhIZsThixTPyO0ZJGB5igMwAYDcFDZyByAdowBhzID8rA7lBZjjgKGOTg5PJ4yo5+UEAZCqqqG6Ll+XcKQXZVAUu2SWJDAcDkIqjAxTb1vdvXsm3dRu0002+uzVr77EKzXW+jTvZJppO61e13ZbNDkLbk+U53Ac4IwSMbsnHzY4POAMYBIY5VkMWcCnaoK3OSoIAxPIcHBbnj5lGORuGMbm1QcbSysNp9M5UY5yRklcYJwcZ+bGecmzWZraN1QFHN0yq33thnmYMRwoYY4wzEF8nK0O6W1uVX7OyUU3ve13ftonazOmlrQqJrRVaW/e1Sye266J3XY05MF4lOQfKg2seAzeQuMlzg4GCeNpI6b8VAeikB5DuAYqhwC20hjvJHl4AJGflPIOOs8v7nywVbIhtgobGdxiXBY4KKuSfMAxwCxABzTAJEYYw5YEuvOxCuNzRsOMDZhQFyWJLHaKavstGrc2jdtEu+z2v/w7xSje7le/Rtrms0ruyeurtzaeSvoAFmbaVyc9QCPlwRJlBgsRtIXOV6FSucZ0UJGo35YOMiA7Qcli6Z4yFXK4PyqNrEggLgCrw3DcEX95vUMWdWWRMoGk27lUgEKMjhWYEqRvxDHkXd4y4JZLRgMKWX93IEVgAxUkjLBiWzyucCqV/L3bKzi076d1G9lfbZq/U6qTapYqzTbpLs7v2tJNvZ+b36Xu9SdCMjdlSWGEPJJOzLrlTuPU4wFABLNlRVC2RDDDJ5Z3LPeABixAd7yZxuDADqinLFmA5DMqgmyyM6gxFjMJBJEQXBLKVVgSSuQ4/wBpS5wCGbINXTm3WwUoUKtOCpGMbrmRsITuZ1y3IUZTJ5zjGMnzSSTevVeSp317pppL0ut0TCyoztdPmgmk9dnZelnZfyp2b6lvbt4ToThl5243dFCk4O3hcgkAAjcvFQSzOgdTDKCIozA6+W4dpHCOigggOm4SHswBcc9bg3+YUZUIkJdJAMFSCFwcscYz8rKGyWBHy8MSFVIQq43EgsNoXGEUFyCMAbmbIJPIfGV5rRvR20Svu9FBW+d01azWj2TQk+Vq6vt1fk76Prbq+qWrtemG8gASOSAAGmdd24krGFdh5mGwGdQqcZGTxkuU7IwUjmcKVdNx3EqfL3O7MclQMkoyjnnKkMwmlVXwGBcI6SgdsIdysNv8Q3ZVi20kncCAQry6q5BIDAEEHORnHzHkhgNy8AnO3CgAgUJdW09IpSsrNO3d22Wm/TeyQ+a6vyu7d3G66WsrbXb0d3Zv5NQyyRHKbwOEY7duVBKYJJG1A5Lbjvyp4GSMVE2+RWEQZHUMgYNj98u0kLjzH2soJ5I3Yw3y5qbejM6JIGkAVuCFQBsEBiU2kHzs7CCOMZVitI4l+Ux+UcsplEpIxCQGLINoBf8AdsMEnapA45FDUWnrdWjqrb3S7uV1ttum0k3o1dW6PRty0++3TRL1v1ekcsbsiBZjE42SM0ca72ZQUaNQx+VHOAM4G4lg3Jw5IXKIZZpZHjbO4qysxBVSCFO4owG7a25zkgkCpjHtJ5ZgVYruyCcEMSQM8cgAZK84TgVXCXBmlLOBbjaIkKKXlYbSXkbIK/ccDaSG4GBzmvd92SUm3bTXTZN32WiWu71vfdtO6u5cqXvap8zvbRXTu7Nbva99N7KNGx+UqVBAba24hhsyM4JGO+edmAOoBhNws8FvbRhiI7i+k3gBVCy3EalwMFpVOMxukY+cbchlJEohRWdlBAkZS685c5+ZgCRjc2DkZJAZeAwFSzW0Uel6dJEphc3uoHzATuYLNC/lybABjO9k3M3yjGNhICfM7N9L8yet0nF7tJdr626JvUXNCLgtXzSSjsveUXq/yvpe1u5UERWMxpNL8q48xgHcZwd7csGHygYZSRklR1NN4JHJcKikSMyFnkAX5sqcbm+X5QoQ43E5BxMzqRtwqv8AL5iN8riJlUNkEMQCSMPkn5sABiGphxwoVgQwP8QXA4UYwByMkqCqsQM4NNK9tE7Lu7prXRW3XV3TViryuk1Z3etnotF21vvrps7WaIAkxlcySRtGWIjSNVDJjblpCWVmbCsWKqGDbTwSwDGSR1dQ+HjZfLZMlsIq8lQAzqxA+8W+YA7SBirLKxVSCQMYCOMhnG0gbV3OQSeSxGDnB28mtvWTegco8boScSoQAseFXaFeRPm+bB6DJBwSCyTWu/fdv3erattd6N9rGkXJ20je6Wita0op31V/Wz1vq90O6xEMMDBA2BjgFiqgkEPlSAA2clcnsQSpCRDzFwjv5YZt+0EtsCnJXb5akjCkA5PHGQFCMwb5vL5ZwCxkIC7GLbWXI8xflUZ2gMyvk8U4ghhjBAKfvFI/jVkZSMuflw2c7QrsckADDTemnpddfdvd6aLdrS+iWt7VZO2vZXWzfuuz6W0emlkraXd4VKgMY87ZCSfmLDJweCflBbgAr0CjDZJAdywBOeCMryOABwwwSQvKkgALxkNwQ6ONQgQcYKlcl2GCVyctwByuRgklSBzkUojReSApwFywGcjb8qk+u4ADGFAwcLty7NPd7p6a7Wfl27LV6rtV7Prs0l11S81a+1rd721tGCc5GMlSAx5yGCjG85K5JHPcALkMcCGSG2kRd8MTEsxVWjLEO/JwSyjrszGOCF55wpnCpvB2gnIZsZ+4Aikfd6Ag452kgn7wBp7qC+PlUGMMTkZyNrbSTuOWH3wcYJUjGBmbJ2UlvrbRvlbT1VorS10+rbbuF1Gy1V1zXSimuW116JtO1ne3lYr8iUhQcYZ9xBA2o2AcjKsMNhQByowfmGaRQi/Iq7SQWO3IJZ8FyXbALMWPy8hsLnGwCpXeOMbpPm5CggksclQBg/LgfMGYMpIAPJxTArLgBVfa53Mq8oCqswG5mVkDKVXa3AwV4OwtrTq2+u1telk2lour21vd2cW2rtNLRN+7Z8rT72dr3aTdunVqCNIwDMybWlAj2scY8tgYmKqFOXKmQ7iHBcqNy4USuEUg7CXCeWjqXLRq4J3NyoIHAbDEt/DxUhG0fLu9lxnGAgVicEFAD0XGMlcDJpgjfc2GLRlyzqyj5ccfumLAoNgGcjcBIAFIoskkkm3b4nbSzjzP1u76X3Wmg73s3dX00voo8uybe71V1r5u4xkDPGwcqY0doSOI2LbdisGdSV2qzDYxU/dUq2WFeWIvGwD7QQwAYyJ526OR9jsWGJAXyoJJIxIxKj5bLfdZWyArgLtxGvlgBBKhjJKcMcMSYyWG7BIBzRcrIX8gSSN+9ZwyMVhj2IWfEq75YyzAgDaRkgADJcTimru3Nsmtb2itO6ve61aS2V7nXhVKVWG9rrWUX7qbWm9ntZbtNLRbu6uDFArPnKQhcoF2sFIOS5Ziv94qV2/fwGYmpSRGC8mVUhVJXbkklcMrEfODkKzZACgMfQ17d0ENj5iMrzW0eVK7UO3Me9nJcbmG5gRhmKhQD8rNZYHbnzNhJUbiNwZlaMHcpUKOQRn6ZAyWpK3T+VfZ1vaOiez2u9Vu9tTOb5aklpZSlpb3r3UXq+idl069ER7Su5kVmMnIVGYZK4ITIULs4CAsQGIAUqdwCREIED4WRULsoYHBwAFBHVEGA+7cQxKnawwZjtyoC7cFVG4HJyBjOSxGAfmYHLDDEkHNI42uPvFwhTcC2CuQFYqTgqNw6HLLtyCBSUXdNdN7JdFFO+r00d2rNO+rvrV72fK9dW/5fJ3afle177kCoyblVyAwZsOoY7hgKApbZyFBxgAj5UAYkiSNCMDO7CgsdoUtllViSylicDAYAhsENgglmpyAHZD/ABFjGBnhQMFQRsy2DzkA/J1yZH2uADgHAAZdqq2NpAViVPzEqOOGAxgN0cUt3ovPrty2V7Xty762BO7SldXXVLaPKntpezWqv56G3bFW0TXInYkstg6Fd2wML1ApKsTlGD/wqwDB+COW59otzNvYYVCo2gfI28nDAD+H7wBYqMbULdBs26qNJ1RwjsGFkoAd8bTeoWYkIgJBB2KzblDc7wWFZbYOQpOApI+cKFIboRuZsKSBnJG7AUljgaKOkLO7SVmtUm3vbR2stdle1zLDNKWIaa1rJ6Ncr/d01d76+dtr2fUrlCuAEII2qOflCkK2V46ckFsqBkBsrUWFR8HKnAPzf7QjXBxlQhBAG44bOV54qUyNlQykpjJO/c+Qyrja5JCbh0CkjkFgQAUVMjAAIY7gSQdoCp0YZG0AgEHAABwRuCrMrLRK/uqz1WunW1rRX2b7XW97dieq12tonvZxvbvbfXmvrfraIKoTy8lSpxggBC+cMzHhCdxAGACSoHXBZOGVcbVwdu8jaHI2kZy5wG+UswzuY9cqKm3ggjY+T+7LcMGyBkgvtZmJXC8gY4OSDlgCH72DtUE8oCduB0APOCBgjBZTvwwo10Wmjvb1std/VaK91te44O2ja6W0i2r8qWtrva/q7JpPVuIyNwIwuSADnGQpVWLbcAknb25IOStL1IwQxAViCX3ZyAwyQQ3mY+QHjK5BPJLXaMPE0inMytF5vy/LIVQrGyt3YDghQ7dGxwSpXYUCl3XbheplL5UbQzBVbeFOBgAsTjbzg6Na+7ZaXe9ndv7tdVa+ru0y/wANlppZ7W0jrq9bu3qnr0FLcAlThRtY4bDD5QMA/MGycDgliAOpyYkYOMhiAC33lZCWAGUCnuAcPzjnAycmkhbzI45o96s5fKsynY6FQVIRtx+7weWIOCW4p7qec7uDufG7ndgkAYOSM/ezgL8pJXBo+JRaa116arR3snddWlbbfZ2acuqata+np67WW99tLiA54Kk524bAHA292OdvTJx95QOWAy6SSbycwfNIhTaOQAuYzIGZpFyeMA8defmJ3NO9gFTBdiAm7IQZIIeVmU7QoJI3cHG0YPNPSNmkVG2A+Wu50wsRdTtcAhn+cnCrgFW4OAcMW09Ulryxu9NE7ejSSS6PbfqtIvZX625tb+ia6r7N9LvR2WrFTDhVbaDyCcZypRSGVARltvTPJIIwAFDREQzv5o8vLeXDhE2hAh5IO5lGD5eGJ3DIyzmplYsiFVOZDgBiCQcgb2yuWOVZlBy3HBOOFCgAZPJTuWG4jG5yCDyDuAHA4DkAnDQrN6JpdHtf5LTto/TowdlZK601a91fZvuvJ3fVtdNCsdiDzJJNqIqkAluQSAwO0NyPvNxtUAkjAyGyXMUMYkJb5hldgVs8qQM4wM5LKWLbh0BJC1ayADuVXLxtjIyGU7dqsT5YUjaSXAzlgobrhgHmAoRhfmDpgHZtDhU6Mw2lgA+c4IIGcrUyU2nyyUW7W0Ts9FZ3aXTpfmvuK11e172krOzduX1XNZJJ3t30bapB3BHmRMU8wMZIjHKVUKCu4DcMhfm4K5J2lTgmrC+Wz7yWSQgSRByrId5URMqoC6ncSrR4GeAcMoAkxIzq25Y1UM6om52b58lZHID7GUM2Bv5+p2q25jlFMi5KFiGJVZT8xXzZNwGdwIAK8EDlaIxktW5NN7JRV00lZWd1razcVbXZIaW1tVLa+rfuwSk77vR7K9+xCHDurrJseNiCrI375VZFZDjayBMM4V22lfmX72Kkj3MisGIR8EDaVLghCDjHyEZPIBJx8uA2Avl5CgMyDLISpAZo33bl4XGCXPzHk+oyFqQxuuQG5UANuVmJHyqFXLFiSAOSV3HdgDAAcYtPVS1aT6romkr2SVldJLortXKjffZarbe6jfr66NaWvfXWt5LeWUI8wA/IcPkIQFVizbuV5fBU4OcEMeZ8BSAFOGX5nbpuUgF87gpLDJwyqx3FgMKAWMwDxqHdGZgY2jUqgO5BskfP3WByFLnK9TjguJZfn2nZuCtgDgcEsCxZSCVOeG25+gJdraztyx011XLpZJu+rTvHt6lxtppdLyX93TT1srWautUnok0aSoY5Vcq2GCh2UgqFCMGAGFO45OSCB3Zsk8pSV2sVwowGJBIUqFQ5YkMQEDcANghgDjEipiR3GC4j2l8sVKAthSvACjIIOSMDAwTmnADll4HUq27OBj73ygqcKFUknB9ARVcrfM42jJNa3s7Jq2tl81qvm7FKyd3pfe2v8vl289tE9rQjqMDH8DEbiOqnaoK/eycYOTjhTwCWoNoYkjLLgsoARAQgDrvYIH6jBU7jtGAcE2flTCFd26MfvCuQjny1YEK3YEFUB3c7hncRTDtICkbj8qDdkcZjxk4YFRkgc8gqDgDILaO19NE21t7q+WulldpLe+rpdtXb7la33W89dGVPJiKbkkkYbQGlEhLlwqkKAvOOEBBwcDCFs5JAHTzFd9zEMBkHAHyqgCyElS2FfAAUhjtCkEVYZCXygxtDB2KuokfcGx5e4kN1ycAAlewIBsZsblK4CyIuUUAnbweCxBCgjkkZwSGYkKMbapK6ilon3Vt366avq9Xo9fXZd3pbu/zbet09hVyCpBAyoBLA4AyoIAG0Y6At97JwAFJIo3Ee65t8MB+5udu4gbuY+QuMFWA4UckAYAIOLZQNkgNksrbum0DGBubDA5JwQAcggkEk1VufmmtBltxW5JbLAgYjHyg8lQecYA7nGNwctF/29BW3u3OKWytu7r09GF9t9bLZ9Wt9G0WIDI9xcKwUKmnXXzMu4uS0JyrEgkbsqPlwCCzAgMRJtBABLYBDcMwO4sBztHdSvmJuJU4CqRxVq3j/AHd9t2Bk065JZQGkG548EZVm3YyZAScAA4C5qqoBxhyUwWILMf3pKEE4IKEAoqqV6spU4ZQaiktO712VtVp9yt01vuRTd61W+y5NbrdRjJ3W+17X137q1pBGdOvmcOrBrMRneBhPtGA5LbS2QVZhn5gN2V2sWzjxnHQZBU53FwwUsM7BlgAE2gjHDAKADrxnZp94OuWtj/qyflEjLuYEgYK42lgGDE7uHbGVJzGdoAAGDgc9s4UAMNpJyQTtzxlc4Jv3Vpd+zt52u7ad99dU9bdApyvKs76OatfaLdKmnou/b0a31t3DHyNKAMYzpaDaQrHAvLsHd8wO4gAAEYxhc7uaoKwIbAZQpGSTgDAjyBycnJCls/K2VxnBNy5DmLSDGSv/ABL1JVwSuz7bd4IVlYsvAK4bD/8AAcCoqlQMLluJGIQLtc7RISCeAdpIBAYAjIyRUx1aWiVk2994qzTbtrrqum3m8K701d689Tr/AH7a33el7O9reiTSrKw2AMRtRxk7drcqcLtT5cYOGYglflILkNwRhlU7cgucJkhgMsmDgFVG1iQygMNoxUmT/GoUBvkwoy+RGVJYgIMnDZAGRySGJVhRyTgnbuVi20jOIwSmCOWJIUc7WIz8pFXbdfg/lqtG1d/3dtL3Om17b6bXWujXXv8AnvrYbjcNwB2bGwPlDOcJt64KqCA20HLbRg5yDExQfLuUPsyVyQ21in7xshiu1snK87jg4YAmVshFDq20MnGw7iny5JDArgFgzDIHX5sggx8eYMkAmF0JIy7KJF4VkbLHay5IGCGAfICilpddFdLmvZ207Stv3T13TauDs3q07rV9VqrbLq9t23ve2oQVQfvMHYvzkEkkBCAWGQOB1UbSvH8OaTzgu07kO5docbSpcMgaPfuGSwIyzIByCRnaCLwoDA5jZWBwcbgQVcHIZuTtc4/unAw2RNhKq8abgSAMYV9pADR4LNu+bcVXBAPXgAJt308rKy0ur67d1t2ut2hpvvy3afXf3Vt87baWv1RMCoBJXOByecY+XgEbQCCCpPQfxYBzSkfdJ6NgYAyASAAMDGcAAnkFhgIcUg3HBxk/KecHaPl+YsST0PDYzyQw3AijLE/LtZRt2hgC2/OMEMEwG8s7TjHIw2SQtWulotHb1vy6aXaejvb/AIClPXW6em+/TRWtvbbq+nQIvMjByc7ckSlUbO1VwjAgkMN2CcccDG7BMqsuAMhDjaMsxwCM4JIDDqCoHXB5Q4Bai437w6qGDqdwYsCASVyTgKQ2WC7CQA+GGKeirxzwRwhOMEEMN3UjbnoTyORjipT76bLW2rulfVpLrfo+nQpXTjbrZW1fLrHttqtZPp3sKy7z2BdSfl3ZOMYyBjJ4Y8DJ7EHiofLRWywC5AGGbIVsAKAzAAk4+U4LkEAEkYp7s3O0knADMWDIGYL5eCcHJwQGGONvzBgQSKKNF8t3Z9spZPMfLqFCqFDgnkZUsMKu7a3ABw/RX7a9dN12vtp1td6jV27pXeuvk+VbW+S87JWY5QSMEBMIVV/veYQF2hQzLlhkEjG8jLZ3EAWYCR5anLtuHzAOxJJTkqTuyQcscqzDHy8bhW2nJ8tsSNgsG3BVOVDMu58EttwDgHcdzblziOO2l+0Bw7+U8jN8wKghWTaw3OQAMbckEq2VJKfehtqzUU97q+2ztbW7d/l56lJ6ppJ2cVda6PlWz0bSs9PJNqzvr3Vwzq0ABVzcFokIQ7sNI0ZRQ3mCGVyVdt7AkZx0Ju2qpOgkUxq4iZHtggxHLlzs2oHcEBiYiWzGDgNtqHU1UKLtWXarnbvwCsLuwlUb3T5gJQw2gYBYoQBg11SeO2Jsw0ckmJfMkfzY3gjT7wMhRVlcp+6Kvvyw2bRiuNtwnLm9+yjdx3suVq3S97p3a0b1dtPgny1KMXD3eeaXM78qeindLW3VW26X3NJklfy2SNVferSZEmYQZGGI97DMRB+ZVO4FgeNoFKscD+aV+9HMX8wswaEhlG1yCxwNwJCuylh8pCnaKdhdXJWGCWKVrhsSTXMqsipBmNPMKuzshBBVX3dgx+YtVxPs9sfJhXashkmCs+SS27cF3LtLSAApGp2sQrbx92rhKMkmkknb4ls5KNkm9PVq+rtvthKM4NxbXNpyKGqlFu0pSu9FquVNX1fbW0UmTC+bFl1DFjCznfuXLKSSTgDPP3zjaQcsKt2GgSFvNcTCaEiVi+5iAA2ETkqi/McZ4x5ikoCXW85mt4HZvKSeXbg/vHQRqoH7xTuAkbJAZR1UBVALBLi3/fmdmcN5crCRi8gTL8eWFfJwiIpJBLxkZAJKmpO6XK03aLTcrRSdmttb9U/1uiYLlnyzaSi5NpKN3K6Tu00r76vRJuyEFysqtcWxgeML5BabYHRs+bkpIA4dPkUbpDudkjQlACLe5LmECCcRSmPzI5xGDKZFEfziBgG5LKmQQpAyGCnjLtcb4rWS0e3QMzZ3xeRKYAiI0sD7ipaRizby2SUWIBVIrTu2htUgvJN3+jtGqlS27ypB5TrhdigBASN3y4V87jncoSbjKcr6qKkryVk0nKSTV1pe123srp3uVKaVSEIX5r3g7xne6TStZp80o3fRXaabdyS0sVtGfE7Ok0aloWGEFyu1WkHmO0h3GNSVJB3EhBtTD3GhaR4ZXbCIpYxBSA78CN5CCpKIF3Ro21lJ3BgwbdUjmWVp4rd/32HlLDDKDwsTMsYwXEjBvL37HjKON4bbU6C5jit0lMc77k+0zt+7XYQCZETLMzYV1GVQDIJTBO3SKgo8qi2tGrNtXXK+X5We9+ul2cdRVXLnnKMZtxi4tcj5XBN9HHRLlu7O70vuOaOUwsoCxyhgAZwkkUixFGXzBncQyqSqliVyQW2k4jeFY7gXDyHHl+UYlHyGRmwGVUZTlo1VIzITtVVDMAdotNLCpCSSBM8YYhSchdq4QEHCtwgL8EEcgFnDBJ2lugIbI5B5jwCB2YsMZ+uQRV6OzWqsrvomuVc11JPVO9r72TutpjKUU3ZRTTvdJu0uW6u23stLO61V220VLbdHGscgCSIzMyl1lG1GVPM387c4OVAK8jp2kmSHdE4ijlmRwIWxyqMU3srYAXbhSzEg4ZugwRJ8xIIwN2B0Izkg7gQAwwc5J59VJ5B86sGDKQFUZ2fPv+XAUnaMcfMpyD2H3gSytGLd/ejd31h8P/btttV1auVF+9zR9299I6LVR0erumt0r3Ta31b4YQ8gKsw2AAeWRs3OwbLrnaMbiNhY8AZU5JprBYwAxXBZk+XBG7cOWJJGCRuXaS3B4x8tIhCmRVDDfKZJRwA7AKAyBSAEQHg4YnIXcVJpx+rHPTqB1DAD1brgg4BOe/CvblTstU3eye6SurOzas/m1ZqyJSez1W+itfWP3dXdXdtel0Arkk8/LtLAkk4CkttBABA+6QRtUrjAzWZqhI029IB2/ZmCg8FgwQ4yqsSDgZOclhgYQHOiFIG5UIZtoKMeoypweyhT1XnIyR8uSc3UFVLG73SKC9s+4HLAsVQFEjX5TwMAgAjOejYp7ptdI3eml7JW1/S+u+iV+nDa4ij3Vanv6wbs+W3qr3vbsm1swDZ2f3gTawDLAkjCEHBY9QcspAyQ2SKtEB/LSRjhRubAYEgnhchVJUgEsAwII+XnIqnbRE2lou9hm3g+XB5UoSm3aqcBiCSc/KSFwxOI8xQ3JxK5luyjMGZmQCIKqort8iIpdiAwORjLbtlNO0Y768t7aLZWe999LW2v86qRbr12m3JVJuKSb2qK99LJJa3tLZdk1maMGWO6MaqxRLfYG5yRJefxF1ZVYKQCwKAZYYbOdaIXEpIuFCINzlsRiR5o2AAB3n93n5lbgsxLBRIoFZ2k7A8/yKcQ2gyflHzPdbuiBdzB8ruILYGeozrtNGoMZAyQX2FR32g7mK7VIMmGUHG4gqQxAEx2jdu3Na1tL3jura6PVPXQ6sdJxxM1y80lGlZ21V6dN3u7LXd6O2vaxE6+cJFBIdQSG++WZSoVhjDKhdTux1wSQpHMBnRHVJRtfYFjRwRksqgOhO/cXZzsRmLBQx2tjixKS5QhmK4Us3GQTtKkbQFPDMWBf7uN25htqm0hdCJRF+4mbahRGRmWPYknyuXzK4JTDBVYMOMqCrtNO63Su7Nbq3ddfJadXcwglKPvbetpJuyVuvRaO7XoxzNKZZcxq9sYjIHRVHluMeagLYBLbPlIUY+XZyNpcsm+MNHkIY2RRhWY7SMqCn+rIJCBgDkjHAziG4klhRyPmdyGDKmCm9CxYlm27VQFVLE4J3AYBJao89Y5kLIFQplgHDMqltsyKQuFcqCcEevUgymtdb23Wje8dr9EntLurWukr5W0pOyStFNJ2uuW7aV9Xotla2i1Yk5lMTtDiGRlXyzPjEfzruLl0ZVCggJyBnOOGOLjLwjKxUDaRgAIRkbgyqGBBODuOcCqcFvgeXcSNcvMFDmSNlRiVKhIVQgIqFCX2Lukxu+YDA0XXA+UsxUohxuBAyCu3gbjs4yMEHIIznLTur6rTVJp6pq3KlZdtfl2YSko8sYtSTlduKsndRTSu72Vk0ml33YzbtyF2q7BMeYSyhgy/M4IK529gcnoMLghGVlQKh5Cgs6qSVwVEm7Dj7oBKq2CBwcEmg/MSiuwC52BUYZRCBt353AEgk9VPzAZOMx+ZOWVQoZDvaRmDbyBsJEW4Lk7BvwWbCHDbSCpq600s2lou+jvZX30tdX02exEYysr8t+t7pN2SSu+3RLrru9B1BCqrIpxu835WJ8r5xu3qy75N4OCTyACoHVBMcgttdpVfEfluo3M6qUBbaAu7YVZsH5gqE4C1XE7O9wvKNFmKJ8Z2DYCHjKFC58xNr/KQoLA5OTSSiRLSSaSMXE6pGTsjVB5itsQ4dSNo2kyLkZIJbgs1DaWy3i3e9uZrlbTV3r8WiTVr6LrqoX5U7JvlilezSdmnppZaa6XbuXSrOV3BRFtQnIRnc/I2PmRGCKUJOCCQdynJOX4yMGQjJWQAsQ4Iwc8LltwYfKpIK4x8xIqEyrHsQ5AkKxk4AVWKIWLksYwjDcFZGwpbKAgbaUbWRFTOFbcMsS6MijkhCB5ZfOAOMgk4JxQrO+idltty/DZt63XqtW2+raVmrP7L0Tve6tZt9bXfq+297ALFs7CRkxLhiMAtjcSw+YDnB6gHLknmql8A0NsNypt1Kx4JBLbXIG1iuOAAQQeQCz4+VanVx5jAlnARWBOMNvwG2MxwcckAKOGJZlOKpXi4SyJYu/9o2WMuwZRuY7SCFO0clsgZJPO1QVhu6a7qzvdaJxSW2q7a629SqOlSOlve6WdvtLbr3bstrOz01eRzy4ySFHB5OArEEjO1Q2cEMQcZUmmKMEbsDcAQBtzk7V2jnbgNjt1wcrwA7acL85GTkk5OCDnO3nOFAJ5xuYEcEYj3KijzpNpG1Qz4UMcKMqTvA3AgAHBPGPujOi0jd3s7Wd9EtN9dPPXRXta5n2te6eqsm29H0fnqrap3tdqzy5VGYqS4STAA5O1A3JYc5PBOBz97AHObYoRZW6kcbZyckE5LyfLiNjja33uTtOCMqGxdyQy8ksWO7KklOjZIwN27ILZOCei4ABpafn7MGyzrIbo7WJJIE7kAEEIoB+bCcY5IzhSayS10cVFvzS2vff4brZu3+F9cV/slXa/1ii0n/hmv1/HzNWberqGZHZo7Zt6HKlWt4xnfvwy84BZQWwxDEk4rJuXdkxsHDZyoBDEJ8qtkIAcsSPugMADnJM0q5I4LFobdRnJPFvGATjK7PmLKF4JOQQM1EqgqgCgbQACQ5PBHTIxgADoo3YyArgVT0a1cttVby6bW9G3q7aXZztNJbXetmk9NLNPa/o7pxa0bsAYZwCrNGPmCjlT8oGFCkBsOFyC+1hg4yKz1jgEuphjIQwtyMyguMq7YUK/I3hE2EqMKOAWJF1c5ffmPYTguVzIyhMS5+R9q4wjY5cjeSxzVWNyb6/BVwTHCoLIoKoFAbcoBPzA7gQWZiuRkryknK70V19+2+q11a0V2lo1fTrw6caeJtZctGEnfZWq03bTW1na3fe3S1bA+akRYPuSMu2dzM8ZRCVy0hb/AFQ3rtAALEfMuTVgi82xjXc0ZDz/ADJkMrC7mH3lIARiTuHqCRxzVsbmaIBpYykykOhQFwpAAAwjeU7MzSMpU5DNtDMxFKBxb2SPIHP7+5T5FkZgDezKwwwKlACdwYhVCggtlgI2fLJO1pX2T+w7aPpe299uhKvytxau5QSXydvxs/Nu2i2sx2yxl9oYGRt+4s+EIwP3Y8wlNu0FVJIcgAEbRmYIqlgGHKhidzE5ITBKggr/AHh3AyFwpzVfZO2xopYXgZQzBkbzmZlDBopM7CcADBXGXJBAUgAthGJ7iNZJJpWDMocEfJhV27iE2RYRsMrt8zL0YAVFctlFaXs+l09nFXervba7fRaIW71lFya0W3WKad//AALRPS111Hg4lMTIw8xWkVzuZRkqGjZnIUEht0YUg/MpJyakRUIXcq5XGAVXDYVQT/C2QcZbaqqdpYAgkKiKhdQzMXYyliF27nwpBK4RY1IKhSwDKoZcHaKVmJCsAMAgBwGXCkjJwOScjaG6ZKghhkrcY3s3fV9dEk+VaXtqmr26Po3e7dm1Z9dXpuuVOTTvunr5K7ZGFCps3A/K+0EEMWfkgknc2coY0I5OVXaACGqCCnUsVzuJflkJDLlkI3EKVHYpgsxkyaeCC2xGBAI3KMgjBRlBHDKcgbhgkA/If4jHG5cyCYxnazJGERhkxhCsjkspk3qu4hSSNqsRuOaLxi0km1srtb6W00Td7vq3rZW2Lu13de8r3b0d1Zb6tW101FjViA+0q7ENLv6JuUCPCKRgJtVtoVnJO3BHKuZjCvmSJlFAyYUDOqnAXfHubc3ysw8v5T9Tgu+bClomL8EhVz3CguWZi0jqQwx1BcnGCVdhgNqsVwhYAbThWXB3DaSSNxOCcccE8KZitF7yvHTb0l72ivrZrRbrtdje173vr57aaLT06PfUjNxCu4MW82L76sNr4Co8m0ONrkLkswJwARgHdtl3XUmnWazwMqG81LyEYptCHyeYyrKkqH+JigxKWQN5agtJEpJYEsWG358DLLxgZdictvwx+VXUDdlioDnMcllZW5MifZ7zUmLFQqMGMTqY3di74+ZZCoCxAgFAd5YcXzWbtZXSSa1vBu9+tvlpbZk3SlC0Vbmu3duS9yW2122ktdtbaMoYG4lF5+6xCAu+BnDbCrttBDEDBztAwucHysAVwPlPBPU44ySMgD2BwQecDBkKAKcZ271LDO4YbB2uEHQbOWPQEYO0EUjDb82AGDhMY2FlBAY5Q7ty4GVGNwILgZOKVlo1t+tnq1du9+u297GnNd6q3Rd03bv06q6sraEBgjeZJjGPNjQiNmH3FLZIIJRc4IwByo/iyc04fNwFZcqVG7AYnAYY3AMFJJ2nbuJO0lWzh+3PzYAZT0IHAUDJ5ycEgYxhV+UEDhqNpYFRgj5SivzkYQbCW4BPHyAbW7AHFNK6vorrdd3y2vqtNO19+zRpFOXLreysvK9tNNHHd21tutCJEblzu+ZDH3wDhcc4QkBWwobqBzkgEgVVwykpwSFyx4c/MAvCrklcAggMSWxyDNhdpJ4DMF4+UHBXgM+Cy5HB6gDIJIADZMKBuzuLKV6k4G0EkjO4ZwSwA3A4I5DF8r1Vk7Lyevu6X7231vda3H6XbtyvRO2z2t26eV7J6EO3yztIAL4KE7csSFPGAMgDqoJPykLtycLznKruBKhio25bah53ckkcZAztBHJHMrKSRjoSo+YEgAhW3KoPyjAIBB5IDLkAkNCgsQCQCvHG08hQq4XOCxIJHfjZjJNNK7Xeyum2rq0bbO27Xn1V9k7vRu66q17NWitlbZ3td73a0aImQMADjCuqDdk8YUE8NnbkfeGCAVyDwSALkgZEYY4OR8qHbk8E7H6ZAPqQCGxUq/KMlsnIRlCZJXA6FRz0wrAgrx0ODUZIHDHfkAqwCfIcJhWQscoAAepP3iDwwE2k/NdN3a9nvt6vazumOzeia0aS0u7e5fol80rNO/rCeF8ttyuW2MGVQcAqFPAI24+df4wAWwFVmK5ClVYk4YLnJxhSuCSx2tkqeTzkKQMgmpWYAEjcQAMIWUEngMeB8pAbdv3ZAZSwwtLsVjkkAbeRhQTJtBJ+UEAjhdp+ZuCnbL5Wv7ysmujeieyvbzt5p63vcXpezta+l783Kntrvo5W06PYhYDIAU4U44ydp2pjco4O44L4YFhjIHDUxV/ehQeCu4qQpDBiATHgliS2V7t5Z25OBmQrtU8dWQFeMBgFy3BAwABg+pPVeinJwOQMjGCA2crlRtwwIGDwwwcDkckasuztZ9b3UbrVq272Wi3v1bSV1dab315vh7O17d+l7basdFeLy3AKEeU6k7VIZQOcqGC8AsyE47oTkiubONHaRCVQQNGIgjKiIqMVlby2AL48oeYzM64zkj5BdONy5J2kLkDJPHlnLHDhSo5JJ+UEFt4OayZpJNRdrGykIhzsvLsgNGEOA0MTheXcAgID+8OcHbu3LltZvS1uWys9UuvbXfZbpPc6cKp86mnaEGnJva14ta3d3a62fX1JFWVbGyeARlmgg++DHGEGd7DAG9xs3Lhx1baCQBVhQol5cmQYXbvGSTtyFVWkXcjDagbduXJywyKsCJVjjgiJ8qKJYxlyzBQCisC3QSEqWKAnJONkgyzBBEowpHyM5VdzkAkg7iScHLDAPRjkNtcnMpPSy1sk7LS6sull1111skl1WVWpGVSe6vNyTS7uLSd7vR23WiVrO5EqIuRtJIxkK54XKEYbPTg4ypJdiM4YKEDoSyrtYg5PRSp2rjAPIYnAZTwMOGwOTJIxMMjRbWlCFoxI+UZlKEhg6jI4ZlwyjGN5LAbY9nOUIUr97BdchQFZTgOGAZApcncAQWyMGizd9raXvZX1S/C19dOjv0pO+nKo662lq3aHbspJXVlolrfQCgNIdpG9AcEdCF6BQyqGVlUhBnOW6KAtQOzb4YlBCLlwzFCTtwiKpznY5+YjgEZ5DKoadMcjG9WbgAPlclSB8+RgqF+Q8Dh1wAFDZFY4KgAsduNoYIp2kn5AxZd3OT3Ic8EqKtpZXWid7bttXS2b89dde7NdrtbxS0ej2XRa3vv0d9LmvZyOdE1pWVS8bWWCyZBBnjUAvI43YKblAG7byBuyHxvMBZ0BJO13B2DBKyAEbiSgCurEY4OQB+9BJ2bMEaPqylEziAqxCoWczxghz83UqHRhnqzFgi4GYSVk+aPdLJEwZ9iER7ZXLJy4Ul05TKh2yrHH3KenuW2a3flfe7dte6drvTthh0lUxKs7uqk1a7f7um+7u9NNNG9dCu25juUEbcKM4BILKxc4BJznhtoIAy3yk1Gqgu6spGfmycZUbQdoXgEEgY2N/CcYOAZgARuQGPeIyUdcuUOM7igyAGVsMrZGMlRjDLsUM21uAQx+XJA+QlQzZVRn5WO0gtt24BpLe7W+ru+r5dbO6clZeWt9VodF1to0rNX/AO3e17vSzW2/RtELRKrkFgCSNxPyt/A2SDv2gqxIORgkZyBTZeQI8kBVAGPbABzhWcNjcQD1yOpOXuqIzv22Zc7W+YALuII5Un5CBt+XpkAsCxgJAjxnIwu31CcEblwNqjLZOBgMGUHHyvTRSTTb0+K1lbZaX80u7tctNNK67N976ddlpbTVPW19bxhdrKWD/LuljThkl5Xby4H3VDADsrAli7KpejOwcMoPBJJXdtHy5wGJG07jjI+X7wGFNGyQFzIyNFtIQCII6nIOwsCNy7UBYbiGYlhnlS0Ed0LHIVh03AHaQc9w2MkHJ3A4+bNJPTSOjbd+zaXdtdkk7bXuhxk9+2trtp35W1a+jfTaySaYEnAO9YlKhTJsQlCSpXCqVAYKhySykqSYmV+KYibI4wN7bSqFmYMQP3bGZ2DbCB0JKgqMZDbCKkG4naQSgK7ThTgAgKwI4wCflwMHngHbtBwzsQA0i7XzvLEfKwyOAoLfd4ypO3gEAlm2lbskkvO+23l0tYrV632StstE0rJa620fq5CdNrHAUN5S4x1IX5iwYbxnkgYdiewzh/K7miZlBJUsOd2VAySoxgqCMgnAO0dDhgeNF3ueAMNkAuJNy4VV2uAcspXnJGSeQachDBWcFW2At8oO3IXY2VbBLDGSFPJ6dCHpf4n62t2Wmumne2nRjTs7W0Xffo29dEtE+vqrXHOFO0MCVKh9iFd+Q24KMtkKnOV3AcgqcYqP5mH3RtJYLna0rbQgRtxkLbHwS5xjLfKN2KA6oQp3FiCHwpcOSqkIRgKHZQ2T0VOCRuKgZiIiyRyIz7DHERHuflCJJCF2gJv+fcVzkAgA5qXy3dr7LZu62ve2t3bydulir31td6Xtda+7pdbNq6drdtdLtRwAwdSkgbaoLoQ4QYBVmLEh2G1t7AEnhicCkVcuWZw8eS8e3AaORSoMbAFSw2pubAYspUxnhhUoRsr87HhWACHKSYQEjBKCNl6Art+YsBuOaUMwG0YIy2cKCQzAAscDAODlUGexUjkBKLum9er1t2s7dvPW7d7WWlJN6u9vu/l3ts+tuvNbvZCwJZCdzqQctkhtp2hlVSxYEnDE46E44zUReMqCcJ5bLGUfaFyCMMBh9yZG0KcAliSRkMsjBHcR5BdVLjqAAcooxgAn5zhc/KOmMEBE43rgkYLKOgXKqxUuwbHOCChOzbgAZY07W0bSaT87tWa+7bdarZXQJ673bas76KyW3RbbXb19LPVAu7av3maQruO1WPysAW2ghSAcA/MSTkcGkYbhgDAZSoJC5D7V4w5wQTjcCxORlScggJZQjkFo2KpIR95SApR13t86HG1iByADnIIp+1gzKAuMFW4D4PQc4AwDjbnoQW3DhaaWjVmnta2jV1tv10a316NFraz30srWvtt6rXRdOyacMabV2fOoBLBWJ2gnyztyzFWJCjpkFeoUjmRl2ZZio37RknaNxKjb824EnJ5wCSTnOGFPVcRx5fcuArOAQc/LvIC85HyjBC9N3oaRowEYyFHUYG7btZMgBCwY8kAk8DcSyjcG2BiKUY2032s3rpZb6q+za08rXGl+NtG3d8zTet29L6LVW22uRlWG07lI3ljvwF2ZXhGTDEDGdoBIIIwe71x8xOFIYoASoHGAjZbLZZlwQRlW42A42tZF2je2N7oFXc3zPvUoAdpySXIJOMg8YKsKmEZyeSSBhsGTIClQx5+8QQSTjdzuPIOCKV1Hmvqn13aV0te9uvne1r1s9He9tbN/y73V+r66Xsrda6lHLFGydwOA0hx935SpBBbnag9B8pwOHbSCxRlbBBDcMzY2ZRlAyHH3uduAM8nbU+zg4wuCu7IHKgr8wAUhiAvB4deGGRkiMAIwCqQWAPBz9wKNwG7AYgZ9AMjIwQKStZ32tfRq+z0b5lr5rTforOzsk9L2d1pty3+a/wAtEMAQEkYBwAVJ5DHaMYAID88nLDPOTwtRgmRcJgYbYQcFtoGWDMvzA4GVww5J9TUisuSiqFIKlRgKpX5ASMhTtDMFwA3B6K2CoELNuUnlBuC7gGywySAQvAADEDg5wQCciTtZWvdXtbqovTe/V7pO3RDV7arVrd2d9Lptr8P87XYULFVBClRlTjBIATbHvwxJOPUDHB5AIqXUavc2uJFTaLlgy/IWA2YA4J9zgjKjkk81djyPlIAIIAJUkYIU/KDzhs4AwFAAHDg1BMB9stMnJ2XQIGVUkCPHIGcDC/McEEHI2gUny2iu8o/+lQ3fe62Xfps30ta2q3t0asr3S12a6X16F63RcXxKHjTbkj5jsddwXaFcqrLnaUXfuDBgm48CmsC581w4dVbYVZtgQsHQj7uWOCo52FWAOP4dOJGRb4NtYS2FwQQi/KVMZC7mbG1gQOVwxIOAwXNV8pt3Z3H5W+UBQGAKliSVPRsn5GbhipBBA0tF0V9HdpNNWa01ez01ur2ttz0m1Wr3s1zQtLTrTj2899N7LUWN3On6gHQRuJLbO/ByFnRVcZJOWJdgPusCW4Xdmo/y4IJYngHAwHJyRtUkcBSQN2QvKEruNaKqFsr0knBa1U5AIyZjkgKjqQwGR1+U/JhN2MWRZ3YmVI0jCkoFO+TOBsYkkKFbYWC5J+YLndwVJ2jF625bXS10bbbWi0v96v1NoL3qqSslNNtO1vcpWuuqsm2rW1b31NK6QNBpiHaNunRbegG5ru6wSwIYkkjgYDY4IOGNFNjMWfIKqUK7upUIWdi212C4baCSSejE7qvTZ+z6bsZnxpyjORji8uxkAIOWbgEYUnJb5flqoA6glRnJ34bJwW5YZYOSigABTnBww6Cha6N20jtbVtR7b3bv08l3WHVoK/K/fm7pq+tS97vts111SI1O0qvH3wm8gABcArlzuDLkA5wQrEgD5s05goI3sD+7BzwAXGApBKDJ4wuBggZYk4JjZnXzS5RCrgoWCZZQVyVKknlUcvkAfIMjqBGZIym4PlWCBQWPmHJQBto3YHz4bbwTgrhQAa0Su9O13Za2Xe1m7Jt2uno9bHSrWSb2s7X2a677fhZ6dbvQ/MPmDmXrGOXRhtw6EnlPugnaCWY4AOKgmjUtHN5hjeLO4LuVWCkbVLEIi7wcZ2nIwMHGFkKruDhd7MgBcSOwd9wIYFQFB3sFbAG/AUVHMhZcyS8huiqxDELwVIIZuFJywwCFPKqMQ0pLRp2tKPbS1tbp2vbTW7e7vdu70VrNJNXve7aV79nb3tX1ttcWURjEjbiVcABSVAQ7ejFtoPI3MMBhlTjGAqou7zclmYBNoJCRscY+VARyCPnLH5gSNwGCKhLSrIDyDtclSBEu0fxM+4kAkOMElf4WVWLI45QcLMpijPyk4fzFUJlWyQ4I65LBBnYMHBMy3jdPXaya/ltpdJv5aeV9XZpq97Pv0bcWvNJq2jdt2rdLOBkfKwIOHLYJkwU/vYYAYOckgg4PGBTJHKY3jajAEHCqA7bDscl24Y8AgEqcsAQackqbQ28R5wDvAVtuI1zgcD+FcblJH3sgZpQY0LMfm5+ZQ33zlQcKqlCQOeQ2MEjIOar3W2lurb/Lv0e99k7rdXBJPW/bdaN3V/hV9bJ3sk/e1uVVe5aVUEseBKQuY0IC7c5BUjcWAPyAqzY6bmIWwnnbm850WLy84KCMFjgBDh9wVWViDk5BwuckVEscYLgDarFpBtKfOxXA2tgsxAbJQ4BJByoANSFI0jy5kkJQOFAffmIgAgk4wnzFs7FLbj8qqKlRfVtP/E2tFvu+t723e2lioppaxsr93pdK3N1drbLpboWkjAUeYwZxsx8wIIKqoRSMDHuVKsRwRJuzIoUsXVcsp2liMt/D90nBG1QATgtyQx5NVFuC0QaPkHCqXwxZwVGNnzHzDuIBBAZs7SRirBkA8sA7i4QZOBtPyfM5bhQQG5HU9Qa0i1a2miXROydkn0vaz7tX18y6jrolzK+l3q1qtbN2vrZbrdMc8WflG8BiCCpIPDLwACQCM4IzjHI2kMakiWQkKQqqjKCzHLMRs+ZQwVghPZnzkYLZAFBywRc+Wv8AEQm9gCVOAMEkndwQeMgj5jxJEo3RgO4K44yRhfl5JYuTkZ+ZRg5PH3WqZWd1Zq97bLW17Jpy1VvLlbT02TVk77q6V7Jp6Rs33V2k20tNH1Nm6S1lL+bGrtIU2HdIryhxt2oQrEEpIF3Z2uSjHABzkwE29w1pKRIPLZLZSCSYW48rO4skiSbl3uihSG3A7QBuC3hClgch9pba5kYbQu0IAWxgCH7ynLKHYtHuFc+5lto47sz+a7Ti1EP+sVbclPMi3HZtkVgWckkAFWGNxDcFX3WpK1276Ws4ppO92m1Z7b6rorn5/hmpxnC8pRdrQlfSbs04vpqnromr36N6kNwJHtHkhe1dmaNpH2bQqFDGjEKrFW+9G7KvzBvlZkDCCebyZjDu2+YwkhlMasUMyt+5Zndt27HyEHYrHeWBXBtSzRBcSOR5iARRYydr4SMKFRkZgG2Aq3zEZBY8GqIpMvMwVwzxlFwXmt2Jdtod8eYAvyhFQjcTlUYOKpcyikm3rq0ldLlStJR0V37ybtd2V9Ek6fLz87haKi0ocz95pxacbuTbTdrXlo7PcsafJK6SPJ5LpGQu6NUIjaNYyREUQgNwTNujBVQ74KsrmVVmuJHkmAVIjIsKIhEky/u0+0PuEbOc5aNlaP5yFwcENkTKsUzpGW8u5jEjiPzmd5I3IZMgkr543MVGcMgCEYU1YS7sRHH592xC+UkP7uQH7wYgqzeXsUsVcHow3Ydd1JSatCUr8knduS956NXbTto4pedloEqab9pCLbmko2jzON+Vy8lJ2snfVdVzXNa0gl+zsLgbWdT5gAJbylACseS4dSuTlxgkDauBhwIltVBZbxWBhEqqHLlYyAZVOeULAFVdZAAHVTkinrcRsxQA5eISsYmiMYDKu1VkKAFjgAFMjbiNcSFcwFxGrPBHtjUxRywqm0H7qu8cZkyki4jUvjgkgHZgHZLZJJ+72v7tlrZ2Wi7JJt72d3xrmbbmmpc6lFtLlWjTtr7v49LmZbWepW09zudfKYnNxJNKQQ0yLFLBCjM+6BVZBhsY+VUDFjW3b3UBuBZNOpuYIVknDuoYMRGANzbg0mSwYRsYzGSysXZgZpG2lIgp3MCoVVVSqqB+83bAMEl8AkKWbdksRnMksIZL5L/MgmB8zyf3rfaPLyq7iuGxJC4B4KBFO5gTQqTp8vI3P3lGSbd1G8Xe2107dG7d7q1OtTxF3iE6b5FyOnH7ScYx5k9WnaztZJ2367iASGNwyOpXMYGGQ5YZkUhF5JPY5Jwc5IAlIJLdWyAAcbguAMDAJYheAR0U8gDgjMt5o4vNAkCwJMiRk+ftD/LuILHEcKkFAqswDEDeQwWtFXQkbN209FOclmAYEDb1Pylc9RuOCowdocsotdXa/Lqt43kt1q73s762tpc5pqcGrJuL2cktU1F2v3T3tpd92NTeDglXOCF2DlguPvbi2w55YY3FiAeeqsxwu0ZyBnKkgsMDAABCHgrgY+U8DbtNV45BJPL848tGCbMkRtJiPc4YKAeeMhnYZwy7QQIVmjdZzE7gxs8YB+TDKVBIVDv+ZsfNs27WOVwARMdIp9tbW3Ss2nJap3bXXR72sx8kn5JqLdlpFy5bJa7d7PstNS9u3n5SpUHAOOjYzjaVywHfaDwGB6laRYwhkbJLMc5YjlcqVVQDjA4HcuMg5HFCg7cEkucZXa2Ixhcj5ueudwPzHknJ2monl2LgkEkqM8kMxKgKPlJ2EMAThQDjOOCS32mlpy731V42e9vh01luxLqkr7J6+cddXfre1191iXGGU7QeB8vJH3gTnGADxnuc4A4znO1NC1le4OAYH3FpNhVQYztUbdpwRtYgECTAHLYEtxcSKhaJPPO6EHBUhFZsO7bjHIWjwCQCAu7DEE80bl0ksrh1lO02bKi7jGJMCNi4RVJIXcUMZf5mBwWJD0c2to6PlcnbzUeZX663uvkujOrCQar0Jyul7WEdk/e54WTSvrdaaK/SyWtqJVmsrZCTj7LCwdC4OVjySGznqEDHrt3cjdy4bZNjBl2lQEyQc4HITJLIfRcgDbkkjk14pkWztm2yECO280qR93CqCBIQ2AdwLv8ALtGG+cZKTfMYnt3EbOyqZBnyhEQpIbKCPcVUFA+M5ABDEmqi29VZpKNrW1eiT3V9b76X/vWLqUn7eom7J152erV+bVNXWjSW22i3ujM0p8/aQFKlbe1jEzcFQEnOwFt25mY5UvGAwO/KnaraRItynk5PmMSyEsVBLAvKZGIUKnyR42kHoQduKzdLTa1yFfY/lWbKQAoJ+zyEb0AcH/Z3twSSTjazahjkEnEmWYHJkiLGPLZLAg7RGVTaVUctlwNuaiN1ytp7pN7NX5b6J2u7dV21a36sbpipq+jhSb0d2vZU3Z3veyV110toxEdInEI3fOZJfmYFgS5DYBYhg6/cTA+ZQSAQ1QSHAKrKAyShU+ZA2UATy3G0YY7zwwO3BJ55ojCujYVo5UkQFsgETfdWRfLyzI7EcbvlMa4ySWCxi3+YLg8KZMSktHIqqoZowSyEFgEQjCMWHTGB6pLRbpNvSyUUmrJNaJ6tWd3bXbBK0m9W0lfRW15U79t1pfe9kCo0YIh3tsYy5csQqrkMwOSGQZAVVQHkscDDBiRks4c4XIkWRVjBZV2LEoQswI5ZcIG3sNoUsPmsKGLMChVgmxTtLMi5CqzZIMjSc4IQHopBHFNkRNuNoZgodwDgSKu07nO3KYLAlQ3Hy7hjOEkrpJ7JdO7ilda3S1Wqbdt9bKebZNK7avZXts9NWtXbvptZuwn7tjkyRs+Dt2Ay7CduHUbfmBLBQVIVctjJyKchfyy0ksSjachVU4LADdJwrbiC27YACx3DDAM0QjMe8KVl3OGG0AylSyAIGV2ZYlGPvbowdzA42qFLxuJYscPiPyySCGGCCxQEqE5wHYZDZ+8SaqF72srq6av3tvfe+mnVOyTQNK2jutHdx1ez8vnu2tNWOZw8gUlgXVfL27FecBkUAMXDcFXJXKK+CWVWABRA0hfz0KqXfaDj55S+AFLs8giK4G3AYP0U/dIkkUsjRyZMnzoVkwPu/KWVlznJJyWfc5HJOAxdIJUDi3ZBIqgYkRihwpJBLDKyKFCLztJJ6AUJWvJp2Sukuu1tNdt738t22W3dKMUo6J3d7LVapq+jVt3omlpqRv5h4U4ZN2CwGSUViY1UxZIcs2WwVwSGxtOHorAHzHjdlUsGCYGTGo2sg+bJUlizHKgkjgZDf3qsSuzaqlsOjsNwOQqqGdWVsOol4GXOTglaFlQEogJLKjOQVdTISgPlxhvmcEp8pYeUMoMgruqLXVN2Sck27tNK65ftNNOz0WiTd7Cs7LZvfRJtNJNtu14rTddujTtIEwceYjKSZQZInIXA2iLexK7EGGJPHVkbduDLIW+UMrfOpUAt2PzKzFFIPOW5bgLvJJBw4sxdQgTyynTbtZWwGVIskIdyox4wfuhegw1d4JwQ6R5DKylyoBUqu0Hyw24NsIAVed55VQmkm07xXNon1+G3r0s/su9triu1a/K20rK8U9Wt3fR6apro3pexINyKibwzrgMxUbWPAZjtyGXAG3kHAXcCQwqtfBglkRlSNQtCQcNnlsZC8BcdOTx6pmp9zRKOVdmIztBztYcLt3KuUCEKAoJJymVOKq30iKLKJTnzL+zMeQCpAYsSzEBUJ5AO4gkMARtalL4Wnvo9HrvHfV9rPXXzuXRv7SFtVq27LXTV2W11dvqtdtDQwFcjHJ+8p55DLzwAAuBlVB3AA4JziopUWVHjmVXQY2oSQCUGUkBiJfeCd+WwGG3IA5Z5Vi/DB8ndkg5ByoCqCdhOCCVHGcEdRgDAEEK2SNpHOBkKwJ5GPvZUklwAcBgoAu10tFqrX6qPuNO17d10i99nrEX1T2s1ZWad007vZLfv220ZHDFDiOFSF37hubzDkKAPnZ93IUMFOEJAxnBNU9NTFlEygqcXDfKM8/aJDnATAGOoIAYEg8EY0sR7lDgtlgygdB93+EAjGM4VchjjG7kVlWDP5ZR3LRKrpGCpLFjLMxDHKB1wpUbQRvxt5OKSVrK10mr6pRV0rq2j20XNdvRb79cbvC1t7+1pOTad2lGfV367376WNLbEgWOFCgMFsNjMzHzDblC7F2DDLDKkqoUFVwW4pvzKoCRtKwI373KhR8rF2wACVXlVDZKMAw55llVCvIYo1tbgq24sVaEAgsU34PReg3LnCsFIigKyRxlFZUC4Xeh80qqqCpwXYMWILcbuBk4Oaeml0k+jX/bt0k07Xve/mtGtTnafxJN6rdaO26bu72e9tNn2Q8eYM8AkDEewLtflQHIy6ryMkElWC5Y7ySaMO46jqKuioUSBRlUJcKoIDfN8wfhs4VmGcYON+om4ZUlS7YZSVz8p2ZyXwCCcDIAMjZBALAVnIoXUL4kMQYrbKjcVyVXn5eONrZYEEY5DYK1XyXna103y6vV3stLPe9r6HRQd6eLV/wDlyrPZL36d9NldvRLRLdlw7i6sdoLAJ8wyCFYZLHrk7QVIxuOQ2SpxmE3EVkklpiSVbi8yrYKtC15L5ir+8jXcMBugBAcnjg6kZLMCyLuLBWBUEnJX5fl3A84YnjkliNpyK1uweHcSxImunKlM7c3UuDlSQGbJUHoT1HTMyjdpXd7O1rP+Xr6pPS7voRTajB8y1hODSb010V9ejbXdO99bIkiVUQADhNoGCucDAbJAbJBLFyc55f1NSoRgMxU5DNkBVGCqgJ1zuULgsV3OehyFqNHGFYq5MgClHVd4UnJZlBDAjliQdx3IcOvy08tHlELMN6jAZSMqoUsQQrgALyNrEOwwGVsgNLSLd7aJOzSs1FLfrfRettXstXZWV3LW6XRx107LpHXo2k02OSUAAJJBXGOcswUFiwxwp3EHDZJz2NZ8c00hZIolCW48t5piWDSose6IArkuh8wE7tpwTggg1OJp0Yk2jGIy+WjiWLzJCWXEhTGDGVEhdh8w2EOQSKuKg+cBtpO6SRlAwzsmGbcgIYO2eHxkDbn5hlv35JJ+6r8zSad3ZWV0/lba6W2qtS9mrzirvdq3upKKtZW96zeiT011S0gVG3AiMCI7mlBU7mkDjYqHLoCUOM5G3JVP3e7KswXZtUvkArGuwEYKDDtjCHHIUBlYhRvG4AhjjBifzJQqghAZW8l2ZlbEittDPySo3FcLtHO0GRkLI2wqrbCN0is4j3bc+ZySW5ycFgMZABHKUXqkmtbpaPe3oldbPba5Epp2Tfla3w3ta26d9tN9rWekMa5RFSRQySxseQJCxCKQUj+8nzEBc7d6Bc4bbVlxuY4I2vlQo+UpnZjOBlQqEbhxk/MMkE1F5AaSGbcY3QIqlUfDRMS32d4y3OcRsm4AcBQPvEzLEfvDJ+U85cZkBVx8qgncGAXAbuQvGFp2b23t63WmunW97rS1vkVJqytduyeib3st1dd2lt0dldpNgVUJ4B4X+JhgL8x2KwwDknB28AjAzVgxsNL03hMPdatzuTLlbgLvLFcsRGdoDMCxG1uANsAJCg4eRnZVKgkDnBJVZMoEyCFJBOTtzhubDEtpOlO2/a13qy7AMKrm6XOEQ8NsDbi5/dnIXKbmFRjra2yve3nG6X5XTt2IldSpWW8+nb2c9tWt1o13T1sijtHPB4K4U9c/KSWUZUDHIB59OM4MEEBMBip3qQOG+UEgLn5SCPlzkcNkjAqbYijJJ5Iwuf4RsJyFwoK9csxC4BGR0QIBn72OGAI6gBRjIGzoTnkgkEKQTgXa/p1vfsl0f5311Xc3V3fq2rPu7qPXq+qu7rRvS5A0cilCRwACOAxJOCD8gBJAIyCRtPPHIAi5JypV2J2gHOPu5X5+QMZ5GMEEnjGZUEUabIo1QcHbGjEbmyHLYIJB3A4Of7wJIOHYUkjIDbM8Egt0JJzyScgNnAbruIBqmtI9+0bpdPS+t11emhtez6ptK2tt+S7aXu2vq1r/AJQDOCQwycIQRwGG0q2T1YnADNtPynI+6SwnYwVQzjAAwNoP3eHBO3fz2IJ6EEVaC5UFgMZI3Bcs4ZVG7qMkYDZBxjHJJUVGF9FyOjYGQQcfMgUkjrgsQ2CMDJJpWW730u+2172tfdd9dI32cJ317qKtpbaNl5+ndv0KuzCkg5BKjJzh5Pkwu0EKCv8AtNjONpIBpAhA5JXKghiwBLMVBxgEBi3K9Qc5BU1MOQ/ysNp8tSdoDcKGdRgFkAU4IAO4HB6Gm7PlUZBIKgkliNmFznKkcfKRjaQvVf7iV+r1SXZX21tfre2l1u01cuOi1d9tHbR+67ta7pvZO2hFhVyCG35AweATlFA5YDHykKNquzZGehCBVQttzgMD0Yk4ZWBAUADB6HJAbIBY5FWdgzgAcqSSAOvynBY9CRyeSOdqkYpgG5sfxbflJJPpycgY9s9QMn5gGVxj+CXR+S6X2evq9LtlRtZLXRWfouVW16qzaa1V9LMrjIZsA84OAD90EEEDau4HcMhchmBJAHNBHO7JKfcYqVUBjsxyCAOOSoAxyQSCQsoUNg7iSG2kDcGYYHzDqTnAB74JyCWzRhSWABBOSeCVxgZOCBhRlscHb2wapRemifXVX1XLbpvbrfZ2320TTStZO97aP+Xd9rbavS109CIjBzx8x28j5c5GQBxjBAPXIAUqSOA0qSSCMKEG7KrgAFQchTgAAEqckDOeQKlZNwVhnJAyw4BPynOApUAZy/P3c7Sd2GyZHk1Fza2pVLdNovLtWGDkLuijboxK4wpIyBnlBtabdXbVpK1uZvTZWd7bv/N3NadHnbnKShThZym918LaSe1+iTd7XvpchkLajM1nav5VrGy/a7wDIdRx5cW0ffYEbV4ONzAbBg66Q28KLbQoFiTOwLIApJynmy8rvZ8gvj7zAMCjjhsaw28SW9uFWJMnCszOzMcGSRlHJbKuzEYRhgY+TEqh8hmXYMKeWzuHykA7lycg52gFdo+YgnmUvtXUnazT1ttbey210e+qCdVv3Ie7SWqinrJ2VpytpJt8zTVklZJPdNwpG3kBQuATnA4x8zAqo7fKfmHTDAGmOhOPn/hBU5c5VQvyhlG4cAIcEZyvBHSchVVshSWcncEwFQKvyE5ztUkfKyDcTuXCjJhb5VbeNwwAGVCSV4wxBJXaRkg43AbiGLKaLe69Oycmk7Xa1vzOzve+1r97mK6N62auvTlutW7W6pNtK1nfVw7gGLbyqlNp3fKVzgtk4J4zn727BB78IwLH5RHhT8r/ACDzVAUn7x3EHbggBS4fBVcCpSCFAYklSTIRt5wV5VgpUlQ2PugHBLrjFMBGeFPKlmLKCwJwqk42lQRwx27ht6ghQDlvrfWyu7O/Te7av0fe73Li+t+qStZv7PfdWvbZdNerQCZCflwDtKFmOWyv3VOD2wCdxRs/w4y8qw3YG7AJPHJGEO0hWwTg8BmJBORhDgtDAjP3QGLkEmQuVVflZFCuiEP95m4OQw3DhR5eXAJ4JViQEYuQi4ClSQwPDZ5YbgmWJAST1d768q++Nra23/PW+xo3e+vu3j0tZ2Vt7tvS6sknre+5o26INM1EKzFmFm0qowDIpnUq0ip8qkF2AR2ChEDDK7jWeyrkBDlTg4xuIJkDAcfKGIIJBPUgxsVIWtSwiVdP12UhQZDpzbXd9yhLkKgVcAKnO4MAwQvtPAINBlY5HJGS+0jZktghOAFGQVJBBGSSrDIWqt8LXVdXt7yf/gT/AOG2MqDTdXl0aqp3e7bp09W23run+N7FQgjcGX5QQM5JLITgOAzBuildwbk5LLk8QgK0iLkkRA4I+RDjZsB3AMAeCCOAxAyuBm2+5ACV3quxQqjAwPLwwzlXK5xkqOMZBHNJIQFYbuR8wBI4LYJHyqRtGcsOVPLDPJqLWemyUXfXy77emuzSWx0Xl0vvul25bLvfb0v0b1pMm+RJGzkKxBY/IzEoERlZl67FUnnIITAYE0BysYkEbrhkAUbWVTtj5bPGRu+dOSqfNnaciZpI0bJblmXaXyHJJUbR8uxRlxgZKAKdpOKaAjNJIruFYFSgkYJyqLvAJRg74ZC3zfeIPZAcqtZK3pru1a7sl6K+zS0jtSb06pW6a6WX5PfRau/upkJVgTtfO6QYXIwMkYYYLBVHQK3TeQFzg0BJN3yiMggGTI2MrblB27shsKCcEY3Eg4A5nWJP4k4ZWYKS2SSTkcAYWMNgpzsbgE8ZQAYyWYlirYBJBKhAeBvYLtbDEEMp6fKaFG6s3eSSemyfu2fmujvdP1tdJt2s972sn71lFaJ26Jva22q1tEsaDapHQ5BLKASCuAQCDk4K8EAY4AJBo4Zw5O4JldpQsxIIYZblg2Puhn+Rl3YK1I7BfmJwAvyjGc8KQAGD55O5iM4LEjJwarusgkVlZW7Mjb2jMQZSX3CRULqCFYgA+hyORvtdtvo9do31+T8uqT0LTet93rpv0Wz+a9U1qx/JIIAf5goAGwAnaSCTxgYGQACw4UrgoKxtUQtKf3jeYzjy3YBUcqNqqqqcqAv7zGBhAwI6WFUhWUou/f8AewoBXgI+Ax2/dYDnDg5KhgCQRPOjKzMVOFIDMrK45VuoGAVyQzEn5ssCCWLN8vlZpN27WV0rJvpq7afOk763W273tZPtpbTb08iJYwIlihYylSk2GVpfuklkOGw8bbUCkx7QQUOA2DOpYKXKclPmUE4BJwVYg9AQPvfMuFUlsBizcSQFGWUBdzDYpKkKRhtzSkjuCpP3WHAJa4Uqm5nJYghV/dhiDGCXyQfLRhgkuHGAABtLUuXl1Wqdk76pJW0uvV+t2uujitVqrLl89LJa/FZar7tV3XCKqqI12ucZKkgblA+aRgAQcfKwU4wSDhSKdsVARtG0EKFUnaoIUbxuOw7P73BIx0xinq2TIHLAqylG+T5ogqBN5LHKjKnrhycAEjdUqxALvUbQVwxOSScDcGORhThQCQQMEBuDVKL1u7X6tPya2V1rttrbdWNorXr8MXZK9lo+mqukk7Wb3SaaICrMUG5VQLkgpt8xCFXbvTII/j3BsDHPA4VEWEADIRdkSjltpZVUlS+PkIB3AjqMDI4Lwi7fugNuwGYMNykbQuQQQWDEkjCuWGcMAKcEjjVpGJVFZQAckKGAAwWONpyCCEBzgrjJy+VJt7baq3Rp22bS3e/3bq0lbmtZO2u1kuXXpvZWs1p33BEXA4x1JBYbiMD5jtw5DZ6grjOOegTCSfLg9CVGTuDAq4ZCQCQDkg4IJ69sTKHXHy7+i8E5xgHO77rHsOBkDLFgCA/aWCghRyH3EIdoBX5SFCngZZgSQeTgsMU7eTcdE9H2itXZvmb6d30tZNK3TS6V0vTbRrtdPvZJalWOIguGJO4k4Kt91gu0DLcPgHcR/EpJI+YUrmMgRkEnyy6qGKYUBBncBjcG52hmywAUjipjG7gsdiYIK9ztAT5SxZuXJOMcZDDg5WkAlXaFj3A4jJGQoRuOAxALbgTw52tgDIJBlx93ezSVovdr3Xpo7u978ys7N9HZpXWztddL9YtdHtv27K17QFomWMHbIG2BF/i6jBLBm2sC5YswJIBPQ08BwBiPcoxuYA7VPyKDuLYZcdGzuLA5DEbTOShQHaSUmCYChQCFGGYqCFYDBypIOEYkk8DKMNwWLEfKFGSuUGSCMYGcAg55HQZq4w7LfVNKLu7J26t+W9tE+jKir2lbfZ20+y1pqtFovlfs4FYou0KTuySDnJA28jC7QOCVPQ4/h5yEBgN+AMBgSB8rZXajM2euBlBhjnKnI21KVChSWH3eWIOcjaWyQcYAx8oBBzjBBaoG8t2ZWDYVgByAXdRG+9ApDFPlOVzkZwCQVNKUWopWa0Vk09UuXW13tr0vr1ui1fS7SuvLrbrd7P8APURsyD5T82Tg8gMqgBkbfgBnCDaQPmAOcSZFM2DGGDA4V1BLcINm4HA+6eDtVsEKAMEsweow0q5LHccsf4kOw7RksSzdNy5zjDHIUhVzGFyDtDiMHDZAIAG4kgEAZO3nHOMNxUq1te1mrXfTTff8rq+1gdn52/Sza6at7a9NVsJIODuzjIOV/iDdOhPQD5hnb905BAJqOP8ASrMnAHlXHDOcnmIjGSc5yoUk4bJGBkAXJlKqCw4YqrHPUEqdygYXgAtknjAwSBiqkqEXNsyE5RbobjzGwYQ/MMAq2Bj5AcBFwNvLVM1ZpKztKNrO/VXV7rZ2Sb7aO24t13uu+6S0b3026PTTa5qrHzc4YI7adcMSWIGNyFQoVejDjaSVYjOTg4oltrKA33yoCucHOAcOx3YPGVHVdvBAO0aFv5i/bVyoVdNuVJcOQGZhtba3Hc8ghVGMhTycvezqCoTytpdWGxwW+VsLkqFBVgSXDMSS3JyRTeset+a6Sbult6/ld32euNFNV6m7ScOjenLF7LVO7fltfqy6FjWwvXzly9iAQ+Ch85wAAAo2lRncMHABAA31nTLlCMgjBJIznJ2lsg+mSNvHIGCAcC+kkMljcpHIz5FtlVOCJFm3MXxtVhtkVQ27LqxYBsFaoNtCHazY28jHG/ONxxtU7jt24OBuCjgYKlHSFn9m6S27aOPW/Z9E7rrrT1dVtfbjb0VOkrXtrdpaWs+vYlmYSRaeXUo0Vgu3dgIcXl1k5ZnLB+T8oHmYZWKkMarBow5SMFiQzEDcCiqygs5ZfKJUqwxhSCgAIBK1oXIRItMCkEPpkJCgJkyPcXJJ+VSn3n5BJBPzKAwxVBm3MxGQ/lsGJUqoIZsAbSpy5wD8m6TocY+ZpNWtZ25bu3S0NF0v0XS+qDDt+yulZuU73WqfNqtLL1tpdatajZEIjUr85C8fdI3bRkHuSQW6k7SSQGzmqgQSxLIjGNlUBWABKqqqTGyphcAkHBU4wAABtxOXRsorktxu3BkbJ24UblO4knYMfNGMrzkGowsUYaNidpJyC0hJDBSI87QCVYjGBnHJJ6VEnzNWta2r5rq6tqt77a2u9OjRurO3d6WulZ6PWTtrt1vdbXRUVJFYHDkSyh1mztCA7gqOnmjOCu2ReFVQDjhg1xWKIvn7C0jBWZANrsyqVCgB8gKCCflwWJ24Y7iIMdwbazJgliN3yYjwN75DlmUkMAd5zkKwFMELLP5vmuYyuAh3Kqv8pJVQ6hlAAdQFDByCDwwKUeXZNq+q00s4qTtfVJK+jTu3pYmzVtJP7V33bSd0nfTfe+tu9p92zAJALFsAquWkBXhGKYwRgA4KkDplgS1Y9qgEFWOJgxcspYgMQucZweVAUoT6kFiiq6FRIv7wudjrtzsygGCSTG+VyXO0Fh1yassWKkIQGzkFlztOEY5DDuAMAEDHJBwKpczs2ld2tprFJRvfu20nd9HZLYuGq3ure7fl0u1a77W1XZO76squjN8ueAC6k7iu5QAE2sqg4BDbGO0kdRnNQp8rkpjIhUMAWB3/ACkja4ZS7LtwCSVztO5QyC2I8cbmCOwyDkHdlQ4HLFGOMsBnAwcEfdifbGrsqkBHJYZIGWZBjOMHcSAw/Lj5qHHeTSbTu3u7aXSstNF62fkNaa63X36rd6Xemi6dttGAJkGEFpWfa0jOf3eURvnVQAowgyuSNrEZ2fuxciUlBv2s3lD96Ag3nABUBsAMCMDCksSQQpGTVWMAq8bEAguFGWBkJ3bSFIwCrbdoyoLAqSgwJtxQqsyElpuHBG3PIBcMWZDjdnDEjjjnNKKSe1tn1a6Xb0suru7N3Vn2Fft2ve3Xl7ppaX273urMmMCSx+WykAAPtyVUFcKmBtUnGRuB54B4wCUdmIKqpDEMybgCqkEBWLlGG0EnbuA6hcjcpFhs5DKWyA3dj82M5xg53DOGBwVA+9kA1l3F9nIZQGDKFVHjwpPA3MGPIZTwQDkBjuoa1fdrtdrZu7W1tUnfvp1Kas0kk9eWWuqdoXtotL3dns+2gQFYkCNIJpH/AHh8xssWYqCqZIJRGOBld+ckgEc2o5kieNWbcdysCNqDaxQFgduSAcjcobIUnAOWOdJtZ1YRlmChA7LuCnlkIB/eMAcrwwUEksWYKBpQKHaGSQMp+VlD9h8pyXHzgDsOCpwhAAFStmlfRWXV2sndt3b26763a1ulvoru/S19le9mnZXjv6LRa9DJawxLJJDAFkOVJXKFiWwGJLJtXOwrwo/hK7S+eeDQfaZQZ1jZ1ZyGWQhJJEWPyCpLI0IMpZyGBOcKzOCtdDcHzVWMAhSwbcQpUbWG5PnO1VPzFuWB5AJJAORfxrHPb3E1vE1uwW3kD/u1DfK8My73ZSRhkjLAqxyHJPJ5cQlZSSSSlFtWdtVHVWvrd676XemiPz/Byd3Gc5SlKL5bPW8Umk07rWN2r69L3dibbDLEys0YlIiyArLLHIMFMKpDpD867FIUtJg/KxUipd280r7VlLMEYwrukjVGiKhHXecszoioFIUs6knaDlYHuLiaeG7jt5E8hNsgZsmSESOjvKoaJQ0TBQgKhsfOwZVJNsI8m8pKrK6s8zKSQpcBwCqDfHjKgkOQmfl4JrJtTVorrFKSurpWavd673t+jR0csqTi29LXknaSg01pppdxs7Lp6Fc30cccMcEYeWUiBxIsRRTGAZJULyE73WRgu04AJQ5JAF9zb3Xl2jRSi2UrNHcbYYHk4VIlj3Ir4Yj98FZgzZJwcloPLeSPLOo8txNaymIAqbdIyRMoYfKQcbZFKhiHJ+cVLPffZoFvhG00W5EEYcoqOcN5kbkvCFGXjAIIHB2jcpLhypN1Je7ZNtreKspd3Zvtf7KVtxSV3FUqb9o5NXUpRtNqLu3sla6SasnfdXNK0ulEC/aTHE0D+SYyAvlJEp2OrZlJBVHbywXIIHIyu2KW6ubxH+yQIZILkK0Nz5ZMu0BXkXDxSBDgFcBl3sSS52kSxyfaIWdoQ85RgqMIwHtzEzCZHTaUZlkDAklyGKAcgCt/Z8NxNa3LzTIkOyONYTN5TFNhhG6RwFJRnWQoVwQFTK7gNbytGMZeV0lFpPl1k2r6bvR7WtZnJD2UalSVWLhNPZ3nC+jty8y0d0k2/d1dtmp7dlwyrIhX5SUnVg7HdH5xiwzZCOjKWQrD8rFASWKrY2cT3VxqAm+0GVvLhBQxx28I8vcixllG5znLAe7cuxNw23lsSTtWEM42SyBI0YgFS/zAIqsSFU7Tv+bg/KtvJDIn7mRZBt27gqpwFRWQIYw2VBXJ24OM5JAFaqMm0puNkrxi3pf3dbXvprb3WrtNdWYupaMpU+dKpGMZe6tm46XtdXemjV0mmtXeOKG2R5I5JWnlFw8kUdyfniP3QkPJ3gFgx25CgbVKOCDLO6oqx+d5JdDGXCPK5eT5YVVip2nKlVcKNgGG+cKDBdPK6iSGFrgxuFALCMbVKvNIrfI8hQI3ykqAcMwPBMpIZVAyF2BjkIxEgQFF+QON0YbGQcgnKv1K0mo3UbcyV77cySjbVu+yfXaysk2lMlfknJ6bS1ho0o3aX8rTTvbXVu5OiyRwoCfOkjA3Hg71RAduWZQ3K4STAaRhudRgCkiCyAXUkOJGUbdwXzFXKv8AMq4Cvv3MGJB5GcjIBG7gASBUY7SGVhtZQFw2XJIxk7mPLk4G04ehpkDpHu5YEru+VSCVHzM4wO21RjePugHAqkotpt3gtFe17vlsmknZ7JtPWztZXRlFtp6c0m2m4tuy0vZLRq2r+eyuSSMFVWyoLDbtIHDNgju5ODhmyMAbuPm4y54fnEkLyJK0u4lVkcFSVDRlQUAJ2oURV+ZDhyiDInuBK0JMEjLMwKRSnzDCpyrKyKmNpjCsWc/dAxzxVZba8to5QHN1uWQ25ZDm2dBGgP7xwrRbt20HLlCGyZCQmbd2rp8qS26N26b2ey1XRq+p0UElFz9pFNvl5ZXtKL5U+jS1bfa2tv5pHZpQUCSIjo5VkCqrY+VUiQsrqCUGVEi7gMKwKgGpePKtlO0g3ssAQ+WJVUI4iQyuCeQvdg8bEjkMAc3Y1lSOOCR4J5xjzZVj2jG3yyGVcbBHjKEogdjlgRVS63LFqKhkKPbSTLu+/EWIHlEyOwCko27AKhhyVbaKS763s01bVuy0aW93e9r9L9zfDO9enFWcVVp2Sbs0pxV1f3t9dbPy1TLdsoktbVZOFaCF1wNgJVPk4UlmyQrEKx3DOCTuy6XzGzCFVAdyF2YBXYqFTy48nDYLAjdkLyvK4JYACxs9pIItoWPzYyWj3dWCryB04yCwYkYYRySFnQpj53cSx7QWUIyLlwr8dFdwpDuCVA2Asmyl7sWna6jzW3d1DpoklF2T87pXvaarlLE1LJNRqy5ebo+Za6JXd9t7Xs+l8bSvMEkxiYoGhsTIjR+YrALcRncA2cKyYkJYAIzoGz8taq+axUssWz5nkdArKF37SmPNGQNpKowXKPuCh0IkpaMAfOZVXcLa0VSzBWfc97tyBnLMTnPCsOo4G7ZP7oSM+475GDZ2jJcgAkDCFQCDlueSwAXisoq6U2273bT1Wrha6eiu76Rs+2rOnHTti5pJXVOjd9f4dPS+nd6X0s3foQBpAGWUYIVYk2lGR0IIzyWBCnIMgVQ4GMKSCarWsAdnjgiScygl1WQuVyuZARxuBAbeCFz8hwoZjZmR4yZEy6r8sjbQMEtuZ1IdVaPAOEHDZAZOeWJJGrnkmcqGdzhIwqomVBVu/IKYILAZICEU2k1FaWWmulm2nq0rPysm7e8+y5YycbuLbbXvJPRJW+K7v2dr2vZpd3tGHydxCkFVUkggkjbz0zzlgDwv3WOAAyIZ84Lgg8gI7Eb8ANhQMCPDKFIydwyW3KBTeWmeJ4F8hYN6XIdMu5KqYfLKLs8vaxV8ZGCQW4wjHyygDMqhhCzDdgqrIyxOd2NpUEuyqx2Y25IwBPVWVur3vbS6s7K15XutNna1r0k1FJtJzUWtU/d0avZ2vpqn8xHEe+OXaSVbyncFgV81SQjMRGAFLBiVBIwqIjnNJKDGfMALI2Wn3MrZIXLMmXC7htAPyjjqeCtSRvHEPnxGN+1d29hsZlxgMuVyVJTg5GWLFnbLpGAQu7gIWUALgl1ZcDB2FSwB+fBwyggjALGopNc0nFJW103aimmnvdaNtX0t1sldxa93T4Zdfd0elu3Tv1vsV4HEw81PLkinxLCREqbcbhKG3bSzzSIpIIYEhWDMMAKroTtLbhIHkYsqF4ifkCEbzuCnbtwnG5WU7TtpxIQfKoYL91QvG5QGMalVceWd56KuN2QBuxRGJGILlcABw0bK6R/KoA3BdxZSCCSrY5BAOcSrRS6PdO1+1uujum7XsrqzNZS1dklBtKKb1Xw/E479VdpJvVd00mF/KWVp45MKY1AwwGUBk3oDGWYswYsycEgkkcoUjbck7SKUlZ9xlVChUFRKCgbzAx2l8leRuUBcktSWYsfMWGJWJjjRHLyI7sUJmJK/K6x7gioW4YJjaoqcusoBV1cIpT7+4bTg5GF3AAHKk5wxyVJ4o0lq9tLr3tvdu973Vt2rdknoEk4PTR6XaalZ+58LVl1d7Xtre/VV/wBUAAfn2EfMHUsdqgs6g53DLSLgFcnkbiQ1eMNLMpO0qQoVYw5CKQxG125DMCfvAiTlmIaKTYI2diwSMFwuZGICks8ZHyglw+2RSQBghsoWoDlrdMZgM5iOJQrMoZVKsVy0jO4BAf5XCHpgbaOqSWsdUr3191Xur3t1V9LNpKzslFtXteMm02knZ6WS10T3drLzeylkzt2Rrk4UEE7giDG6ZiQgLDcwB3ZXb0zuzXvSUgsR8ikahZbG2qGZi2WK43heCpfkFmO/KoQTMmVLlhh9zqhcAb2DKQrFtzSFyAFJwTkKSpXcK98hP2AqxMg1CyLndJgEkgBcDbgcgKQrAkK+VJUOTVne1rJJLpfkbbWiasr36q7urK10LKpSjtq9b3u+W1m357WS1u31NHYAu3nALD5mbO4EZLEj5wByBjAwdpGRSsdoAIyMKO2SDsXzCWIyVyfnJHJ7ggU/Y+c7s44BHGCCcnbjG3GCuec8EsoGFMTAB1VpACASpAYHCg5VmIZVPbgA/KOMCqjpZJrpqnZaKKu7NW32S5bbab5929G9Uul21dee/wB731QIRlcFSEb5hgNjlcFtoIHY47kgA7Qc0rZQbdQFX5BNtbbgZE0oYYAZhg4JIGSSG4PNXUhjLLnADHLZcKM8ZGehXIG/qVAO0kDFVLNAttEisNpWY5EhAYLO6gkheDtGWJA4IwpXOHFK297NNK+j21u9U93u0r+67G8XH6rVWvN7eitdknGfaz3vunvdXtrpXJcmM+Vj93bYcHAVRboS7fM+7A5dcHGUOQW4qCCFZmuF3mfG0P5zkMnyjIjUqo4VVDYC5JJAZzm5KVEi+WCT5VspBUEqpgQgkEqVwC55B6hWO07RBujaZE3SF0UNkFthBZMHcEVC24sCh3KCCB8w2s7K65krXVrqyW3e7una+tuyW7wi2rpOSvvbTstVpa+l+2vkhw3LIUZWwxwpQH1VVDZB+YLkttPynkgnNVBj7bfLxuxabRwzMPKbB3MTuDEjcp5Ixg5xWhEmDI4be74PKoEQAICsKgA4LDG45KkkHGATSCl7y9KkcCyct8pJOxh1x8ysMD5WwSMqd44a1vba2i0WzjfRXttpZbdG0b4dNwxGu1BN27c9PbySurN9eqsPCqs+/Y4kZBGApcAqGzt2ABQuAoD4yXVgRkhWrwFVhXKkAz3MfmbFVYmkuZyVYsTuHyFsqMg9M8rV4mPhmKgAhQSRhh8q5LZO4bsYYKATktg4Jqwu32GNhhi8t2u4bBiM3MpLOclTt2MWAw2NpBAYlkopNW0sru+rv7tm2ru97NNpt29bKE3ySutnTXM9lpvo297O6d7u0eln+UwwYyHwwBVmYgAOpEhcErtVSB8wYEKN2MlRNzHHuIYj5BhUVS3KZI28BRhe+CBnvUaxHLh1UhXJ37fmI+XAARyExnJXAbaVI3EqWlV0eV41IMyYEqAtuQOFG5hgHYTjpnkgAnqKvay00u9bLS6dlbrez6pbekpte9a9tW9Nny9Gr31evVtvVc11BMhba46LuOcdQuUIXHVDjYCeQWycnLDtLeUsgDgZZd2JNjELuKtuYBiSuSSCwHKtyJim0M+CScNIoZgXOct2bDEMuBzgDjAJoW1UO06OySMibiHZgVUDEZTO1Ru2hlIOWGMfMTTV7pJaab9tPl0eq33WxHNbfS2qtpZq3TTortrXrqyrtCyhZEkZTLGUmCg5yWVYn8x2K7QuSwwV3HcQVyJxGNmSz7t5mRtzvgEhlQnoyOdpB3YY56gU7E4uGQQr9meHd5+5FbzAyqYiDwNwUY6nBDM38JG2kxTCVgiI0e0s5SZjsMatuZMBBuCbc8qAMKpWko2s7bNpNpr+X002e9umj3HK9ua1lyu6btdWs7J6a3uvnZ6WCjOSOxILMd2d3yskamQEAlduVBA5G1lI5cFJwgTYPLIDliSdqpsKh0DMBn5mAOFJbqCSIChMbbyVZiG25BUBTh2Jk2hmIwRldrEHDGpLZQf367wZOCpdmUDEY2RLxtUAYw+HGScbSQaWr6X0b1V1qmk9F630872V1zNpPRJWaXVP3bu6Xuu2ru9Vpr0aseQMFcMVB6FV+4MDrnIB4OdoJK5OCt6WN00vSujK91q22MAksGuEUEKFCswUsWdi7LvUkqjkNGsapsGAoGB8oxjAJwACeTuVmBAORvA2gGrKwRnSdJcFWdrrV5SWf94jNcqjKGyqhQSrjggtubBJBNdVbTTddfei1970X+YKV50Xdu9VK3/cKa1W2mm3bboZjRgsPu5KhcDAJPy4wvIxkg8nfgMAcYAYVIxuUkqyj0B5VTkHkHI6hQAuN6gk1d8o7ie5wMruYDO0jHViuenIYnP3cNgKEAbTzs6+vTIYAD5uPmckcY2tnpai9dLLReq93bW/3at7d31c23LdrrfW22nTR7X1XVLRXp7GIJHIfDn5QWQqFztJbkjJGMKGzuUdacEK/MFyFUKBtBZR8nPAADZJ+U5IOQByc2hGEAJyxO0Ko5IwU5bJOMZG0Yyu3ghRimNGOxAKhW3HhTkAFRkhSCOcBWBIOCCOFZ/ZXNpdO11a60dtFvbVPfW+gKb21e0XHTvHp6Wv1e+29IRYBVVJ54OQFIyp3HgDkcezEcggYRlLKMAA+p7gbCVOckEgAkheQeACwYXcFsHjaFGMg5ITaSDuyOvHQhhjPONsTxyMoCSPAwZWJRN+4AZKMZBlVwoAwAQD8zcgVSjdXtd6b20Tcfu37xldK3nabdo6ebfny77p3svN+VkV1DEAvlQQSoyS27jaOQSOQMADjCktupm05+YBTtG5clgeFGM43Z9c85IBBWrrQoMZ5OQEC9SMrsB2sxAAGQQ24kHjbmkWP7r4G0hQy43fOSCMhWbnO0jJJBHyEgYoUel79HdpvRRvZLb8fuaLi1Z9ei2X8rWuml0r3tbXYpeXlVIOdpBwScAfI21iOVOOduO2Q2CNrDGQdxHzEgAAZ4Hl8HgkyA4/hwR6YLVcMO0DB56HkggYTKMp3AAHJxxkjPzKDSNEQwLFcBAwUHhjhchlAHRR98sAcBhhRxfLtZLS3xdV7qfq7enW6auyr6RaVt3bXutNfk7Xe7fR2qGMnggLnJLHP38qFLHILchScYBH8R7qqo4wcEgBemCQAuSGOCFXj5uOcBl6VOIwFAJI7HgbgWwTkDBIAxkZx0KngYRckk7e4BOQGJIXmQk53dMHA3g5Pany2dnZ3Vt9N1a/2bPXb1vZ61zSt2atr93X8fxvbQx7/KWN024BsIoJdl8tXeMbjgZG7klcdicfI2bK2cdtbLBHGRGi7lIeTJkZWBkeT5fmIwzjaSQA4O3Kk1RGaznAVskw7trFRgSxgOAcHA3YViOjEsCSM6TptwiqAMKu3G5g3HAdW9DwwGQDjJ2qKiSUnppaK313131t0u1076s2nOSo0UtpTm2tbtpU7N2fm7XvpdamSsWCxKMz4LSSZZ/MAGMDAVcZXfuztww5OBl8aBSqrg5wRjcpbKpkNnICglTtUdSdmMFRcMb5bePnRhG21mQDgdVy2QSckjB+ZdwxwY2hJ4UAjJYqVcshAPzIwYfISUIXg45wpAKy4NPRPRXvays3HXW3TW+z623Mee6Wivr1t20ve/mm+1t9SDa2BsIbjJVgGXOQMbRhiSoDKfvLkgjHWNVwCVJ3ABfn+7ICUJDgbF3H5VDYPAO0gYJutH5gIf5RnfyWOWyuMKM5VtwG3cCBtz0BDBAS5ccgtuGRyFJUlMElsqOFDAYU5LclicrdmtrLW+7urWd9uy7WTs7oOfTl+Fd30V076a7J99OurZUCLvzhgWQ8gnoSG3lVOAuGwHDZyAQpXcCjR5HJUMqBlyw5+VSnzfPlic4YgLtyCTtBNloWVeG3EMrFCSXEeF3qMsBhDtAICrlWcDk4HRjyj4TPRdpDR/KeUByikA52k4wQD2pWvdP+71Ste1td1o15d+iYpXktmtm0+yT8kvXRO92nYz9oViUxJNJlnJckScoGRQWAQF1KlcHzD1CgElA3yo+7Kuy42AgISi7gQMl8bipYu23OQAVJq20THcASmQcBGbO0sQu3qU3KVYEN8oTDEEGozEIhGkauRvVthywi3Ahwu84cAbSp2hj8shXJKmbNWu9/K2ui17u6er3bs7mnOrLV+avqvhu/LVJJ66dNDbs4z/ZGrN22WP3SQQpuo9pPl4DNyPmLYbg8heMjbjG3oCR8u75WLAkZIOMg4Oc7MMTnHO5ZBl0XWRjtaBskksPtcGMLgAglXzjgbyBnBIxiFYf3QoOd38bKw2lS2eTkA4XA+63HJai3y7rS7va78unZdFfo1qzLCzd8Qmv+Xyd/WlRVrd772tp3TRVAIZiuMlv3eR9xdgkOCxGSSN20cMpxxgmomGTGWdlwijOCQVYgsjKNoxIGJXkjAXLZY4stnYgBU5YkKFUnY6ozIWUhhjAAJH3sDGPlquSG8uIF8s25CAFVdojJIZhhX6rgEjOcfPgUSSs9E7201Ts7XaTelr2T+fdnaumy0Wu2qUb7Xv5NW1a3IREEjK+YpTgNL5alQG2L5fyH5TGfu7AGyDs25ApxX7pA2hYw2QSCQm3YDnLA7FwSDtJHzAAZClVcxyGPcSSFQN8gYBSrlgqqxAUkEkhCNoOTxLg7tqkKCGPIwx6HjP3Tk5yCVHAwpyFS7bWsr3v0V3rt0erV92kHMopWbaVrvdq3LZK91LRt6vZ3TuklXWNw+Qc7wSAu8hFLKdoLOVcqFIULktnjAyKJGijxI4EfyqCxZhgAqCoIGOTt2qRlQOhXNE0jRoXUR4Tbv3FQREWJeTyyY23RxqSxDggnGHJxVZlRmKysEWNxLBIq4WVUG1SCsjDzWk37o2VlIjIIUHDxJ2bStdWXps1dv/hrO+r0HF6XldJeW3LZ9bJWb00tbRauwikBiFYYaRHXcykKmV4iUHDELIm6IoCzLheQAERJT5zGFYoyxkhbcjSyoCoOcnYIzHFksQHHzAoPldpnUN8ssIJUltpZyI2DERshCEOWI5G4BiAARt3U9ZRliBtVSwIkVAxIcMWwNxI+YKGAUdN43fORLa+yta2qldRWqt321Wu+zSq7ktForJd9OWzu1e/TyW2zREx3ghFbhSUOwEblxsAAONwY7c7hkAhfm+WoEyzGF0ZXUCRpCy/OoKLuCu52mQ5AJJDhCMKwBNhmKbg6Z2scAhCWjjAyQAXz13MQFQqctsxg14ixkFwIpEgaIxx+YRlCTGfOkQlVTIcqUIZioDxFowSG91vqtEldJK27eq9dG3ZKzVi4Jtb6u2nrayW/3bbWtpeUJvAkjYbSwzIpJQYALMoAADryN2QVONoxhi4oEYSgkHylTc2fnGRjKBgqk5xj+IgBmOXpyKqmPaiGGWIMnkqBGHUhWDHzGViyhCp4IfIHAp5Ukr8hGUwd2QVB8sgD5SOADuxkLk7clqNXukrPV3bVkl0b6p7vpe+9jVKyXduy6tawaatrd3tpra9tStbNGqui4BjY+YHYMQWVF3FgCGUnG0EhwdxIxwbRxGIywJUtsYqF3AEKQwXdyxGQowwKkFiQV3OUEqV6O7FpCVKrIJFRVYnKl8ttUEqhwAWGfmKqgHKrgqCpDYJBKqxJ2DJBJyDkbW5PTFOEWo2e219uXZpWV1dJ9dX2vtpDVWbaSUb37e611d3Ze7dJ20TaS5UfcSSsZYJn7o4YgDjKE/IeeehOQMHOFCOV4TYNp+TGMZCk4YBjuzyDnjhySGzQFDuwHRVDq/Ch1wgCEElsAqc7VCt825gwU1If9H2DDMjOFOwBljLBSrEnA2t83RW2D5sArk24t6J2Vkvd1vqkrX6b+Wmjsmxt272bUbXd7JK17tp3vulbyerDYRgFgWbDMXUAjYVB2hSAFbBJ5J6EdCDKuGICsG+XnawO1Tj5iduAxDYPIweDx96YR9CFHLZZfvA/Ku4ZA+ccFSM9wcY6vWJRnYB25A2rjCnBUEZyuB3OBjGc1cIz+FJ3Vm9OZ3ai9Xrezvyq9rbXeqei3fL376W1v3du+lrvXeoItzZO5CMBcN2G07l2g8ngNkdOeMGnRxfeABwM53k43MqAum8MWBPI4G04Iz94XHhaRPkYx7drqVDZAA4z8y/IeF4wB0xnObMVvj5QTkcAgEAjCgtjLDDDBznkAfNgAi1TblovdTsnrto9m+tr7dFrdoqLSfdW02d7NJO6tu10t09SkI5AQAAcoC+MgArtbJU4DkgZzgFsnAPADRGVb5ipYkEHaQcsFARj93gnKjBBIZsY+WtZbdogqYZi3G0bixLFRgngEA8qcc9hwRU62ilfmG4BQFO5cAnGAMZBIxyucnhgQAN2ns7pWurLW3y/9J87p36g63L1ta1leSvqrN25lfvffZLc5+SDYq4bjI69FJwduSCpAGCTgHrjk5qBo3U53DAAB3DdkfLyNowBwQGXkFsZ29Ohe3UnlFIIGQQzYKkYBOBjac9yRx1JK1U8lXGduAF25yfmbAGSWOf4sHovGODyZcGr31s0k/uWjavrffe+mm5SqJrVPp8vhlo0mtnvvpppYxVTdvCuoVQFwoPys+3GAvIXjLYbrgAlitVpJBEF80hN3RyMq5LbNrcMUckBsttAU8ZxWtMioQygsNyqQDtXBKnPBGCCuCeybWByGqpJhQu7J3OihCBtLAgqxBHlhQc7mAJ9QSMDGdNrW9pXV7t23WnTRLS9td79S1qtLdLdW9Y6apO9utrvfrpUG1mOG3Dj58HJBwUbYRgrhicgYOQFBPWrJvWZUXa0gSbGIzlMiM7jk/ecN24csEcZwKvuqjczEYIYKclSxJG1RtJDYLBowNqg452qFFERos1mqhgRHcLGztvBIWIMSpbDFmJAOAJMA/LtFZyi9N0/cctH3T0Tt0tq/lvcF08mn1WtlbR36K+2mm+ltC0SEi+WZSSdPucLnBHzDcVIKE7jiMx5+TOOSNxzmhiaTPl5lcfMxkYhY22AjeucEABQ24ljg/MvNasZ2G8wCzvYXIwv+yx5bKlSADzIfm4CscZFU4ljHyoMYXLqwVv32VDKfLI2gDAPULwq/MSFTgrpW2urpJvpZ2dtbb9U33SM6K/f1mnpem909HCNmkvK6f8AmkhYrTy7K9Ebkxv5AAZCwhHmkhVyT0ADMoOAm0RqCQy0sSGIpKfmR8ByArMgXEbsSwLAlR12hlxxurXjKtY3ancBvtFJZhkuJXBYZI3rlMYYAgfRFGbcK23gA7UbIyTuXDALnaOfmznoCQD93NFRJQTTv7myfeTfRdX26adjWGjq67TSsuzp0rPW611fztoWL3Ah08EMCNOh2ksxJDT3GE/vfKWHyFfvLwwwAaMn7tC6xlxld21TlFcDcS7bsxIFO4EZAAIZeAZ3mea3sTMn+rsyqkjLIqXlyqnaXLNkjaWOCoByAcgVJmiVEVhLGXMS/I6q0ZYBt7DcrHIZ0T5iWUlsMy4MPWF0teVWsnfaKTtbyet7b+dlh4uNOz356j2b3ldX32069N9xjkhdziPYzKv7vgrE20BwHYHcdpU5VWOAW25ABgxBmiUyKJGYoxYhSWDO6tu5A4yuCAGAbLA0pkyVXcrEsF2KQQJBtYhhhiFG77u7kAY+VVpdj5bJJDyOVyudq5TcwUMMd12qudxDDnApWenVLR66tWXXVWTs+2t1ojdKNpN36WtZ2fu26uyV1bSzd0nYEkCl0YgkliuwKokVQDgckDspydhIAGD8xUCLl9p/eKScfeDEKSOOBwOQSCOOqnaYrVHUO0j7i7lyx8w90YddhRjnc2FIAxjBzmRgzvKp4i2lGOBktsTOWy2zbluQoG7bgFXyHG1oyad2rpWu9LXvqlprrrumNJtJtdG2tHZJre11Gz1vo5XW9tXxMHAcEbWwoAAyMBXAYqSMnIJwx3LyPZSWbcQN5HBIGD0U4OT8xznkclRyRtFRIsajYjBY9oIAkI5DAtxt6kuSBjjGUBAIUiiKg4LMgLFdwJ2owVwQrElskcEArkg7MDNClte2i1elr6Nu2j7uyWttBxtpe9tNVbb028+3TzHHAKsN3Aw/I4ztJyARg4OQN3AXIziqsknEjY2mKVF/5ZDI3IC3GSMEkHKtkFuuQRcUfKMgqWIZd/IOQv3VHBB/gXnBxkYK1XKS7id6mMNsVQmflKqpdiQrABcgMuWU4z3NKSulb7W9tG3ZdUuj6a9O1gadl1bdulre5yvSy6tvW90lo9lWLbIZjK7kKfLUD5UbAYKBuUEYGUXbguxzhCQXQySkl5GWFGULhcAhyVX5mzuBJG4DBdep2qACjfLJFtG9V2ofm2bJCxbhSzYwEJ2Y42syFgwzIse4h5h5nl740CkMNvysHLYBZxjIf5ixOSBjAlK7stFq3q1du1rpb2d1rfR/JNLzd42ve9m00r6duZq/l3sWimFEYfsFDMGcs2F+bIIOc9xhWBUqBjIrsxUiNhIrIQCysP3igquVBYlc5JPUYPToKY0yMGeFwzKillfeMqNoP7sgkghvl54xkkA5WUSIERmZRuKqwYquWJU4OCdrKNqnLAkLzwQKE1J2vquXa/fya1SXby3uHbWzur6trok7q9rLeyWjd+qJiquqI7ELuV1KOykMu3aAzBSTnDOgIXjkBhUykhlZhxnIIGCy7hgtgOxYA84yWJJI3ELUSyIHADq3B5LBjkqpU/LlcY2/d4xyBwSAxxzyKJGf5XU/unCKcmP7zqEy4XLAgleQQQcUSb3ST0sntdOy0erVkk3tpffYFdtO0b21S0u0o2+7W2q62TWhtW8silY7h4ZwqBhJCULjAHySocAFMZAXcw4ALfMaZfRRXW6Bh8ykGORGRRGybijjDJuYMy7yeGDKMLgg1WmuIGQxK727vtkIiXzFaVznyt0hbB2MBKQybndGAwRTtQvUtQiNHIwIVCgEalJcJhSxChkI3bIzgyBWOFwAeNVP3bUrtJRTUl35dnu7NXel0r2Wp+fRoyVeEoJKUvh5bJJxtuk7R0d3ypqy01btWieOCa6hWREcE3EbPEzMkckDCVCSX3FWBXyyGRGOCwUIalWKKOaB1Z2klxJGMkxpM06FxJJuVAq5wyGMBDk8uyhsm2W8M0ySxtJLbTCfczmPy0QudglYGNopWn2xhVKb3UE/vA0mzp0wuZZjNGyG3iMDoBEPJeRiRtwmWOefuKyMNqMSyM2NOXO1fRt+7o3ZJreysrK1rabaHZXhKmpy5lK0Y+05Xu2oqLtuk2029Oz3RYESRKViWQ+aGeU9DkoyuA8Z+ZCzIyRBGMh+Vjk5rOjS3tfMiCtJJF9oCpNKXW4ARY1WNFYIqJEeWfCqCWPCgrrR5t4bdZle5kjkJaSMHcxKAxktI27KJhHU+WUUKZDuAAiuRMtwtzDCjMYZUnkk2A2373a3lYdVc7XOdyP5jExlfKatp01KMZWtJJNJq7jdRa1XVbddetjmpT96UXK8XqpN8l3Dlabvdq606XvZdiaG3ckRMoQz2R8yVZDgrJKwGY1Z1ixkeWSxVEVGjQPgVPaTqYWdpVbySLfYf3RV0RIwCJEO7cwJjc53ICXxmmrJb2aLIiArIkERTKNKxkYl2D7isaFw2C5ZCCCkhXO2VlllZyCEib5x5SKzF3iJDPIjojlAy7CCwEiqCVGVOlNOKSjJqS0cUtFzWe6S2avdpu+993zVZc3MpRSjJrlm27Nq11ZRd9Ho+yvsWlgmZy0kgdQjCMKCig7UUpKA8YcqFZt+0l3YD7oJErRb43LN5akA7sNHkRqMksMrGCDyOA4BfOSQa6tLDa/vC966BJd4TEspAXdGpdm+4qt8xjbeME5JJE8YaW2xcwJHJNGBNEWyEXaCq/KFcEhcsBlgw2sxBAGqUbcrve2idtH7tm2rel7y6yfLqnyNtLmTjyKXLFqyTtbWMW09tW2t202tnGHjWS4fOREFaTDM8a7gCShK/O+3cNq8fLgE7sVWgkinuGliE7mQYjUkKZIR5eGjAZTGznJ3SIo5cDOWFW/mSKVVDlwHwF3YkCxhRy+9QBDiMsSEwyqhU8mJLgLsE0csW6NQEkQOEw5jKAorkEsMiN1XAIO4DJK19287Ja21ve6s73toraWulboaR0UuWLbenNKUU0lyu/KtW3bdu3SzGWyyLAAqPFISzsXdnIcgeXIi5BMahQSXyxDBWwBzJFBcoSLi4imjVj+7W32O3Me0uysCA5VshcKCSp+QgBDeblkDQTKsbwowAhLTklo90WCDIEbcrbQxKgcfMFDWulmTzoX8xY5UiKsSjEqcurIFVlKkcHJQYJLKmGE3jpZu9lunfTl+zore7ZXsuuul21U1vGKTaveMXytqLVnq1fTRN3ei2sPK4dgyOwZiyqwZSySbUOMFtshbAYYGVBJHUljKAFleUKvl7TFIqeUHJVQ0jHEsjFQF3j7rkqfSpnjafaxYxmJEmiMbKHEhKkM5QJuQhQoCnByWXCsTT9iyJ5cifuzGVcMMdMEMCOVK4LYPClgeTya5OaTsvdTurvX7KSdtUuurXbS6slKMVHWPNblmrbW5Ukrp7Xe/puRCBWYOu9WCyBstI6ujBnQShyANpKtnBHC9MEGlqEf+j3KiOUqsMhDBlRSrrvbedisVYgiPqrP95SUUVdUO7HcxiPzoqFY3dyjZRnZ3eTYwUo2R8wQ8Eryy7y1pdMSgYWswG7cfMBjGWXevynIIBXIUdNu0GnZSUtLO11s9Vy7tay3T206Ntaa0JclehZqUvaQSVndJyjZPqtH23utbpkNozR2loSytGYLdXZcYhJjUjJLAY6gcFwcsDyamlOSZI5I3yRvPJUI211lUKuzdyDu2nGclc/JUFoUENlA4P7y1jkYYyjKFwFZmUIqksdpTlyqqQjhlN1UVyFCplBsBA+UgEbgE+XDkcHAA45HFEObljG+lk33TstE3o1otrrddHa67tXnK7UnUfKna0oqST935t7Ly11eHpOAsnIDG2tWIO4f8tb1gcKFGCcBgwAGcscZA2IgBGpRjjOMsQxygjDBghKk5UqCSSpGASACc3SwCXbCuTaWeflDMv7y6G1DnKs2cK20qx2hicCtgfM+zy8gDcJBtxK4ZQEGSiqSQQQEwxHJBxUxVlGzdno3rq2o6XWyfe/XZptmmObliZ6XSjSerUtqcOlr3ev4vfQYpAIQOu5pN+CQJFDBcqQ24YKuQEzt7ghcha8zhF3KNzZLRgpgy58ss8m5OAoPz52KeCRhVxZaJfmDof9IRUbBb7w3MpbBCqqsyMAANuCpwjECJYdmAis6geW8hcGQg7VLNIGbjAQqyrlh8pzxiknsla+vd6KNvdV7tJJ6pb9lrguVW3btdp6X0Wrd79O1+nUqQxhZGQyyuVBCxuwZvmKB3iddxaJmJIQjZgu2FLcDsxZYV+TgEyEIQw3riOIOqMX+XlSw4LbWyeLJjEow/mCUODExkZSqjO1owMHaQwLITknJLbQQCQKI2LZIBAwu9chD1AJwF5O/BXjqCdtEVyqyunG6STkpfZVtb6uyTs9e+ylbknLms7tWSetnok13W9r9Vr1IGCuxjkDEhgqLmQMrdFIbcwIw464w+DlWUMsbW7LLlGZFkyzO28BCHUbFVg8bFgvBAQ5JYAE7asSDOCo3HywpEZVAcfOUZyWDBwBg4DMTvyMgVXQrLGju7Qh1MbpnocRho8I+55QcnO7kMFYFg9DSsmtdE3e62lF6N6Pdar1stioSlFczdo3S2u1Kyd9Ve1lpZ2u1bqReQquJYw0b/ADShkZ2G8B1XcpZSYmJAAwSzYxgEZcrrtDsTvGFKFQTGqFTKrRgsCAxJ5f5VG3GVZqkRdoO9MsqqisMKrIRFtAZ8uCrbSXJGQQmdxWkZHSNtnlZc7pGZQflJXzD/AAISCAkYCh1LMwYD5jEUr3Stpr36a7pd2m72bTfKtRuXMlGWrXLZ+Wl2rX0tfbW+nVJqA771BMYIOQxDFg4GCMB2CqXGRxjgE8ZDFZuP4/NLFfl2ohbAIUfIrbvn24GWI42laWYxSK0UcmWzhUQ7GG1lC8ISSzcDyw53N82QCBTXLbCW3JhsBQW+YqVxt3K5U7SSzDAycuMDIel210S/NWS0tfreSbur76gtox1V3FWs7p6W33vd320VtydXEpkC7owAEK7VQlgAgwGIJC7yGB5GcHPaElDIcI0gKPh1dmC9G5zjcFLNiMENuPykDgMCpJAUwXjlMak5CyH5VLKzIrHKYVZTuO4DOdwAKgiFSoVgFIhYgEINpA3EMfnO0LkgBi2DxkAtX5ldRsrWffVNJflfs3d93ZJaNt9Vfzjq311u7LTvcdcIoRd0qRHEZRwSzA7iAu2PGUKsSy4G44DMQcircKALBDlmGoWJYhyc7mJyXbA3HoGGQFAD5ZSxtHLsQMuCSVILkDYSFICBcsr5ygJDYIyrBgM/UHZGso0Vyp1Cy3HPmBMEsCDIASzA4ADnhNoOQac0mpNO2kVaybupRem+6d7p20vbe10bucIp7OT1atqo7Xbvb59bPodHEM528qfv8g4II4xkc84B3cYAzkUpjGCm5kBA5UjcduGXazAYU4KkjC9QMNk1VNzEkkcJkUPOdqIGZgzAgsQQHCfLnqwO9cIeRmyj/vdr/eGABt46jjPcE91A3bfmIIOdE7K11ZJRtt7yS6X16eSt1tYytJatNc2q06JxV1rraz3vfdJ3sORCqgKC/wAxCLuYuCoyASN3K4IIPC5LAFgQc2zLeTaEupMiXC4J3jImkIB2gjaUIAzyR0yhydcBVYYDMSTlQTwvGTgFc4/hbPzFQDgNmsaxQLbQKD8pW7zuLnapuZSSSCA3OSpUHaxz827a020Svt/T/Jfr1vvHXCVFvevSv3s6c7t2fpZWstdLGxJmV8g/II4CqkDG4W6DIHBAbjaGwNuM4GBUEjFcM25F3FMkNgK2DnagfCjcT8w3gYKhgTicRmIhXkeQiG22yNnLgwROXYvtVl+VipCoCFbgMApQFDIyLyS24ZClCWChVVjhmAJJUcZC4UgrgVbe2mltb7q19Pm109dDmuo+aSXfX4Ve2jv2T3001d2EyiSOMRkoyl3meWLchDICpXG5jtyxP3lOccrk1IwGvb5d29iloMKxDDMTgCQAg9cfdRW3HAGABWr5SMwkIBdQQrONwAO3IXO3AZiFbggKNrZcE1l2oB1PVMEfctAcsfL3eWdrZCrwAAQ+Rt52lSoxcbvmtbX0stttOvlfbXRnThpL2eItsqC17tzhbv6bWSXmTFjujAhnLsAEZULokjFBsmZkXDOgZgQXZoyVxhcmC0AigRN2zfc3kKqXIQh7mbG0lFj8sA5RiMsBtU1MdOhaRpZZbmSMymaKF5tsUcgKbHRQykoMbcEhdpwQx5DbUIltPCQGltprrzEV3Gx5JJJYifvHBSRiGLLtBCnJ+YSubVu+l0rv/Bbro01dK991YlSi6MuWTk04ylaLSSbWqd3s7eWi0RMqCLYFRypfY4OONxz5jMwC7gAFLbc4BAUDiphbRiZ58ESsiwMc5jKAnaQm5BvzwrAHP97JOJUjJRSAwOxWfdhWydu4ZG5lOMHkkAYUnnNWFVQqsCfk6klskrhiQMEZx0UDPcEdQ0uvo1por2fS77pKz6+Zjzv7Lsno97NXi3rb5dL6Xa0KkcOxFjTPykFN5L7mAA5ORkMQqrkgAAArzxOqhlXcuGUAlCQpXhchQC/QnO7c23GM4OWGRR/rXLGacbWKERoAAyIrBgEVcYkYqcNucBpPlq7HGuBjlVULyWbGMEHjjcMsAVAA5DDPFXFc2sUk0vlbTR2tsu9kn1IlUtZuzTtq17zatddXpZd7brRXKcFv5KtlmcvM87OwbcfMORsyd21VUJg8NncRk5MUhZAGmTBWUROsIRgVOBHKvEju75JfaoXBPIUZOkRjLtjag6MxwinGSzNnaQCOcYwecZ5qvDHfxxSxXDIsVwJ45bcufMMabnXarKBvBAOQSrMWwAThqLSSTv2TV+2r09W7+d2rExqp+8/dTa97l7qLS0t1urJ2epSkgljkMrXBS2VYxNbLCSpYuh3h4wj5IRAzgdRwoG7EsBBuFlNyjxSoNluQS6PuVVKElF8zagVkKOQwYlixUDTRW3OvlvH1cZ2hSjbQCpJJLNkkBicgMwDcg3I41bb8oG05DAHByTwrBRg/vCSqkAk7hhxva1Tbd7W/mV35W8tnbVb9the2SWsd9Ftt7tk0ldtK7fM77q/ak0B3EYLcBgEGBnG054AOCMBgRu4BwcCpmh26fp6mNl/fakQxkGCv2hVOxCoOwkuzbRy6sqkFSWumPJGARjAycnJ+TOCSCF3dGwu7gNhus2wiw087QyifUcqEO5SLmMDc+cZ/iAGQCdwywNUoJaNJqztrsuaHpre36IhVryg+VOPPvfb3Hy369Ltq22qtYwwhUJvDYLYJ5JY/KSSThiCBjsSM9hwvl/dzxtGFGCVIO0DjhScj5S2cjnrjGubcEcheCoUsRlQdqkKTxtIBLEDOcZIIqFYWLKrDG1RycH+6MZdtoyQMEgKQSMEkMdbN7XV+/S1r33t56ad20daq7620S1s3urWWvbf8+mYqAAbSM4+ZCc8fLwcZGByAVBIPXgGozCCQeVIweSAScoACcDBz3Xhj8pwQANIRtjJjJyBuI3KMHGWI3cnKn5tow2MAZ4aLduPlJAAwcZKqSmBt7HqMHGcZBJ5qeTTq22r21d7rune60W6tsmzRT0vorK61XLduO1lfS199V6K2fsHJYj7ygnawJwQCD8xbAwScBtp2g5GGLWjycnnzMuWPJCsQehxtLNk7ehI28E4rRKYK7EUgkBsqNpOE4wCWAPJ3Egg9CVJFNMQJ34yB8g3dQuF6dSWHfByBgHuTpGHM99t7q3RX32d27X0tfV9dIvRdbqy15nf3X5PRSs9HZlBY8ZUryCCFJJPDL84wnf5en3Ty23bTDGo5dWf5CSRgANtUYKnADbudoOcHcAMEVp+RITy5JOFcAFty8Bh/Dk5BUNw3IOGAak8nBwnQ56jgD5McK2NwxguC3JwhOcU405NtW22b2knazTVtO3vO9l5s3gldNbSSTs9Ps+e6eu7XRpWs8sxHGM7iCAQMEfwtuAHygheQctj0+8C3yjyVbeB8pHI24Ixlfl24/FTjgHqdMw71CglWXaQT0yCnTdtAU44bG1gcEhuab5OGGenBQhT32Fl5IOM89gy8Z71XLb3Xt/8As+elk27qzT3vdGlkmo9tLdFflflvvok97t3uZ4hPLLyrFSVPQH5ONvCtxnjJwgYjHzKG+WQ4YjdlVYrtAUMCvyj5iMjblMZK7sAEjAumEttABCggjOTlQVJ5wSAMnGOB0YKcbk8pWQuB8hOQeWI5RWyAodUOMZU/Nj5c8sVyK99dLJPtblXzbfy127t9u9t3dJaa6NJtpX+70MXUV/0O5zkLujXPViDIi5GdoI3D5fkIHLMC3BvyxKGBViznkFGPPzHd8g2/I2Qdoxk84Yc0y9Tdaz7gVcMnB2Bl2vEN2OxfouQBk4IJyx0JY3ycursWGU+UBk+XK5Me5iZAuCGDAKy4BLhpUW7aK9o3T1ur6a+69d9E5W67lSk1Spa7Tqfiqa3T0eiVtHbr0MvaGO1dvyBXc4wwBK4XDj5pSc5JyUG3JyQaaQFcYXK4zwPlUhULcZ5brlWzuwSp6CrsqBjuG7EY+U5wuXPBKgqHVdzKCeB26LtiWMO23GFzkbtpyw2hSNy8hSVYLjkDAG4LuHTd3t9nvdJKLV9+9r6rpp7pi21Zt3utL6Wb5W909Omt+l73VqghURo4PRgwLElSzFDjcmdzZJ3KxwoG0EDkqsaknbu3FcnG7Kg7chdudwIIbIZipPPykCpo4gdwAOAXfZk/IpAA24AwCSoIKYBAD45Icw2hNpHGxAXJKqGIKHDuozlSpYjGdnUk4hJx1vbZ2Vr3XLZq7Wy3sl02d2Z899U9G93o7XXyd2lpe271W1Vo0Vtik5VSNqnawJCkZ3AYc52/OSDjAYcgwGMNtOMvgDAwuVXbuUFgNxDDqq5wDkBgSdDySFwq5VmIR1AUlSQAXAcqQGUg9Cu4MOGBCFCjAMoB3FCG43FCuWyNzZOSS4IPZx0aol0ul72rTXRcqb10lpdXtorW03PaaNLyV27t3s767pu9vu9aDAs5IfDJhVC5OVIQcg7tzMVAYHCsrZwQCKikUl1ChWUpukOwcY25K7m/1gxkrgkZIBxkDQ2fKSzKUPKjKliQI9itkBg2VwFXI5OT0WoSuNoC5LMgKqSQGwAQFQHIUAYJG/kEAghinDXZ62d3a71Se13ttpa61dkgVXqkui0VlbTWz6q2/fzvfUtVY6Pqy7cgrY4AY7VUXK4OVIUL8q7Rxgk8/M2MKbgNuAU7iVycENnJLYVySDndn7wOBwC1b9k0q6VrUbJF5bJZfZ2ABkkH2qMP5oMm0MNhdfUuw4H7xschHGFViNrF+EBDLgF8HJxzhQwwpBToAxdrpaX5op82l0tE9L3u7PW2nldsMNNJ17ta1VK62/g0tf0duu9jMePJbAYbiGLHcdu1HdV2pwBvwPkf5Vy4YbhugVP3aCfynlBQh1RcMiqjIg2lfnYgbwoIY4z86mtQQsGJUk7l3lCucOMDcAD5ZBBxtU/NkqACOYZUyFBUks4wR8gXaVIZhhlAOT/EVJw4AAaocXfrs7K/mvXv301+fdGpsk46tP8AJWfTpqt3ruV1jc5BHmMVyAAFGVGdh3MikFgArYUnzF3dDmIGTy12ptlPLJ8hRVVlDN/y0BQFXxk5ULkBlY1acMOinJ+UEAdDg5IIZcYJLEZZjg8jJLHHQxhnd1CEEhgM4bK4YKGBDbQo4A71Lj5rSy0e7Vm+ru3b5J3asy+Z2Wii2rJNPryq6smm9Nb320b2KjJHGQNjFfNfbgsrKTtVy0kQZSjFs8gZLbecllfHwrbzuXDFGMaxttU7fKIZt7ABiQwDHkHcSAKc0REm4HgqUm++4lKuH2lchRvx1GSpyoO07qdvVQzspUKSiKFOSAQNq4V+VGQd2zYu7zOpIhK76q2t9246JJ6pXbXXe9nZIald2bWqVrbNpRtquqtZdGnpdqyhkSPHmykpEiZYKzEMjOrhZOcvtG0MY84wpAILUiiM/vUiw7Dq6Yk2EIeAG3KOmSWctkFmdTVlQTGcADfgMCqEEkLw6gMPlJGBkgbQwLHpHLEHAjyQCrYHzruyMLzywIXBAGFO1cYzV8urejXuva137t7Np2UdUno9eiNIt6JabJ9L7b2036rZ7dioiDb5mGXzPl2sW+UALgkAYLSYBO8ZxkMGUhVhURu7KcssZK7G2KpKlcSKMGT5WI8sgYVugI5W0yT7lG6IwkgPuj2ylVYYVdxKqQiEbv4yQD8o3U1oFChju82AZjZc/u9rMxcbcBgG2gNtQsBjhQQsxTfK1ZpO7Ure820099k7u3e225um4pa3s01tbp0srbba3sulmRRKNildzHKuVkU7tsSkbQNsj4CkFSW3t5pLjaSRIIlWMIjks8vnbt0ko+YgugAAwCSqBCFJIYgAjNP2MApibYuEDIVMiSDzASCd52HYeSpxGCQcAAVKWRnjUDqu5GUKEjDMoAXPJB2lVZGClhuTB4q4wfXyWz7q7umvv0vdq71KTd7tqz8rrRxb3fXR6NaaXtdpwBy2QygcJnnIJUgncWIGOFIH3twZVHVY1BOc/d6HkAcryMqCcHjHUHAx2p6jO0H5ezA56ZBC5wxBBGWz0H3fmwamRV+Xnb03MAQDnGBkkklyBhuFKj1Ch9VFt8vVaa9dFfTstEtNHFKzRpd3irxu1HybuotaczXKna6dlba6RGoOBjkdMEZYghQSmTuIGcKQM7eWUA8zwnfgqMHAAD4DDGzsM4AAAyCSxBAC06MIcgAkEfexgHIUEj5STnnLYznOQCDmaNVc4YZ+XGTwCMDB3HOSedpUYxgAE4FaxhLms+61dn2urXbXZP1vr8UKTe8rtJa9muS/bXmUryScldtaXuxEyR3BO3PUDhCcrknaByp42n5ccmrSwlt2UOAVZX+UBiGQlBuAZcg/M4A79CeVjRyOCQMKzbVG0gbAMbRnc2CuAOO+e96GI5BA3HaEJwyo445ADAL1VQAOAuQd3C7xp6JW0Vr6Wt8Pr179tWuiVSySb5nZde3Kr367+b970vFHCXYYQBscEglWwFO0F9uT0ycAkDHUA1q2dixCgruJC5wu4BW2qACMKyZPGQDg9flOZ4IN7BGzvCjcUXO4DaAck8jJAOOcHBG4DP2T+yF+zD4k/aW+Lfg34daPHdxJrd9G2p3ltatdz2GhwsBdz2kSoftOq3zgabolpIEW91GeDey28U0q9+Dwc8TXhTgrc0kuaTtGKfKrtq70v0vrdK+7PbJNXqUqUVGU6lWrJQpU6cIqU6lWpL3KdKnGMpznNqMIpt915r8Ef2YPjN+0J4jt/CHwd+G3if4g69K8fm2+g6bJcwafExXbNqt85Sw0yMkECS8u4IsbsknOf0stf+CEn7YkNl9p8X6/+z78OdQOxl8P+Nvjp4G0vWUEgUrHPa2txfiGTI2ypNJCyOGDEBWUftn+1z8XfCf/AASj+Anhz9nL9n9tE8JfFPxNpS3GtaN4aeF/EGnxX1pFv1jxx4uiK6xd6n5nmG4hgm04T300lmZPsFpBbH+Xj4ofGL41+MNUuNc8a/Enx5qerajJ9thlvdd1y3QxzEeXJZQvNn7OMlYzG3lsMAKuDu+wlluT4Ok1UwuKxs4KCqTjJwpKUuX3ouEoyi2k+WLUuaNpafCZ5NxBw3meHeMy+hjs3wMZyprMYTeBweKnCSi6mDUqU61TDqScadefIqqjzRhyu5T/AGmf+Cfv7SH7LFpDrPxM8G2k3hC9uDbWfjvwdrui+MfBc86iGSGOTX9AvLy0sppY5o2SC8S2ndXRvLDcD4bmt2XllKHAJIClTjAyWHLZAGDjLA9Cev214J+KHifWNQ07wF47+Jvi/Rvhz4i1fToPFM0E8mtWdnaNcw41a88NXdxa22tW+nTrbX9/pguLa4v4oXW1uYb57Z6zv2lP2XvFPwP1zxPpusQWsknhPXtI0m8vdOuDcaRrnh7xjo0viP4b/EDQHeJC3hzxro1nqcdrIFC2Oo6Vc2Llbsta2/k43I1isJWzPKMPVjhcPJU8VSqzjOrRqcqm5RS9/wBi0m/e1UYyV/dbPQ9lOrha2ZUKKjl8cbDC3VSNSeGlWTdCGIsoySnaUYVFFQnOLVlNnxIwBJOOEBU7hkk5UlQNuQARgMxO0+h+U57owGEwzMm4bgQeACQxDYDKBlVxgk5DAYztzoQCNuSvBGSeDkMSB3AVs9GGQWyDWTIETIZtoG3aWGeW2DacEqrE9OoIIOeor5NprezeibbSWtrfzLZaXfRK/UUG3qraNLTdWSfW/dtrom7aWRmyxgx4VmSRCrqyKWfeAPvgEIdy4BRuMkvtIXIrSxIJbYMylhHcbymFZyRCGyBv+8R8qqQdoUfKyir4j+diBjOJBg5AYkfLtB+VRghtytnBX5QDmrMWW4tty8eVcHgYAYmE8nb0IA4wCvA3Y2kc1SFkpW192y+G+sLdUnZvSyvpuapax6Wa8kk+Xfp6u3zdyzarI1xeIVDKumXDKzjzAoLKrEh3UlScICAu0KPMwVzVJkP3mCp5IVm3Epu+VcRPkfd2bd7K6o5DAICQa0I0Mi3mS2RYT/6s7csZUP73gOVf5g205k4yAW3LVUKSSu7asZGHLEDJJL4LAlSHwjMoxnLKpVgYenMnq1JvZ3blqklZSavZNXt0el2Y0VatiW5XTcEv7vuRtfum3rZu/wA2yaNCbG6OMgyWapwMbWkkwzsNo2sfugFjn7xGMDKn3FMJvBBIY53DahOWVCSQNylSSfl6fMea1ooZfsV55rFi8lkYj95ljEsgAdflBIxhvkBRjhgdxYZ86sccrtAw2OBkkkkAYZBkY9ixxxms56wuntFXslvd3atr1t5ppvz3hdqtJN6z00VrKnT31ve+nVbO6dk5J4o4k019mx5dOSULiN0Rhc3RLfITncFDujZbeCR0AOfKQ29A/lneHVx8qswC7FjLDHIbnkKclRhga1bvCWmklUEiDT2yAqFwRfXhJDBgAFbAO77wIJUqSBlgAO4fhw5bztkaKELI2ApZwyMwJBTG45yuAHbJu1ktNFd22vZu1rX23f8Aw+VF/u1d3fPNdLO0mlqvLzs1o9HrEwVHxsIZgFULnmUMrj5t7K2SMjJDcZwVAy9EAL4YKSoMmVBIbC7QqDgHABUgkgcnODTH8oMyPvRTLwOqSsR8jKRGwYZ4CsAWAIzkYKs5jiJGFYAYHModyEO5uChYE7iQQuAWPCHDTtdq3V6JN7rytbVeVk9Op0J9b9L2200T87b31V7Oy6hEoihiQYZm3Lht0jKSwJY5+YFAQWBB2n+EgEVAkiNK3kjcuXJnBUq7nYfLVsIgfGQwyV79g1IoZiWKuE8ryny5LM7YcoqqdqncwYMSTgDJYAmp4ozGgiVCoUlgVQBto2dWLNuaRQASeWPzNyACrv3UtEk9U43volHRbPXr2d9Cr6JJK2i6Nu/LFNLz1vbpZsb5W4q7rvKgbVXGA37s7AgPzgbd3zEnJGwsuKfhd20hhICGHJHHygBs52qTjPUDAHG4AvDISFAKgjHLBgBlW27TwGPQY5AYkbiCBWLrGxXaTIz7o0Ul/MBaP5Q5G3aeDtBCn2YEirWtpstW7K+2uyvro7X082Gr/wCH3+FvbXpZXTSV9GTPgAgtgnAY5YbV+UktgE56qu0gH7uQfmpjSiJUBDMzYQALvYn92AWB+Xo+cjbkHIDEtTHhWUJ5jlF+QsAy/OflBRyq7hgYwCTg5EZJIJlVUSVGXa6MBEWyNvYxsrseG78BSSDkh8gTzS1t233tt/l0tq/kCVrpJ7xSbfRtJWsk79W9LX2d0NDjcQh2hUZXyQdrHozKm0gqG5bOA5JyuRl0ZTymkkcCNiQm8udjBFO5sqSrkjGCF4IbjjLZMNKJCnmFY3P3sIWBLBSuArOCc7dvJIJwcErCI5I0crs5dArDG35V3FVBZ85G4OT5oyQwz0UW3JptNNaW00fLbyuuy120Q43vCNr306bWVnyvR2fRvmbVnqiMZnYSNGQIpQFjIVXmZRHlnHlgeWVU9OWBAAIKsJyI9wYQKN6DauzJy5wYyQwKkMAUXjafm3nHCFi4ZW3DaS6HOFIjxtcksSxJDKN2AxAVuW5d5ylN7DKkqEAcDO7ByCoONu7gbjgc7twBpKNr3Wtr99dLWbSt02trdbsEkla+t1q7dGmm3rayst/edl5DhCR5axAZBDyAgsoVSA7ZB+X5dhjwAVIOBtLCltwI5dshBTzwY2c/MAWQgu7NKAAMBlxtwS6noC0t5SeZhnOBvK5DNvG4uONo3DAIBwAQAADtpsCSSTiVSVVHCMpyVOGHIBOGB4Bf7+4hQACAFO0VyrS0XpZrSy5tLpLWz7X2voCVnG0bSum0unwvvu7Xv0avoaLzvp2LW8QXAEJW0ukRPnTazssjSn5ZkH3MANnHDIcVdRVuLWMzuqRTJtZXBQwgKdqMyxsFuH3+YChOVIBUKygX5oVnikgnCsjAABcjYwDjegVd4lQuCWyA4y+Sc5wrUGzv44NSk3KyFbKeViIZA7psMqtMWEoCEjaUcN5eWYDaeKUXTaUnzU5Jwi3o4/DZTauvJc19dtVd/CUpRrwckuTEQtOXKn+8slfkV7RevvLVq143WirM5glhD73jikWF5idkiLK0jtbXSs5aWAkqBORuEeUbJCqumLeYzS3LXKRiQNPGxaVfNDAxiDcNgZdu5km3M753KxJyJbwNJ5jbXMYkHyNlnljctEVkJiy0Z5jXPG/GcgZGfLvtIlcNOlkSpSMuTJayDDpBLucM0LKGeJlUbcg5JCuZ5FBpu7Udbro0o3TtfSzTs9fPlemqm60VyyUKllFppNTfuvbpPS9traLsbNrHBYp5fmeVu8knzC7tIeFZt7KoVVYKsalVYt8rjGMTgM1wZRFhVjAjZguGTewcNgKoZ8MEdfMVtrZLFsLQv/tEdplYRdpcCMyXEIQeQxUshxtdmJK/JOmDhzIu5s50kT93E8izFlWJQpbD5BQOnLEgLnAYhWTyyZU43V0wu5KmrxUXFq93dS105r3STXwpJJavSy8+ovddVyTnUck3e70cd0vhd01Zq22y1VVLGLG2QSPPKJIxmSVWeFkKCJCqrsQbyjNxkjoFAFTR2sUMMcW1ooo4ndeXJWQKy+b0bkkAqh+8VUZVhmrCp+8afzSTJEiM252CbclTGdyFWJEQckM2W44cGsuQ+Y/lSyyP572sM0dskh+ytCNwkbEyKPMLbGyN0jlipUZNDShry2ckknor/C1b/E0ruLe99bMVOU61o+092PLKVr2ukk1ZuzSV1uk20rdC9ZvKq7GlFxKqMzPJGylTGqAZdiN8SNwoOXfLAAHGZknum89CLWZoiojEUmN6lFYu4IkETKGDKhKMc42kAms+0llV5/PhJ8uYxySTMJG8lXiWLygzDzGXKxtJnbIT+8XIFX7eMwPPLJky3cplJ3fKUkXZAsiFYoxlQwYKmFwpPznBIzk1FtyW92tXGzSSaabbvbdNNaeTmrCEXU5oxbag42+03yuySd7W1dt3aJPFARJNL5jNHLhoomQ+XEYjgxxqhCt5gXcWI2sDxhsgOlZsxeT5YVmDTlmkG0DYXaJGCL5vQbQSFVkQKQSakVgjhZAcqu0fIDj5tpwzbY8liUQqMErjAxkrbky7ncbSpZTgKCpVApQDDgsekh45IIGDkaxStZbt6xvPa8W0n0bs01f+VLZHNzSu5tRdko7afCkrpPR2Vtt1721ijGtq/mqsY8+CZ5WXPlyLIqAq6GN5C6sSGG3CREGMElnpZTtXIjO6WJ3+QSKULFiyyPh5ZHAARSEzIwGCA1Wp2QHz87i4WEqrlG2FizKu1cl1Z0LmQHafmOcALSmh8542Fy6JCzh4oF8yKcKVk2ySghmYERxlx/q1B3AFwKlRS21mmtI2Wnuq3fSzd97202ZpeM2uaTjTdnablJ3SWisnu3polqn0GpOQIooQzpKm4tM4VUVJFEhKSAGSVSXXajmEgeWhYlsSvI8RJLeZGHTzU2ojo0hx5gJdUZG27kUFuHUHaowXSLGIy0gyp4jVC/lsQcxgIN8aqC+c/dyvpGRUeQZZ45YjEqHzIpt0DLdSERqGAwApEhP7uMEFlYKQygBXtb3raqzXVO1rrdWSWr7NPSxa5W7qDas27yTbTSV7O0m46aR1t7ydtSyZcLKWk8qPDopxyoOzLKyABiSx2LlccmTAHNDUJJ49PuGIaVxasHY5VVUrHuDBicoV+bccM5+aQhQAbeEVQJCgMahkEkhwjBuGbcMFgW6NlmHB3EGqd5Ij2tyqByklvKzTfL5ediM0aq4AfAJOVBUR7vLGeQ72unpeNlq7vZ+unokndb7a4WKdejaL5VWptt2XLaUY283u+yTuuiKum3QMFrF5cUkj2qFZFeBp9sbBZUnQTsybGwI0RQxIUhsjNbG3nBD7MBnJUiQsNpzwvHVd+1wEOVycc4kFlDbWdlKsMchVBc7kh3yzSOksm1JwFVmiO4wq4wN53eZg4ksJoBI9uZZY59zmO2vZI1e2CyhDGgRvnkdF3MpQKwJKgFWNZwqOPKpPR7P7XS3RaJt931va6NsTSVSpUnScmoTknFK7vz6uyvJJLXmatotloLpiK2SS6j7JbdCSG/eXDDhWLdFTcpYABgTgqANuMHAymGCMGG0bWXIHmKcsQWYkkKeWAbHGRiaL8olAfcRaWzMCdpwXuvl2lVGcsNrsMNgmTGVFaYuEDTRDcs0LqsilVH3iAGjJ2s4yrAqANoAyxQljcLOMW92uq7pO3R3au16sjGqTxUkk2lGDejStKFPXputE15p9iUt+9WMFHR1d3zjzV8oRMPlIClCwwAoyvBXbg04jOMsASdwAIwMFcNuwAyuRyEKrk5O05NKGUnaq8beCoyuA3BYkj7xf5QDtYdDk1GzIrRjdlyCq/e3YfC7QynYoOTgvneBg/dYjRd3rquienur4m76rRNavXbS/Or2jpZWt8Sbdnf8ALr1SemzGSMQUj3LH5gYEDId1yhZkyrMQoDNlSBuG0gAZLIwQdjMSUXh9gBkTcq5wxZ2JAwxI2sBgdARHLGQ6SjiRJFRSN+xVwSVLBkAXjZIfmDJ8hU5GHBJgc7t7D5vmToCFDImwfLyGKHgYbBBY5EpSvrF27t9+XXou17JPZOz30aXKrNW6qy37X8k7a9dCrczXqxgwx28jlwr+ZIVWMBgA5XCEOERmdlbaoAdQTndbaBSiyHcroUKMCV2MAuB8hKFWyvGBySWxytRmSLcYs4zkMuQi/OFXa5OZNw8w4Ck8BtpBBqSKKKGAxRq4RXdowzO77mbcQCQcqQwxngBQDxhQlvvzbJq+ityq8bJ9227rVeV05SSim1ytaq0X7ydvid7WWluWKvrewCFUBCFlcAEbg77CMByQSqMrlQCNrqwIK4wcxqGdEdyGYgKzoxxnb8wwBgAL1xyTzyFJpkzMpIDFzKrOigFiZFAYRqPmWPB+ck5ztUg5IxVxOFQI25VVHdJUTc+XjEiE7gYREykg8IMtlgCQS6V1vblTVm3o4u/nok7taPVPYcYOaT5ormel7PbVb7d3535tWLsjZdkjqJmkIiUl4zLIBlJlYj96CNrMFI3KgA2lkFPSMllVSyt5PBXzGLl1YBxyoDFWIkO05TPUggxR3CzQJO0ZV1kkMCOI2dDHFgyhkC4dSyNiRivlhSAcHKN5gG8FplMgEmNw2RzENmMtJ94MrJuIGC/zZQiklpte+ito2rJq6d2ne7suy3Rs1JOMb2cdGnZpPR+61a8Ulro+tnsTLteNZPNIYsjmRJRGisFQeWm0Jg4OCGUbmORkZpZN6IQkix5XP+r3qGyuRvO4lycbey7nXIG1hIY4wBvjRRjbGw3qqkMGACozCR1Mm4gALu2kOoANVgQJCwBdo1yoZRGijahBKMUaSV+u1jhl5JBIxaitn8WltX0ST636aWW9m3baFK8m7u930um3a61W9+9rX0vomhG9WUEjyyyggBTuhx+7CtiREfIbazK7Ywu7ljBd5/0Ryox/aVmyoQcopIYKd/KgY+VchAqgH5lzV5YG2FlRJMoSyCXaqyuwBP8AdV1DfICNowxyVG0V7uJlisd7IZH1GwO5GXbtDEKuducqC3mF/vBsnqamd2mnZ7XaSWjaT2Ub+Wuna6RdKf7yDSSSeiu29lfTSy6Xav5l9rcb0aQN5isGhYDkb2bKoR5Zbfn5/vrJ0GGypvKCuweWcFc8HaOSCSMj7h2jOSNpGdvAqQgOp2soIIJJz8uP4So5wARlScMdrZ65jaWGDAllVcAZ3cMcbQSNwJb7xIbGMZ3ZALVV1r0tbsu1vk9F+ByuUp23bi9Fd20tdWWqulrv5aWbfCQdw2ksDklcEAqBjBY5KEAgAFScgnggnJtADbQFhtxDct8uAHzPI2cKSThTgleBhTjOK3LdV42uvzEEIMOpJRWXjBUsVznJ2gFnU7OuNaYW1g3ELm3uuGVSjEXDEbcMFLEc5yWwMrtIzVLVdbWWu1728/Xz02R0waWEqfE2sRR+XuVE9VpfZvut1bQ2JJYg+SCp8q2Ub8lsNbJt+Y5cs+3cAyrkAg4IGa8hlMTLEdrsCI2PzIrfISVOOAFXcSMbSuTgfMHzwpJNHIuQ0cFqyupyQzWaBmYR43NyNpZuoIYfMQqxoY5GZnld3Qb2+fy4yu0EJHvGwkBzg73cMSPRq1cravbXXyu3t2s/k9NDnvZXur2Td+lmtL3s1bq9NCUgBsEjAUYCjByDg/OC52jGcZ3Ddu57ZlqT/aWqI0ZVysDxjcNxiCBVfcGHyknDDH8IHG0A6kcyFpFUbXjBjkMiqUzwFyDtZ1LHBc5C4Ocs2Qph8wCRGVJhhhMqk7B1aE7AoeNyQpDAg8HghcaJ7d7Lzvold6d+t2mbUakY+0hO0VWhGPN0TvCSbSezcdbbKWz1vKYUdAHyZByBkgYBIB+ZeOfmD4G7GMKcMMi9he3uE1CJGddipqEIyA0SRti4UM3zNGmNxZWPC53KGDbi7ySpVVmHyyR5A2qxOXjIL74yw2t1+6QwB5pVU9dr/wCsBOSTlSemCCNmFYHGAck4IBpJXd3q7WfTR7Jq+73vo+idtDCNSWGqPnvJNWnF6uUGlzWa0aeklLTVc2+jqIYJolNvMoWTbMJFG9tiBm8pRjEauEUZyxTJIBOAbiKc5KgblACFQcABQWbLknvtYsdowCSDWc1mdOmM0BZrF2MlxbYybJmXmdELE/ZSOXTpHu3KuwHbsCJ5UVopFAbaVk2+YrJnBACqcREqnQ4wT0Yg0Ri27219NLXVmulrdfMVSaXvQk3Tk7xdtYq0bqa3drNONtU7puyZXiKNLLGFInVg22Tyx+7DhQ4wDlXJYkAhiT0VWVjeMb7MhNzhcksAAUUKZHAZk+YAZyMDLAHkFioUiITSlkAkiVkwyhU4VQixBn2MSzkbiFBy2UOK0Rb8YUhSuOVZsFQAGDbQMBgzR5UgbSAQBxXTCm33106cyV1rbRXVk07Kzb26cjnFvR2Teqk230Vt3d6X1TS0M9Y0nQ4XcGIjZDjLqynKsEByg4IG7EnDKxA4kFuI0HlWxIxgJEiKDGF4xv45OEbcuHLDIXIJ1ktZGdgdwiKIViVVG0o2NzkMXYbU+VFYBVYKrLgg60dmxQ5jIG3cSxwfugBecgKSCRlSOikb+u0KN7JK7SWunW3Xtvvr72uqMJV0vte6tbNtpvT59tV1tpZu/M29vMI0DoqN8zvjaQrBguxciQsCigEY+Q5G0AIDahs2Vm3O7gklVcIvl5x90jPGFBOcAAgg5yT0SWbMP9WcklRw2MDHJCYBJJIBPOSu/gk1MunMRtCMSAp7kA5XAxjaMkDAJwSQwOBitVR2sm+j1umtNX3d1rbvtqhfWotXbSvt2VuV6tX1Vn362ukzCW2UAZBwBkAff3DaRyM5+UYwWycqc8085NlaxGKSMQXOo/vH27W82SJzs44AVVVyAfnIwFbit1bFjjaDk8ncC4/hBwNp3DHPB9sHIqX7GVtbeJ4tvl3N44fYAX81ojwS249WDMFG4/Ly6g0ezaaez5ez68ujsunTTXpbWxGtFyi+ZXUtPe7x6Pvrva2vlc5jyPmCqh+UhAcKAw+QdeODj5P4TwCrHIEXkRruABZlYYAOT/DnoDgD+7uyMgKBxnpvsTOVbJAAJxg5IAUgbiASCOOAQf8AepfsWMqqknGDkNjI2+pBBKggt95TgKSwGL9mtN0tL+6/d2snZWT6v5aG0a11a9urtZ66PXVeV1a1rxucu9sdrbCBJhdrEKUGNnLkgnuBkcEZxhhzELMLEse8sy7HZyT8/wAyFwqpn5QBtBVT8oyQGUmumaxLgLsY8AqckdkAYMQPvnBwDhsgna2AY2sACrBPmjLBHKt5gDZBIJIJ/hIDYAwB8oJBFRkmmlpayV3dWa26L1t023Z2UqnNu+q6O72S3e3Tsmr21uubEBkCuEYAnAUgE9UwGBHIPOzoOmWJBBkFqwZvu5K5OASBnGSVALYz3zuYjkAcV0a2LAFWBJGQmF5IGQvVidzEHGB87c4GM04WbHHygELyQCQTxkHdgjgEEfMMNhcFeLVF3Ss7aK9tdbW7vW2uu/VK53Un9l2vu7yabd4v3W0767Nt2a27cwbQBVHBzjIxkr0zkAEdPu4GR1RcAihrfJUspIyBgBec42kFuSpO1jjGQdzc9emazOPljLcZwCcEA5BGAoB4wepXOwZPFNWz6MoxgYJ5wAAmMFRgcbhnPBBDcAbmqNrcq2SVkrWtZ7aa7rTva19+qLVt38tLP3Vq7720ulq7bHLm2zwVOcgnAwSCUHqWyTtweOAqk5waQwHeXCgNgKwwWO1SuCXZgxwMAkAkBT1IGekaxUZK7iTtLLtOeAufuDHA9MkZJBCnNQPYMVyAwxgoctn5SpAcdwwIBXIDEjJORhqnd7Po7d03Fbb2s/ub6NMtNN+enNtv7vXR30ersrbu5zQiZySqksCoGRuJBCkOxOCTuIIL4Vh97nq17YY44BKui4ITgKNnzMPlfjgAjgD77CuhfTtyMpVsMpUABgRng7HUEjpwGyF3cnIGYpLQqI0CMyoI8k7h93AxkhiWYYJAPzEK+RgEDptPa12mtNdLbrRL9Lu6dk29r2ve/ayVkm7N7r3fPXma1OSvoT9mnO4EfLtyMAkSgtlm5IJHHTaBhsFRV+WFmY5G0kx5JON3djk5cMcg7iFB4BUFjnRvrNmtpiImyBEMZYg4eNjjCuR97IX5hnJG7irwtEJP8IGchmJ/eDblvmHy5Y4ztw2PkYECl7KyV09eVvT1vG+rtrZbq9r63JqTtThdpe/LrZxj+6vvfRaO2vVvqYP2YFSx4+UpyME4ChRlujYOcAAsqgHpgVTb5bIUCRixyAcn7qnL42/L2YYyeDgjfXSfZcKAQzMEPJDZzxgAhSzcgLyAVG0kg/MWSWjEZUAk4yAATgBDlt/JOOSR98YU/LyZ9m1Z2tbTXfVxvqlbv1+dtDhqVo2SV99Hez2j5+Wyeqdr2ulzUkWWHzH+7gDJ3bV2AghiSMAsuSSBnBB5YYN37sHyyxUGTDYXcUJ8sFG3YGeFYYySNvzLW+1ooLKFY5G4quQQ6ZQvyVBEjBQoxyQFJxwYPs5Vgq7jnDhSpIVnZQyrjhdxHygbgSwzk5Bh03ez0Vmnve11531tdrvb5c069rNSu90/Szba+yrXsrN9OW7Rjm3jUkuCn7tQCFyJOYgsfBb5n/iYsQQQThgCKqRLt3ElAy4dSVLJhU4ITHPR8/KwB4JAwNo2/wAuWAjPmIx3bGZGCopZt2MBucDBIOMYZdwjeIEKPm6KUQFGAI4TcvbHIXHbC/e2pUcjk0rLRJ263dm76X3drW1XdkxrpRaUm23q7bp26LVK/dW0W/TFaPckfmK6yqyhyDjccgKyjceAfLVsYII5VskiJ16bgzAoVwNx+YclRgZ3YGVLElSSBnIWtBokmDphsrkkkqod1VeIyyjdzjcMAHDEsrhcxSRJGqlC67dsexh5qxhiGyxlKqHjXOGAOMBuRk1DhqrK9mtdPTVdVu9Hd/OxpGot72va0brrayutNde60085rWA/2bqO0Hy2S2cJl84W6BzIAoxnk8sSoy/zDK1lSRqGDSZDbcqryEYG/OcqCTIGYbQQQVIXOTkdFbqP7L1J2X5YoYAxBZU/4/F28gsoLDiMKQGBwcEgnE8qSZS0RZI1ctChALSrGqg53LGUjkCsVOVGDggECpasldXSimk35rbRW621auknbQvD1G5VrS/5e631a/d09LaN7ruvwtUKnDD5SFYIFCguDxhSxAUrjIycYO4tgjmoIiTIQylA3mRblTzFYBQUwzlXiXIwSNowTtAII0gJdpLBA8gGQBvwSFCx7upbIG8tycYLEAOa7Bg3G7I3BsZwhYqGGFAyvzDA3FgB3BIrJpX1uv5UtHze7pyqzS20W6fTp3wm2rJ66W0ts43tq9XbTutfSi6LGNoOA5UMrZYBgwxuxhFA25QghgdpHAxUcwSOJjI+EUsAzHABO3aF+TazAn5flI+6wOFNTzFVaNGYqzxuVRtqnKbCDkrsBBPygN+8OFUDoGRxxOUYANhQSHBdjht27DqrNljgEbWXZg4xmoavzJb/AA6N2WitdXXNba6tuns+Y3i9NW7WastNU4re6+9/kymUlYkpIsSI2ZN6pJG7blP3kww2DkKASzZO4DCmdVRQpY7WIGXJUF96qCuCQRuAO0EDcDksTyZDCvmDcuVQBh8pYb3YEHIVWJRcbWLYDZUHjFSeXwynJwTyxYlSFULgAnkKwwgwFYAKwJJqVFptqzTatutVZb9uraV7J9jRO7Td0krt9LaJO6S1SXVvfR9CFlRTucbRs8sKx+4ScBUCgZK5C9M4HXGRUTBtowo3AAjjcPL4ztPmfeGBnHGWzjtTpFlzGUyVJEcrucn5mjKbF8xSEEYYKwO/gAbmHzIwmCgRbASoIEis+4K6gr0DICoJTJ4D7VIJBGrV7u2uibVubl9275tXfezvvrvZnTBvXRWsnfS+lvK2m7aT1Vlrsmz5iB8p2kYGAe+3KoXyQV5AJyC23BzTHDKvClygxkHAY8AFiyZbBJ3sxAUDDYCsaRpJOTHDlVPAkcIAqvhmVSQ3ybMn5zu3jhz1QAefboyMwkeUKxPyGRUViQDIwRCNw2lSRIVI3ZNJuMb2TfvWdk3q7W5flrtayvbW5pdPe6a2ey+zq911fdWfRagkUTPIeS0g27d6rglUYKI0Hy7eMPtXeM8/KyiV22FIwkjZGfNAHlxruVCGDBTuYkdMkZBw2VwsSwSNI6NukCeXLl3Y4O1gNu3IUFlAlyEyoU52grN5KBzK5bzM4B3MVKgoFATgnC5BY8ZYkheiVFXScbatczTb0TXXZtPe1+t5X1Tu0lq7N9H/AIbczXxJX2T0dru+oxQuCpAIIwQwyONoU5BUAnGCep6Zy3LwE4AyFIGAQAfmKnBIUgcfxdDjjBOQ8JgjJ+Y4OSuOODyDzg7gdudxxnLcUuPl+ZWO1sMehwwUAhT8vPPQ46nPOTsoX01v3s0+jfLa1lp066rzd2t23svLVJL/ACtuk2mrCxgsQMABQx2HBOPl5YkKwyAdo6q3GCeGvRwowBY42lG3Hr2IO4jgHGWABBPykg4JijjO4ZJDblwW+YHGAVLHdwe5AAYADg1qLHwvAIypUqMAglQfmI3KNzdGxk4HDEZ6YQvfuuW902uml/xWiatsTJu6Sdk121u2tLdLK737a3uCQK2TgjBBGGcMgUhs/MOSxxnoecEDki/FCG2qpAJCvxtG4htu1GY9W2k5JwTndhsgOgiDn7rZUFVJON2NgGGZQTzgDgZ4DZP3t/TLF7mVVA+RVUs2MLHGoXeQxGR82SFzkfwksqk9NKk5OKjF3bSvuraau2ltu7VvRmE60IQlJu1ve1d0tFu09paO7d10SumbXhXw3fa9qFhptjCZrq+nW3gQZKA8b5XYjKxwoGkL8qI0IIaRtrf2DfsaeBfh9/wSw/Yq139tP4u6Vat8VPGtlb6b8GPCupRoNUkvhZTWuk6g9u4E6XVx9qvL0kxsbeKVNsSubYt+Zf8AwRx/Yci+PHxcT4h+OrIWfwv+HVrD4n8VaneBYLK30izd5o7SS4mCww3OsvB8zMSI9MjuJtm243xek/tmfHLVf+Cln7YE3g/wpqJ0D9mP4C2uo2el3lujx6HongvwlC7+JvGpttyRG51C3sHt9ISRw32WKxgjlDuwf77h7J6terh6VCk61evVjSowtdVK8kn729qOHp/vK0tk0o6NXPyfPv7T8QOJsu8McinWjTx0qOO4vxlCTX1LJIzhKjlkqyf7utms4ylXirShgaU5N8lSSfhfhCO8+MN/8Qf25P2uNQ/tbRbzXr670DRvEF1cxWvjTxNEwmkguhC73a+BvBcU1rFf2emLLea9qT2Xh2yE11eyQT/J3i79p7QfF/xbi8f+MvCeqa5p9t4eu/DngqG/03QjZ6RNeC8Gl65c+HzZDQk07Tb93lsfB1nIukaZZmyt2vNSvLa41S86z9pX4iy/Gv4j+GPgP8PLOHSvBnhFLDw3pWmQNJJY6Dplgz3gspVUAXNxp0Mv9seNtURTJrvi/wC3Q2WdH0nTYriz+2P8Pvhd8K/DfwP+EPhTSLV/iaLFvE3j/wATtcTTa3JceLrhRonhi+ijK6c50fw/b6fqzR2SKlhPrEOmRyTTW0s832WZYiOFp1csyqdB4LKakJ5hjKlKFSpmeZ86jU5JTi17Ki3y00nyrkTd1t+75hmGXZHh8DwjwxhqcMmyunCliK9KjDkxFXDp03VqNq0cOpctGhSjfTkk07yZ9Fn9jeP44/sL/Ff9q/S7DTdM174DeKYNH8R31nb/ANn2fjLw9rs1tFpdyunwB9LS70ppILC6kgk825gea4ug9xMjNrfGewtPij+wf8AfiLqp+0eIrn9nX49/CjVLokveXVh+zd8QfBPxM+Gd7fz7g9zc6Roes+MNCs5ZcmOz1Z4wqoSg++PiHNB+z3/wQbutEmka11v9oz4xtBZQZWN7jR/DsVpBNJCvIkiF3oMxdwDHmVjncRj4S/aDK/DP9gv4AeCplS2v7P8AZt+NHji7QsyzG6+NXxG+F/w80YugUkNdWKeJ5IiVEkkem3LKxCNjvyqnTeU5/jMTCnGjVyut7VqCiq7jCdKNRrSPOpqvFyik3GF3eLbf5z4NY/MczybxsqYvEVMRk+Ez2rgcmVVqUKOIpZll0MNTozbk5QjjJVqlON26a54K0Eon8798pS4nAGMO4G7J+UkMACu1eR1YBiM4wA2Kx5gGALfKuVbIC4z8uGJKqNpIxhc5GGyXrYvzuuZWOSCWCj75ByCTkMcAAg4yNh6jBIOPNyqjDEqy4BJLbNqjAwSxI+U4+VRgDb3H89VIr3uvvaJu+mlmklorbrfeyW599CDjCN2k+VXV1o+VX6LS6Wl9XdW0KEiGRSpbywrjDDO4YCgBiQGZSQpPBYgYPzk5oTbvtFscxkuJwmQdzHMeMljlmJAIAB3JuVstitNhuflSAeFZtuS4KKpJJ+mwZI77lIUCjdRNLcWg6OEuHJBKZIWPjJBAYsE28hiRggMFrkqU9Lpae4u70lD5aO7tfTVX0Rpro7LW1r/K7d9O91utb26WoI4me73yYIsZiUZiVwXB3bRJGNgBGIgrEZBQKC1UpDGAhP3ztYKgGcDA3MzEgjkZ3EAfKXUkADYjjCRXjgrtaxnBCAhh+8UDkKSAqsd/zYDf7LYGUI2RSY1IB2rtPzD5lUsxWMgZXaHDHoMKhC5B5ppp8t7aty0cno4pK3S+1vRrqZUH+9r2l7qlTVkuqhDRWave6+ej0J4xixuyqMAXsw4+YrgSyYIAA3AkZDZ3jPAKDC50yIQQMgANtyw5PykH+8RkcjBU8kAggHUXK2VzGx3Yls8krkkeY4BLlsbioO0ncCG+YHnGfKm0kBiwYHgZAXk52gHIKjBQEkKeVJBYGKitFPW6jfrzNc2l7aJd1o01vpY1he9Vc0r86a0eqcKerWml9FG1rtJaC3wb7LpDHBVdPLbeWU7b27KhtoQZ25AZiSp4JXPFAEhC5TOUOUIQDnACDAwJSxIBXAJPPy5Fadwytb6WqkttstqBznP+mXPyqoLKenB2gbM7fnyKzWQeamTkbW+XDIgfeFyVBCiMgcKAcgDOR1z5W0n0cYWu7W91N2T1b62Xbo0hYeP7r0nO23WbfWz+UdLX20vUAkfJdQiruULhDKGXy1ErtmMnJQsFyMYAAweayrM0ksWHIU5DEniH5F/iLqwYLgk8sQVZSAWrRaKTICEKVVWIYOVkO4fI67icck5wFIAA54qJY2LSb2U53eXsUKyBVjIkK7gxJ2jK4BBwR0UVDV3por33T10VuVuyXdWv5Xatta+m2qt0d3ZJvpr52srXtfSBVjjnykbBmDIfmByzSKwwQQcnK4UA8ggYBxSMzQssqBnGERwBhSrMcPt3IA+VyDtZcY5PIqy8PnKqM2MCNht3ZAVshcDawJB+YZ4/2jghjRO4KkhY2jKhvlaTcVAIBJBVDgnABcFguQ2QU4vW2nWyWt3a+mr23u36K45J3utGt2l3cUl5LVO7Teq3uCmRl2gExCTZujAL7wYy23G1F2ENuGTuxkHJJocpErSOFKxjbuAySoK5GQxJKkhhkjA5bocPgCxxxoSDlAcknc0m85K7hlsbgMYBAAJ3ZGSVkj2zO2Iz+7kJ5DMwzuwxAwCME7WZR8oANDfu3utUrrezdrbdFor3V3u+gns9bXt1V7O2r2as9Wtr2u1awFRKrEEsrJnjIDb1ONpAJQYZecnsMkEmqeyJIiZOAiEcFgwYgLlnw2XxtXYecrkFiMm6H3KXjTBU7QjKq8LjAK8ZT5TtIzw2cYyKglKurpIxDhgAoYqQylNrpsJLLlixDnOByyrhgmna978yXmtbb62s1Z2/XUfm5NW1ae0k7NSak7JO7srPTUXbMYo2gkhYBkEjvu4XKkqrMiklAAGDEv8AMGHyAlFuGIZUjJRgVL7vmBRTtCYQbg2UUqdwyDuyQxw2SeFNg2ZjZURplEaRofmIypO0MEDA5KkAnZk8kdVmJdMKP9U2CWG3IyxUoQGQfMm77pK/MTglpNJrmb1V+Zq1rWS07rqm9b32TGtLW1TV3rfXay+1t6J3e+lnxyblRURoXkASIyKg3KNucABnOwEDDcvsBLMxQFVjKlDvLbgocMCCwyFds4I2fLgHaCMjIyTitiRUCu7sqPGYH2MGljZQMnawYkEEoSo2qDwx5E5RwSd+cKwk4YDdxjb833SCDGdvU8j5juNXe3S1m7trRPo3bVauy66rQal0i2pWS31i0042im1+V1buydomEbeSDvjIbrkOFUtg5YAMQcKxBDfKTjipLRBIYychgRlNygg/uxgsOcnK4UjPRiSQKpmXyFVnZhESFLYJcMeX+ZyPlOMFAAe6jAq5FMDJGInQ/MjkJl9qybGGAqgncfuKWGAOOTUXjeTuttruybSWqu7tdtL+elzmV+ZrVW0va2qts29UlZWd7Wb97TrhErsJNzblABO8qrZKEKQSu0DA2AFhg85OCGz2UF9G8cq+Ymd0ZUlHjdMkOhABjZWYHaCF+UDnLCmxXMFxkRzxytv80BJQp2kg5IGWO4EA4OzKkcNg1YeEu6SpPLCyAsfLyyPH94xyh8rk/IGc5IBA6dJtFp2SlzO2jVnZQ1t3bX5J2R+Zc1SE43nKlKGsWk4tdu8km9H8WtvQwpI/sz21td3EyvGyC2uY5NiszbgY7kM4aOcrty4IMsMYjUAlZEsTQt5TPGI4zGQYTLAHSRIif3T7TIjMd21sZUDO+XjnSnt4riKSNiroVbIClnMg3BVAVsqU8wMhLsRIQF+QkjCskfT7tUvWmZpm2W0rSBUkTcsYjG6VjHclUYlnYh1JV1IZiMJRUJWaXJNpc2j5XZJXs3prv3s72tfrhU9tDnjJqrTXM4JaVNYvminZLe8lq76qy90lmt3tjazxGdIQ0S3tujMI3G0yR3G9pTENrbl3EEGMkkbcsdcPJ9st9yxrCYJy7mNRsmJLRsrGVQ3m7dgJGGBbAIC5yJI7owXW3e8okmC2rxoqPbkKZ0tJIzGBlEwGYjJQIFJ24itpRDAs8xmmsdjRw3Dx+Zc2swRo3ivVIZpLddrJHLGpwG2svJalCpyytyuClyO7tpa2q8nrr0bT2ZpKk6tNSlKM5xvG2zlGaUknom6kW7JO3NZWd1Y0bWYOqrMpjlWZ1kBKDaFbZmMBpCFZvlZVP3wSAdoI01VAsz2/leZOVkmZWaQSERld8jDIMm1gqqcqWzk8nFJFNzCjKxxNiMhDuJyzDb5ip8rhgrtnBCleWO1qv2sAhHlr+7KdUBIAwAjMcgby564ABbjA2sDtC94p8uyak7XfTfXdbXv2dlqcFVpNyV4u/vU+ll3e76aPyTshj2lvL5Mq+XIYNrq6YG11LPu/dqA5VnDNGxODhN5XBqvcOiN5K3KAkeayqcEYOUVy6lUL7wrZIVRhVDFgBYmkMRt44oYikkpE0hdEjhQIWLlSAN7snyFvukHPU1VuYF8pmt1VWQ7vkXguCrMCqkhw6qpAJC8AkBDmlJO2kY80XeS2b0i9HypuL9beq0FTbbhzSk4yXuWaaTdlrHTq3o0r3v2ZciR2UY2pnYwjc75VQ44zIodA7ElGORyfuty7pAULNbxgkMAy5KoQDvdmIK5kULydpBJBxjctVI5o2YeROSSqZiBdkMSsCzF5FEe1clQFlG0ZKhyAauu4Cs2ws21QqKAAT8oD85Crhyr5YkDrkAmtY/C29lFa322a0tunbRrW17vRmcoSi1dJ83SWm2+mi7a3bt00KlwscP75vMMhkxlWVmdCXYp5ZcIFUkF93/LIbwCC22tbqFMtxCGlNzJHJOpYGEHamTAY5GAw7DeoRmUKylZAVFW2E0kihXKwoCXGAZBIzhWWMqrBMDcHy2VVyytwVLpoY/K8oArtZdgTzCA0YUoQVCcdGbAUscfc+bbKi23ZJap6vS9o2au3rq29NUnZamymlCMbuSk1zJPRRumlrsrpPS6srvpZqqykRF3kZ2Z1Zk2bMHapba3lhOpjACjJAIVyAFeNG27kV2QAqzhmKnLMNmCDjcxJXCg7cgAipHUltxxkjJyGB27juZnHUEhWyPlyCBtByI1Ik5SYhVJUgDcxxsLbiSHAIBwR0A6gAYaWj621Vu/u66yW2i69V7rujO7bf2XfVpNXtZ6pLfo7aNLXW5FLGLjKSYEYc4BLfMOdspLMhyjshG0EfKqvkqWp0qMLK5CvtjjtpY1yGJKqgwS5LlBtxlCMFiWUZZqkVQz7QoLRqTwoALbUKq29mZm3Ek44dQCCD0r3pZraeNZgu6Es6GTYFZ2QLgAKMbsZUkGNMqpBYEpJRTacWuVro7aLe3W2yV0uqvY2w8pOtQheSXtabstbtuL1183e+v8A26rkFvbTrZWbxGCVfKtxJHdFivlZLuYg6gIQFAfrvABA2tgsu7W2nvxIbM3F3DDG8dwzoYUZDtIaJXSMmNi6hicH52JfaoNqwnjurO1O11P2dVZljjRNyphfKL8ESo4Od2WOS21jmptiuSJNxWIyBIyxMQCsCpYBVIUnjYpdY2AYDOCpGLlFPVvTW0dLcrtZ7N83du8b6t6aVKkqWKqrWElVqRfLJqTTmnZ2ava+z1S1fMtuailmih/0YSLI9pahY1aMLIpN085lkcEIY4QxBZjtZtzEPtA0rZWuVgkuLgjEcbDypQYo5w29o3YuJnysrb42Yspk2q2ASK+i8mVlAEv2a1VS7KysCtw7f6wM/wA25h0XzMctyFN8W0MazNGxVbhpC0h85jksh8uMMx/eB9xZs4kU7RhfmCUNE3rHlfu35UpK1pW7N3as0l3WqfZjaiVerBLll+6lGb1bUoU043s3GyeqtffbQsxSq8YLYKk7GZwQFGFOS5LKc7fk3fd3BSAxyZg4PljLOGAZNpI3EYXDEqVQDJHykEZBXG5lrKlc2sypdvG4uZXjtWIESby6bRIHOC67ciTynU8JnByL8blySXjlwrABEIZdm3iSQEI6lQHZtu4h9ycCqUul9VZNN9bL8/n0fkcU6bjadrxlZqSUknsrLTpre+u6vqSBtyKZIzHIdsciEqzLuCkAEBiwAO4vjOQOcDIjKsreZFgkL8+8OVc7geASAJCCFyeB0BIB3LITEJJCCSq52qpb5IgrMoXBXAGRuYgBQSBikiiSVUnIcM+2RQrMBlghXEakqvzKAygnj5QDmmnf3V8T69Fsk7W36tXXnvrKWnNe0LJfDdp9tXot1qlJJau6IZYpVEiqVJQZUPtCodys/BBVmChSVLMASCpVjhYUCJNGFlYyeWEO4jMoRkycgmON1JIIC7tqjaMsuZyu1lILOspQuc8REBQGXzGyRI4YHgk84OVUmGXBDOhADOrMw3tG+OpO0AgtiMM685ypIIwJSSfM9GlazSeiad499Hq23slq1Z3Fppxlt9lr5aN76NLR6Ws9VoRhZgfMaZSoJQIiYSNeMu+DES7hSNwIYAsCCAuITvkQfuDHgIyr8oLocBjl2/dqTsZVKssgYbcLkiYkvIpKBgC/lxsBJkqfukBziTJOzIGwMTkBgRTeOPEMciusbMJJUzEzFwUEcJbcJEj2qzu3AIUug+6KTulv0Tuldc1otJ32Tvtayts2kjeMeaya1STvt2WnTe67u+19C6URT+6jC7mH3UcKxkDfvCF2nAG3GACpUE8bcQmVlZRLHuIdmBxGAUQdCWbbuZSWQ4ALnGS2CrWmWJ2aZmXDFR8spZgGRXCsCwbhlIJyu3PmYIZWnTcQ5IXATeikxqyRsigsXAOS3JIwN3A+WNmFXdSXu6W1srvlfut6W3vte61011Js07yT5W0ld3vazVm9nrbVPXW1x0DLKkNzGShlix5ZAOEO1VXgjcXCn95hSS4wcAGopA5LBwwAkGxcsAqoQMqyMSAw2nd9yMgA8kVYZwj5AIztVVAyvzEvlgFO1MA5+bg/MvU5QPJkhot4ySHQIAyjAAwWPLdVIKMxPzjHyibR2ktUl73K+nI35apbLTVxEpNO8VG17xi2r6taS2Wl7aq7XyHRgAqzM0kjIWUIfuKqoW2sgDbxn5mfCDJ+YkrmvqCO504ktGTqNmdv3kHJIUADGRkMQR1OCCoIDTNErOTKBtbzyRJzGoCH7OygCOMOZNpy23kEBiVVZmJdbFiVjSS8tdizqGeQLkgh15JYncOCMCMZwCKlu8Wuvu63XRxu2326fJa2Y4JwqQm9G29GkrNx0VrLp7z8no3Y2PLLAOGG8HduBYqpBb5TnYCjbVHHBIAAAAWodsMvlzSRxo+YiHkVdyshwqjaw2qxLFSdw+XI3Y2mY4IAYH5sqNq5JQ5Rh8wI4zwRzliRkjNSBkwAxO1VBXdg7gNuwZIJ4z0+6cdVPTVJvTr/AJa9u67Lvocvw3a08k7aaJqzaVuvnfvu9F8ti2x2WRCyoCSVACNtdnQrhlzsy3LHblQzhsiziZIWtpo1We2eZZIPl8xIZpGmE8bBiXiALoG25BUg7tqmtcsQoCjcPlRhgELlQW3ZIZh3x8pUk8t0qndRM7iaFmjukf8Adz4fy1jckeXIAys0D+Ycrj5RzglTm1omtHez+elk/wCrb6726KE1KE6E1yqpKDhLbknFK17tJxd3ruumzK8Z+z3Cxzu7llH2aeRsB8bmSCYuxBljU4VNgDqi4GR82nHt+7gKrZKjbkgYUknKngDrkBl/1hyWy0AMV7byJLEIydv2q3AXfGGZyHDgs+w9YnC7s/ISVOUoIXsJRHcyPJDIHitpmbYMsXzDckMWEyhBslC4k3KoJbpSumnZ6K1+l/dVvNa3t3vsKcE7ppxqKycPszScXeL1VrPma3lq07bXDNp97+6MySmJioXeVXK7AGGAgfnYQmT90KMc50AqxqN7hY0ZETdlf7q+WS4IwQQAhO1iNxwCC1J4rV3SBolLxKsqkoqRjy2ZQzSFAfMGSQMnJI5BCkWUWCKXyzGd85LIGHmRxBGjRU3yMyoVKqUPDs2F4BGWk72Vm72bt2SS0vZWbtv1XW5jUcWklzq0dU7N7pXbuktVts9uutqZDKBslCTwndDINzeW/HyEDbmJy4DoflZSCBnBWeBjKCFVYp40dZYiFYqNxO9eWLxOSCCASQCpw6uog8oyRIIc2uJI2YpGsheNdm+M7xv2uTgOoZiFYtgkK11UDyK0Z2OikIwLbVJGRFIqcFPnTzVdiVYLwRsxtFapaNaNO2l2092tN1dteaatchVIyhGlO7Sb5J2u4P3dJPW8JeWsXquynWFwJdh4OSckkckoV27AuHyNpIOMYK5GDD9hW0mhmiLfZDJukgUsRAzspZkDMA0G1d0kYQ7TjBXAK3I1M6BUcwTrscx4RmVdzM8sYySyNtHGQVAA5JrYtItqA4y3CEbSu7BCORncTvGCwICqcKcADG8aKm42VlpaSSX2oxdnbbZJPTrpscU6kqDkpaxd0078rXu+9F7Wtqn6vbQckCyxxSpskjLx/LkMsmApBC4AJTcCFLBkLAsMbQdSLT2DLmNugxHj5uGBySRt9SgJ+UgsCVyK39B8L3Wqala2unRSzXN7OqG1jikKyqVjIkiUkpE6hT+8I+RhkbQpJ/pW/wCCaX/BFi++M1hpvxj+OmlPYfD1HW70q11b7RZ6ZrcUEkpkxZ272mo63bRBRI8kFzpukxpG8UmoShntk+gyzJa2PnZShSpKyqV6t1Sj8L0suZt9IxV29Fvr87mme5Xk+Gq4/NMwo5dl1JKVXFYmTSjJpNUqVOnzVK9WVmo0aMJ1JWclFJSa/n8+Dn7NXxq+Oes2+ifCf4aeKvG97LIFb+xtLmks7YHaTJfanJHHY2kKAMzSTzpGqh2YgYA/U74d/wDBDX9rTxTe6Tp/i/xD8DfhXqGrK0lrpnjj4m6VHqcdulvHctNPa6VBqflIsJLuWdQHVkCCRWr91/jt/wAFGP8Agn9+xNpc/wAJ/g14Tj+O/jDw4r2UmjeDJbDw58LdCvrf915Gp65pHk6NfvAyEXNtptj4mZ23RXWrQvHtr8Wfjx/wWO/ab+MUqafoNv4E+EXh2G9F7ZaB8LPDFlZai7p8sLX3im9sdQ1qd1Vgsn2KawinkUExYBNfTLA8OYCMYSqYrG4hJKq+RKmneLvCnGUZtJrac4yatprp8pQ43xebTjLIOEMxxmAnFunm/EGNp5FhKsdFGdLBU4YvMJUqi96Mp0aUZxtLmV7n0Npf/BuB8WbiFG1L9rP9l+xldY2eO217xHqu0MqsF8y30hUJIJAY4zg5OM1rD/g3F8bAES/tm/s1RFCflM+vIBgD+GWO37g8FfkGCOAQPhn4ZfEf9uv9pDxFHoXw+l8a+PfEE6+cYhpmnX80duzFRc3ep6/Y21pZWu4kGWe8A3MSiAEE9x8RPAv7YHw1u5bb4j+PvAvhXUYUhe50ybW/A+tXFlJcI00Vvqdx4Y07XtM0+d41aSSLUdRtriFFkM1qjCIS6UsFg5w9rDB1fYu9pvCuEdOW/v1MTFebXM01saQ47lQxlPKq2W8JRzVxU/qMeIMdVxKpvlSn7GNBVXGW6bgotPu2l9OXP/Buv4ug3Y/bQ/ZoVsY2nUb9SQpBA/e3ZJZl3Dd5aYJYlsg7sOf/AIN6/GyxQwp+2N+y/iHd8765erueR8uSvmSOmcA7TyskjHnBI/PW++KnxYhmaKf4v+DXQKC/kaTa3IB+bOHg8LAPjswycqdvQVzlz8V/iOgkz8XvCuA2QE8LzZz82PueFy2SVGDj354atI0Mr5bPA020knJcqSbcbJ/7YrPTfd236v6COcZ3NwdLI8kgk7pfXMfKKTte18Pd67PdbX3P0d/4h7fiJwF/bC/ZYJ5Iz4k1TJHynBH2Zjg8g/MQfvBQwLVEP+DfL4hE/vP2vv2WY1UnGPEWpSH+HsIInOcYOOB1yTzX5tP8XvHxPPxU8Oyr0JHhKVgeG5BPhcZIBBJ4wfTGDGfif4ylz5nxP0HaOf8AkWbpM5DZ4j8NZAzjJwOnAJORKw+XvWGBprZq7Slqo7/7W1tbq3on5m0MfxLzLlynI7PW/wBaxyjZtWteknrq30+Z+lw/4N7/ABvgb/2xf2W42OMH+2tXbH3cgEwcgjI+9knkkMrNUR/4N8fGgPz/ALZf7LKkd21jWF2j5QAC0Sggng7mK4YZLfNj80z8Q/FEhAk+JegyY6Z8OajgHkbjjw2pOAMZ4I5x2zCfGfiWTOfiT4fHIOf7C1dQeowAnhrqBk5IBOSAfug0qWD1SwFF2tpo237qWv1nR7aJej3v61DMOIYr3soyW3V/WMY0vhSteOt7W+7Tv+maf8G+/ihMiX9tf9leMj5iDrWqMe2cALkg9OvykY4Kk0h/4N+teH+s/be/ZXRcZDrq2qEYBHaRgwA2nnIIBU7WIIr8xZvFfiQ8/wDCyPDzDPJ/sXWuAATnafDfIxjI+pJ+YVUbxN4iYsD8R/D20fMM6RrQIwTnG3wzk9AB0AGcMScFxoYVarLqMkl9p2btyqytifS+jb766+th8yzhNc+UZW9tPa4pJPS3K9HfRevVd/09k/4ICamuUf8Abl/ZaDcbR/amoMSBjHHnscNg4OcHOcZBNUD/AMECdVO7d+3F+y2u1gOdUvsAEqM/POpA4I+YFF9CVBH5lSeJfEZxj4kaAwB5A0nWucZA4PhzsBjPHTkk/LUR17xLls/Ebw8VxuBOla0CMbun/FM57YzlTwdp5GNksBu8moOVo/8AL3lS2fSv6PW/l1PThm+MtDmyHLbu12sTjIreKva/Xqtnbqnp+n0f/BAPUeC/7dH7LK9Tj+1Ls/dK/dH25VYcNjOMZw2MmmH/AIID34O4/tyfsvgLwNupTMMDb8wzqkTEbgSFZWUKeS20Y/LeXxD4oBCD4g+HyB126frwGDnqP+EcHbGcAk9SapnXPE77gfiF4dVAu4brHXlx9/OMeGGIx8p7Dr8xYjJGODT5lk2Ha0VnUldaJJXVfW0knfr6XOiGaYuTX/CNlyjZae3xTa2u9+q897PyP1Qb/ggRc5Ct+3P+zArEYYfbbroMHjZrCrgjgnJGTjaMVVf/AIIE3u4kfty/st4HzANfaijAgcFRFeznCn7uAwAwcYBA/KyTVPERJ/4uP4SJyeXtddUg84B/4pMnpyQqn169K51HxgAWi+I3gViuSFe9vrYkcjBF14XjHUcFmUeo5pv6nL/mT0Lt7KU2/s7P27V/NXT3aRt9fxjtbKMu02Xt8T0cLP407W1a3fSzTP1Pm/4IDajLGYl/bn/ZVcEhmzqetJjDIcjaCD8qNggZBwCmM0z/AIcHa3O6JF+2r+yzcSNgYj1nVxkhVLBSyA88jAZiCc7CV3D8vDdfEy5MMNp4m8H6n5rBUWy1zwzLJJwCFWK8ewlLEMpUNEuGJU9Di5bXnxX/ALS0zRhb3/8AaWo3ENpp1h/ZFmsuoXNzsEUVpIsCW83mNIgV1upAwYMCBxWXLhefl/sOEnJxhFcta8nJxUbWrattrRarRaK4443EqUI1MiwVZSklCCq41uTbirRcajk23pGOu6srn6jR/wDBvB8ZNQH/ABT/AO05+zVr0zqxhhg1/wAQQ72G3A8xNFukXeFIDFtp4Vs9K8G+KH/BBf8Abz+HdjJqOl+EfB3xJ05C5WXwD4x026uZY4xuJtrDX08P31w3ys0aWkdzJtGCu4gL81a/o/7Sng5ZrjWfCfi/RbaAHz7uHTb+2jt3VijxzT6TLNHAyMpUpOUYNyVJwDd8H/tn/tE+AliTwl8Wvij4cNqBI39m+K9aitAgO7c9pIDBIqswMscqiPYApKtgG8RgsJRqcmPyWrhE3FtqniKVWMWo6Q9pJxund+8mn10tbevi8Bhavsc64WxmBuleWGr4nD1oq8feUcVGpB6dLLfS6Z8Y/FT4D/Fb4Na5L4Z+J/w/8U+A9cg3KdO8U6Df6PcMAyr5sK3tvGl3CT8rPbySwysN0UjDbnxmSxliKIUAxj95tAyfk5JyoAGMM+0bcAEAjNf0M6F/wVc8U/E7wJqHwk/a7+HXgX9pLwBqFksFjqPiPRrXRfiB4ZvVUqmr6H4g022gikvIwd0i3trLcSIWjS/tm8uQfkl8dfBPgS31+/1r4Xm/j8LXlxLdW+iatG41HR4pHR0gE0slw9xaxq22JpLi6lMaxvJPKz768fMcmwipOvllapUhFL2lCtDlxFO9m5x5Vyzi921yu6s00rvwcyoZWqCxmU46dek3arhcTB08ZhtItOUoKVCrTeq5oTUrr3oLRv5Ka1bO4njhSoAJwGALkFQAqY3KNxfPOQcGqL22WKHLADauUUMPubWYgq75JLA8Mf4lLcV2j2Tkb9rEAFiOm1RtydwAAxzt5IBzkcknONiWG7ovPGAdpZU++qgEHH3sMcffQc4HzLw8ra3UVbvfaOqXbfTstLrb5uGNV2pW1St/5LbVN3eyV7Jrs9uNaDK5yykOpwwcZ4VTsDAs25sAKCCyggq3GK7xldxVMgHZwigbWx+8BJ3BQYyFY5ZcHgjCjqpIMlVOcbcc8ncqqqMAxPHzqFc4cqcAjbzmSwBsB1yDjbjcAcGP5juBJPXkADHLgNknGVKzd1d2V7f9u6bvdfc/PQ66eK5muVrmu1fV3Tta/V662+V9URW0WdD1VCpA8uAq3lhnGbm2UGXG4jLrzxjJ3Dac4wWSQIVd1mdQ2CEKlivCqVJ2khVDfL8zgg9SGPVW6FNM1RFCgSW8IZtwTrdREAoGIbgkru/hG7Dgktz7x4lZADjG1iS3LqVDEDDKS20HjdtBUqCBgc8otcqlulyu19+m1166ddHa9urDVLyqu917ZS5muqp02r77pK6vZr0MR4zI7gcspkDqd6oqlRnaVLqzfMGXuCFBBDZZiwgKAkgeMEFSx3niMblDr8oZcD5QeCAy4IUHSdPnRFTkDezAopRUZN21SMmY4ONwyeF+/wA1EYyd/kx4BId1ySrkffwWZURyzBPlP3sg44rCUNdu97prTRpb+XT5q2j9anU0335WtG9mrrSz02XZWT03yzCy5R8SLvLLKoYSMw+QHIlX5yFGcdQ3LYUGoJNqKVkPLlY4yFAR1JCruKmQow3qzsVAwAAckkXnKuWcYOMg7iI+ThuQVOCoc/Pna2ACwBGIohwZPmQ8KQxXdtwmWYJhjuIG0jBGBgZIzmovVRS5e6S7LsmrK9tXZN63R2wd1ro1o7aPZX6St6N2d9LFfytoO+UykSHYNjEnBUmNQNoc8EocBAB2Y5LCMngMpMfR9hbJxhSCc84CgnLMBjAJGX+W5OXdSFJlDMjBxGGARQHYhsBWHH3cjJ3Yy9ywXqZQCq7QxA2ttG5nJbPXONwGCAckinFO+zWivvrzKOt3e1+mjdttLm0bNa722Tuvs+7r8N9b3Tbs7FRwj/K0RYAcZJVI5gQowWCnGRgDpnAJUkGmSRl9zq5V9wwGDncgHmbHTPzkM21STlsBT0yLexdwywHLMvyqMYIJGcNlAACQTg9QSGAWEwrEs5KSM8hAkZ3LM+BGqsfmX5E++oYHaeScgChxs9UmrJyls07R2V7tq9t1/l0wSilfyu7pO/u2sk9NHtre93Z3iq5WRXR0ZY4gSJFKAGRR0KlmJDgLtJIAbdnaQSKlSL5nIcljjcQxypBHG3G0KRsJBGcjPJ5MgjwdhZpOASzKu49FYgghfmIbAGOMnIbNKUOVKHoQGBycj92SWwoLE/3mOVOSSWyRagu13o7N22sk7NreyfRat6m6s3ppbpvpprvp1vtq7WdiNYQgIQhWbBkdi7sxPymRzjHy/LtDAhkADAk7qlRGwA2yQhAp2ELuzyHPXAyTkjadw5BxmpVBDABTyPlXIBGNhOSAeeACC20gA4K5FOgiZTghlByxDEH7wUY6gdV5G3HI2jduA0jTivhWlrLZaaNa2tq7O+rer8hvq20l2v6W1dtXayb1u9wELHIDDacZwSRghQQdpwDyNvYdRkcVPFbbQFGcYDDdnPIDMCQGyeMA4+91wBkqiB2Q4B24OABgj5cDnADE4z0DYwauKAj7lyC+Afvbd2FIOAVIOAcABsZzyu4V0Qpdu97Pa3uvolbRaPXby0T1slbvo+ia6+fRuzt5jYoEBG1cE8MckkllX1OFBONykngc9BnRggLuFePoQeuVYgIFVWYnJJyWPfHDAAMCGBeUA3ZwxU5IDHau7HyLk5IwBgnOPQa1rAWBBXnIBKjnjaPlAY7gMdRzgDcCRmumEG2la70XRJaRtdvv+C1a2OepL3dNdk9730au9U2/ei02r2/lJraLcwAVicgA7cGThcKMkk5wAcjleeeDX1D+z58F/EHxc+IXhj4f+G9KudW1PXtV06zktLWMyXF3c3lykVrpluygfvLiRjGynHlobm4YiK3Jrxbw5ozSyx3AiaR2cRWsQAJnuHIAwDjeqZXBALl2RMEnFf1h/wDBL74DeBf2J/2Y/Hv/AAUR+PdnDFLomk6ha/CXS9Q2rPrPiCVXs7nVLGKUBpJ5J5I9E0WVA2CdQ1AHegC+/lmBnXnShFJVKslCMnf3Ie651JJ6KMI3m7rW1k9T84484tpcNZRicYouviXKnhsBhIXdTH5niGqWEwlKKvJudaUedxblGCnLaLNz9vDx5ov/AATu/Y98L/sJfBzULaT44fGbS4L74va7opBvLTT9Tijjl0y1ktz5zC4Uto+lx/L5OmwzvCNt2jH8wfHSWH7Fv7MMvgOI20fxU8dro+ufENmUPcnV7qKDWvAfw1uXYNI9j4f0+a0+I3ju3craT3j+CtAvIibq5jk7/wCCd/4r/aL+MfxA/bh+N0VprD/8JNdx/DrQPEDt/YuteNrezn1O2gufMdVj8C/Czw5av4t8YTQHy7bR9IjsMre6laLL8P8AxB1K8/aq+PWpXk17q1/8PvBk2o6vqeq3bNJea1ZtqRu9W1m+jRVjGvePvEMoigsYl8yHT5rDQrANFp0EDfrmGVPIMqeMw6vmWOpywOURktaOFqK2Jx81ZctWs/fbXwRVNO7vb6DgDKZ+GvB9bH5tUjV4740U80z3Hylerl+ArqPPRptvmhKs+XA4KldKGFp1akYr20W/XP2DfghNc2fiP40+MbCXUrC1in1m8uLq526tNbyQarf6ULFpGMlzqXizxPpYt5IJ0V50SyjlkaDVxIPkfxb4qu/jX+1R4g8TXl0b6O48YanfRSo4liktdPunSFoDIf8Aj1kkt7SCxR5FjNtFAiMC6E/sb+1DC/7MP7Otj4Elig0vxvYeD7PUfFVtYGWFNG8S6x4M0a40zwq9vLIGS5+GWg61DBqYjjQ2vi74l6VazbdR0cCD8yP+Ccnwku/ij+0D8ONBMbyr4v8AiZ4H8HyFgHUaXdavBq/i24ZWQiWCw8P2c0k7A4iADSqUKsPNxuCng8JkuUUP3lTGSq5liJvecVHkpSlr/wAvJqclfVq11c+nzCpRyXhh5zikoP8AsjGZ7ipSlrTwVPDyrUYyau9acPab6+67vc/Yr/gql9ovT/wTt/YU0dna68OfDLwPrHijT4RhovEvxCljvtTa4gwzGaGBLlj5hdz55wWXBPwR/wAFZvFGn6brWu/D7Spo3sfDF/8ADX4IaRFG8Yjh0r4GeCZfEnjKOFBysUnxE+KbWU4B2NfeHZEcM1uDX19o3xQ0X9o3/gqx+0j+1DrsqS/Cj9mqy8beKrW7kMbWMHhr4Z2N94a8NpGSfJRbuy0i5vbVEHzXDqyliMD8O/2y/HeseLPiHaWuuTPLrWnaT/b3ipXEisnj34napf8AxQ8cRShz/wAfOmax4sHhuUNhli0CCNxiEY9LPVLKuEfZxk41MyrfV0m1f2VBL21rN+7Or7dNJvSWmj0nwvyOtw14KcMYXEQVPMuMczq8S5mnH35Rg3jOWaaT5Vj8fyq+snh/mfDl4ojkYgbmY4YHPB3Ek7B3xg5zuXoG4yMeQkOGAJTkdBlfu8BcjnnvkHLAZNbV5uDBQUIfG4lipXJA4UZyFyVU5HPUlSc48gyQAyqBywCnBUFCSCpJ4JYLyNoIC4BzX4LiKTSlZdW27bq68kl0TX4M+g5Xpv5XSltZa7Jadumnk6Mi8EsQEVt4I4Ck46kdQc/MOCT8wGFrOd1kuYApdAoudrFv9lMAglWGQckfNvGGBy2a1mAYkFdwBI+YAKSCuAMkHjBAYj5SpBw5Gc2fC3FuwDYzce//ACyGOTyAcAjHAOAfSvPq+7FPs4rz1lFp3Wqs9/V3Q2nZedlra+rir3W/rbb5GrbBjBfZJIFhPzliMK0ZHycs2BjBwFJB3ZKsTigojxxF9xdQAvYbymM4yiBgcFMkjggkECtm2LJb3xzlZbCfahUZDF0JG0KAWwQcsSpz94qWByI1C4VQTlSPLZRmNmcbi+wjAdwDwSx2/L9055qnNdWaT189LrWzs72ur9XZry5qCl7WvotZws3Z/wDLuCva9lyq1u+7Vi3tIsLsZQ4lsudoYgM7qCWwoZWKjbghhk4ADFRmTKeVDDHOSCSQQeAcHgYHzAY43becir5LRWl4kiM26S2bzACqgfaHIV97bGOGGxiPmJZxySBRlwMBR8pG0LgZ6/NjnA2hh1YYPKBg3OM027Nr4YuyS1abbe+l21trd7XujeCX753vafuvR2Sp0nt0b776apXJ7tT5Gm7lGfsK7VDgNk3dyy5P3jwMHfkoSCWZsE5uNrMDHuyS+dhUAEjcDhgSABwNpIbkfKW237rLR6cqSLkWKlvu7QDdXPy7ec5IyEDAuBuAyflzZJo4VRzG8hkOB5cZYl2wGz97bnBZeAygYIIBBm1rNvRJWvp9iNrrW7u+tk+2tk8PFqF23dSnZq+nvrXTR9EtVaWrdxzKSWAQkhlYMNoLZONuAGwvIIP3Mg9FYGqpdmkRkKqMEspAbeQ6gxoxCq23Awx74JOCFqUI0hXzXSOIFWQIAJATIPLWR38shNqnAHALcFWWnyrt+bPy71G4rLhgNq4UZYqc7VO3l8k7cjNQ/eTunFaPez0s9bWv2u9+q0saO9k2rqya5d3a1r2dt/5nq9W9GxChQYGeTuBYnPVRuwMhSSCduAScFcY5RzkeWDs3DgkZLcqVX5hkljjccbTnG4FhTRdKZGiO9ZF42uPlJJVSwZgAY1Y4UkctlR8y07gZbIZ0UB2LNu+ULkZGCoBAwxABAAYdWKbjKKSdnsrK7TTSce2mzel9d2N2kld2vbd/4U/N63ffrrsItu2Q7KWZS205woAwV2H92SV2hWJwcEKw3LkoflUiVgQ3zAnbgjARE2szsGQkBfuhsLz1NSbwQj8YYKQCARgbDglSxLY/2uBz0zTZNzkqCAFAfAXHyjBCkDBUMpJYcAjGCCFBOVWve999k7e7vquitf8AyEteiTdrax1V4avVLRXXWyk+sbtkjYyxBwuVIG8lgThtvyhcqXwwC4J3FwMYFRpGzEywyuGLITgKV3BDhVI5zn5t2QAW2BsKavKQoYYIZTtUEjLA4G7JyxVl4bIIA4yVqsY0jLzSSbuWADAKsaApsRFA3BgwwGwSRz0AqWpN3TS1T1afurlb3fXvbmS6XBxmmmm0m43dktlB+d91dWS8m2Uo5FZXdc5WQMwZo/LVeMMAfkdPmyFwWUAMB1JlTLuZHdPLRSCiuACoKfvTwu9doUKzHO8Ln5SQs7D7PCcASMAHGyJWB3BVd2PCOFyOABkMNgyOYEG8nkq0SlNm8DcFK4eLYDnkgY6AtzuXmlZ3XM02rXtezastbLq901b8hq9o9dbWei3inffZrbZK1ug6OXyyWJLHzNmGyzg/KoKszMqNwzbQeQWO1s4qUpE3keZ5gZTuQqyKr8pgZyN5PUEcEAqQCDTG2IheQK5lUEDCrmXerbdjLyflJY7t6nG0/NtqExyrNtySpKnzAyKpEbKjKq7nUFuGVSoXGACNrZTlyqzV7WVnpZXTV+rTaSfl32DSyT1v0cdFtrq3q/O29tS9GkLSXEUjRtIULeSS6mOJkQrkMXPmFskY5UBmPylnaVLOMGAxZLI0ar8zyZLOjbnGVDMeowwYYXAwMmpHMAcxR8spjaVF+ZYic/eWQbjkqJAFBICh9zBVqzGESTdBkB5PNlyzyRkExNuC7lbOQBvUHC4QkNwZcVZtpPRu6Vt0mrOzu3dJ2tbfWwLla11W90ld3sl0W27318oq3UWtvbPHNJ9jhVfNkiV/Kb5tgGZC2FZSGAO0AgMBwOlXERI4tkTgquCCzb8KwAK7mcHJOAVwAcbRhjiq1rPDNZwtbuTAcFmxh2klGXjkCZIkLsVJYbhxgntYiRZVUDIwV2lyqAj5SUUYVgeRtOB8xzw4FSmrKyTfdPlTV1ppbfo7rbRH5lVc1OcJuaUZO0ZatWstXJtp29Gnd6aWlikiEg3B8OWwDwm0OAW3FQEweEypA4A5cEuvLWC/gdPvxyOp3R8FSB8pi+X5JULFieMLncDvqaNBu3ZYkuCeXBwMblcjJYAlsjjcxJzjJFpQkaPhcJ3ChlIHyhgAuRk9D02/e6CravFKWquk+mjS000vvp6J6WMPaOM1OnzKS5buMraq1+l/NLb9eWWafT1SwvAJY5V8u2uzsDTsFcrDdNIx8qdd2EIH70OCTkHEVy8liv2obXjZY1njREiw8pcCZVcbWQlmSTKPC7HefnVGHRXEMNxEY5kV4pVZTHkfeYhlI2gsJkDbxIGG07fmABNc04a1nhtdQDzW0riO1vDsLhBtC21wzklW2s4LAjzM7l5jxXJVpyhHduKaUZSveDvHST2avfV77Ox6mHqxrXbj+8SvUppK1WMbXnBaJS3bjpqnKLVmldiF0bzeq4dmEqgqRatGznzBKDJsIcFHW4+7IqMQgZsjVyzrJs3JKrq02CC0b4XdGSodkEnIj3Nwuc5OM4U7zaXKoy7W86LFBKA0mC/KQ3JJZW2ne29EZXAVlZ4+RoGJ12zi4fz5I/OnCCQxSyBXbY0QZUELq4GFUbgFwwU4YpytFpKTla0k+VaXi9NdVqrPS+uzbazrU3JQlzQjGUbU5JWTaslGTurNN2tK7T09LJhLgqS5WUYRMvvwcoVJAJAQSHaCDtPzksxIqjBJC1tFHM5dv3kUSszAMEZofMAOZJFJCMGkwpPyZQhWaeGdriJyX8qSJdssIAWUFiE25XzCqBg5RgzMG67SoYtNukUlusP7oRLMiqyu2xZH+7HvLKZXJYkgYkUsQFI42VpNSik72i77u7Vre9rs97paO17sxS5VOFSTUlJSXLolyxve/W+iSV9FdaWs2KQNPMhKRT27pMjfuQZoDGojd5FZlYswRPLGxM4zswrjUiY4JyhHlgsQGGG2jIBXIxtAYDJRPvbvug51zIIXQbd3mN5Rf92vlCU+YFYSKNzuoZVXexQHKBWBBngV9oRndiiBlDq7OVOCFldSVYHltowhUgADmqheLcU73d7p+7o1ZWlZWV9d76bO91VjzQU7OMXGKinaTbW7vr1V0m27OydtCR4IZjDJIhkeFlcbGlVywySoEQUHmQFkYeZkfMQpIpEmiMzRKyu0cIYgAho0cRqPMMmfMyQeEyQ2Rkk5FO7KLHENkxZ5kG2BGeQFgA+QxCAStuC7CsgA2xtjinB0twoKgzNEWVEYsJlCh0WWQTbX8tS/7x9qvtKoM/dfMlN6JWS5mtd0lZO3qr6uy6gqblTTvKV7qC2ael927xWq6Wsuty1gIxUBjKpAXIL8DkHA2qCeAnVZDtGABVZWm811lh8mL5ETLxs7SAKX84LhAq7cj5Q2MFcklTJEcxw+VG7mQI43bMDdsyXaPcCmSSEGDtBI3ZO2VopMGQvmREbIVdsTsCOFAYKQSoDMwyQflxyaLttW15bOyu1b3brpffRefVWTmCirxkoq/u3d7ppq7ST0ttdp9bXK7ybFMSHMrbnjZkBSMsN6ySsdmQCMZLbQeRgjipMkr2colikxFC4LeZtD5WMPISXZmBGVidSSWCsygoWrQtpllUcMksRaKaN40Dxnjf8AdJ3KWO5WRixx8wYc1DfzGO0liALPKjruKhk8toziSQkKATtKp83AJGM8CXFu8pS0klflSSs0lon5+TtbpY6MNJwr0KailJVYczlZu6cfhaSVrXta60RNYRC3t7eLzhLuVWjAYMAJ8yShSo/1YZ1wrqMbdobA4ke2iaZpi8jbN2ELARRgbMyIgMZ2lUBJyyhgCQTjFC3tjJHp90A8cqW9u+/e7GWIxsWj6rtDZLBg+GTAwAMiWadfOjVflWMBcbCxcCTYAELsWRNu19m0xsACCoUralywjGS/lUezVoq+u2l9bJdXZ6t1afNiqklPmlKc1NuyV1JJ2210Tv5q+5iWsoghlJw7PbWcaIEkZpMQ3DsoaM8y7c4jIXcBhiFVt2orN50oKIIZIALOLakjndGpAlZJFUyMEJYlVMaKEMgeQqudp8czSNIFikaKKLdE8YYrGPP3B2D7kkkClEkGTjcNytsJ1Yo5fOdWkDCSFgkQhbKgysFSIttiV9vMhTar7QMbmYDOm22rNxtZKyvdWjo7O9lzXttdK2p14xwVWekeaUYJtq7VlB2io9Va2uur0XSK7t4rjyYbqJi0gVVdZGUJOCy4AR9wDKSRtzux5r4XG2RJEiuPsyJwtuhICE4VGCDc7lB50qqro5ALEgMWZgpZeRtcwyWdt8s7uiNJmQLCsZ3iRliwQ0gVlkAfdtYE/NxVdYX0/T5GYSzXEKbjIMh5JMRoA/LM0ClCirgsVjyy5HFN2lJxSstXJ2bdkrxsk33t8Xa1zmVpU6cedtt2hS1VnLlvUfRK7tvra6sro11HVVB+Y71YgDapJUA5Ypt5yuAoJAztORTc7t8e5gpILMrFcKDGQSUTHmEcMuFIxkY5qnbXbSKUuYfstyPLDQEoQsLxBlZXVWG2QFgiMRLuBCqG21aLHaVQqzryCFyMYUDJyC0nIB6MSdvBBxUXGSvspWu2rWtZLZ3u9bpre990ZShKDtNO6Vrp3SejUlq+rVnrZNojuCzxFE4dl2q+0FVBKKzZZWDlPvLkDc2eQwZ6zFWeKRVlmElosYRCyIsgmXaBlXCEpIIw4XYWLO2D5hJrQmCts3MVRdshViwLMhwIyfkwNoZuGCscBSDkjPJZ2Kvl/wB4cEgO7mIbmEoVmZSxwFK4UFhuxtDIrK6d79V8TTej97R6X7fF5bm1G6jy97JpxV0m425Xa/a1rL1Jf3KykCFHcgOHQqpHzhQN2VyuQN37v5X9MNhs0gjV2ynzO2SiMxEePmfCsp/djIUrkKzFVxuNPt4zLslcGOQ5ISRlLZYp8+4Akr6BsfNw4IJcOmU54QEIMthMFI2UEv8AOCobaGOQc4IyDuFOWt9JLZrS1krbJJWdm1bVOS0aSd3Fx51H3m0kpXaaesb2106Pre2+ukaTLIkc0JR0ZdoYoqtsQrJI8aEKyyK2AAXJBHmLkYaplOIxIjYG0gIFyGJAyyryF3EkK5bBODl+KjICqSq4hGyNydhxvO0Sp82wLtAHCjBbOS2KCAbctk7UICjJQmNWVirBFJB5JZOQibjnAIpRsut/KyTcfd1vrrd7a3tZO+7lZuNtE5dZLTVfF2tZN9ddNGACozYRjCzF8liFdhwqYZlXdtVypQbDlQudxIAyyoyRuiyFgVIHzRvGo8xWjVZMHDZJHcBsqMkTrGEXZyVVt0Q27WUKoJjyxKbR/CxO0nDgqeVqgrHI87FyrMIWtBECsrAph5WRgN3lrvIc74tjMp2yESp+6rL4bu6bSsvcTbd3fS+je+qvuKNpO99VZp/zS0tpbdprV2s09k7Fg20QjdEiRI3GSArJu3jgeaDt+QBXBbeiMBIc4xUcqCOLTovMV3F9aEyBpM4CMQPm3AoqBEj6ZVRjcMMbAWNIl2lY4wvmKFeQoflUSEMuRgq24kZXcAwx1FW52Y02JHfyxqED7yWkOdjEb5MlX3E5BUEKp5wpAkclpZJX0Wmt7uOivZNK2n3q6ZNJtyV5Nq8n1/kaV3fRvZP/AIc3lGCBuVTjOMEnfkdVJJ24KsOQykkg8im7htGWQMCN+NvPKYAIyM5ADgqASNpB3U4gbzuU428Ek4QtjHAOATwBjgkDB6BnhEI5A5B2ZwOyAMDxjLDjg9AcZ243il2fTXpuvXXvbZ9ra4SaSu038K0vq3Z6vlcd90r21+Z+7yAd+0Egc7gSCCSN2OQw4GCAAWJwMiKa3hnUxzZ8tgHIVyhJ5wWePB2glW2lsEDOWPy1ZRdvzAFmHGMt91gnz8lR14HXA+8CQMQ3AgMLRz5ZJXSMIpbc7lo8KdhBUA/645A27j8xqmklZ2dkl0Wtlo77Wdr/ACFBvmSg5JNp30vdcnvP05dLS066aOB0V5xcedJDLDE5hmCtIsgAKRxSoyqZogCWJXLAFslGTBtFre6E8MiL5gYpNb7gw2LuUzQOu4yKWJZSp3QhAp24IKoSWcHMQKlFYtkNHlVUAMWIUAEeZtG4KAVTIBh/s+GOU3Fs80UpdpYQpd40nbcrvlnUbZMKkin5cFGJLYJaV09Xt1V9NFbe/wA+nXS7XVTqU6iVOrJxlFJ0ql2nC7iuV66xaab6Ju6utUii4tGWCd2eJ02QXLYOS4YrDdCTgyqcLE+AJTg8EAHTWOTaiq5jwFcsUDM53KXDEgASFVAZwcA5xjLVHG6XsM9vOi/aQG+0wMV27Q0gEiEbnMTAB0Od8fBHXiOMtA6QMzOpZ44LiQ4BzuKwzNIWPmjBxKOJdwJO7qoqzilfys9tnZ6KyfTZ7NOzOWrCSbUrKqtdNFJNK04q2z0vbrt5akR3DJGApwGzx2KsrkliCQETuAQDkYp0enReXcRQPJbmeUXBKO5KMrliqDdkI5UB+C5JCsQASCFSTtOWKsF3thcAFFUEsASQcFMD5skMdxUrookoaBUiYq7YlkZgTGm0MHbftJLFSqhGOd2CCeK6owi1bVpJXt8Sva60SV76u7Sav8uFztdXs3yt3d29mr+m63vfrbWaS1bbFMkv2Z7dgwk2OVMaq2+J1VyfL+QBs7hzgcZrpNOto5nt5x/rD5aNGpKB2f5m2oDJ95myrHIZAUbO0Zpx232giER/LxlT9wldoTugCmRcjbw2D1JIb1X4ceEr3xR4s0DQ7CCSe4v9RtbWK2jB8yV2lRYI4gfmZmd0ijQFCpIALMwWvUwWHdatSowTcqs6cUrapycVFpPXtqt2kjhxleLpJSkuWN3KbS0gtZNt2skrt3SS9LX/AHt/4Il/8E7bP9pT4mf8LM+JGmOfhT8Pfs2oa0JEMEWt6g0sh0rw7bS8Oq37wyXWqneGi05QpbdcqH+zP+Cp/wDwUn8VfFjxTc/sY/sg3NxpHwv0KSPwT4t13wMr217491K3l/sxvBnhiXTFR7TwZZyo2lrDp7K3ia5SeWRpNKWJW+ov2mfFtr/wS5/4Jd+CPgx4IuI9K+NHxisE8Km/tXEGpQ6z4h06K++IviNZVzKreHdFnj8M6ZcIQ1teX1hPG0bIXP4vfDIaP+yZ+z9aftB+IVRvi58VNP1Oy+EyyQxXOo+D/DRkn0vUfiDZwTB418VeKruK/wDD/gKafcun2dhrXiQr9m0bzJv1KngaSVPAwqexo4elz16ySUYU4pe3ryd9ZzlenSjZacsU3fX+RYcQVuM8xx3F+KoPHZJgs4lkHAGSTb+rZnmcZqE8zrQaanBODr1KrjP2VKnVaTdCnf5s+K/wG+HX7Ovhq1g+KmuSeKPjJrllJc2fwu8MBXsfDZIeESeJNXIkjnFjceZHqEsLwQNqcMul6dLqbWup31j8WWPxO1Hw/by2dlpGh/bXuZZptUuQZbghl2rZi000RW8kVuGKQrPNcld2xmdgzs3xv4y1nxprOq6zq97NPeatdG71G5e4mup7yZiFjjuLuZmuZrazhWO1s4mYIII1KwkNxH8Nfh5efETx14c8LWifLqGpabBdSj90kVvcXtvbR75uRGlzPNDDJI3+qieWdsrC1fK4/EQr42NHKaDw8LqnR1Uq9ZylGLqVptPmqSfvNR5IQi0opLf97yShVwGWSq5/jFmGLlF4jGVWvZYOgoR5vYYPDRkoUsPS1jHnc6lX4qk5uyX198N/jL4/+G3gaLxtruvaguoeLxe2HgrwRpN9q/h+LxNHZTRw3/iLxdLpmoW1/F8PdGvYksrDRNNu7L/hKdbs7zT0uodM03WGGRodt8QPjt4mtbfWtTvNf1a/n2WOnRRR2uk6csnlN5Gk6Bp8VnpGhWEa4/d2dnawBF3Soi5duS8e6ha+LPHeq6hpsQTw7pa2fhXwdaqu2K28IeGIV0nQFRNoEZvLW3/ti+ADNLqWo3k8rNNNIT9U/s7fD/Vbq406XQp7638R65cLbaY1m0iSwQI2HmDAIxDvyrrIoCxO4KiMGvQwGHrY/HUcJKpUq4elOKfLKTVSzSnNXtZybfKkkoxemt2LLKmRYXGTznMqFDD01SWJxlWMaVKeGwcFGbpqfKlFwhZVJ7zkm5S5VGEf0L+En/BFDx54602x1TxF4p0Tw3bXUK3MiXhXci8ECBbSSTznBUxtLII44n/dbZWRyPU9U/4IT+S7i3+Iuj3MKsAH4TLc7yu1AjISCQxUSqDkjBOP05+EXij4t/Bb4aeAovjT4Su7nwlNJp4bx3axPeadHBc3CRkeIEZ2l0i6mWdEttQvBDBelDAWdFjZP1Mj0bwhe2lpc2elaVPaXkEVzaTwrvjmgmj8yJ1dHYOHRgwYM4I6HufuMfWyPI3TU8opYqjNuEZRXO+aFlJTl7ZJS1tZJPrqrn67lXiL4Q5jgsPiclyupnmGqws8Xhcxi1GpFR56dWClenNatppXVnbVs/lhX/ghlKhY/wDCdaWQfTyywwMZy23d0IBx1LDnipV/4IdQIQ1x8QdPXAGdsatg/MRkLyBxnIOF5Uiv6i38P+Ho2bbo1gQcYAh+UFQOeTjIzjkHBBGMgGoF0HQCcf2Lp5xw2YVOTjjJIAyT0wCCoyB3rz1xNw3C1uHabUrac1n9nvNpWSXq997r16fGHAStKHCuNa0aU8waSjdW2b+d7u/c/mD/AOHImhAAy/E+wjxuBxbMfm5yc55989gRknGHJ/wRG8NnJb4vaenO0hrByD9QHXBPTGRtPIG2v6em8OeHCuBoengkAEGFTjPzZ5XBwOOhGOuetQHwv4bYfNoen9duRbx8EkfLyp46kj+7u7nB1jxdw4lb/VuF/wDGnbVPqkt9U+61O2lx1wLBq/BtWWqSTzSrZ2cbdF0Se62S2sfzJJ/wRA8NMP8AksmkjbkgNZSAYJBwR5nQHHHTg5zk5cv/AAQ58Lsw3/GbSFGTgrYOQeOP+WqgA8c+5GCOK/ppbwn4bJJGhacQd23/AEdOcYOeEJ7kf7OPu56IPCmgAjOh6fyMACCM4I/n35OOp9MBrjDh+N2uH4Lyl7O262vq9U23rr6WPRpeIHAacW+BqkryVlLNsRony33Sdu+1rvXU/mgT/ghr4SOS/wAatKBI+8bBjjjvm4ALcckDkHvwamH/AAQz8JHb/wAXu0UHggNp7Y55B4uAcHsQMdgPT+lc+E9AL86BpxB5H7hCcn1+Xb1/PrUyeFfD/Q+H9OJBwN1si88DJUoMD5SBjjn0xhf64ZFFRf8AYUIppWTjQaastet7J2S7elzqjx9wI2pPgTmT6f2viU2vdW/LdJpOzv0Z/NH/AMOLfDcgJX43eHNp7NZSnK9jxckbsc/Ke3JzzUbf8EJ/DhIK/G/wwOGB3Wkpx7AG749s57d+v9NKeFdAAyNA03AIOfs0bY4HAbYMe/br6DMn/COeH0JP9h6aQODm0g4xg8kg/qDz6nrl/rpk/TI6Fr6R9nQet1srXvddfP59MeO+AuZOPAU9VZJZziWr3i07uF3ZrzS6J6M/mIk/4IPaA6b3+OHhUHluLabcMZI4N2AfQk4zk7j1zzF7/wAEK/BdtLGt9+0L4fjZhIxgs9HnvJFWJcu5SPUQ4QICT8jgDgod2T/T14g1LwfoUeG0rSGuWG2CBbOBneRyVyUWIseQF2qMueBgF2r84P2zf+CmXwt/ZE8O6jofhex07xH8Y7mz3Qadb28dtpfh+5mUy282tzxqs0s0DKskel2pIyqtMSN0jdGH4qwNecVHhmjVjvdxpUoRWiUp1HSmopLVtxd9fO/c+OODoxhKl4bKvOUkqcJZ3ilDRx1nai2opNpyulrf0/nj/ai/4JceDPgp4bOpeHPjp4Q1zVIg7PoGrxT6HqskcYLNcLHPd3O2JkR3CXCg5VEChsZ/JS31rxX4B1WeDTdbm8hGCPaSMt9pxw6urC1nR7YlHCyRTRJHNG6pIhVlBP018QPjV8Xv2nPiTrPiTxPr+o6rrXinUZLi48y4cQyPNKQkENoHEMVtCCkcFuqLGiDcSzDcee+MP7OHif4daPpWtatcpe/2vbC7CxCQ+QSyHb5jcSBdxDbOUcMWVCFzjnWIwuOlDF5Tlksunh4xVSrRqtxnNWbcVGNONlskox01d3qvk+L+M+EquY5fh8BlWG4ZxmJpKMMFTzCrinWq00pTnTlVUJR5baWUdVzLVq3X6j+2B8XZvh/pctlqlvf2GjxW2keI4buygF5pV6WRdGvrbVLMxajPo2sWNiIGtdTN9Fa6rpl3HdNNFqFgh4yz/aX8Pa/Y6PpniTR9ag1AtJDrd5pp0G3srqaW9a6j12wM+lmS3vo4ttq+k3YvdHvbaKOO5QEbJPDvBqQtrS6LqUsUWka5BJpOoJdK72jmRRcabJcIjBjHbavBYzo0YadAjLFy+1vONd05bC/njjtjbpI7yRRnloAXZZLcnAcvBKGhbfh8qpYIcCivn2b1cPQxlWu8TRUVhq1HERVTklBxfNCUk5RU4qLvzJuble2ij4Ge8R57XoYTGyzTFY2hB/VpYbFVqlejTdOMLfuqspJQqQlZS3UlJJ3V19PeOvhjpOvQrqHgKa1vr6e3aeym060Gn6T4rNrE8+paR/Y/myHwz4/0mOO5uJPD8L/2V4h0+GS/8N+Tc297pdejfsq+GfCfxcnb4M+LdAsJvEWqfab34d6nKZrC8vNcs4bie98EazqVsVe20jXrJXSyvrkSJo+qwRyLIlndXEL8D+zPrFxrWtW/gnxBrOoaR4Hv7/RpPGGsW1hBqj6Rp8WowpZeIo0uZN8F/pN3NBFb3ilWEEhjuHMMKIv6rfH/APaC8E/D+GH4J/seeBbX4aeB7vTPDXifxb8RLjTI7j4gfELxD9mhbWoINcv7KLxHYeGJtRsbhpEu7yK41CbzzY6d4f0vytKX3sowWEVfB8Qxp044GopQxmEeH9tCq04RqUbScVBtNyU3JWcb23b/AD7O+PnwdmnC2YZZw/QzvDZ5jquEzjCY7EUMPleXYSjGnLGvFTqe0r1FOjV/2SnQpOu6qUueHI6r/DD4xfCO3+H3xF8T+EtP1HSdZtNJvImtLnRtWttbsora9trW9Szk1S3VIJ9Q0o3A0zVo4kUwX9rcwMiuhJ8RvNCaENGVwoKklVO0P8hVQpYbkbr7cdWIz/Uh+0F+z58NfjL8PdJ+Iuk+EPC2i658Y/hVrF/4avdC0uz0u70H4t/DfTJvH1hpMCrLaxf2X8QPB1r4p8Ia7ZBJorDxPommXM1zc6pBAz/z2+JvCfllikW1cKw+QE4+X5VyQVPGc5G4Y25ywHznFXCtPLsRUxWFjBYHGVa1TDxirqjHnv7FtprmpxlFt3dlKO17HyfFWc/2JxpmmRTeHVGLw2ZZfUwtV1cLicqzWlDFZfWoSkudw9nJ0ZKXvRnRnGTurny5eablWV1OePlwSQA0WCP9leMhmC/N82DnHPT2oByoAyOTjIGANo4ZsnkKDn5eB82Crey6ppIUuDEq/KAreWCGwFCntld25Se5wMZwp4LULIdcBce4Hy5XOWAUhTgjB4ycMQSMfnVfDtXSSXu2eivfTW63v5tvqux6+AzVVVF31ai7pp7qOlrtP3ktWrrXS+3GQ27HTtXxGxjWO2Zmy2Cpu1UEYXGRnBc7QGC4BHynmHt1UqFkkhYuWVCxkLZcZWRSh+Ynbllk5QBgwyxHo6gJaavbGOQ+fawP5i42qILmJTGwdtu9snyyyAnHI3DnlJbZFLRxEADdKEy74k3ZJTBVQJFX7mFJTKkBjmvIqUtXZ6R0b6Je5rpy79Ht5aH1mCxLtU1SUpRad0lrCmm3rfePutq2i30tzk0Lrv2qNwDFYyMDcoG0bsfcIUA/N6DOekEkeQuVG4KCVUggthRlWByRztViQQScleTWu6A4+9yeGYL16cb+24kZIJIBHDAEUpozkMv30K7WLNgKdpCsR0J+VtxAJOM7hkjFw1bWjsl26JaLvZp26Net/bo1HZXfybtromlutteytvoZBTb+6Y/MuWTCjGxVULlmY5CtnJPy5XHJOarvAkpXcQyqAVG8kBkMYDFAobbgKpVuCACcdBpONnztuCFtjkKCfmbCnZwMDJDEFegPzYqBoWyuCQFUHHBLg7NoLDAZcY3rzwSy5JO3JxS0Su76uyfWOqSvtq/Naau1/TozXw81r220ab5EtbvfX0SKO0bi4J2kKhJYq33VLdSzEbflBBz5bDd8o+aPylRU2kqQF4OchgVBBLblOeAFx8xzgk1aZGVk2oNjErIOiAKUydjt8x2ozLtYcgrnOcMZWUfMhwZFQOvlghDjaXDEkDjGFwQTkjJUEUU0lbpFdEtOVLo7PVO6/C9l2U5Jpe8mrOzSi7v3Va2909bq+tru6sq/7oMAqhndQGAI5yEzltyjOfmUYPIwDk4ER2g/IctwcAg7VJjx5gC/KozjOWIx1AyFumPCgAEYKqoBORtwd4ZVAKgncMHhgCAG6x+WmXKrtRmLEqD842qu7BOSCCOqhXZeg4IiyTsrW0W1tNPuu3dO2zStqdNN6q1lfq7215fd6Xve13ZXevZ0ySHfcuVUblkwmHzjKjlidpBGBk8Z+9iiGEIrIiBQHdtuM7mYjlSx5GcAKflIywxyKvYJH3fmJAZctgA9wMZP3iODu425xtxGqjLDkP5mCx4HAVcEsS2ffG0rkMAatU3dX6bbaJ8ul7WtsrN7+hunvpa72urbr5rrZt6X0SECqrcgngbu4DFkyWxgHAwQo5XknjgzCL0f5uW2+o4IC7Qeo7rgEYJGSDShSNoB3hiuer/N8u48ABSOQA3GQF4yQJ0TKkg4VSx53HHG4A5XKqRkErkYbI5OK6IQXS+qS84tLbfvtZSuUntvurK+9rWvdrzaskm7X6XI024LEEAhWIQ8H5Ac43Ek8N82CvJPy1dhgkOEDJjhixAJbBXC9gvCjBDYGSFPBpsELkqWRdpUELgPz8nzEjayFcEqMMeeDhudm3tyeDlTwQT1xxhQSMjdweAARjOxsiuiML2u9bJ+78mkrPR3fVK6VuhFSSin3S3V2o7atJt6t7uzduul3W8I6ABgDhDgAAfKMgkjOR6HO4kjByK6PT7FrmWKJSq5x5j7RiOMH53YkEgYBAYYyMn5srmvbQBiuP7oXhSXxgYwccljnlgeM5BGa92+Fnw51rx14m0Xwl4f06fUtY1vULOyitbWFppp5rqdIrTT4UTBaaaZ0VoyOCSWAUMa9LDYfmmnJPliotvSz0Wl7ddVZdLJq54uY42GFozlKUY+43KcnFKEIpNzbbSSjG71slofoJ/wS9/Yq1r9rz4/+GfD7Wk9p4F8Oywa14x1pon+zaV4cs3Et3K8hUKt/qG37JYJuDtcT+ZwAHr9F/8Agph8eYP2tvj94G/Yi+Beo2Ggfs9/AMLo2q3lnMlv4bhl8NWDyeKfE+oTxDyG03wjpFlfSvPIZEmnhubhPMluV3/Ufxm1vQ/+CQX7Adh8GfB09qv7Wf7SOloviG/s3VtU8N6TeQFLq4jkTdLCmmQzy2Ngx2iXUZLq4jytsmPyx+GXhzw9+zV8DfFHjv4l26ah4k8SaVofjL4gWF/KRe6tputXtzqHws+DBlfdci8+LniKzi8Z+Pkj2S2Xwo8JXltJJ5Xim38/9V4Wyai4zxeOUqeHp0/b4qo5WdPCJJ08PFtrlqYpxk5R39knp7yZ+NcGUqPHXFGK8Qs4pznwLwJWnRyHDu/LnufyqKiqtKMrKrOtWSwuEkk+SnGtiEk6bZx/7VPxa0zwH4G0P4HfDC0vdKGu+HrHStF0so0OreGvhHd3EWoaYt9bsBLZ+N/jzrCH4i+MUfbf6d4P/wCEG8LSSJFHfWtfVn/BPf4JaH8KvDXif43+OPD0XiLSPgXdeFvFV54enjDx/FX9pHxXOdJ/Z9+C9jGW3Xllo2s6gfFviyyMU6QS2lrHcWxt5lmr81PgjpXjP4ufE+9+MPii2ufGfj7xr4xFl4L0iWJ55PFXxB125WKK8W0AYy6PoPmROttCghht7a1tIdiMob+hLxWuj/Aiwl+FWh3MGr+G/wBgvwPJ8TviNq4YXFv8R/28/jbp8ej+EdPvJo2eG/l+GEeq509FdxYzaKsDgFWaP3MPTxHFOc4enCnKUa9WlQw9GMbRw+C9pGPKrLljKtzKPN7rSkmnZNr9KpPG8c8aZVkGKqe1xObV55nnSpPlp4TKMDCNTFRgoyj7HC4aiqeBw6doqU4uN5U3f8Uv+Cl/jXV77xBN4R1TXk8Ra9ca/qkPijXI5fOGv6/Ya3deIviH4ijchQtt4h+KutazplmELI2gfD/w7bxu8NnFt9U/YFsx8BPhv8cv2ir2P7LefAH9nTxZ4j0G5kXCp8YPjrNb/Dj4bWyc7xfWOj6rqWtpsxIiWbljggp8WeNvDnir41fH+fw94e0TVfFCeHVGjfZrd7S3D6Z4Ospb7xbq82oanLaadaB2tdd1e6ury7jjMzkySlpkV/vT9p5bv4dfsb/Db4H2ek6noPxE/am+Lt58a/FuiX9g9jeQfDHwpZ2vgH4CaIozJDqFhqNzL4m8U2M1nPLBK7208HmKI2r08zo0que4h0Wn7CtSyjLlHRyo4NQpzq09G+SpUgttU5pR1d19bx/hY59Q/wBXcJUo/WOK82wXD2GwSnD20ckU1PGunQi+b2Ty7DVMOpOPJGVWMZNyaT5L9nzRLL4ZfsE+LPEPiORodU/ar+K9n4U1KcgR3kvwh+GiXnjv4n3LTHrb3fh/w3runyEfLLLrVui7vNJP4c/ETxPf+NfFXiTxfq0mNT8V6/qviC9LcYudZvZ7+SNdw+5E0yxRLkgRrwQAqj9v/wDgoddwfCH4e/D34GaZItv/AMKg+DHhX4aSW6EoI/iJ8YktPG3xIuyFYA3Wn/D/AETRNJu8EyQx+NiJFUTbH/B/UVEkrZBYYyC2QFG4DG3JzwckAA8sSAAceD4juNKpluT0HzU8twVOFSSs+fEVFF1Z7byspNtauT01P1rjDDU8JmGEybDxf1bh3LMvyWnGDgoPEUaSrY6ouVWTlias4t2s1TSs1a3G3IKNt5GdxHzbQMFCQdw9QQBwG4UDPJygCCxIJDYLk4A3EL9wD5cZyeCc5ICvg56GePa2QNwI6bcgHAzjaTndyVyTgZwewxJ13FcKxG5RnHdSuMcYHOVzgjA4wwBH4viqVpSlpfSzd9LtXWmtr22W/vWR8i4JK2t31t3UV6qzvdpNLy3We4Y4VgWIYEFc4YBQBk4JJ7jjjBDAdRmyor3Nqx2ho1uGQEY+7HGOcj5htYncCAeOcHNarAlt2TlVx0bBAZckkldxbAB6krlSuSC2dKypc2zEsB/pO7apwcohGMk4HGBzwcA8Zz41Wm1rb4ZRWrX80Nno3ZW6JbrcynGyWu9u3eOqfe/RLzfS96FE8q+O0t/oM2QGwFy6n5wgOQBncpO7g7SwArGYoiAsVYkmBWKbeThRncTlB98uBkE7jtYCt62B8rUASFDadMcMCRjem3O0BepAQchjwhxxWOVkYMFUqu3acKGJG0bNqjaxzuIRzgg8Ak4zyTi772WyXLL4b6XUdUu0b7K19Wc2HTdavGWtpR2i9UoQulq23v2XV2W04O7S75kw4DWQLAAknzixclM8HBeNlPcgjqKxZJAgVpJAN+OGUrjcVOMHcMfewAAGIyW2ktWyq/8AEuvQxy3m2r4AfO0zFsHkLkg5B6ZB2gqG3Z0qBkOV+XBCq2AoB6Eg42lQcAg4XBB5wKxlHRa68qs093sr2be2l9Xb1OiMLOtJJX9or9b+5TV1Z7Xsr2erT1vo6dQbTTwoYKLF2VssVKm7uWAQAKSGAxlQCM44K1nuu+VGLoI8CUAsNzOHVU/hV2jA+YjepViCD/ENWaPbb6cQVYNpy8Y5Gbq5Hyt8uJOxbktgliNxAoBUIAdmDxyYXMhypU4PKjGGJJySFGCrbTycHb3VdWtG9t3ZRa6tLVqzfTdoKKXsYq1uacndtW0m+uiWj6q+2isiJ8nemeoIGQAWDbSCgYghmdiDuxuyQANvNciMFUKEyGNQiq7MThiqOS+0fMx3NlgxJAGWQGppQqxyHLEtlgRvON+0BYxtIKqzAkEgbsElTwK7QukeIJSCFAbepkLJn5uQxVThdqBcFN58w7csJk7Jqzk9NN07bW891vZb2ejKly7KPvdeqs7NK/f4lZ6Jqz1HREys3mB1MeYwhdCxVsPHK5U+ZtcsxVmHyjAAK4JJZCk0aBZCSGZnHzJHudUBfftBJUHBXAPAALDFNaNN1u2C0qJ+6MLbCXU7SjBQQSSXHzkfKxbABXFlSAoA3ZG0swxw4Vfl/j65XAJIGB2ANSot3TfvWTi/Xl0a2Td1tuk721FFNqzk09FfdppXTdttLvS+yUvKlna252cESlVXeFRkDINqFWQZyBhyMKBtwzYxKkYUtmR9wy4DElVzsYLglTggccFWJ3oRwCyRFDNJKJJJCfKUoFx5TgBFRtoO4BQzSKwIAIU72yGupihBQGbYqHazK29SYxIwkfP3ONwIIyfQA1Kdm1bbV99k3pezvbRLYFeLv6aJatxaavrZ3as07eiViWTeUcIA78cbBgDGXIztJdAvALPxghiMggiVTLIyKWAPzALtZMKoVATkH5PlcgM2Mn5yQGxLtBDuHDKGHyqCGOwnYgY/x8FSDjJCkA8Tt/q1Zsn92xyoIU8AHKhSdwBDbtvGCTgZNUknrppZpaX6erv032Ras9XJ363S91e7bRbW5vdtuo20uitJG/7oxzRInSQSZbeCyYIduEYAbAVxuC/LlFyYpUkZWVd+VJdCCgLEAqFUja2ATvXOCwBJwOlkAPH+/aPJ2lcum3A2hBuQAuWYt5i9C23jIYGldrceb5SRYSTgOApOWHypvVXVEXG85IZUYFTuCgy2knu27Xirbq3k0lp6d7WdlL3U0tea14rvzL4lrpbVaX112d4ZUnV1mRi6ts38MI43+RsZdzhVAJVwCyknO7lasKzyOVXbtiUMUIAdvuExsUHKE5BKswABdiVJFBmWFY45A0jlUIKDdu4RfnLEkqNw8sAbmUcjepNNE3lsURFZmcfMAgOZEXJO11DhgGC5AO3JzlgtSmnvrZ3d+9k0nuk/zXWzIVtLJJNrdPb3Wkmn1ts3dtLW2qN3lTYYKLbDsHJMjeZvLY5ZWTBj5TBUHnPAU6sFwgaHzGG07NmPlZfmRcjajY2kjci5CsSxAB4xZNzYOXYpIiBSG6AMABtAWQ7W2hSoLYKsFOQLMDb2SQkqVZcyKfLR0DI24DDbZADuJIAbcQxI+Uym1dJaPa702Tt1ei+FNX3abeyUmm3fSTve2lnayatZXXR7fNGwYri0c6jZR/6NIwa7s3yqCQodzwx7Y1EYyzK6qGizuK+UGx1No9tdxLNCxaMRlMAKro4ySkoQNtZW6Lk71OQdpDiK1uoZYZGQbXAIeEhPMgfakZikGXJiAYqMkBFG0tvJBzJ4LnS5Pt1tkwTZe5tQGCIpLE5BYZiU+YYpAB5R+Vv3O0mYpQs1rG99N03b3kvvTivh16H51OTrt0p2pV6bSpybdpx0ShKTbUn1jO75lvd3vuSkx7EjZYydvmbyGZVDIqsQ4VjIGG0AklVBXGDkwveRI23LOSRGVQOeflHDBypcjJzltvAO4nBit5oLxM27F0kBWUEhWjZmwTKFY7WO4qHwQV+6WB3G7DZ28ZyqLubkBjv2KSpGCxBVVIGctjJIGCcU25XTTVrpu680kkrK1/PTV31sclowbhVjJzj7vKvdTbcbtu/o15X0VhBvZlPmBQNjAA4QodvyABVGSvygg4Khl3AEZhuIVuklgdQ0EwLkBQpbAQB4RtJVkb5wSxKgKVI7zLcJs3EEHcUEar821SigKwDZZiScnncSHC/ep/73IYoqBoyY0OTJgBeHKhSuWyxDADcVIzk4bUbNSu1ZKW9tFG6a1s+r2vZ7ijKUZKStGUXeNu94vprdXvpq/wADmZJrqwCWt1HFd282I4LuZVeYthgsEyM6nzFWQ+S5KbmVQSoZ1E8eoJp0kVrchjFeqDBcMhjjUuVzbzGU8LEECKdqlThlBVmUa1xBHLE8T4lEsYBTjIOB8wVANksalWV9xIJBXgCuSuQbfbZ6mGuLUyJ9nvY490ywtuSJZzl3imjViyEowlChWCggx8VSnKlJThJONrRu07K0fdlqrx6RvddG1oexhnRxkZU5wip2vNR91yTs1VpptpSg3rFJXT8rrrpledWkUvAQnnRsEYlSgYCOUpsIRs7wSGDL/FgKahtFEtuuzDbUb5t753mNRJEAVMqhF+dUZiUBBAwMVjQxXjQrFcySvbxlHjvhK5uRbxvtEU8Em35xkyAvHvYkBNwTJ0IpVSdYYpSWkR5XXDqkT7g4klEowx2lXcBwUUswLArnenK8lJJQUrJp31k2r2j6avo0rb6HJUoyhF0o1FUcG5RlHa195NpP5auLutLlp7ZFjEZD7Au4l3lwu4Yclv7wABVSpVXUOuT8tUbaYwyraQfv1Q5uXaRmMCHyQrsXCgyHdtXYzIUAGxiCxtwPNJEkd1sWVZGWVVVFOUCoJlUF8NJvBKqMqRyDk5cIgLh2RQWKsxkG6NQ5YL5gBYCRsBVdiAqhWJPDCrd0o8vuxdm31SurLW6V7RVu3Zq5kpKLnGd6jXwpNuEpae93as9GtX1uTRgOWXCtGQWXKbXU4Maxp0Vhggjy2ym4FCCMhZFUKoOCxwowfLxkMTkqoZQAx3srYI2uowpJr2zFookliBkjU+cpjMSqwIXexUSbwymJtq5KnqqkuiXUQIBkLkBT6u6fKeVA2KqFO2eBgEDmqjK+6Tule7b6p2blvZvu9npbQzknGTTbTTaSXXVa+V9NddO19If3MIky3loxJZgsjMWO3BVlGHG8xsV4ChQA3ABkjkSSNX3q+/AA3ZONiZVkO9kdRtLsTuUscDA4annRnLymVgwUbIURYV4yIl++HJQbuSGzu24zl/O6T91tc5LOVDCTbtAL4ZQRnJHAUndsKtRGTe6tdpKPK00rpJvldraq7euugNQstW5X+K+mtnZppWd7W112sOkG4srlwGQoWAJOW5BVl6DDAgnKg4LNkDFH5d7xK+7KMsg3Z3JJtLBd6kyMd+fMwAF+XCt8pfcx+bDuRmhAMbF1LFmRGUy5YFCiEbSG6DaAQwO1qTLA8Cx+dlJDEkRjLLtZVRlTk4ABfzJBvyduVySgUk372iSS69U7XSWrV9LvXyv02o6csoubamtldRacbNtuzVnfRd762J4HjhhhspGeWWO3YwH7omtgrspcMXLSwrgSKVyU2SADeoE0ckbgOw+diSVKjLIW2kxkqGALDkBNp+87LgZo3VuDDDumMHlSQFTEXfB+YO8flneCyOqkksrE+YVJHCxNIjmNw8jPujt5mCRiVUV1MRzuZZ4xF+9UcS4OxAoKrKnye7JK20Wk3ZO1k1q201o7Xuk9LtPonTVVOtB2qyblOKuuaScXKS6WtfmiloveSsmZzLFp032i4ybWcT26eTMXe2ndpJ4zNbMUWQKkoUZJaR5Ds+ZFDb0LxXEUToN8T27/AGYIxcsiuwMgIUlFcAl13tIrH5lbJNVliFxJdwXEIcyI4IbJSVMqEEZws2/ejOspIZSgwYmVSMTdNoUvkkyXGnXBceY3J2nc7bd7BYbsZIIACXBJcbZA61CbpWaVou97JJp+7u9bxfTbZaO+us4xxS5eZqvGK5VfScWklZ9JW3195a7ps6eJY5pZjuY+TmOXYX+WVtn3wqq2xWz5bMWGAVxhSKz9QVrq3mgt3Blf5DKrfu2GEkfc4UFnk2hF2OqyByhYHJV86f2h5JsZ1itpfMklcM0H2xhG6Ii7IxIZYmjDMWY+ZLsbKgkBrtHEU3q4kytsSYzt8pCvzt5jsnIVgz7w/JkWMjOHumldR5d0tbS5NW0+i9deyZzwioOE7tzjZqm0rw5XBWley6cyirq2lxRu+yqmCruIY08wkSNKMf6shzMwYtL5MbcsUKllxualc3FwpiS3iRUEblmlZWY+W2GiQP5ch8wRttJ3FtykDAUDZkjWeMrJllMa+WUZtqEZWOQPGo3MQcmIt1IKkMMVnXqlflYLs86NhAzPI80cbAZRcbyrmRSfLYRLzvJDoBTTim7tWs7p2b96K1a0eu2rfda6aU5KU03HmbbbTeiWltNdrPfa1+thxuMIgbCu8SAKyKpiUhQFkbc5TBO/LKW+YYJzlm4j3scF3kXG7OWIPlglyoA8sHDZ3bxk5DEsQ6JZMmM7AQrHOSWwpCrEqyYV8bFYNt29RhTlQ7Y4dwrkrIpZldXOHIUAjDABcAZVQcRnjduDCotu0v0tJ3cb+Si7PRWcVolbUT5U3Za6PlTsraaX/msm0r63ez0c3IwVjYZjwzjAVwqrwu3OWEZAB3ELxuPB3RbEj8xeQhJYKTtO1hkINh4csUODkgrwc4VoRKz42DAwibQ27KMdrEJhMLhdiyYJVsAgkE0SSxhJTJMIxJsMXy4BY7Y0VAAyllJIbBZYyoYZIGROKTTeqTtdWTvyvbT5tPVJNPXUcJJRWq5nF+7q7pxaV737bXVttbMcSqvIWf5wxJJDv8jBQQhChSSrEkbCCNzMQAzULIyxb3UhnZVWP5FLjapAYkDBdctI23G3ac9drGBLO8hV/kkVRGmXUlVUyB1KB2YDGQflBJY5wDIAVWLDCNuIy+GkAjdUIJb5iEbBVTwxJLhdo2qk5apPon0b1UbPdO2i3t0dr6KnZ8rbV2021tbR9nq21dJ9NOt0t42imkGGP3i6MQdx8zIMIDiMnDDA2jaAwIIZnV7yIdxjEIcsGdGKq5QFOY0wzhgSmxomyWGQyjaoilZI5Uj2EqQGLqIsL5rKojY5yu/B/eAkocnOUIE8aLnDr523CwyzqMwsikKrSh8NtOGjZF2h2DcgLg6csemzdvxsldaNevVvmFK1lN9UrWS1S5U2tNr9HZpvRvUilmNsjNIpZpii5BC4ErKdhR2yVQBwzKEZwuY8ihxIn9nNKqTKl/FGJURSshAIXYFcBSpG1SVUeWv3QFYCaV5JLdmEE5BkRSiMgkeFSjmdHIDMNvzBwoKhxlsEmq+oYgjt5hEZRDc200yIu8xrGoLbFUqsewfKx+Y4UZOMZb+1y3SSi1fS2sW7vdtWu9dG3bUqik5Qj7qc5SUndO6tFR01S1k1e3Xd3OgC5J6D5iSODnBA6DcduAMrkN8oZsDGDau5FPTIx8wdh9zGXAYAA+mCTyOR8xFItxGk8T+ZG+WR13bWyWIHy4CscFcDG3uPSQKeACTxznOednO0ccY+XaV3DGFA3A9EbWVrapdXpon/AMBXe3yOGXutxafMrL3rP4eW6as7Ltqrq927WF2FmAwAQQQeAMK6AA5yckk887j90AjFOeBJUMcyblkTDKPlzjaRhVy3ykdMg8DJwCSzzIo5khaTM0gLoh+Z9oC7myFJXAGCCecYABU1YXG8sCSSORuJGCEHCjkIcEA8EnrgUXXXdb7+r300Tva+y7mbk4tNppvWL22a27q11q1532dR5lFzHExxw75ZkXegZYxtDEueRnaoIkIwDnGJ4pJXZw0LKCQVk3RtvUlBkKQCu47tuAWcoQRlV3OaC3mkidrcTSK6tGxUZVmBI4AAONxOC2ADuA4wLkSglwAARkALt6HBIUktkBjtXHIz8xBIy0m3bvqtl/KtX3V9k+vyJc4pRVnzcut3e0rxd1Z3ttve2qV3dlN1V7hliZRJDbxskysfkYsyiK4AABBV9xV2GMKSNwBFyFRcq0LIodY5BcQkLgEMwDRlQzbDkiMgjYDj7oIKxW8MPmmOOJDM2ZdoOZGJY4dRhslmAIIO3qo2tT5gTsKyCOdSPK4IPO0COQRkFo2DnduJ2jBPYjVQuknbS2t7X2eztLTbXzd2bxrKajTqXVklCe0oNWupL+STu0tXHSWuoQFoJTaOW/eKwt5mZh5m4MxglZuWmjGAnTeF4BIGekt4jiKNQThVUE79y/cBDEgZYhV7EtwMgDIxYGW4SWK5UxSgAywZXerYyHjVQWAJfEbKyspADEk4Xb0/zyrK+XETqonOFkkUhcrIrknzFRWDSADdggLkV0Ulqr9dL6X3SenW3mrX7LfjxUOW91FSirtX0leyUorZqS3Wt3ayV9OpsrUMUBycbckc9Sp+cnk45LHB7cEiv10/4JCfBWH4tfto/CTT9RsheaPo2tr4r1OIxI8T2XhK0n8RukvXdHcTabaWvzAo/nupC7sj8k7HPmAJkBmXIy3zAEYI4BwSPLXA4HVSp2j+oL/g3O8DW2tfHnxf4qeINNo3hl9Jt2YLsWXW9I8R3MgyCFAZdChbADN5cUiHfvIP2nCuHjUzF1pJOODw9fFWe37mnzL5qSjfTR3VraP4biqni6/CvF8sJOUcRh+Fc/xNKonLmhUo5bXnTlFq7jJVFGz35uhe/wCCvvibWP2j/wDgo/8ADz9nrTL0y6X8PtN8E+AobeJ2+zWviDxlc2PiTxTqZjBZVuIrDUtItbmQBtsejqrLlOfy2/4KMfE+28SfHu88D6HLFB4S+GOj6R4Z0DTrUkWltZ22m2lno8VtHtKoIfDiaZLJFuZINa1bxHOHJ1CQn9AfCWpJ8Uf+CuH7R/jeeUyp4b8d/HjWtPkwZvLi8Jwan4d0WQcZX7KttaNE+B5TRRuMFQK/ED4965N4i+N/xV1eRRm98f8Aicq6HbFDDDqctvDDGhKHyYbeGOGFCo2QRxqAAnH0GYV3Sy3EVKbfPjMZHDp660MPFVKkb9pzdPTXVaK2h+LeHuU0cJDgzKJKElw7wVh8yqU0rcua57VjGpXau1zunQxiTkrpVpNO7OAjlXdncg3YAHDHc21tu1STwuMjJbng7Wyv2R8JNKXwB8OfEPjWUGPWtetf+Ee0SV8xT2+peJbK+sjLF8h40XwQ/iHUZSWUQ6j4s8LXUeGjidfk/wAC+GrjxV4n0nR4EuJo7m5hN0kIMkv2dGjJjhG3BuJTiG3RSRJLJGilicH7X+KLwWGvWHw/s2hNt4FgfTdSNq2be48XXnky+JpoyrBWTTHgsfCtvndiy8OWwQkHny8rpqEK2OndOFqOHk9E61SybTb0cY80k7XUnFOzdl95xBjop0MrpyvUxMXiMSt7YSlyJpq7TjWnJUmlupNq6izjfD+ivq19a2NtCrNNIinZzhAVxxlgNqg5wBjupIxX7s/8Ervhcnjb4/6NazacL7Q/D+mz3Ey3MW+JIreMRKx52sZppAeU5JYnJyB+Svwv0HyreTVJIyJZGFtZgABjI5IdlHBLJG2AQSwJGckgV/WT/wAEfvgYPC3w7174m6jaGG98SSxaXpjyR4P2GzYtcSISB8sk7HkNz5WB93A+ryiEMJTrY/Z0qEpRk7X9rO0Kdr6c3PJN2v7qclazPw/xe4kq4DhaWUUajji8+qQwSV2pLDNXrvdNR9hGqu13C71ufsJdaRp13ps+i3mnWl5pVxYyWNzp11aw3Fhc2UkTRSW09pNHJDLbyRlkaKRGRlLKQRkHyTS/Af8AwgWny6R4dkuJvC9s00+j6bPLLcXXhq3YFzplrK7tLeaJExb7DE5kudOh2Wwae0SL7N7hOCoOScgkHjIPCqO4GD77RuGMZznBnlw5ZTzwcE9BjAPUEAnJwQwxwT3PFGTrwqU52nTqtSnCV9ZqXxq6b5k9pXu02m2rp/zVknGeb8C4+jjMoxE6VOLj9ZwcnKWFxNOCipQqU7pO6vacbThf3Xa6PnfUvGcVjKVlu4ogflzI4AOepBYtxjOBuOM/MeKzx8RLELg6raqTznzY8ZA6csTnI+7k4GCMg5Hgn7bfwa8e+J/B1z4g+EdzqUevos817oGmM32q5kgiluPtelRRsPNaWOKVbywgVpCxFxapIwmib+bnxV8Yvjp4Uvbix1LXvEVvNbSSRzLNPcJsMbMCpDc4J+8DzkgMobIqJZDT9lGsqrUHe9oubg04vllr5K17prVWdj+4PDfxb4U44wVNRxlPBZnTjFYvL684+1pVHGDbhGTTq0m9YzitVo+WSaP6uX+J2mIPm1a2yCQTvjbnngAvnJHBJ5HbHAEQ+KukDltZtFzkAGSNTkDgZLk5OScY+bPXPX+Qaf8Aae+Kan954q1he3N5KD6c8A85HBB68Vnv+038TDknxRqxB6qb2YZBxnAUc7cgcj6k1zLK8CrKWJqJtLX2S6OLte9kt9+vax+zUqeXVVG2Mh79rNRjdpqO3vO91tZ9XpZXf9hB+LmkJydZtM9MCW3b24wwOef4tpyCMAc0N8X9HH3tYtQBnBLQZ4xnLFwMkcgL3BPI6fx3P+0z8SF4/wCEl1TGDkC8mBIGR6nIX5dxx357Gqj/ALTXxEz83iPVSMkc3kpPG4jIUkgZIHp1yCQAD+zcrW+Lm9Fp7D/DbVNa9X0V7+npUcHlzS/25PVWSik1blttLW2nWzTe/T+xn/hcukDP/E5tDx1V7c5JHThmHrnJBUnnGKlX4yaSMf8AE4ssnP3pbcnDdABvBP8AMYIBIFfxsN+078RMHHiDU9x+8Td3ByFzx147DIOM5wGPNUn/AGo/iOqnHibU0GcY+1z5z8xPygqCfQnkZ5Oaby7LOuJm7NJr2K20T67W020b0V9F1wwmCT93FqTevwJu3u+et7dFprY/tEtfixpcgY/2tZuME4EsJbIyCWAcgAZwc7QR0IHFfPHx2/bc+GHwi0i6fWvFWlQXkcT5iimgnu1bGRHBaxOztKxwN0hUKOoOMV/Ix4l/bJ+JukWUscHi7V43kRkBS+kGMZB4LkAKT82WyMD+6SfjbXPif41+JusMNQ1fUdSnmlyXubmSYsWYBmZiTgdsDaB8vrzdHK8uVamqftMXOcoqFOMFFOXupX1b3eqSWqsz38ryenVrQk37aN48keVq8mk1p1SbtbVPSz6P9v8A43/8FbfHGtate6f8H9PXTmkkmgi8QXwF7qrK42edbI7Nb2RGNwZE3JlsMpKmvyc+J+mfEr4hXl5498cyatqV1qk095LfX/nlpnlfe0nmSq2/JILOAM/KAAgFfpn+wj+w1beIbOx+JXxOsnfSJGjl0bR7mNkfU8ZxfXAbLJZZUeSgGbjljhAGb9Nvj1+zj4T8afC7U9M0fQ7G0udIsZ5NMS1t40YiKNiYQY0UgbFABOQzAZHJJ/dcn8NpVsBCrmlX6pWr0nLDYGEFFxcoRdP6xK14t6Wi7vaUrbH9CZJ4U5ljMmq5riFHDzVH2mGwsqfvzSUZXasnG8dYLd7vc/mL/Z9hs7P4h6FBqRMNp/aVus/JVxEZlaXDZDDCq2SMAZUgjGa/o6/ax/Z88LfE39mq11XwhYwSX+g6EmpadLBGpkuYI4A0qvsHzuFTEhfOcEHgkD+dDxPol38PfGkw2NDJYaiwyRsxskyMg8rlcgDcSBnHy4r+jn9iD4v2nxS+E8ngrUrhLi6trB/s8cjGQy20sbpLFhiSyLIzcKMbG7nmvgsVl9TBRxWBmpU6uDxE1Uh0nT+F6Weq1aa6ddr/AOb/ANKXCZ3wjnnDPGeCnVhQyjGrD4yhFNRSnWh70rbRklKMubfmvofyc+IdEm0fXri2kWWBrS7JIiOyeLa6yAxORtV4nVSrH5QWRscHHo3xd8DaSb64m8NG91K0fS7HW7bULxlklv8AzoIDdzhIlMMMmoWE2na1d2dtNdRabqFxqlg145sikP1P+3b8FpfhV8Zdbit7TydJ1Sd9R0x1TahhmlbzIg+1QSpZkwoA4H3S2W95/YN/Zj0X9rO01vQ9Q19tMuvhrp6a3fWNtbefruveGr2SW1ng0pnm2D+y/OuC6SrJFO17HbyQOrBo+TJcBRxtPHZZUUITrWqUak5qKhONldt6JWfM3zWT8nZfQ5v4u5Hwzwb/AK1Zw6lThvGYLC4uviqFKpiK+FnUioUpU6VPmm26lVUZpLRv3mlFn5s/s9abpjfEPQdL8QJdt4e8WyS+E9Xhs7uGxla18Qxmwt7g3U8tvbwjTNXfT9VDzzRRqLM7nCbq/qi/Yz/4JmX37SE/hu7+MdxZ+FNN0Oc2dveImlar4s1698NX15oniu30dYbm80Y6Lcara3F1Hrt/HexPfXdxd6dptzbXAlT+c/4rfAzUPgf8W/Fnw51JJ2i0m+E+k3UqBPtukXoS6064EiKFw9s8YZozmKYEKw2sK/pT/wCCNHx7az8Kan8Ppr6RtV+HeoJ4y0NJZmkuLzw1rUiW3iK0UsWaRLG9CXAjHQX5YLhGr0aeEzXCZLm2UUqiw+Nw8a08PzxVRRrKy/dp3inJpXnZxcXzev8AOHjF4mYCtw5wjxBgVXzDhqXEuUY7NcXgcRVw1d8N4+McPi5RnSaqKUYzozcYuM170Lx1t+0PxX/YQ+CPw1+Duj+DfBngTTYvD2n2N1p15qGprJrGuW1/e6XJpdp4httQvnuGsNRto7i4WI6atlbwTXbNbW0CALX8FP7SnwO1P4T/ABC8a+ANZhYX/hPXtR0lpGjKm6t4pmksL1C5d2iv7I291GRuylwjnLsc/wCn3qVpp/j/AMDywl1mttW0zcjjBB8yHejK3OCGIZT1BxjjGP4wf+CyX7PFxovjPTPixbWIWPWN/gvxUyRsFj1vR45JNEvZdq8HUdJE1qkjEFl0yBQSWAr4vgTN6+f5XmeUZrWq4jMMBWq1oyrzlOrKNSUVUTU225RcWnbSMYRWiSR43irQl4f+KHC3EeU4urPg3j3I8Dg8LGVerWwuEzHK6MZYalRnOco06eIwk4zgk06lacmm2mfymeINEMbtmMAqWIAGcAbSQTgPvIyMBQQcEgnJHkup6eV3lhyF3YIwSp2nkheQDnHp/EOSR9e+NPD5innIByXYNw4C/NuBJyMZUYOSWwcnJwD4BrOmNvIEYLBiqkqxzkqCQTnJc4HQgqOmRkeXmeD9lUmnG3K3Ha3u6a363S1s9NEfvPC2drE0qUudS5oRejbd9LK3e2vZa26W8hmsnisdQkJKgwoinGctJMHZd205+UKWCsV4DBeAK4K4hmBaPyjjccNuB3kGMAqHwdz5x5gwuc4UNnHrGq2s0fmWpOY1BcqDlPMKY3ABVXKgfLznJ7MDngNQts4G0gZAyCMEgL8gychG4JYMA3C8HBHy1WjvKy1ldbWSvHy+d0l5O9j9iyrExlGN7K9nq+qUd+Vtdd7K26tqcXMq+ZwwBCYJGPlBVcDAGS2SOVI6EE7gCMsxkEorlGGZBG53MEbYRtJZzjkIcrnaORnLV0c8BLMyjDA4Vj5hIU/wsucEZAA5GSATwCaybmJwDgKXRWMZckKCOcsOFAPzDazHnOGKZA8+pBXWzto+W9klbT1Wq63b062+soVVJJqS7yXNdpprW79dlfXbXbE2YklQFkZY0mKsxK7lACoVbJKEk8Knyk8kKpyNEflMibXAUttO1cjauwbizAArnnAIHzYyM2JY2DJIXdAkcu6MKSG+YYSTbIV2ZLYIO5TjAZSwVhUjBZ8HyyGA3BSGOeFHAL54ILcfeB+UDFxV9enRLZJRs0teVfor6vQ9elJ2j8Lso3Wj25V8N20nbo1om2tSlKqkSeZIqqNvzNlVVScc5BJALN8pxz0yckQckqqkcRiQkMuSvyEZOAC7HPIJBHzZyDVsqRjfiUqQHJRThD5ZwEznIbGSQ/JwCFIURsAONoTBBzngqAAFODjkELgKQQBtAYECbevvOOmra1V9Nu+z03VtEvQpyulyu9rO3VJ8rXW+iei002eliqkeGdQd+TkNkkMv7sgYfgNyVyoGTk8nClhRmZdg8spiTdhhvKiM7OMZIxnLNtOQrAgZqYsclAgBD7STjJDDkgFidhO0EsMsMEjcVLNAO5pBuYHA2EEq2TH+9XkKpIB5wAikgZU0kou11eTdnrK6emqfW3RJ666nXBtWfa3y2010216pvutHGyNuJONuxh90lg5xgD5iTuxuZc5UEbflwaYCAwQsgkaBpETkOYwFBdlxyBzzgE7SB82MSvGd/UkMpDAHCBsjDgI4C5AUjksCVJxyKciEkHkMAqgkDeyADOSuHwCVZedoPOFABNqOrV7drtPXRdL6vqm9N7vr1Rbkt157Ja8qs7JJa6tdNdbWBU3D5jIW2AbgRtZ9yEKVOxSDxjC4YY5z1txxOS3lorsuR/cUhdpf5SwY4wcsCpViBgDkkMTruOQW++FxwMhW2DcDkYztVTtb7w43BtCCIscFT8wBJI+9uCbVbzdoYkkbmA+YYU/NjPTGEna1tdndbuy6t20Te901fzNL6OV1okr21TfLd6prTey00V+6WC3VmiwSvPmITt+cgqjR/K4wqtudQzbGUqRyQ1b9tAcjAYlRnI/hyFOBnk5z1JyTgEZGDXs7dpMja8bjAJcKpYfITsYgFhltuT83PPOMdTp9i9xKkQByVDOSMLGuG3MxIAwFHUZAzg5JGO3DUXJq2rdr9rPlS7pb67u1ra3ZwYiuoU5S5tOVStfVvlim9320vqr9NTS0PTDLMknl73LLDBEQW86YgKDg4LAcElRk8DGQWr+qn/gjp+yf4K+DPw78Z/8ABQH9oWCDTfA/wu02/wBS8Hf2rGoXU9ZsomNzq0MU2BPJaTPDp+kKu43GqSwrHmRDt/HL/gnf+yB4k/a0/aB8F/D3R7OYaVcagk2taiIi0Gj6DaET6xql04BWMrZJIkZJXzbieMjgrn9n/wDgqz8d4fHnjf4Z/wDBL/8AZYgVfhz8LH0TSvHy6JIFt9c8XWiRR2mhXlzCfLa00SR57/XJ3Yxf2rNcmZgdPXb9pkuWPE4ilBU3U1guSy/eTk4qFPtyqSvKy92N3qlI/A+O8bmvFWc5b4d8PVKqzLiKa/tXEUZe9leRqcY4mo3G7hVxS5qFJtWa5m/iiz4ouvGvij9u79p3x7+1l8V9KvNZ8H6X4h03Rfht8PlnK/25qN9cTWnw5+G+mvIDHE2qPAL7XtRVTHo+hwatrt4TBayKfk/4/wDjC/8A2hvivb/DTQ9fi1LwZ4Q1rWtd8W+MrVDBpPijxvfR28PjXx4iniDw7pdlp1n4N+Hlk2ItL8GaHowjjjubu/Ev038bvG+ifAz4S+HPhp8OLlbjxD4h0XV9A8E39l+6vv8AhG9dJ0n4jfGRoYgWh1L4pTRXHw/+GYuAtzYfDHTNU1y3UHxxFO3nn7OH7M/iTx7448Cfs6eC7E3Pjr4oXlhf+O7+KNmj8M+FYWW5+w3Mkas0VobRZLnUssrNah0DFr0tJ9zmdWNCjHJ6T/dU5xqZhOL5fb4m1nDZpU4xShGKVo04q1ru/wBtmGNybIspweSZVKGF4U4MoVYQqwaVLMM2w9FwzDNqlrutSwcefCYOU2+ep7epFOVVSPvT9hbwx4W+BHwy+J3/AAUC8c6EkXgD4BaBceGv2dfDmow4Hif4j6iDo+m3McTrulnuNV1CCa4ljy8LzTPL82ku45j4oat4i+Hf7PXw58G+KXudW+I3ju68aftx/tF3csX2i8vdSaPUL3wPp+u5Ksyz+JtT0zTLe0kYQROsqiN/tVvEfrr9rrSfDXjb9pb9mn/gmp8MNg+DX7NFppPxI+NLwEG11PxLZWsE9jaa00Q8mSeJ9SS4vlZsDU/EWopt822jWP42/aO+ID6r8G/2i/jbBNsn/aP+I2hfs6/CzcsYMXwZ+E8lt4k8W3tjHJuCWWt3nh/wdZytGFaNrueNgplkDfp3h9kk44XF5uqbdSUI4bB+7rKrU96U4J35vZU1UnC2sJ4ebvFJyj+o/Rm4cxmZcMcVeK2aUatDF8aynlvD0asVKeC4Sy1uUJQUre/meJlGVWUWueeIim2opHz7+wt8Idc8bamiaP4l0xde+N/jXw58EYLOPVI4tTsn8b31vr3j++1y2InezitPD1pGkN6hUTvf3kIDCAoPfvit4m0f9qb/AIKW2I0WML8MPhHqmkeDvCNsCqWumfDf4K6eumWEsMK/JDa3A0nU9VWMKFkkuVDKGlRR+sX/AARF/Y+8CfEvV/AOm/ELwnp+v6T4Z8KD4pa2by3aG8Ot3mpX9n4Pin1O2W2vAttDfXU0cHnmO6igWOdZIomD/pz+3n/wTv8A2avgvd2fx4+C/hbSfhz8SPE2pXOja0mn6PpdzpOs6XP5mp35u9N+yQukf7qdLm6hn+0SvdxyXTzW8c0UvlYzGcN8O+KPD/BWOxGMr5vWwGDxCUMDCeHw2ZYz22MhRr144j20JuEadSU44WcYwlTc5crbp/tuB8JcBlPjJwXicyzirjMwhkNPE4XJIYB/V8Hic1jQxuI9viPrEmsVPC5Zho028MoUadWpJ1YqvNn8O3/BSq0sNX+InjbW1uvEc+uQ/Eq2OvG/v/tuk33ifxN4D0HxB4ntoYpYhJa3ngW3Tw14FVFmk22GkWyTgTxkn8jb20CuxCdAQ275sn5fukHjHPLdOVx3r9Fv2ofGGi+M9XW10Wy1a3t7XXfG2v65qWr6jbanceJ/GHijxHc3Or+JYnhgiSy0640+y0ex03T0eb7Pa2X2iV3ubqavgnWbblzkHBO30YLtwCVDDd83C9cjkZ5r5fjfLqqzDGVcRSUKzr1m02r8rm1ByvZfA1rZbX0dz5/MY4rE4zMsXjaEsNXxeaZjiPYSlTlKlSq4upKipSpycW/Zcr0k3d7qzS8vukUZDluFIOG2gbtufunjb025BJPGCBjn7gZiJxlVC7W5b5QVbDEMH+bJ4xweorr70DOcgAYAJPf5cnAH3h02n2HOWJ5eQE7wAQcGIkquW+6NwOP7w5BTgZBwxFfjWOpWk48rV7u7u+yV10fd3trvoeDUi4ylaLWqs7+SWnl9+/bbKlUNtxnJwQQoBK4UjByTuK88ZHO084xlrKst+I41LtFFN5r7dyRPIqBYlfCkuVHzId20MScEkGxdSPNK1vakhlYCe54Cwr8u9I2wMy8HpjZ3y2Sr4reO1jEMajJOQBzI8j4G4kbmZn3csSOQcH0+XrJOUUrKMfi3XZpNXurO3Vq70OeUU0r9EtXFLS6lZPpbr6vRaXkXEb3anILaVJ83RQfOQ43dNmBgsMnoTl+ax3VQyZO/IABO75SQgO52JUr3Dc5yWBbnGrPJ5KSwxlGuWiEclypV8LtybWEcF1V0Z3ckeYBhc7Qay1jkfcHAUgbS3zHEYIHLMXHlhQrq7cknkhgS3FJNyTtsn16JrTdb6O9m43b2VjnpQcZ1pp2jKzSa3SUUlJXWj0Vne6d7PW1vZ5en3oYMd0llubYTnE55JU7QgVQPUkocEFqyrjIQq7YXPXhSVJyS2Bv3fKWdeVP3jwSKlFwW8wBx9jbaQWCg3UqKpjmTKxulujK3lgMhkbLfdwKhcPIwXDMZBtSJQXdncpgIgVwzMxAVQCcEIrZOByzatvulZu6T1tdbtq7te60aavo3UE1Go5NWb510TSjCOjae1r2TTfNoy1dKUg0pydzHSwdqM7bv9MvOCSQNhG1STjayktkCqCYCOWdXZiVDD58qVXCk7TuKD7wYEj1+YYu3am3+yWrSCS4s7YQTKkoYJJJcy3HlLjYp2iZUk2lsNlW2kHFCJcszZIwTiEnCgKEDNtVyxJK5BzvAxuGFwMbRdm91a9r2T926d7J7a/dbdrPDy5YQur+/K26dpVG091b3bbXtrdbsYsRKqGmBkXBLfMwYjoFXIBUKBhQmMjOdw3VCTgkMGAjG5DhCrKHxn5jkHcGKISWfdgFeKsyfLsVEydpePDsFUZXljgg4G47ATzggKxIEGGTzWcqWkdVhCMi5QgBQT3LNlyCvsx3lc5yfvK0WtntdX0dk3Za+m7V9Uaaa3Ts+sWmtVF36X6NvRttO7SQR4ZnbaQp+6pw5ydjZKrtYKSBzjjAQn7tN8sGfeRtGwhGI2ocuVPAIJIBAAI6D+FlTDvLLHcA6uuQpDvgHccMowMgEgKCegOSTyZ1DbfnbspLbQnKjA46gkAnjqcAENjDV2krbbt3eujWlrK/VNX29So7dHsk7NtL3XZx+S+y1ZpaIpeZ5R+4zBnUxkAszFiehyWAGArArhhyygtzDNGzyKzOIUOMIdoO/ep8pmGCrbAvDApnnJwFOkxbchyemEBHT5gADuwcnGcA5KjAJPzVFKocqCASh3KhDEBhgLtOMhsZ25JByFHoBptaPTRp2tvy66eWtt3bVasbi9nJaJWWyt7ravpr1s/i5b/au4JLVGYOFIkRMhwWQg53ckYLY+XJBG7jIxjNWUiIqmGJYKzsQPlRiqudshXYd25dqM2FfJGMCrImaSLfEMMJAmJQuVAwWZkUM5UA/LnA6DtysamNAm8khsuCP3mSF3grhlA3Y2kBVAyfvAk5yTb912vvpott035P12ZLs9ko7dlouVattXe7b3dtrNopOvmSRAO0IVA0LSSFlkjy2/AVWVpWVlKqeGXqqMzKJEYwo1vuEm5gELMw3BQAmHymFDjKxlAAScnLE1aFp8kg3sykHAIdnGR1jO8Mrg7AQuwNjcBnC1TlgliYYRWDKQXVgd53fedWDsNoIZgSCOOjcslo+a3xPVq7s7R3V3Zfnul3hqatNvTS1rW1SVmvPvdp2XS12Ose9mERZWBk3MMEF9wD70I2AcKQAAHGFYYyYmSPbnkg8hFUHy3IA2bEVsHBDEF1D7A6nBJWVSWVQW3SKqEsGxujCguQehaPowKhQqjzMYpSpjzK0YcHKrG+P9YyqxKoCCNu1iMPxwV3xsFpOKttrfW6t2193S6tdJ79O7mycU0rWa0Wv8retr30s+2y1ekWQQkRMf+rGXKgDeChiVyzhgwZsMT/rFYAk5ABD5QkQD923mA53BAjhkVgpBHygYGxxlRvb5dqqQRBXy4by1UyIQIz95gyHGccsCzAN8xUMu11NOjJLDKn5HG4kplgGQB3wCdxJ2hwMYGCDjJiV+V332jo9Y2Xn302Sb2vsNa73eltV1Vr7+a621vfdHeXdjMp+12ZZLlOdoG7zxtIJCsyq8jA/vIvuXAwxK3IV3tWN4l2hKQhZY4m86LBO0MzL5iEqWlimfeu0hTGw8qRVkV1NzfHllJJc7cY2sTkbRztIwCegJ3cDnjOdeWzhheWBYXUZLyRqcCYFSJGUMURpipAkjYhblVG4rOIpSnZWcUrO6aXW1r2u2rrTXS92mfmVOr7SKpV/dlZeyrO3uuytCUv5G1ZN/DpfexRvbOXTJPt9jgxbVM9qA+wJyzHAI3W+4ZOMtbNl1zCMR6dreQ3sbyxMdsYMbRHaGjfBO2QINxXG4Rspw+OMc5S0u4rhQibkn2MZIyVYxkZVyGOXYb2ZGjIV0IUSAhldqF5aSabMuoWHKLk3NqoYRFOSzKoILW5PmMxAzbt88YMG5YxxUfe+ytGkl1tZ9l52e+60utleqlQrpRxMElCcrWqJWtGXV3WkZN321vdy2Qzxsd6bi4yp5UggruBbIYFSARwpzg4BOBC0knysE3AMu0AgjjawcEOQxC53kgDcc8DJMKXkdxEk0KhlcmOQMEcxHAd43VdxGGB8uRmCurK4yuKlaMqGZTtcNkbxtyn8UREcm0AMMBTjg5yVYChq8bpuys/d62s1ZtP3tXe/W1muvNyuDaqJJ/DZt30cdd/uurfLVI3zs6IzDe20ktguqhQdqqDgrnJZcrt4G4bSILeGNrlw7oySRlxG2CHeNmBfZMSrLGpJQdwRljhakKZJJISFImCBSgw287C5Q7t2cHau5VwRuIcqFiiZpY5R80cKEPGWKMzsIwyAAF9iBs4RzsfcScE0nq18VnK3vWtb3b+iurJtbWutU3pB+7Jc1rwa5tVq7NJNq9+l/e373IGnwxzlZI43jEYgVy0SALujC45yHA37QqjB+QkLXt4WM88/kDZKBJJhFDtH5yKqqfMOIoxHv34BBZlKgAA3Jkumd/LWN2RGQeY80W52LMGSRdx25xlfmVmck8BiKNtLI87295DHayyWirbpDMnlzbSTLhs7xLEV8xo1O3JTAJRJBlJq6i27xlaN1ZXdlG7V1rq9OrTu7tnRSjelNwcXeKU7TTqSVoOT5d33as2ldPZmuPKuPn2q/lspjdgQM4JV412IXVchgGyuSckDIpzIu5o3AZSrMR93lwBxgs4C8Ar91ScHGFFIGmRYkdXkcuIneFSYk2hcMPNXGMLwwyCWO8byyiSQYjwSQRtQKQygKCm5CNpJRtzYGQSN5bAORtFprbfW26aurb6vpdpvptucb51JLlas7Rvd25ZK/TW/qr27aqijhfKjPnxogBinC7V81CEEDRmQ4jYKCxZcttMjEMzM9pWI3j7zbSMq3ygnjcfmb77EsMH0RgAVNJIBGHctgyFVbAwEDAdVVCGIMijCMWG0MTtbNRLhlyjuFZkdZgXKs2FUnaApyRIGPDLgAKX2k1KfLbVt6bK2yTd07rTvezSXvJFWc2lyyTerdr3bau/e2V3t8NuqVyZR1UYwy5OQMlgBgEFThyduF453bQoIACUO1G3kFRlI0I4yvy7yrFc4BOABg8DdyYmbyyjFZAryAArlirPt6hlIBI6ksCpKlc8kKscrg+blF5GxCOc7cea+QWxgcDA4yuMAmrra2um9tGuW1nppZJaJXttokUoSjabjo+uur00Wl000u1+ulmUmhmljEcs5lIdHUJGQzRK20JuyjsAFVyzswkLFQAVqwqRhSuAqooOzcUjLJkqsSlTgLvwCMkkZfKgBZHDIEESgsdoCtu8tVDKd7ArkKvQAcgncQSWNRBXSQGRmYlB5kpXaFI2q5I+ZVVghAAjLtnJ+UEE92DuvevbystN97q+6Xq3sac0mrXjFK8rLRt6N3Wyu9btb9WtRqgzRCSFzIr4BbDOXSM7nZVYBkYsrfNuDA4IyoAE0iI0Hky+UiMisMZSQhgkYkjZMvHIgO4EMGZ9pUrg5jkKw27kgmKPy8rAAD5LBdzbm/chthd3cDIB3DG7AR9jeXgFocLtQkZwWV0lWNFIPy7hgklcElgORDlpt02tprbVJ6W6bb20aSZdNyjaUXKMVJuDT1vaLsrap+Vr6NWb0bbZ5EeO1mLNJIHC3JiAF3/rSYnDYdb5Y9yhdw85P3kagq6q27SKe3kt5VUxvK0fl7JImkATapDgMweMkNujbgAs5ZmxUUjjy5Eld3jubhlMaRqHTONsx8siWO4jwGQ5BAZZRyGFPtZELC1mLNPsc29yfLX7UqmUjLNnbdohZZo0wJgFMaYDqijK3uvWLstbu1+XR2bfX3brR2W6RvJOSVeHu1Y+9OMLLRO/PDTpvKKs1bmj7rduZSa40mZodzT2crruljUMzRcssqoZGEVwQxV0I/wBIAbaC4kVt+JHlzLb3SmKVVvZSkLBJnHPkgoxBgER2uFYPEAQrBZWNWbmyhkLfL5z3UJjuIyJCJssZAzBihjaJxlTxtkRdvdjzpMujyGGffNpsjOyMCN6O2WaTbuKidVIMkA+WYMZUHmpLG2fLKHxXlDum04/Cr2aTs+2629elThiVem1Guo2askqlrXsk7c1ldJb79Tf3KB5xEuxYZDEhd2aUkBiu1Q6lmVkDW5YFVYHCgqDVJik+yyPGWu0RZdplVWtbbK4klRCkbSqynLM6ud7JIigAl9uIjcPcoGlWaF5o5I9klvEA5KmHYI180gKJAFcqCWDEZ22ZFKkyRIPMl2tNy5BUl2DvIGBCbudpBBONy/McaxTklZpJNXbSlbWNpa3Selo6a7Wd7nPzRhKzTUnFXs+RJtWlHo+Xo73bst1o4jcQufJjY4JMIVYyoABUMrsw4GCeQ3ylt3TaKiVQ4ZAzIqmU4G9pHVl+Xy2V8lUYiTdhEY4YgFWNWwZBJJFJHhQpAlUgrJESFwqt8yyEISSWGcZKgqAAOq428MWJ3HazHcIxt2AbnKhlVi2QgAXB3fK+ZdWkrJLfX4UrrZa31V1bvG6Wd0lpFv4WteZxva1mkrPsnp3d7NU2iKoiTObiSMqA8TbGBG9Yw0ch+V02q+8gmQEq6nOalVCQMiGQ5RGCqFPl7tysuzcybSQTIMbyNp2liKmjAcybdywtkkZVmdiUIRcoOVYqchsgAjIxmoztMsbRueIgrKjNhgWVdkYGzchAAdRkDGE2rjaJJK1+yTesrK3V3bSste3lqU5ylJJWWisknZN25k/O2llZXbWj3QQkO8g3yB0CGLZkFoh95SzMqq6Rru58xix3EDG58UWxGGG+aMyFi2CNy4RD5YALJ/B2GchgpApi3A81oFRiI3RXfaNnmExkRoJVTzJBvLNln2kbvmU8xgY3bXd081ndACoEagM2CSI2ZcAB1XAGMrg/K07X5bO2js9ruL0+eqtpa79JcZcvLLRuMbJ9dFa9r6pbq97XbtuSBiWEUco+QqsjIg3De0TLGqMBukOMyncq5VmBHzUisJoJhCux9nlB1kUR5URM8mAJGjIUgB8D5iCpweJI0SaJWiyFmO4tna28rtZysQ4wW5Dn7gDD7xzYELByxmJZUEalV8mM42bXdQVZyxBDZyGyAw3KCaSvtrda623atyrdabu+7u9NAbjFaq0o6JP3tVa+17rSytZKz03vYDBFABLBUXktyVXKO5dc4+XlicAk5xnkVLiOc7GjMZXZkh8RsrEh38pnVkYyBVG1wQwcnAAAM6OAxdgeJWGwvtG35d3Ql1UgrtJBA6MN3BsQxxCJQoIQ84YksSVXIOV3IWDfdOBt2jo22rV232v300d1FOz0vbRaNGSm4a72draO97N7W5XqrN2WzbW5jq81iFuLZWezkIN1aMMujYBaeADGACwJ4C/xFa6G2linRJoJVeKRd+VO053cqRjcpX7pBJZTlenFGzeMHncDnuoPAIYKDwQ3Kk9cEcYNYzxSaTK08CtJYyuDdW+G/dMQczQZBGBlSQDkAccYw0lTT/lv0Wqva7Wu3e21rpbhKpDER5WoxrJe7JtNVEls5P7X8rd76PXRm+oBJOO4TjGWXhgM4BBB/hGSMZ5OQHIDkIVyCBk9cfdxuGcAHqowd2MAhsCkgkiuFEsUiPG6FkZQCRg9SpBwykfMhwyYwTlgBY2blG9yM7QpPAGdo5YjIbAAAHBz/Cw41SvZq043TTvor2S0XZt82rXqjicrXTVmtOV3TTuru19XfTur3d+jFB7KSoA5P3SRsJxkqckkAE5HUdSM2FOBuxhsAkg9QAnAG4DHfhTnoQMk1GvC8ncobBODkjK55yeAd3QBugIPFTIC3IJB4Kg4zjjBDc9B90gHAb5ssOdorSN420aS/wAT2+bS076J9ROWjVrbK+r0Vt7b30Sdt9r3V3KBlcc85I5IBxjGAWB64APTgDocWPJSfYCCvltvjKl1ZWC7TsAYE4JXjJIXGCMAhETJGBwDwNxUH/V42kMMjIY45HbJyFqVVuC0AiWLarh7gyswIQKuEhXap3McHJIKkEHgkLaV7aader3Wq07evfS6Tzc3dNOz11dla9rN31bs7LW2m1nq9YsX1qxIDm2ulyGYDYkiOnyMDvI3FQGJBJOCCATuxqEiZn2hhPbBcblLBtyYZgFwDtBAUbWxghfmFYrrILq1Gz940V2pA+XbhIyAQgdtgP3snAADp8xBXoIYpTBKSY/MM9k/mAhxjDglzhyUAG5j8hPLNkYA6aakuVaWve6V+qs9Pvafays4k4qcf3Ld0vZRbveS+Lqr3slZKzTa00RuWvmxuvnKpYbMFAMY/d8CQ4BdmDfOq7SQowDyf6bP+CEPxi0D4Kw+OfHOuTJFbf8ACc6JpV0xVpCILT4M/HXxFM7RwssnloulxIsm5VDMpZSVDL/MtGAJVYuAqouGK7sltpI4dySwIUDGCpUEnO6vof4Y/E7xV4S8L6r4e0PV7rTbXUNcg1e4W2dkm+1w+HNe8PpIrkBwrad4g1S1eMEb4rly3QLX2XCePw+X4+rPFQlUw+IwWJw1WMFq41aaju2rN62btb1WnnUsTQjh87wuJpupTzPI81yvltfknjsHUw9OpZrVU5TjNK10l11R+uP/AATS1abx78cf2p/inqkf2rb8Kfid4rvZnyZDf+LNZtnBQ7gzTPJdzbEdlMxUhmPzCvx18fwsfHfjW4fkv4s8RMy4Jwf7WvDkAErn5B7K2R3xX6mf8E79cb4f/s0ftw/EncLWf/hGPhz4TtJn5lRNc17WVuWt8ZYlGNoCygF5EjQAuAp/ONPDd547+Keo6Jodnd6tPrXjC+gsbO1jaW91GW81R5ILC3iiVna4uVLvNGgLxW0NxKAWREb0cZzYjLcspJXq1qtetGMd37XEeyppLVNv2btqk3vvr/P/AA1UVHjPjmv7RwwOXU8kydc1oxpUsuy6ljJ2eihGMcc29Vy2k9NT2X9nuxh8B+GfEPxe1C2ie802OG08Kw3KZjuPEt+s8XhwJETiVbKaG98TzxMDG1toUGSq3Ee+hoNvd6hfK88k1zdXtyzyzOS889zPKXklkY7maSWR5HkLZdjyTySe/wDietnplzpHwv0OaK40fwAJrXU7uzZHtdU8YXAih1u7heNfLltNIht7fw9ZFQ0Srp95c27Fb92bZ+G+gH7RLqcsYMdkiLb7hgm6kyIlAOT+7B3FRjBVSWU4rqlh1Tlh8DTty4RtVGmnGeIko+2kr3uoyXs007WheO52UsRHHYivmVRtfXuWVNTbTpYCjrQi7tuPOnKvJNJ81XklfkR9hfAf4c3/AI88deEPAmi2zXMkt/Y2KxxgsZrq5kRZpGx8uEZyWfBIVCGPAI/uN+DXw/074W/DXwj4I0yFIYNC0a1tZGRFAkuUiBuJnAXIaSZnYk8kHOeK/AX/AII9fs6DUvEWo/F/XrAyWnh2I2+ktPHuEur3SHdIpYFWNrbltpHIZx1PT+kgDZGMdTjPoBgZPfJAU4zgDOM9CPYx0vq2Ew2CVlOpy4jEW32SpQaS6Qbk76LmjorI/kLj/iJ8ScaZhWpzUstySLy/CJWlTliLU5YmpF3s/ZyUKKdrpxqxfYpXRynPK9scDggZzwRggseue+DmuUu2YMx6AE49yD8p4O4EdOTjAHTv0l7JjIU5GNvXqDk8569x+PAIOTyl2y5wHyvOABnI6YHPPzKF798ZO2ufBxu+ur3dmltZX+a/JWeh+McR4rWSTXu9nvotUk73S120fY4jxX/aT6PeppFytprEUL3GlXckaypa6rbjzrG4kQlVmhS7WLzoWIjngMsEgMcrCvwH/bb+N/7PfxEstP1SXwJL4R+LkE97p3xD06O2ig0+DVrBntrtxOgCX3nXkUskGoeRDdyW4VL1Hlwyf0D34VlZR2Ug5AwBtOMtjrn5hnnB9CoP8o3/AAU88OW3hz43+NnsV8hb2eDV2RMhWkvbOOS5OFG3c0pkkPqzEnknP1eGp044HE11TTrYdKSldrmpT5YzhKN3Gac+SUVJNwafK48zv5nhrKOZ8bYPKa2MxuEp4iUcVRqYOr7KUcRhZL3HU5JT9jVp1JRqxi4qahGM7pI/PvxLrfhpr+d7ZYkiMjFAcDaCcAjjAH3cqATnleSTXGyazoeesa4I4JGOCMA55+oPYc9ifA9f1x453AlIyT/ExLZboygkjBwCGODkDGOK5GbxHIAR5pPbg5wD3wOvU/exjrivhq2IjzzbjZuV9NEtVe120rXsm7PZH+nOS5XiYYTDw+tYiajTpxU5VZOTtGKTleT1bt89bNrX6hbXtAB5ERYLk4Bx09Wxyufl46Z6kVWfW/DxyR5JHIIBB6Ek8Y4OT0IDAEEkjFfKj+JZSSC+04yGB6Z6Bid3TPQ4I4YbeMVj4klwdrscDH3j6AHJyoOc8AgjoGyM1yvER0slZWV1/wBura+97NbJaK+tz6ijlmLVn9ZrWtovaS7Q6Jq1tdtbv5P6tOr6ExziIgHnsRgZBZeScHaPXsB3HH+K/EWgabp8syBPOCsUBJ2nIJ4BwpzkHgZBzgA5z4H/AMJLKF3CVgoyxBZgccEgbSSOw+Y9AcHkZ8z8UeJp9Rm+zLMTGOCP9olhg854z0AwxAORk1Lrc11FLm2Vnaz031W2l16WZ9NkWSYrEY2ip4mu6MJKU7yesU4vl+el9tm9Ot3Wtfu/EF7IsbEws7CNOTwxbgZGMkbQBgjnOSuAv6KfsB/s82vxP+I+nnW7cy6Fo4XVtXUjK3CQOphsWcbW2TzBVm2rzGXCDI3D84vDlurzI7Bh8y9eS3Jy3K4A6YOAcZ7gtX9BP/BMFNOg07xQ4aMahKLKMLhRIsKh3BPBYgtkMOnI6YIr9l8IMiwuZ5/SrYynCosJRq4mFKaupypwXJ7jvzKM0m01srNK5/XXhbkWExedYCniqcZUqVq3JKN1UdOKcYvdNOSV02rp+Z+1Xh+0tNPsrWws4Y7a1toY7e2gjRYkiijRESNFACIEChdqDAGFGTkHsgqPBJCUDI8bIQRlGLDBBz2ORjIA2nB6ccbpb/KpzyR+QbqB6jluehAOWGDu6eObGBu56ZXJbPG4FRnOVyW6E9TkYx/Q2Ng/bO99HzL/ABJJ3duzt179z+2cNh6U6ap8kVBwso2+zZLVLRW6JW+z3Z/Oj/wUG+EMvhL4gajqlpamLT9YZtQt3CMI8vI6yx4CYG2RwwVRgbjg4xXM/sF/GW58BePtMtLm4eO2W9jiuAzttNpcM0UwKnLEpuJGAuCMkcAH9df24/hInj34Z3uqW1sJtS0JZL2HagZ5IlVhMmAuSDGC2DgblLMB3/nC0m8ufBXjSCePMKwXhD8EHaX6YBAOByuGOCMZOOPyfj7KoYfMMJm9KC+r5lT5MQldKNeLhGqmtV7z5Zxv9mdttF/n79Kfwxw+cZZnmVzop0czwlWvhJct+Wq43vF20caisrapO/VH71f8FKfg1B8RvhfB8QNFtEnv9DijvZJYkVjLYXS7mdcZLIyjfzuKurkYBUj8xP8Agnb8abj9nb9pbwH4pup3h0C61NPDPiuBmAin8Oa8yWN4ZQcLIbGSWG/gJ+7Jbo6kYav3R/Z98Qab8d/2eE03VBFezRaRNompRsyszQGBhbTN8xyyqVK7uoDDsDX88vxf+H998K/ij4h8PTQPbHTdVmNq2MM1s0he2kQ4wVRWUMVB6Ag7RX5nSpxwWYKTV4wlyVY3dp0J+63eN370XJXj6q6P8s+CcM+KPD/i3wvz1tY/KVj8viqkU5wpNtUp04StdUqqjUpvVK8T9pv+CwX7OUGmy6R8YfDNpHLbaU1rFe3ltGGjuPCmvv52jzmRd3mRabfJcWCyZIED24zjr+bX7HnxxufgZ8Y/BnjRZW/syzv103xBahiEvvDOsJ/Z+rwOMgMUtZzcxAkqJ4YpFG5eP37+DWvaN+2t/wAE9dMs/EEkF94m8FaFc/DPxjI5WW7FosKwaNqcwYhs24XS72J2J2m2vTw24n+WzW9G1TwH411/wbrcclrqnhfWr3RbyN12ndbXBRJE9Y5Ywjhh99TGy44J+kqVuejhsZO9Srh6jy7HNuX750oQeHrzf8uKwcqc0ravm6s/GeB8NDMcj4p8NM4fvZfSxKwlGUdaWCxUp0K1Gnzrmtl+YwrU4zaSUXRcbJxP9H/9lnx7b+IvBy6LHexXqaSsC2VwkokW70i8iS70m6jYMQ0ctnLEgddwLRsQSc4+Rv8AgpD+zja/Fr4beNfDsdpE1x4s0h59FmKD/RfF2i5v9DmLnAi+0zwiwmcMpNvczrjD4PxH/wAEh/2kR4r+HPgiHUr8y6n4QnX4beKzJLmV7VFNx4M1Gb5iWWWxY6asjgEvbSnIr9+fit4Uh8Y+B7xERZLhLf7TaMoyyzRp5isuBkN04A5U4OQa/Ec4/wCMM4/oY+h7mXZu4VG1pBwxEo+1jJqyvGo1UcVdKLS0um/0LhjAY7xZ+j3xBwbjW58d+EWY1IYCTV8Q5ZI/b5ViaMW3N0sZl16EJNrnqRlJN8qZ/mF/FPwVc6ZqF/Z3Vo9rPbXNxBPbSowkjubeSSKe3lQ/OkkcySRSIwLB1Occ18jeJdLNsplaMBmz5bEZwVUZ5CbjtIwCeQSvAGMf0Jf8FQfgQnw++N2ua/aWZtdB+IEUni+xCRbY4dWac23inTU+UoJItYR74ooBS31GAkAMBX4a+NdOLzTMAFGWVVCkAJkhcANtDbNu7oOu0noPuOIsBGVSNekualiKcK0HFbqSi7XW1lZPzT0Ozwg4t/tfJsBiKkpKtyxpV6bfvU8RSkqVaM1prCcZRd03dXv0Pk3V7Vyzlsk7icndk/NuJJOeDx35I+Xlq831GLG4GNnyR9xcg/dzzgYU4OcsFwCG6kD3LXbLaxIUYA5xzzxk9FznHUAkcgnPFeXalajLBlHRuATwcAggnbkE5OMDkZ2+ZxX5ziqHLdNW1srdGlHRrXTX076Kx/WWR49ThB83NdRtrf8Al0drXWmvXW/VnmVzEwZSDlckuuAdxG3BDEhFKnC4xyOOmRWLJFy2CRksSc7gSQuCQcheRywzgHaAMGuyuoclgFKjO7rkZJ+Y8gMDzywDdOzZzzV1CARncANoUgkjHy4JAGTkYPI5HMnHTxqsLX93dL3U3pdrtq7XtdavTS+p+h4Kqmo62Vk97XTStv66/cr6XwGTY+0KcMWYtjCjLDIYvu3EnLAFccgkEFqoSRoythyMHerAk4+VWEbkY69TwRwQeTkbcylclVwS2GxkEZxkj5xuIA4JYkdRlRWeI1yR+82lcjA5OVXLHGAcg4O0lSwJXrkcbirpPZ3vZb6J9GldbvW9tVe572HqLT3vestGrXb5b33vo91bRIzfLUbJc7XIOG3Mo2uVyFGTgfdO0MSMZbjgscABycKEyMgEBVGACTtzx0A6gc5BOKlkiRcCVFDI2I1yXYthGWU7FDmRyq7WLBGGSVAABaRgyJIrBRlOSrGU4QEsTnp9/IyGwPm35Fc9tdEru1vnbf5dHa+nQ9WlO9ttbbJ6P3bXafrurttWWjtQYwy/IQrnCuUGCFGVYOSQqgZwTyM5A+UkZchAkCqoZSCc4VQoBRQGJJAVgpBPznKnksGCzhULsBncMDKlSGXYrjIXZkkjaTx94HDbcB8Me9YpCnlMVDsmQCp+TCfLliCFB5Y7gSPppCHNbTfutNLX8tV5dXu0jvpy87a2ts7q3pd6q672abZUkiYBX8zKrICwZFA8oEAqvyg8EIwI+YZIUcsKd5EO9Ztm6QL5ayAEvsJJUDhVCsSgUqcMMK4YEoZspwNuNzBSC2RuxwNwG8jcAFAABI2lg2MTRwq7qpKpsUBSW3s2VUqB8pBPQlQCcAFiCa2UFdLlvqny7tt21VvN99trWubqdkrXTtFr3nKzXmk09Xs3p71r62dbp5eyJASJJAgY5/d7trZlZwc4AC9MggMvXFbtvaElFBVduACAcEEqGO5l2guxJZgFDAnKhsYht7fy440Zi7xj77D95JITtG47u+wBSQMgAtkrxuWkLMq7gN2FJfnjIUnKhgQD94nAYk84PNdlGnrHSSuldOztaMU9X1bumr6p3WmpM6ukpNtRslJPRJ3WqurKyfVtddOk1vAzbBtZd2OjNlx8i7R/EDwQqEZxwTnget+C/Cl7q19Y6VYwSXF/qcsMPloheRBKypDCoUljJKWRRFghmATPSuU0TTGmkW4YF1iZVjjx80s+3ABUgsyqPvEEsAuRkkV/SD/wRg/Ya0Hxlr2uftX/ABwjh0z4MfBK3n8TTz6wqpp+s6xpkMl9DDK0v7uS20yOL+0L0LuWNUtbNN0k7k+7gcPKUoRjFOU2klGLb95xjeytu+jS3s3ZWf5tx9xdg+F8nxmZ4qfuYeDjRpRf7zFYqfKqOHorW86tRpWSfLdyd1E+3/AkXh7/AII6f8E7734kaja2UP7WP7SGiro3gPSrhUOq+HLG9hW4t7xkYNNGumwXCa1qDFQJ9QOl2jgIrIn5V/ATwtb/AAy+Hvjn41/Fu91D+3vGPh+78bfEnXZJ3TxJpnw51/ULnT00LSryU+bbfEP4+65JN4I8LyxlrrR/DC+NPF4QW2lQTv0vx1+Ousf8FHP2xPE3xl8S2mqX3wN+GGoWPhb4aeCLEN9o10TagNL8F+DNFti3lN4k+ImtC3imZFf7Db3k15KpsrM48R/aQ8Yap8VviLp/7PfhPU7LUtH8L+JJdb+KviTRWY6N4q+KMdnDpWoLpjIzRv4H+E+jwxfDv4fWqs1q1vYanr6D7T4iut36nluGhk2WQxb1xuL/AHeGi2tU1y1q+iS0cfZ03ZWjGpOydRJfJ8HZZmHDGS1c6zSUo8e+IVOeJqVZN+04d4ZSSqzhdP2daUJLBYSNmvazrVLSjRTPMfDms33xC8Z+LP2jPiNZwsv9oW8fhrw9ZxpBpyXcUKad4Z8JeHrPCw2+h+GNMt7LSNPt4UWG1s7IFEEdtuk/pg/YR+E2lfsKfsf/ABd/b/8AjrZxH4leLfC95rGg2WoxiG7trG7AXw1oNkkmJoJfEepy2MfkqA8Wmx2o+ZVda/M7/gnN+ydB+1p+0R4d0pbBn+AnwJntbvVJVQ/Y/Eevo4JgEmBHcG7uIDArjcI7IXE4DPdjP25/wWw+Nt78ZPi/8GP+Ce/wnuUg0fTtW0G68eR6W2y0i1rUI0i0rT51g+QW3hbQPteryxlcLLPGWAa2Xb59OnVx+Pw+BpQcqtepGpXmvebjKcFbupVKjjC7+w218LPjM/p4jjPirh7wr4fc4wx+Jwqzn2N5PD5ZCrSccK7X5Z1otSqXiv3k6EZ3TaPgv4Lan4s8K/s7/tDfth+NJ57v4y/tS+IL7RfC15NvbUXPizV7zSbWezYgy7S0/iXxBFHEFUWWh6PICqRqG5T9qrwu/wDwsv8AZx/ZM0dGa2+DPw58IaFr9pCAQnxJ+Kb2PjTx1NIq5U3dnZXmh2E5yDG9nNGwycL9/wCseGfCeuftH/s6fs/RCC2+Ev7N3hU/GH4kRkE2VlpPhjw5da1Yw6ioHll7bwr4WjVxJkfaPGQILNOqt8N/s+3ms/HL9pn4n/HLV7SS61PUNV8R+L4ICplkHiLxtrMmk+FtLgzlmltItRgtrRAfMUWMQiI8tVX+v+FcupYb6lgfZR+rZVgaeOxc2+TnnXlKFGbdveUqeHx/tObkipYmDtOVpQ/184R4UweFhwlwVgMPTp5bgnluUyhSUadKOGy1UsZmlVpRUYR9ooU2kmk6Djc/sZ/4I+/CG38E/BrxV4+W2EI8Z65FoGhPsAX/AIRTwHAdDsREVBURPqja1KSpIbKElsA183f8Frvj8fB/gHx5DaXgjk8DfDvUbKyCSkMPFnjpodG0pNoIBltzdafdKMllj85gOGNftB8Bfh/Z/BX4F+AfApMcSeD/AAXp1tqE4xsl1CLT1uNXvHOAc3WoNeXcjkAlpSzHk1/Ff/wW4+PR8US2Hh2C7YzfELxxrfjy/TcS48M+F86P4WhlRcgR3V1evOgOUL6MpzuiJP8AJfhfUl4j+OvF3HeIVStgsvxOLq4KrNpxp0ZN4LLabeycMqwtaLUbrn5dbO78zI81hn3HniH4gzu8NlWFxeDyWo7JUqmMisnyhQsuVOnl9GrPljqmlK+zf8wHj0o1zLGn3Y0WNTuB+4CucjPXHzEgFyT0wpr5z1uOMM7tkFiw6kFevAxgAA7Sc4KsD1Ga928UyiSafe3OXIORyd2RnkjAyMc8gA5AxXhuuEbnwwPBBABAySuQB93gYJYE7fQjr93x7Ujicfippu0pytrezsorta1vPzWx+TZxN1K85pXlJ3ta8tVFK/ZdX1V30Wnl9+g3OAGY54GTxgqDnG4EYGeeo5rhr0tcTPbwMVAIWe4yDsACho0faWM3BBPVVyDlwCvZ6gzXLvFBJsjR9st0MDaepjhxtBchcHB+Xkqc7SMOSFYlEMScH7gUcyMcjJYFhuJ6vjnJwc4r8DzOnzSnpptezbtomo+ul3om9m+vy1ZOzdtLq+13ZLTXvd6ddba2vgCLyY1t4kHPC4G5pJHAVWdlZsSMBncVJXIIfBwY2VbcNGCr3GwiWZCoEakYa3gbgZVgN8gADcqAAPmuTYXfGjBpdwLzoc5U8Lb27ZTanyhZHHLncq4UVlSSMzsqR7QqlWLAkHkglTlgVUEBmIyQTnBBavksTHR3TUdrJ21XTVLd2VtPyvxSi20tFGysls/hdrWVtbtJvWyKzLn5VPUu2TnaikKGBI3LsXneTnb7kFqouBcReV923z5hmVwHuiNhCxjau20JVg27BmKhBhG3NYOyUFVJNvu3EgLm6YYIAIA/0RcMAOPO2f8APMAshD3EsUcO4OfljjAcA8EZzllKLkEdAVGSR0Hm1Ipxae11HTrsne97L01e21yZRTilbRWvppbTRvVWVrW00VnuyowdyBFGzFnRI40GSWG0KoU7goGcEcLGAcnGcTMIbYxwq4e48p2lu4pQixjaube2ZASCDs8+b5d5GInVNxmknVIBJDbyKxd1F5MuS8ig/NDbbdrJAhUFnJRpGBBGzaDSxGqgoM8LGCoKIe5Djdw3OfMKkgkHDqDnhlCTdkktV2VmnFP3rNrbdNaLZ7vGSba5vhbStaztzJq+ratd630WmmiKkiLEE8obQWQSHJkZkY7WYqW3O4ARWc7WOF2qQOGvOsexVgmJkwR5SoygEhQz5PyuclhlmGDluhVbuPnXBJAVSflBC4xjIGOMMAjBj16sTgxSltjIudzIxUsRgrwWUhSg38cJ/F1yrEkYuNlo7W2sk9Lx2V2ltfVX1111EklZrzlola3u2td30sndbu6bumlTafaVjjjZ48xEsjJldxwRGOQ8g2nepJ5OeMAF7lhE0jI7FGICDaCFGAW5Cx4UMxfcW2E4J3KAREEiLgthCqKVbgOmMSgAgsuGI5dmPKtlgpDkWVkJcRo5JXcMEuVCA5Vs7GYls5ZgCSuFYZMRu7RtbmirNRTf2Ur9rJdV+KSCN3GyTkrJLR23TXS7sr2utHbZjJJd0kalcqXDBxtYlsqEUjICruRywYZ24J4I3SFQxcbWOAT8pChWG0qv7vdh8hevBLZBGCTLlgMsADgK6oSQqgLlgzAtwxz1BBwThCCschEbdf8AWhdzZY4IfnJwCrcKScMUCswbYBTcXu3duz2S0Vu7sne1te+vQ0V1e+1/e0jrqrp3ba30V7Kye5TMqJEGmcSSltqmMMux18v5CATyvBdmYZVtxyfmqJpbgPl8shysZgHGWICAsr4chAH3r+85yo4bdd2uWwUwQQqnAP7px95txLYPBJ2g7tjt8w20i2qqWYMxSRjIiPukUP8AKQ53MAcnkYQZ42jzMA4Welr211V03ovivq7vXTotLvbKS3Sd9E2tuVLldm9G3d3+6ytZFaO1VSXlZpHKqCxZyWQBOUzsAwEKuQCHAXgEkkkSGCaOTG15lEDsGOwZIbeyeYBtIBVQCxJ6H5Tizu2uSoZsYUp8gLrkglVK78DaRu5Iz8xYniFiRGX2PIqOm9UKg4IBXYvzEbPmBJ9TggE4drWutLa2V7SVn0fNe3a/S+4k1qk7O+r1burNtWbdrJ66pWtqmyZcOWQAllXeJFKA7V2BCq/MMyEFfNyEc5UYYKKhmKrJG+4g4csrM2QWw672B2hS4YAnopK5O3luy8ypVMq2d2JMkRtuJjBDoIxGxUgAMygvn7wAeiSyAiRTH8wVlVkcoAADgt82HZm3biTkbTsC5Dj7yerumtbJLRxvbbys+l29NbX70la2/K1dW2tfRJWTWmrdurSs1VIVco8TCRWYKwKKZCcKAHIQ7ifLI52uhClVUGoFzGeVZgyMGXaQME4wu0gBcrhWAdlb5SM8Ca4Xa+VbcrKzNnerH5tu1CxY7GXBGCNhBIJwTTEYMu2TkqGRGYHbnjYcs2Vl3FQGwCc4BOBU7XV7NWSeivpHfTp6t279Y12VrrRNcqUrqL11ttfZ2s3fXVnyxojSDYwCtzkZVlRRtKDbtKueDzwWIG1qcpCMqNgoCjBl/uttCjfgMQMYVwW3YYfKcCnuXnhCTBVMJLpMoLASAFGEmGDOeE3fuwWXOVD5zFGSXTcdgikCruJUjDR8AHc4DYBUgYxlSGYKRM+ZLS+19Lp9N7Wvdrd2d+j0BP73y9GpapXun0v1tbRWd7Hpaj+FVY/dYsCD2BOC4XczdjHkfKduCAaGUEqqowXBLMSCvBXu2CWPBYjIPRWJ2muZ+3+JMADS7V1YhR/pW9skrlATNuGD0UDKggEcHCrfeIWZg2mWfP3Q9yVwNoOEJm4OORggcNtwQcc6rxeip1NHt7OW2n4du99H2/Nngaqd+fD77uvT7q7tz+fqls73Ni4spZ3W4tiIrkEsMF088qG3mRsKqSgkgSNwy5jkDRkYbpGonUUlkKGKWCYxTAAhEyu5WjDh5FDKXDI5Uq27PKlqy01HxAxDjTLAOrDG64BAIIGdrP8ANtIOR8x3ZyTxU+lWlzp1vOZmhae6u0maOCTasKMrMwBKICuXk3g7yhUEsygk17RylHljLlXMp3i1uoJWvrdNPZa63SRpKjy4eoq9SlKrF01h+WpGcrN+/flbajy2a5traPVJy31tJYTm9s1QLuxdWoBKKuHLTeWSMwEszttXNtIDJHiNpUjmtrpJVVirpKQolhfG9N4Q5jChzJHIz5QnOQwG445vqDuBDFSYwGcg8O3H3FVs5SU4GWVRyMZCGokUUMsyxRRhpSJbmQuxbYzxFYIVcIE2MpOI8BSCAAuFNap+6rRdm7Xd1ZXcV1Sfe2l9mtMFUjUo8tVc1WCXLUSs3FW+LXonpvKVku7HgxM6l42E8yhkfzCAwIjUDzCfkcBTldgD7iMKKsxPGSQX27ido3MquMrt2kfKXBIDYxnnnANRqUO9NwJVipj+4MfMo2gA7mKyHJQsvO7oVAQIVeR2wRuAXg/JGqJg7iEO+QBQSd+0EcAqDQrq0dGt731urX069m+9k01q87RcVe6aTvd2uly7K70s9ddLd7sSZ0VTG7qrDIJwQ3lqMSMC4CErk87tzlmAXcCTVuNPt76FFnMjxAF4jHJIZUYjcXRlJGX3jcvzEcZByu1stzJFfBDbO0TJFG14oWRkMjOpBQAs6EI+MAvwQThXWrEP/H5O8bN9lSKJPmLBXuCQzMnyDaFiC79p+STO4YPMJwnpo0pKL0ata2rv00V3rZNa331UalH34ScJckakZKcbN3jFxsr2euivbW2mhmDwvZBBma8IBHH2nACtjhcYB+bBQAlW4yM4JqwaHp06vIjanGquVHm3ewyMgRnaPK/OpJcDlSG2KwIDY6hjI7tCFb5BhnO1RyUACsyrmTH3SMBiCRtwwVhMn3MBwFLZVvvbAibcufLLkKckKCVzkKVzTdKiteWNou0t3dpxSSvq7Wu7O22pSxeLUW5VpycnFw96yirJ6rrfonZp7LXXnoPDliYw+L9A4IVXu2V0AAAcgAnBIPBHIZR06L/wjGnDAdrw5Py/6WUGzjJAwO2CDhsAkEDHHRq6thkY4PylSQCRx0CkjvgAHuBkqeWOxAyvz7dpK8ruUYYtkMFULgjIP3QflK5pqjSUV7i6NvVt6Raejs3ZLbR3XW9msZi3LStOztb3k7aR7+S06vq7WZh/8I9pYwuL0dsfbXOOQMsw6dQVBxnjYSDy4+GNIHAF638Wft0nHOQzfN3O0Nj3xg5rbTaMM2FY4OAF4UhT5Yx0OCBgkkjbtwekh6gKCDgdeSeg+XcwbknHIztyq84o9jSlZunG71TcVrbltvr0W91e22oLF4rVfWKru7u82lda6a+ui3as+hykugtCzT6dfXkLocwiSd5ozIuzYrIGTcjHIzn5Qd2w8BdW0uluBJE8aw3Nupinty26RXwQJUbLF4JAP3cmGZMkAqTmtIspLKAC6jBUYIOSCAN5JbBOSMAqpK54zWNfWgluYpreYwX8IPkXBGVIb5TbzLGd0kMjMVYMMqCcsCNjxyRp+9TSV5JSjfe7V7PX3uy26dmawqyxNoYiTulenVatJNcuk3F3lTdtXq1a6u0077RueJnlAM20bXVflClQcH76yIcNI2Dg7sAgMBo33hVmZomdJDbsFPK/I0CybwwAG6TKSANyu1QxzFZ3Zug6mJIbuJCLm3faShzv82MDcZYJCTsYbjwELAZDSzq6l8ghC6O+GYbGOQyD5VBBUqcKAeVIPBNUuVpPSzSWrae2z/J3V0m9rGV505ck0ote9aycdbNtOzTT1alezWokAk2yKCzZdnkJ3lRzHuwS4O3PG4ABNpQ4OSYrtWlUR7MxySMd6I7SooU4kXaUe3eMsHGH8xvmKKGZgXLNb/aTbhv36sT5QXYh/wBX8yTFBv2k7tox82BtY8hJreOVg8k02IpFISGUqjquSHcnZuYuiDzIwCDGSVDAsz0cOVe9ayezX2XZt3u0773t2tq9Y3jOM5c0HpNXve78r7O97X23QltIxMdrcMHutvnCcqifa0UMxOG3Mlxt+9Htwy4dQqhgss8EFxBNHMm5CwATdtJ2sBHJFtGQQQSHGx2wejKSSeESKY0YqWIZDGrII1xtEkZjIw6bs5VtjDLKGJzUMEhEggmINwilUmwqidcud6r8xFwFVt6YDEHcFAGA4q3uzu4taX6pNaNN33/H0Q3Dn/f0nyVI2lOEdLS928oWa01baW3TRmCouNFmWBg0thM4JlK72X/WSO8SMw2SlWDvbhSLkAtCBIjxt0DuZIC9qYn3RrPG4VDEVZgS2XCrnYBkCUKrDIJXOxzwxXVqY5lJEisGRgwcsNpEiFQGEi/eVgFbI3EbgS3OK1zo8gtpC01i8kjJK6h3RnLF5URmyJgqFprbAEwVpYF3iRaxTdJrf2b1V7Jxd42bfbXSz331OlcuMi5KyxNN+8nblrJa3urLm7rqtNlr0nlsSQsQKmFsfKquoDH5lctIu5/9rJOdwIAWohbwxl7mG18uZiTuRGcsQxaVwG2iNwABt+cALgb1PMJN08iNblJ7SZXmV9y4XyyAiwbZFikX5SXDBQAxyuENTBponUS/vTKUUsq5WGV8h42YkosRZJGBRWw3zFSARWt4yadmuztfVpWkns09Nm0/kcvLKGikkuW8oxk1orXTV0k9Nn8vOuk32sTJ5bwRxySKkjqisxTC7U2spURsVaRA7lQAMnK754ld125DtGvl79gBIAXymUEO77ycu6kMxyG+ZQwmQyrI0Mgj8sjFuY2jMksYKxvvIIVJR5ZJIA4ABIJWiZQYZEdnQD7rRsfMBwpjKKuM7Th3G7bnnKsThxTs5XbbfotLapdn3tdpXWgpSjzOKSjHRq2tr8urejblu13ulYpqS9s0KSxGbIgaOLMLibCsjBmUksyIqHAG8kqShA3TgsF3ZAMcbIrsoQzFT5W9CxY+a/yly4O5jgkHILWiMUeIUjudiK+2d1Eg+UbnWfczMgWPgPvHzYGADiaCCJR5rqsjOuZWyCgdgCwiVFUIQQDhQFBbKlkIeiKeiaV9EvvVtdr6Pr223VSlG3xXSbcVdJpvlutWmo6K127N/MQKE3F3YyBcuwyAFQR4jjQIgDZG0j+LOGxjNPjkjcI/zruUIokUB8fJ98qGAPOTkhkGGICtuKyRvuV1cAukhQssh8p2wY3x5g+ZAiKwxgsxG8KQtRW4MVwsE07yu9kJG85m5khkCyupcbQJE2qqqucJl2DAitE+Vp2aurNyaX8qW9n5a66K+9yHFShfmvJWfL712la791JaJ33tppcvFHcKFkdZFZHJjILFVK7o9zJ0YhSCT83zZbbyLSRkvuVySq5wN5wwIHKkkkLjaoz8mCOc7RXj42O0rsUUBwcYG+RSpdFCuXUEDf8Awj73yZyqXKb4FXdi5Y+W2EHaIETAkPCxLbQpDFcggHjNJp6pWfye/KtbPpf03e+hg1OS5Va1kn9i2seZJddOl0lqtNbXFywI3gBsHGNxTlcoo4+cZ59gAuTzQFJc4bcMLtQR7VjyyqdxKvvDqB8oG7BHQDJY3yq25xCo+UEuRtQkAMCFzhX2FEUFX+8SOgdbxb40Q7ukcxkZizSgeWFG7cDkgby5UBwOFA5px1enTyu9orf79UktLu6MbyUXLmbd9NG9LJ3TTaWmyabSd1bS2c8LaU4ubYStaSlftluoYCFiCTNbkFAqkEFlUYySTzit6FluI1lRlkiZW2FSM5QjIzgsCp6oT1ySWIpRtnDBAhDAowOFHIT5WVkLbdp5YrgKMfdANZbRPpkjXFuJJLJ2/wBJtwW/dMdxZ4lLA7QNu3jAzjgAsNIe4k3rG60dm02466c2l1ond7db3HL2yTl/FSS5pP41aKs9dHsk31Vr9TZVSCSwPO0AY4AIUn5mxkHqTwWHcYFWApUqhXJABLA8MML0xlsHGARgEKCdtJC0c8Uc0TB0kBZThclgT+7YAE7gwKspIBIGDggm4DwrAZzjKkHj7gyCTnnJ5BLA5AB/h6Yxu0t37u9le9uj201dttVrc5ZT0VtXHlv9n3ly7a7380nr3GoFO0dR0BBHB+UYJyc7QOdzEA8jJwKsRKkZCbJXMsrEsR5ojJVMiRskxxEFgoxuB54zyRoSwAUnnchyu35SvrgLyTjhlPy42ncGvxQsSXV3yIyPKAARnAUmRiAspORgYbK4GQVb5dowsk3ZNryva8dGua9krLSWmje6vyzqpJpvfpe/ve6tX1d7tPV/zaJldSwv7YKvmI8E67sgqX3MVVSHTYGCMVfaxwDnOAB0VspWGQqCd0tqrkjbkhpGwoHAKtwCu4A8c7jWWsIa4twyMNqysrEqGOV2HhiDt+V29ywYDcRXQRxOLdsgYM1sB03EDzMAlQGA5A5xwCGwSTW8IWd3aye2nVq726X16O/S7MsXWi/YpJaUYxltZ+9q9LrVNq91bzuX7e2WQqfu7WzH+8KgH5D8qnHUgbVAKdBnPFegeG7VhFdnBIVopsAMAFWGQhuSScswB4HJCngCuStInGw4VuVJIDAn7mAx9EJJOcgMN5JyBXuPw+0VtRsPF0m1W+xaCt6CTggRyBWIB3E8N8xGQCCRwa+gyjCvE4lQi7ScKk1/25CU32s/ds1ru30dvIlNvnUdlTnbR2TSuru7V249rNt7LU+vPhP4xXwz+yn+0R4IsJVifW4/hLrd0HQjzHsPH2rrKjP8iwwpHJDJKzrK0kvkRRRgyFk8s+C+s678LtEu/HCTWjeL/GJ1e08HTyJG9/4bsbiW3t/E/ju03wsYdQv0tpvCXh69ilR7eU+Jr+3W2vtN0+6rM+HmnXXiWPxZ4d+0ta6XfWWkz6xdHcYLLStC1ptc1HUpoxgSf2bp9ldywR5ZHu5IVEclxPEokuZxqmrPd28DWdjHFb2WjacWyum6NYRR22l2G4bVaSK1RZLubAe7vpLq7mYz3EjN9NTnUhDBYhKSnh6UqNFaXU1WnJ1VfW9NVLw2tJpppxsvw6FKlSr8TYeT5lnOa08di02m3SeX5fho0Ja6xqywz9orNSpRlB6TV+j0TTmuHG1GZ3YL83zuzyHO5jnl3bJJywDHkkkCvtn4TfD+713WfDnhTTrWS4uL27tftMUabpJrm6cBIRt+8RuWMbhlW38Hkj52+HWkJe3iXMkZMFhGJ3yAVZxkQRru3KCzspI+XOTjFf0Gf8EnP2d/+E7+JMnxG1yy8/RPB+y8DXCExS6vLxYx/OSpMIDXG04YbUGMEA+1lOHhKo69a/s6UHVqOTTuoJOWr0blK0FbdyS7o+R4/wCJZcNcK4/F0XH67i4xwGXQb5XKrWcacGlu4qTU52uowpyb0Wn71/sq/B2z+CnwW8H+EI4Fi1BdOiv9XZF2s+oXiLPOrlcZERYQpycJGuG/vfSEsm1SzcHbgr044y2MZyQByecY7CjasQUBAABtwABhQAAOBgYAxjB/HmqNzIcHOEBJ7jIHOwduCMZ6EYxknrx160sVXlVkrOpJvp7sbpRjGztaKUVZWskttj+Qqq+pYW0pylVkpTq1JNOVSvVftKtSV93OUnJ9U3r1M+8l4Izkenvk4H14BOO3QjpXMXUqnAUgYBwCRliCCfvc8noR29Mhq1rp3YFsDgDHPtxyBnPP5HHQYrm7lnwzcHOTjKgjB4PQche27HIJA4NephKUdO6srXS1dt+z+7vdH5jnWMcnJJpp8z0emlktb9dN9L+llnXr/fJIGflCFsZXAG4g/e243A9ucjAOP5Zf+CrWoJJ8bNe2PuxY2UTn1aO3CkADAOMAYOTzjouD/T74h1OLS9NvtRuZFjitbeWdixUDESsysSc4znBwxBGDg/eX+Pz/AIKA+PIvGPxO8VanHOrLJqE0MbbySI42eNV9FyMDg54yMHr9Al7LKcdWlZRnGlTh5tNTk49XZp991qj0/BbDVMf4k4GpTjKUMJQrVKskm1F1PZ06ab1tzPmfXba+349+LZ3t7+4Td8ocspBwOSWAyMAk5GcAHGACcjHnFxqO043ZGMls9emMjp67gehYsCSSB2Pjy6X7RvUkksQW4AAyMdTnOOSPQtzkCvHLu6TJJJBXgEgd9ox82CTxx8uDk7jwRX5biajU5bNX1fRJcu+nrbXpqf608OUJVMFRk1dunFPS/RR38mrpPSS11truTaoAAWPU4ABIwWJ4ABOSFGQOPXpzVd9WwdpfBXHQZIx34GT1zuyAenUZrkJr9cEfMV+pAI44xjv2yASc4PpTN8CVCj5cHO5uQSATxxyTnv06fLkHkVVJWvtva7dklqr3V/JXvrs7n2tDAaR91N3T76e7bo1bps9bX6t9bda4/lEBsFuODtAyDz74Bx2BJHJ4JwoHae4O48ByeeckN9SWPU+49skY7TmTcAeSduOgHUnAHy4OeSM4OPTi7YMRMDwMNjOflLemejHqTjoBxxkVvh5KVWN72urvSz2SsvPTRX3d3pp91keFpUVHSzco8z0bfwrTS/u/8HRHqWjMFaMrggdsgYPAJ4B4GSVBxg88Hk/pd+xH8XZfAPj+wtp7kJYaqVtJlZgoJfcE5JwxBPy8AHPABANfl1p1wyyJ3HA+8Ov3TgAqvQlQc+gPpXt3gfXLjTdRtLyGQxyW9xDMhRtrAo+8EY5HIChiPlIBA44/afDvOnkedYDGRaUFOMKq5rKVGbjCrCSS1Uoydt9r620/Z+Fswnl2OwuJoyUHRqQbs94rk5ldatW/O1tbP+zDwxq0OoafaXUMgkjmgSRZAcgq4DZB+Ynk4zu75PUmu4t5FJyFIHUrzuGMfewSdq455wvBJwePg39j74pxfED4c6VvuVkvtPjW2uEDfOdoKqWyWO0gN364H3c4+4LOYBByCQNp7nHylgOvBAzjduxg89v6ozXC04z9tRblRrQp1qU42anTqxjKEvlGV79GrO13b+1MhxlPG4PDYiEklWpRnpu9Ixkmr9PLvY1db0u21zSLywuIVmjubWaGVGGQVkR1IIOcg7uenqM4OP5ff2tfhJc/Dr4m6/p627R2pvJL+wcKQr2dyxdCpwSRG7FT3G3HIUkf1LWbbyEOADnOR8vzEA5A6jJ5/vE4A9fzj/4KF/BFfE3g6Pxxpdmrahoisl8Uj+aSwmb5WO3BIhfa2TgAMcdgfiM8wKzTKcZl87utTi8XhHs1UpxftIrde/TvZJXc1GzPz7xi4cjnPDs8RSpKWIwKlUTS1dOTUakUkrv3bSt3Vno7HzV/wTO+NQ0fxCvg7U7oR2mtQnTXjlfKC6CubOVlyMbwTETkO3GCBtI63/gpd8HhBqmmfEXTLU7LpGtNQkRdzBk+e3bcmCcBCqkkMwyThlZW/LD4T+KLz4ffECyu4ZntlivYSWViu145MowOOPnx8/BxkDHFf0WeOrax/aJ/Zza8i8u51CXRRKuAHkh1Wyjy+MKSDOFVjzxyXbMhY/gdePMozmlGdO+GrXsndW5Ja9V+CVrn+GXidklTw38YMDxDh4ujlXFE/quO5Vy01iJOMJSk0lG8k1JW19y93dHxt/wR6+PFt4O+M+qfBbxJd7PCnxl0m50IwTSlYE8RQRXL6VLHn92JrgSSWcbbQ7PdRkbduD5V/wAFV/gNefC746Q+OobYx6d4vaTSNYmSPy4xr+jqgtrp8KAp1bSzbXsbg5fa5ADA18DaXqeufCr4oadrOmSy6dqnhbxBaapp8sbPHLb3en3ayqgIAbIeNowAOiqMYNf00ftq+ENM/bR/Yx8NfGHwtDBc6t4o8HWGrxpbhXaw8ceGoZbiS3IBbypLlbfU9MYH5vIFvuVgwrryyr9aVXATsnjaX1WN7XjjsKniMvndu3PXpLEYVyaukqUG9Vf8H8UsvfAfidk/GuHXJleaTjSzZRaVOWEx0qOFzCc2umFqvAY+MHo3DEz3vI/Kr/glp8aF+H/x1g8E6pfG10H4q2MfhovJKUitvFNjI9/4Tvc5CiSS8WXS9/DZ1Fck9G/u0+Bvi9fG/gDTpbpw97DbtZahE2N6XMAMEgZTyu5kLj2dST1r/Mm8DaxqWi6nZajZSy2GsaRf295aTKWjuLPUtOnSaFtw+ZJIZowTjBDAfeBAH95X/BOf9oyy+KXg3wb4oS4iRPiDoFte6hbIyhLLxfpY+weJ7ERjhH+3wS3CIRnyJImGFKlvhvEDJ55vwtKtCLljMmm68Wrufsfd9qlZXSt7zb29nFPex9JwdncPDbx3yTN6k4w4Z8TMNHhjN03bDrOIQU8pxNR6RbrJfVYy1uqlSV7t3+S/+Cvn7No8WfC/xXqml2Pm6v4Fnl8daR5aEzz6TJELfxZp8W1SxRrJU1QxrndNpcRGScn+K74g6O0NxONhCBmxxjgtkZIJ5K4AwAB1BUjj/Tg/aa8C2nifwfPqElnHex2sM0V7BJGrpd6deRPb3sEikEPFLBI6upBBXIGRxX+fb+2n8D5/g58YfHvgVoXNjpWqy3egzOn/AB9+GtVB1DQ51JyZNllOlrMyZH2y1uImIKMBtwnmi4j4SoRn7+My5OhVb1k4RUEm1vtaT63nrseJm2RS8LvGbiXheMPY5LndZ8TcP6NUlhsfVcsTh6V7RSw+I54QhFvROWqsz8jtesuXBUqeytnkfLwMgk444BHON2TXj2s2wUuVGWOG6N8q/J975RnGeQNpHPdcV9L+KNPEUsoIyVzuOTkEctwRlTtIOD2K7uM48O1m0OCQowGc5xjJfbx94gnnqASQ2VJAFfOZhhpQbVkmpNa6t7NO1tdNfubbP6e4XzFSp0pcz1UdL3eqintZWbV131Vzxu9gA3HjGOCpJ7KOWwSNvHcYHXI681cRh8hSCcdydxVgpyF+U5GNqE5ORk4Hy13moWzfNsVADg9AehU4P3cAscgKcnJB5OG5O9h5LY5BxjnOMoOAMnHBxjp/Fk4NfN16avtfflVlpbVqz/mX9Lc/X8uxN1DW97e89OVNLV2+V7dnrojjpdoyoZWJYDIyAG+VsSZXaBjAyRk4IXj5TnFWUkIxJbkhirA5VQwiVWBRT0wccY6hsjoJ4Gzt+8uMrj5dpKqpU4YZ2/wkk44OQSAMt42B4KjqqhVzt4GFIA47Z5IDDI+XK15koWu2orrZ7Ru46q/VO/Xa66tP6rDyUrJu+qtotrx08uurt5vWxiyAP8qMrmNkBAAGeAcbGCkjDYZ1O1R/wGoGG1iASQwOFG4bSwUEqMMRhjt2hhuIByQBi/MFLRqQ2VXlssq8bcKTkEPkKSccqMMcbqqyBJG8sggqUm2xvtP3VAWPgk7gfmXJAXkEYbOHI0r2V3py7b2urLTTS+jejXV29ug7KL6rzb35em/TS7lfr3KhjZCoB2ru8yVcM27zCjgAvwrMfmwCSRhckYqyflUEBicDCgglRlBu28gBA3QHGTkcEEP8gKx2lgC2/ZlztZjl2BbOAw24G07cAA96mSFAH2g/PIXIO453AAtknI4PGc7ed2ckjandJvla01tvZWTVknr67paJuyffCWmi2srr1V9dk0/Rt2W5WeF5FMahT8qvGzclwpAKkhsFCqZyBufIB2sRi7b2iqyxKjBRtkBZm+Q/u1Yg52sZCuBghT9wjJbM0MLAgA87QzHZk5wjEHb8wXHJGeOCM7sVqW0TM7MExjAywJOwAMfmDAnI69jjaygddoU1dPq7b2tb3LadNWlayv089L6XbstLO/krbbbK/N20V0yWCEOM8KeG+fZkkbcDnccfNgDIyfl65I6HTrIyuioPvAlupCjHLHcCV6E7sYU5UDjJgtYOjADoMghj0C7SCWOCN3QjIYndg816X4V8P3eoXVrZ2sLS3l86RKERg6I5287SGAY5BXBJb5QMkZ9bDUk3G6eu+nR623vd26tvRLXU83MMbTw1KUnOKk018StHlV7y12ind3V9VqfUf7GP7NHi39pv42+B/hb4RsJrqXW9Ugtp5kjZ4LDTkdX1HVLp1XbHDBbLI5lc4Gc8DBb+h/8A4Kn/ABn0n4BfCr4af8Etv2XHB1G703SE+K+oaKwW6uDqLwPBodzJbZc3+v3xGp6qWJeLT4rO3ceWXWvS/wBkP4d+C/8Agk5+wV4p/bB+K2k2a/G34maFFp3w18Oaiqx6nGdTR/8AhH9OhicGeKbVZd2t6s6LmHS7ZUYgsqn8hfg9pPiPxvrnjr9pf4y+Irmw8T+PbTxH468SeNLgl7/wV8Nop3t/G3xBtEckprN/FcwfDj4UWCsp1HxfrlvcWRFtpV09fovDuVwqc2Iq3hQhHnqTdk/ZRaUlF/ZlN3px6Xc5LWm2fzpllPD+JXG2J4hzepUXh14czliqyV5U85z2EoKlRopXjXn7VwpYemm+apKDtKE52b4m1XTP2VfgroyeErlJfG+sHxD4T+E91bCPzbrxfJHJ4f8Aix8dsLud7TwZb3WofC74YzrEyS+JpfEuvadOJ9CjJ8E+GngLWtBs9A+Hvhi0ub74pfFWe2tZBbo8uoaRoN5MkIQMoeWPUNVmuGtUkJaQyy3JzvWN6mk8XD4xfEDxD8c/FmkReHPAng2w03w/8OvBFrubT/DXhbw/CuneCfBGkLLu8+aytEhm1O/kZpdV1+51DWL5nuLm4eT94/8AgjN+x9f+MPFWs/tY/E7S/MkW5a38D2l1CTGL/a8D3lrHMGVbXRrdktLMjJN0ZpnJeCLZ6ONxUsdinWcuTD0ounhadko0MPHlUeWPRyiopNK7T1uexx5xmshyzOeLM3cY46vGHscFGUVGjGEFTyjIsOld+xwdJw9s43U6rrVmrTaX6j/A/wAE/D//AIJg/sN634p1iKzTWPC3haXxH4gm2pDP4h8dapbpBpejxsMPKBezW+nQJGx8q3HnFQEYn8C/2EdF1z40fHL4v/tZfE25NzcW15rNy2tX2RGuveIluNS8QX0Ur/LFFoXh5WtYyCFt4L5AoUJ8v0z/AMFyv2pn8QeM/DH7KnhDUGudM8HvZ+JvH0NlKWW/8WapEP8AhHtBkSNsSNptlcfbJIQci4vkRh50JI4zxP4dl/Z4/Ye0n4X6UwsvHPxPGh/D6dozsuJfE3xMvoX8XXIZPmf+x/Dr6ra+YMBIbW0XeocCvvPD7JZ18dLMJw+BU6jk17sXNqGHp6veEXOrsmpNOWp+mfQc4Bx+Nnm/i7xTh5VMVWpVczpe2htGq3HL6UZSTcPrFTmxMYxv+7p4a693TgU8ay2P7NX7X37S175tp4h/aT8TaX8EfADSsEuYPDniR7DX/EFtbk5mWOw+Evhjw1a4VwIp9fvUbb+7B+wf+CKv7Psfjj4ifDRtRsi9nqXjHUPilrm5NwPhv4ZKlp4ZjkyP9Rd+Nr6EiMjy5orZ2QYi3L8L/tnwL4X8O/srfsx+HbdRLoXgdPiTrWnwLiWTxh8arlZ/D9rdwoATd6P4C03wtZRqVVooL7Yq8kn+pb/gjB8D7bwf4U8d+M2t42i0e08NfCbw5dBMK8PhS1bU/Fl5C5CqV1TxLqztKwGWlsMMSVYV+h+JHEf+qXhJxdxBTrKnjM/VfL8tTbUpLGujlGErYWb96SWCpxzODjeN5TlFuO/+kE8fPh/hvi7iWU+WvgMiWTYKfO+b+2+I5Rp4irSlv7WhSrYiq1G7Sp30SufpT+1n45Pw/wDgV4tuLabydT1W0j8O6SFYLI8+rN9ikaHABLQWbTzgZBDRkjAwT/nHf8FH/iWnjv8AaK8dR2lys+k+CRZ/D7StrholHhqORNZaPG1QsviS61liQTuAUEttr+4D/gqt8abTwJ4Wc3EsX9n/AA78J+IviDq1uzqEmvrOzmGh2r8jEl1cQvaxZyGkv4lAZnUH/Oa+JOvX2r6lqeo38zz6hqN7d6hf3DszPcX1/cy3d5MzdWea4lkZmYYG4HGTX559HPIHkPhvjc+q04wxOfYirWjNr33RTVKjBNq3uwoe3ile0cU9lLX4/LcN/q94XZRRaUcbxVmGJzzE6WqfUsNbB4CErtXpzca2Ihe9/aO28jwDX5tzSkPknI2gHHJIIXbuAOQucZC5yMA4Ph2vStcSyQwsQiELPMD/AA5GYoyQu6U4BODkcnAPFen+IJbicyLGVRM/vZzjcm7B2RBuC+0EZ3sFwDn18t1RSitFEMLgnIHO84Uu7YZAWySznkncSN3Ty+KanPVqtu7lJ3au3ZuLbvp5efZapL8px05SnK8r3lq93ZWWl0nbyvqtfXi50jUiNdqoAVQKCVUkIFMhRXUKQ2ZHZQF+Z2IIJrmbl1zND5kbZyfPwoMu35FSFi0WIiVSSQsCZMkBlAxW9cspWRFQjzAPOc4ZnCjjyuI2ijYoDz8zkBSVUla5m8aNh5XysXVmVMnaqjHzM2xgoTeSwO7BU4G5Rn8ezFK8m9mrcraV3dd7pXT6b6njzjzPsraJdWuVRavfvZqzWrtrYzLkkoYwArbQwJBHlqQo3EncoT5izH5WAYEFm3MuQ4W4UggGDHBBCm4IAbcMbClmCrYU4MxUllKZDXHJuCyKQ1uSWLcbrpiFfjhGW1BX5VPLgZI2YzIkMtxKkEKFndNhXBCDAx5jEqQsUYJDPkDG7IYYr5DFqLbdrbJb9Wlor2ab32vs3q2uSdkrvRPl3Vk9I69Lxbba16662Zlqkk8nkxxndvVI1HyjAIwQpLL5afxbtuwcnIGamk8i0SS1icNM0bC4uwy/OSBmC33FR5AZSzSEqZCoXggAW7x47WNtPtFMrSbhdXiZUyspYGGF1YBIFkj9CWPqSNuNIrsByxXywBEeDwFY9N7fKGyDuAyScbD8vkzd+2uumltFd9NPS9uq7875pa3cY9Forr3ZRlK6skukbNLe2qRA+/eB94bMgMHw2HBVsMSVXBGXwAWO3gAZhUM24h1IHBPygg4Tg4+6M7QGzkNtwcE04h3jWTBBkAGSQMIU2hWRG35Uk7vmJbhTkDIhjidlyFK7WwAGbB2KpkBG0DpghCcYzn5jXLJ2fRXs1rfT3b6PbRvr1TV7u2UtdFaz2V4qNny2e6tZa69bvW9kCJA5k3NkEIDvIRM7VBRMqQGVAOmNxO0Diow29mOCoG9SQV3biACVyC21Tkqcgq3y53fMLDKeDglgO+eWG0KSDkhgMYJ3BeVJBFRyRgruJYHgll3ZwAmc+o7ZOGP8WRkjFwUW/wCV66LXm91LVP7Ts29WtL3bV3paMY25XrbZvZbtqS1Vlu13S2rrDkIsj73QqdyBVPBZFUs2ZCwCqAcYKggrvLEyPhE48tSSoVWLFWYlF4BAO/PAIYZJwxCrTJEDuq4ZgEPltukQKzlgVxgbWIbMYLdt24FiBGz+RsZvNcFNpkCO7MQA218htjHJGVBY7QQgOAcpPlWie1tW/LXms+llo2tFrrotly6a67p9Iq6vs9m7u10ne10WgzEqEXaBGcFsYyGOMjIVmYg4PmYIOM/w1G6uwA+QsArsWTCM6lSyZLAlgQmCpA2rjuQVh3tHGTgSfKx+6D2CJnaOVBUbioBwQw39UJdXYnLkyEBvmBRW2McEkhlJAJGAcnkAZy24uzSbd/5rWV1v2WtklfXW6WqObmTs2r30vbVcqXK+azV47p9vhVrKYC5AZiEHzhRgMCGUjcVxxgHKg4IO4ZOafkDaq7WBB28bFQHCsT1IXvtJDA/NtKlqaD5eWyCFXGcsWXG0k4AIHU7cZC/Nzg5MasGVWVwFZcbS+OPlPIjyqNjAOcsAf4vmFS3ZuS5W3a17dVFOz6Ky6NrVdwTSSWidlZvfRRvZtuOjV9HZNLRuMkOlLBc84QAMdpbK/L91idpwDu3dMAZ34FNVdwHzZTYQmM8ggAOCpHBGVADHAztHIWoECsQ2XVgxY5fHy4AwpQZEcvGSAcAbNuBkSqNw2KNqEeYpbLsGCoQmWYcMQOMEDjHzDBltJ3ck09X2TtFLRdtHt2000UeZtSab9JJvXls7xfdatJW0bXaRc7RuBDYG4ZyAQFBBDDdk9Dn+L5TjBNK4LKQRwI2z8owAF5Ls/bJ3HAXHytyy01mEmSpClSDgljg4+62ACSQdoB64wxBXFNZ9sUhORmJsEkrkKijJ4YqTnA3nJGQScBjV1rezSts+XVcrv1stE7J7O6tqaRe2qe3vOy0jGC1XRtrVO1lbd3tnFpJh5bxjcNjKRyq5KAeazERlWBB3DAY9QCA1Rrub5mwgQbG5UFGUA4OA2CuflclhgZcEDNSR3ESozRHZKzYCMEUu2UBBJG4xh24BViuCrlSRTcsrMysWLlAVYOB+8O4qQCf3ajuCxTbj7m5WyVnFPmvJq9ly9ejs72XVddd9DN2XK/ibu2776K2qfZJ2snf090mG2QTBSyvEPNLfMpyBlkZWBCuq5R8YQjglS2UUfPEwVhG7IRIV3vsDjCMq8mRCSJEZ/mXDhlkUKZRCyxyAuzhTG8LZZGKudrRZJLB1OCkZBgySQMc0kMTGPz2UjaxjkhYNIN8flrlASMklR8rDeqEqm6NlxE9eZtq7Td01vt2v5+Su1clr3kvd1Sk9YtNWWmnntqtPPReipbQld23Yw55VRyCAuxn2g9MFSuWP8W4KaBGEA3qTkYypBGGweSAAwIIZskEgbgBUmCU+YsXXAHzbgRtULjcTnOQVKgK2CAo61AHbocgDkgkt3XLAHCg8KcjJUcDBwSo6JJWWq336b7eV9NfO2n5VeTTbbetmm+ySsno2tdet9+llkhXKvhWdE3juTjawxtGCRuJGTtIO0gkYphMiiOSNghjYD5g5UBwPMU5ZRuO3OCSM4RSSSxcXJBGWXD7TnOcAIpBbKkKTkZwdwODgkEtXZkcMoDA7Sc43FSBt+9s+YBB94jBzuUEGu1r2te2j6NppbaW13e12io6K7bbSs09VZpX0srf8C6ukAj2L5cYYoGZ0BLZQvuADfOdwLhcAHqQcAYUNV2WNT5coUop2sVd1UiMtK3ylAF38l3BHGFYch8Tg+Y5XZtOBuIGQAuGHybiSTliQQQQeBzUcax87FwsjSPKVZnJLhDkuBwASMxn5UYZJKACoXT3uVNaqyaVnFK3Vpuz7rfYtPSTkk5XSu72b00bvpsnot1bbUfKSytFDIEYcRzFVcKAyDcBtwWcqSjK20N8ytnFSf6pBJsIRAPMdjg5G1RK+PNTeAMudm05YAONtV4HYRpuInkUh3e3XeSgVMMhZmzhSsZXhhjIAGWqjG39rFXRng01JmD71Ect7cwlC8IIKIlsrBxJ82ZCvowUDaSvFc8pWUeW9+l29XG19JNNu1rFxpOXxS5aNOXvzeu6SSit+aVnyxdlo3pZl62kW8EsiM5jRTEobKfaEOyTzIiEUmMsSUc7Scr7KUWd1lnUAsFdhvBYKoPlqpVWcbnQnazbAAVCt8pLVMziXeiwPEUUIY/OER2sn7uFY/mEYYOFUbtxRQcAAYq25aVGkNv5DLIwBlC3EjugXzNx3KUUN8yIWkzlSgw2WUb80fhbW71XNe1nqtU21va7v2LdmpzXwJQUYuUXKKbi1dbtuN20l8W+lybdEQwMjt5bnJLlSfnVmUqCxIOcMRiNSSFweaUSEO6FJAsYjKyM25H3hcRxM2GJVVYk7eRnuoNQi4YTljKqoqkrGtvCCX8xUMiMzFiuFHloyksSRsGDVnzFcMPtE8YKYOFgycgESfMmSEydoPYgHjFV1TST6WVrtKyatzaX37p900JJK15a2Vmub3dYu+13e3S9murSs8tkldwGSGG3GBzgZ+Xk5BwFGQSckDJDM/wAIKvjktyMj5fmYlcg84IA74AwTVTMytErXUztIwVdwtkUsAh8s5iJGMsWJ+8QCAA5FOiimUmUXt2d+Syl7cICGADKPLx8iLgkjH/ASVpuUk0uV9Hry9OV33evTo99mw9kkr+2jqrr3ZdZJNXa05XdXdvQshiAcq3ysdpAJBGFwU+UE8HHC42qpXBwQ9mZsAAqxUY4OWGBtBOPmLDJBAGTkMdwrNkumjTc1/dEk7ljiSCSQ/vNjDy1tyA7ZBEbOuFUt65FlvpUz9pnUFpInZVtJdkSbAZnOwJ33FAwIJC5IziHPVJJyk1zNaN201Vn6uztZuySSsaRw11ze0gotpNvnS6d49mrv8y4XlMqKsLBMOZJjsAidApCBXQO+4owLZIABOcg05gz7doygwkn3MRo2xiEOdrcpzkEHoMEjNG3kuoCZJ7m4vYlO2QTQQxzRcBmmhZAqyoCW3KQ2QSBjA36iFWUPGweN8yKyncrjJB27Rx90koehBQ4OcEZJpqzTdpcrtonyt7XumtNXe+61unWoSpqEouE6b0U4uTT23TV1JaJR5UtnZ9Mm9spZGE9rIbe7tjm2nwWOCMCKYBVWWGQnB3AjAyFBHNW0uxM0qzo1vewRyLcW7u5yWLsLi3A3PJbuQVXAYwE5LFRg7xJK7toYEYYH5tq4UsTuPy9cDPMbEEggMoyryxFyyzQt5F3A2baYbvMjXG0xSYKBoJN21iDlS2QQVwZlBp88enLzK+vRNpbLRaN6aWb6l0KsJxVOrZLXknu4t9NE24N6tK7Td4W1UnRebMWeRiAvnKsQJKwYZGDO21GYNt+bkFgPmG1Rm1HcI2SODjykVgBIzcMUVdpILA/IzlXxtLKAu5slbg7XMwEckMbLLaNK0cq5EhDx4Mu9S3zQyBWVQAzjAwtwiSKGNpZC7sIg6iJ3HlsEZSFHlgSAIfMmYlhkHcwBqoTT0XRJvXVK6vZPW++j1XVdDSVJv4npJpRWmys/d6bbSvbs+its0aERkt5jhZPuAnblFMpcZjTy+6kcAA4BBDRyW6zBkYOwMjSDbtXYFBAmV0IbcpJJw2XYHqM5UNKwYLGI9j+UokZGUIHQNwgzKJOoGCrfMh52EyxBiuWUO+zcxCbeOBtOSnyqQ211HzMcsCQSdG+bR3alqlb+6t9fSzSS366GKUqNnFtONkveu2/dbd1dW3uldN+TZUheUlLeVfMuNjSpJGqqk6qXKzKodi0sYOHiGPvKw+UglZ41uElhlQPGZAJEOV3YwoMexQw2kq4lTD7tpwrci1MjSKCZdsoZHjMQbzUfYFDKylCMMwMiEMrqCpDAsDmme6SdY3gV3JZvMieMpLF5jbrpIy5kDABVdA+QGAwVyTmnyJRmnytWi3rd2Ts99fzSWupvZVbVaPKqkXzTgmo7W9+nZ2t1aeqfS1mslVn0acQMZLjT52KnAJljDK5cLk/JdIpZiiBVulUsAknmIehEcLxwS2svyJEskMiNJICBuYRyRKcclyWBLGN84AQgJWbyLxJLdoi6SErtKSRqWwnlhVC5EsWVYMrEK21lYEKayWM+lt5ZYz2dwz7mbauDIJAcqWUQXm3aoY4huVwpETl1OUU6ei1p6ct9OTZvXXTVOyslbRX31dsQv+feJjvHaNZNKzfTnt166Wtc6LDRIC480OEJ2KSxQgiQqWARUGfmRTiPcSjZAqmk1vbRhAwQFmTYzea+9tscilsk7c4ZNyhBgkAqpqxbsJVItoTsSLckjqY0Dow3JEjAP5qs2SCzoWyxAG0VKLZXd3cB2feWYrtZgQrFAVXMaqwBzlgTn+Fip6b35WktrtvVWbS001dlurX662vy6RvGd0+sdFd3STaWi3WzTvZNa6tkfCKskmwbgFG5kD42qUVlTDE7huZWCNwAAcinxKFbh2Dtlljcl9ivsBjUhsAkZJZlI+Zscgiq8Sqbmf8A0WRY4JGH2mVlxKzbCRCjgAjYCQ4IZgpIBYZqw6BoZFMiqjxuqE7mdUcLhwy5LDdgADGSxCncMAXV6K2itbyWz1fW/wB93sRJKPLFu91G791rXltLRvldt9U02tLaCxNG7SRqdxjZfNYbyFfbGRGC4jVmGD5hDAKMYAZcVSW3mQfvI2EjSSmSVeSiSs6PsdXlMkKjDFWA3udoYIVLXbZdkMcPlrHJgEEIoyNqIX2s7s0jjDFiSzLgNhhhZ3jMu8rI0bMCvmRg7sbgRjbt2xkg5KKodQVZgcEtJtJ6NpP8eV3Set0vd6eS11SmqblFbSdnJ21tbdpJtN+9t130d5I4sJGqSsrQBTG7q7tlQMBwHAcNkbSVyQFB2k4NhdxVSR8+1BhgNuA247VALqGZuGzuOdjHkAZltLHKskq+akMDmOKQH55XjMYd2T/W+UpDMNzEjLhgwJI0f9bsEbbXyrgqWcqmIyVbb8w3KckE4UKRjHSo2tppqn67O+/Vfgr+SwnGSklrLpKyutlpJRWrsuvW2tki1tDsgZS20gjIGA6ltuckkbcn5TkKMHnOS9IhtdQAMkspOWIDBQu13O4bgAVIGODnaWJLYHV8sjoVb5RuxuONpICNtIYA8Escn5Ru4q4A2wlWQhdoOQyjDEFjx83Q4JXbyQD2Nawhd82rsr9Lq3K79FqnvZrTV290wc2lyvRJx01vG/Lfd9tU/TokQMJV2vGnmAMnmRlihdcrnYW2KFXDHqxBBVTtq60alW6FSyq4AGORgq+FJ3AHByB13ADOABT32qpXCD5dwGFGwtuI3KDggHaMkqcgVIsUm7cXO5SCqnlFCiMndgrvJwOQuCGBc7sY2irWv3V0rPra+raS20b2toYyldczaVtE22neya7N67NPom+l83y30uUzRjNhIw86IZJtmdTtkTldoUOCCoABYgrjBroLVY5UVo2EiSBnDhjjGSFVRyVJC4CE5B5BHOI1VccjeHPlldqsNrgA7wxLlGXKkMPkBJGQOIY7aXTz5kHz2blzLbncWhMnO+MFgSqpjlTlcgN8oBrohCzitLeWtk+V9E10ts9bt72XNVqxlHVpTslfbm0Te1vfWuv2k9rGzHF0bIAUDC4KliAuADjPCjnIHODkFcjTghJVWweAoyR3GAAQSSMnAAIzkDPIDEsooHRXhG5JAfnBbdxhR0GARjBCncD0IOSdmC2U7eG4wckbVOAvvk8LggY4wPvYI64Qvb3d7a2aX2U/TbyTb6NWPHrYjlveSTVn821ddbNLV206K93fPSOQ3cY8slfmwQCST5eQVbhlAKEZ+6vLOOed5YD5LfwZlgJ5C4OyRRwc4AByRuQYUHIPAktrZZLqMbSWVJSOODmIDnccAZwAxGD90/Nyd61sHmRoYk3M0kBVVQ5OVdSCc4xzgjIIxn7vB7KWHlKKXLZyaVnHR6rVOzum0u3dra/LiMSuahyvVQSSWzvJW2v66NdktiKyhYuqneSABuIbD/6vkYzuJByrADkDAwDn9M/2DPgAnx2ufjL4ci8Q6Vomp6d8E/GniPRbLU5WgPiS98N6bc6xc6TaSKUMc0djZXVzLPsmjtIYRcTwSLtibz39l/8AYZ+I/wAeJYfEN+0fgb4bWtyIr3xtr9nefY9QnMkECaP4Ytobc3PiLXL26uLextbOw3A3U6RFiR5Un6t+L/2S/gb+yd4h0Xw54tu7+z8Qajps8q+HtN11L/X9eMsl5oMfh2wubKfTLm31eOyu9R1bx+Jo59H0a30v+w1jub9Wkj/RuF8rrYOrTzHEvD0oeyrQo0cU2qlWVWi6SlyfFGC50lObSc7W0ba6cXChw/l0M6z+o8NhMTTrrBYKN5Zjj2qXLKrg8KlKUqNFyhOpVqKNPk5veb2/Gzwdqb6Z4S1u1hgjW78YXkFg92yyCeHw/pVxLd6hbRiRVCR6prH2KKRlIkMekzwOixyyK/Sadp4kkjXgnAZgAPmOAACSedxyeB82Oa561+zXV5cPYRyx6eJp47CGWQyyRWa3EhtkllAUPMIXDyyBQZHJkwFfdXt3gTQf7R1G3WRR9ng/0i4cgBfLj9Tg4DEBM4w244Azzioc8owVnGDcY8va7k+zabk3fbTyTX4TUj7XG1PZPl+s1uZuSu1G1OClLfl5YQV0tFq9Xc9u+GvhGeX+xtFt4JHvtVuLeSdEUvKxldUtbfbjKlgwO095Bg/Ka/tk/Yk+CMHwO+BHhXQJrZINd1azi1vxA6qok+3X0Syi3c8E/ZomSAgg4KsCOa/no/4Jh/s+j4ufHPT9f1ixabw54L2+INREkeYJbmBwumWbE7lIa4CyFRhgsZHA4r+s2OIRRqqgIqKqqi4wqgbdo9MDAGM45xnAr18VJYTAU8Mny1MTarN9fYwa9nF7t89ROTT25U9nr/M3ijn/APbfE8MvoT58u4fpqnZO8amOqQjeUknZyoUJXT1XNXkt0h0zAKST93Iznkdue5/hA6gHPpmsK7kz1JAwSFHUjIAPBAOB68Etjrki/PJyDyOSDg4J5wfQgZ4zjGeAc9MG6l4bJOACVzkcD+EcHuQcDB45zkY4MNTblG33Xfl301abur36Ws0/xbO8YmpR1SXux83pd3stPx++5nXcuFfBK4ySc8E8YAxk5Hpt56DhiRzVzKxyegIKkZON3GSOx7AdCOTz/Fq3Mq/xNkLz1Gc7hwcknjGfvA9MllJJ5HWNRh02zvL+5dUgtYHlcswAwisQBkEHJHTrjGFOBn6LCUHJwgotyckoprXmdrJd7W1vre5+SZ1i0nL3mnbW2tknHZa632089OvxT+218Y7f4b/DjUrKC6Ed/f2zxqgfa6oysBuAycMQG5JwVx0LA/x9/HDxg+tapqFzNOzvJPLI5Z+d7u7Eklsnn3AYDIwRk/rh/wAFCvjvJ4s8T6jYW97/AKJZtNGsavujGzcFUchcfKxAAAwuRySa/AT4l+IHle4O8He78dwMsOxz93JyxyAQDxW/E+Jhg8JTy+DX7qCnUcd3Vko87b66vlvdLTprb+rvoz8C1KVH+2cTSaxWZ1IVVKSalCgmvZQV12vJ9Lu/p4X4q1L7VdSBZMhJCmBkjAYjPr68nk45BO4V5vcSMCQSdzcgg5A5HODkAZyRzjpjbkVu38u+RuQx4wOOOdzd8njjr74IOBz1wpO4Dk9WAJ2ZPbAJGR1Bz278V+VVFzylLVyeqT0Su4/8G9rdt9X/AKSZLlyjRpQjFcsYRXwa3UYp9Nd+6au9kZMknYY688DHUAtjHJznqOpwe5qoW+bBJII55AJHAIx7AAHr6njAM1wrlWOMAYLA8nG7AwBt4JIGQCw+UdDznMxVQ2C2SAAMZP3SeOCMZxwTgYxxxWEoNJt7p2auuiVrN6Xt09HfWx9NGg6as7rVNLazdtUkuvW97O/La+t1HLMB2AwgznuAOSQTx/eAABzgdTejkYFCclhxnJ4XtwASRk44x8xyTnO3IRwGyerdMbflPHb7oGO3ABIPTirUUgPBIDFhu5GN2QOpxnJIx0Jzk4xW1GdnFq6S0dtdE1d6WbbuvK+y7+pgJ8sk43tdbtXunG3VWaadna93q9de606cuqgkHBIJyMtgg/MOSuRyckbSc5P3q9G0K9kjeM7jlSQCDgnBI7HPHQgE8YBJ6149pszRyKpbCMdoGeN3BGDwBwCo4JIwcgZB9C0qfZKgDdTghjnhSTyPQYwDksWPB4NfaZTieWdOSk04yje2mqlG60e3lbrfdq/6LlVe6humrKS7NcqvbezW7WjSt0P2d/4J8fFt9E8YReHby68q01ZUiRHchVmyxXAJYZOMZHX7xU5Of6BtKuhKkcgbeHVWYht3G0HdwPQc7eccDKjNfx9fBvxZdeFvEulapbzGOS1u4pVKvhhtbcRtBOVI45ZSwzjHNf1R/Ajxza+OvA2h61FOryS2cQnAYuUlWNVkDAZA5yQew4JORX9icG5r/bnC9GM5upicrSw895SdCTjKjKTd7KLTjrpa1vP+qvC/PFWwbwFaac6Em6abTfI+W6V3ey6a9bO63+ndOcfKSDjgseuTgDAx/eAxkHvjJU4qLxz4cs/F3hTV9Eu4llhvrC5tpEZQ3ySxMrewUEk8kbSOCBwGWDqyJzwoDIQcA9Dg7TyOvqucbecZ6iCQMhQ/dYHCkAbQcZHTOCST0xkAnnOMq7dKvCrFNShNO2+isnF7KzTaet357H6/iqFLHYSth5xUoVaUoSTV000lq1ps2rO+nXS5/JZ8evh/f/DT4ja5o00TxSadqEohdlKh7YyM8Ui56o8flnfyvZycZH6s/wDBPf4xLq2iXHgnVJzJHdwmJIpnBAuFRwgIzkLcRFkYj7zBc4INcx/wUu+ECrJp3xD022ADkWGqmNDwQA1vOxAJxxsLNk9AAMZr87/2YfiHc+AfiHp3+kNBbvdwo5DbNuJMCThgreWcOMYyARliQB+ScU5QsDm9VQio4TMKaxFBqKsvaWkrW0ThNSh11i02tT/Jv6WfhdPF5TnGGpUGsbllT+08sqRjaX7lqrFQsru8E4W7prdnun7bXwpbwT8StQ1a1t2TT9Sne5idVwoWZvOjwQMblYuobcu5l3FQRuP6tf8ABH/4uJ8QPhf8T/2X/EF2k9/bQTeMvAkdywLLJGoGo20EbFSAsy2lwUG1QjXeQAxrzb9q3wTa/FX4Y2Ximzhjmuo7CMysi72VigkRxt3YTeAwcg74nY7slgPza/ZI+Leqfs6ftCeA/HkDPDBoviCGy1uEsyLc6LeyPY6laygYOGtpbheR8paNgTtIX46NCdGpzQkqdaTjKnPRcuKoTjVoS6LSrCLlazcHJPR6/wAFcdZauPPCnC5gqbr4zLMLL21OMb1faYWjKhjKPdTrYaVRRb2qSjLorVv2w/hFL8E/2h/FmlW1q1n4e8TXJ8WeH0KFY4YtRlZ9R0+PJwrWGorc2xQ4IAjyAW5/T3/gkd8fbnw5r3iH4UT3rB45YviN4HjeQjF7p4WHxXpcIbAxf6WLe/8AKQbC2m3BCl3Jr0//AIK/fBGx8WeArH4xeEreO8j0eK28caXf26BjeeGPEPkJr0KugJeK0uXttUUc+SknX5mr8PPgN8VNU+FXxC8GfELSJGN54T1uy1J4lYot5phbytTsJQu0tDe2Et1aSKcoyTHORkH18Q6FetCo4R+pZxheeVN2tCdZezxNGaslelWjOLhfSKSerZ+LYSOJ498LK2CdSUuJ+EqqoUMSpP2yzPJeTEZTjqc01OP1zDfV5KqnZurPlvZn+lHoOqad8Q/AdneqEuLXV9LTK5VsiWEAqevKsSrehGCeOP5UP+CzX7OUkFlo/wAUrKxY3Xhi+fwV4ndUJd9F1KWa98L6hMVHKWd+91YF3OA2p2qA8gV+/H7EnxS0zxR4VTSbC+W70u6stP8AEPhmcyK/2nw/r1tHf2bxkFgfJErRSHPyyArgEEVn/t1fAzS/il8PPFWg38Smw8aeH73w/ezGPctlesjTaNqi8Aebp+pxW12rEghooyDgc/h/C1WXB3HGP4fxDcMFjqk40ueyjKE2qlGWt1dwlZ2avOKjq0fsHiJipeKXgjwJ4z4CDlxHwYqeG4lhST9sqMHHAZ3RqKNqi9jiKaxFOLvyUqjn1P8ANl8c6Oba4uBsAALfIuckAkk5HABC9CCwA5OMivnLW7IBn4PQ/KykbW4wQeFwTyO+c85Bx+h/xx8B6p4Q8SeIPDmtWbWmr6Bqup6Lq1u6kGC/0y5mtLuMg5LL5sZKNxvUqyNsO4fD3iexCGQbWPXLY7/LgknkDp90gt2x2+z4hwTo4islF2u2rXSalyuOkk9dejTau1ZM+m8PM9jjsuwWIjUUo1aVOUZptpqfI07pttPdX328n866tB8z8EfMQoXIycqDnk55XGVGOQCD8pPF3cQDMAn3lPJwSRgfe5z3ycjlSQSGxXqmr2gDHPOSecbucAHHzHG4EHk4AOQcjA881G3DBgSw25ywJGGDDaQwySGOAeg+bnJ4PwWIpWv0vru29OVrb9Pnrof0bk+J5owaltGMbNtae7qtHbf8NXpc4u5iAHIwQ4OTwCDjJHAHJ646j0PXHljG8n5iSODk4K/KccsAM4HIGCM5Izg9HdLgnIyuSDywLAgdCRuOAOPmIwMEkZxjzLzyOBzgn7oyvB2japPQgsckbsAAZ8ypTTsnZejSjZcum/WzTWyVtT7zBTvGLva9kktr6eb2W9nva22nOyRugbYc/OG24OFxs3EEtngAjkDsNpFUhES/zMSS3mqRztDbSVOCFHGDkZT5WRcKSTsvHubsxbkKSQoJK5BwMYIx25znByQaoQSLuCsGRjGSwC7mXaSMBf8AVjaQMna/Q8EVyOMW1fsnq0rJW1tzWdrrS70SXkfQ0J6JX1dk1dJu9reW60v5aJXaijVXVSOhyAQW6gLgkAj5FBBGTwApDNjNWEjIUDAYgD5lP3j8p3DDMcZGGGRwDx1y9ISnGCwUAkDdlQAnHIP90kdQpJJwM1bhjwgPJViHCkE7WYLkhVOBITklMED5QPlIC3GOq62S0fXbrrpe/R22vqdsKtraq6Wi3tblSfVNLVX1tZryboLcKzD58tyfmGPlKkDGQBgdCM5PKccVr28JG0kDPAyFGQO3U8seMkjn0yCKiiikA+QLvwpBbOAeDycZ+4c/KduWAJzwNyxtZJpEjjjLFiFXoDwdpdgCwAQDJOcjr3zXfh6d5KKV9rXtfmdna9tNnrrdS11TRnVxcacW3LlSi1ulpps7JNrTbd2uauj6d9okV5FPlRAEHb95ugUDaSc/LuAzgcZ4r+g//gi9+wTF8dfig/xl+JunJb/CP4XSQ69rk+phYdP1C8tc3VhpXnTbY9j+T9r1FmbZb6bEykhpmI/Kb9lz9n7xV8f/AIseDPhd4N0yfUtR1/V7SxhjiQsjPNIFmuJmQFVt7WIPczyPgJBFIzlVIz/TZ/wUe+K/h/8AYI/ZX+H/APwTz/Z6uVf4q/EzRbZPH+qaNu/tWHR9VeK31e7la3BuBqHi7UCdH01AqyR6LDMyLslDt9blWXurUheL05WrK7lK8FZdNLqMd05Oz0vb+fvE3iPM8wxuXcDcMzqT4h4pq/VL0rzll+W1FGOKxs+XWDVPmUJWTbUnH3oRT+HP+Cgf7Taf8FCf2q7rStIu762/ZY/Z2t5rTS10iPdBq8Nlcw6Vdapp9hFtS51nxrrS2vhXwbYqpklt5LdUVcyGT5d/aO8SaxqmsWn7Nnhz7PZ6i2paJrXxri0iYT6dpeuaLZiHwR8G7OaA7JdB+DWiTmLXBGRFqXxFvfEN/Osl1ZWzjrdL+wfslfBv+241tNQ8c2WvyaN4KhZI7iPxT+0Ja2CrrHiOVWZo7zwn+zVpOrRRWYZZrLUPi1rFpAzXD+HbwRfO/gjQtS8L6DDOGuL/AOIvxIu3gsLmd2uL+OC8nMup67czybpjNcTXDzG5J803MiTfvFimLfbYqCwmHp5XRlZuNOpjHB3Sly2VGLVnaKtBPdtTlZ8zPpHhct4ey/LeDcmSlk/DFSLx9dOLhnfFLgp4nEVZJKNWjlTc9WuV46dWUJJ0Io+i/wBnL9n7Vf2j/jL4F+BngyF28H+HNSgl8RalGm+3ub6IeZqmoTuq+VJb6XAJliVyyfa28sFvOhav7FPiH40+Hf7Cv7K+teJorWz0/wAO/DLwilh4e0v5IX1rXzB9m0bTYwgVpZ9Q1V4jcMoaTma4c7YCV+S/+CVX7IFj8Avg/a+Oda09Y/Gvj61hnSaaJRd2GiFmktUBYFkm1Bib2c54V4A24RKD+V//AAXF/avHjb4iaB+zd4T1MTeGfhvM2p+MTbTMbfUvGlzCgisp9jbZIPD1jKyPkkRXd1dK371Fxz0qKq1aWGsnFShKsrbWcVGnstFpo2rPmtrFM/mLPMTi/F/xOyjgnLZ1KmRZbi51MyrQ1hVjSnH69iHJPlvN2wuHbu4zmpJ8srHwD+zJ4d8S/tUftYXnxA8cyy61JBrt/wDFTxxeXAMsdzqcl61xpFjIzblEc2qyWywW52gWNrcKgEaYX9NvGelS/Hf9tr4P/BSKRpPDfw10WLxD4qkyDDZ6341bN5dXDbvKSfQ/AGnXutRM/EPlzOx2sc5v/BOz4TWPwq+AF58RfEyLZal48juvGWrXlwgjksfCOkW90dKWRpCPLgFjHdaowJC/8THIyFAHl3wi8d3mhfBT9tD9sLUma08SfEHTtT8MeAZpQ6XFrqnxVu5fAfhOGwkKh0uPDfw60zxRqjBcGKz1W1uAFV0kP9DZLgqmXZRhsLhoOGYY50oqXKrQxGNnTwmEc+e6jClVr0Oe6laMaknCT0P9w+BuFsNwZwNwtw5RoQw88wdDNMwowioKngMvoU61LDtRS5YU6dPC03HZVJVFbVs81sfGMH7Rn7ePxB+L0iG48MaHrmveK9FgVV8mHw54Nhi8OfDvT0TGxYzb2Xh+GCM7RuP7vbuCn+8j9i/4Zt8H/wBmb4aeGb6IwawfD/8AwkXiEyLtmk1vxI8uvaqbhiATLHc38kDF+cQop4UAfxW/8EiPgi/xK8f+E7SayEsfxB+JOk6XKGjOW8F/D9P+Ep8SucYBtrm5W00+TA2NLFGnyng/3NfHHxjD8Nvg/wCLfEKyLby6doUlpp65Ck393CNPsI1CjqLiaLoMKAS3AzX479KzHyqVuAfDLKvaSlVlQxlTDqXNr7mVZVC7vN6yxqk5S+KnCTV9V1eJUsTUyTgng3DRf1/irN6nEGKopXk1ia0ctyiDSSfs2pYqai9I2i9ND+S3/guJ8eXu/C3ifTbS7Jm+KXj2Hw7bIkvJ8I+B1g1LUZFKk/uJr220C3l42kXsoP3xn+QDxdevdTzIHxGWYtIcHJDD5IySAfUkggjvu4H7L/8ABV/4nv4q+N9v4Pt7nzrH4ceF7TTJgN7/APFReI2bxFrLDGFMosLjQ7KVwQyyWZjdSUIX8RfEdyytIq7duGwMtnlueVPBGRlixIJJXoAP3ipgaHDHAeRZHQ/dexy+jKaaUXyOnCnQ91fC3h4UubrKV72bJ8ScTSo4/D5RhpJ4TIcBhMmw0bpKNPA0o05KyS1nW523ZN31v08v1q5C5ii4yWAQByMDaA3AYdOWIBC+5XI8u1WbduhBTYPmaVWBMpwD975GEKsgKgDDnaWIbG3s9Xlkkd1Rl8uXeSygEkBsKoK7SihlBLEjcMkAgrXn+qBipDHAXkklkUoBg7t27apJAwR8y7up5H89cQVuepU2Su7aLZNK/m9ErLS3Vo/F61nK7eyXLa211e/RWWmqsn6pnM3TkgHAGNp3Mu0YU7erFgqrk9eo+8c5NctcHzg4HNuxaQfKuZ3whDZ+RltxtykZHzlQxG0qK2LtzOvUJbAEgA5a5YEHlcoyWw8vCgkGVgMgLjOaYXnfyxnLA7iciONRjLuMbRGmCARjA9civyrMpp3u7W25bWey9NNrW1b9b8VXlSUpOyvrotbKG6fu2e2t+j32y0jlupDHGMsSeWBCKgIy7M2USNDyzdCOQQwKl006W0D29sVZ3BFzdJgST7t+YIPusLYPknP+sIGQpO1bNzcRRxmytATEcmW4CYe5cbgcBdrLArIMRjDbtrEBsFcY4ZQQ2DgAAkHd90lMENgNuA44YFuATXyWIlzttLtdWV9OS6aSvZp6W72erOGfvyu7JRcUotK7XuJSkvuaS21+VSSZEBUsjMCimMEbuqsucqxAXd1PIVSzggE1TddnzKzeZOVeQkExbcIAFEbMI0R8McDJwdgKHBuNCWkMoYgspWQKAFkGQ25gD8rDCAlcMFAHIO05d1O8kv2O3UGXhnkYBkgQiM7mAUZkOCY4Bt3ckKMgV5dR296Sd7xjBeemkbt69dbLq9LmU7LVpPVWSteTvpZXer37Wv8AOCWSR5ha223zTjfKwDRW8GUxJKoAG8D/AFaDLNjkAZpTpFlGpIuJ5WcHcWmUGUspLSDaZFRdwU7WTcAf9ZjFWbeOGBGjhBYZ/etL80ksowGdySrEsxOGOBGAFx8uA9WDLuVuQQCC5bllUHJHGMEhSCRg4PTBwlSjN81RNza92KbSgtL8vLu9E+Zve9uqWDpxm1KTd2mlHm5UlFp2+HS/Vv0aVnbN/sy1IxvudykMcTg7c9WO4KcZxgHIIBOO1R/2TaZZjJcbMMVxc44O0BmORyd3ReWJBySQp1dnLA5wcqxI78Z6jgjpwB329CTDjcGGWGJMYJAy4wBkAK20kfKo5yRgZ+YZewpp6RV018V9UuVdGrO7e1vJO6s3QgpJcrtpo23K146rW1lta976201oHSLUliZLwZG4Zuhg4JGf9rOR1B3bdoUHGWNotqcZkvMEg83ByByMkHncAFxyCCMgE5rVyCDkYC5x1G8ArtwTz1AAGAANobBAajBA+bghcgLuIY5G3byRkdevPJXAwKl0KctJU42ut+nvb2cpdLaJPfXdIFRprePVaXfRR82tbO1r6bdDI/sWDcfmu0QICshuEO9jtBCqOVHytlj9/d0BXKo2i22GHm3Qwc/LJnA3fMQFDNg/KQQCcYHPGdgHGVYY3dzkZHVjnPAByMnp0b2RskkDcCuDldx3Y2tyTx97ABLZIGOpBqHh4JaRve2rT0Vou3m1d7LS2rsCpRslGKb6S95ppct9mu7tHyd7XZiro9qUDq16pOAoecqxwFydp5IGMgHgqMkA9EOg2RG5ZLpS2Sv7xenGAc46lc4J2kY46Y292dy4OVPTaxBAKjgZz7dgmCOeBTQWVSMFlJGWAB/ukjluMYJ9MEHsQZVCls4pvzT6crXLr028ujeib9lT25bu1r+8ktr93r5X2d22Yg0O0PzebdY3HcxmUDLdunJ9T/d5w5ANNGh2bMMz3Y54xMMEZIA4XjJ2kngYGRzWyc5O4jGQFGBkLgZLEEZOQeV4x8wNN3bcFhtAGDkkgD5cDgYBOMHgYBzyBmo+r0bpqEel2kr6uKtq99L67aISpwsnyJd29bppar3ttNW+2y65g0S1CsizXWTvIIkG1QSCD8vDbiqnBY7j93JGaBoVrtDPLdMCx+YzDA4AzjALEBhkg84zzmtXDMFXGBncOTgBgDztIUgjBbAw2MZVwKVcKThm3MCvG7r8uADgL/dIU8hTluWwH7Ck7fu49Hrvb3dfz7fkWqUHZ8qV1e7fR2tfVXsutrt3W92ZL6Falzi4uQzEcNMpJTgAE4wcjCgEc8AjnbTDpVhFjc9xkqI1zIgKsw+XAAGO3IwF9wK1ZJFRDuP3VOCCdznrtAIJIByxGOcZ+UAk5ayrLKkbFkYEMH3BQThcHIJGAGKpt+VwAD82KlUaKa/dxb001393Z316tdL6bFqjSWloqTfZ30Sd/wA3prprqrCHRbduBNc5XcxKuCdpB6HlS3z5IQ7mXJUKeRPFoNu7Jm7uRudRnfEQQSATzwV/uhuG5H3iuXRShC0QVwGcudxbhGCgsQf9s43AEBSxC9a1YCoMTHdwVZPmwCoIJHA6EHCtyo6YzjBLD0ZJ/u1dXbipX26O72emmqs3oi3h6Seis9pLXR2jdfJb6PS9m9DRi8R6WCQsszMEYgfY5z12klh5bHK9CcqCOBgkmm/8JBpTFSLh8feLC1nJP3SWyYzhuo3AAA8DJBJ0VWNcvtJBO3ABByCCcbExzwSrDAADElejY49iFid5+d8qsYJBIwhPAKKqhOVCMQMAYDDnSq7qUf8AwFu1rWt7yvra60t0Pyf/AGLrSrp7K9aOrdr7Uelkr7epmf21pD/MLmRiGXBW0uTwpGN+YmYgEFflzkYJUtgBTqulqUl8+VSsZWNXtrlUCs4xlREvr8jFmYBTlj8oGjCrlFLoVZiFMYKsI92FByoVjIQhGfvZOeRg1YNsjqA3LYU5GSo2k7VIAI4LDjJGMMGJzl2m7vmhdJOzg3a6j3b1tZdH6JKyc8JB8vs6/LezarRellHl0pLTzfotjHOvaOMlbtwR8oYWlzuwB1OYWBZQMe+FyCuRUZ17RQrbbohizSKPs10MSED5iGUKcBhlNuDtAHAzWz5YBb5eRxk8g5K884zuO4LkBSSEOWAy57dD5LBULKCwDBewQglcKoI4KclwARtIFJxqJJuUOibaduV8t/tKz1S6fJbuNTCK16eIWzuq0LdGrWpbfkYya1pMSJ5d1JJEzhnSS3upGDlod8uSqZIK5VBg7iBggVc0llhsI5I0fBvJplR/3YEMtzcPGdq4IyMsW2lcLnGEwLXmIpYHBRRgndGWB2jBXI6KxJznIbCjBGDXmfIZWVyCzRqMhQEm3gO2dyZBLHBRQuMkbiKzV4u7lF2TUYpPRXhprzaNedlra2iNHOlOHs6cKijUnCUnOpGekE0toU2rczdrv5N2efdarHa3N2lybhY2aGWKeOCWSNo/s6hlDKpVWjkUhR5YVcPltxcGrHrujKoh8+QbwdokhnQIzlWOCwVFXezfKdu0kvudmbdt20KWkSW8bzMiswZ5CGbY775cksy4EzEggfKoG5eWNTTW1vOrwTxxTRMCpWVY9wU7SCjKpeNwFyjIwJHzIcVSpTkuaEoxvryuLers0rp9O6XTa2harYVNU50qvKlGHNCooKSUYR53Bwk1Jxs2nNq60dpO1RlUm3aQMvllJELyERhiW+R2VdpLFtyjeUbBAHJYzErjd91QFw7YzKGK7VVnY9T8ijneowMcVkeU9jLBa3JSbT2mDwX8xBliZEZo7G7eQkIy7SIZCCWzz82d126ikaMGJ3DxsgjOJCWCsS28qVcKNitheCcMxYkClGUouSsk1a6bSkn7r22aTej7X261UpQTpxU04TTcJpS5LXWklf3Xf4ktn2ZPKpLIFUsdjck7huZSQqksoG7OVQHGRyVZTl7jdGpVmBymWO8hlwCxK84HAOTw4VsscqxTymVFRisjKyFmx88hAUHOckq3A3hQCvUqStRbGt4CN+9myI2Kk4ygKqc7tsabSHDJwM7ioyaet3KTS5rX/mSbT1St5bWv088Y2naKabjJrS2qbV220rO2t3fRWuncVJlkZ2gOULFmJQoJHVldPKygdsMeWDDaF2n5FGEQIqS7pt0lyWZ+WIO7yxFEyBgFCFthyE3E5QDZuphkljiVniDNEBvEEgCg7hBsAG7a5AU7l+U7sk7cEQyTtDbSTLE8vllJfLUIPMlbYpVXVHUoAcOuRtGG6gEJNRV5NO0U9m9Ha/e7tfS7fVp3NeVyfJFe7JpJc123dWvrqr62a7N7F9ZlLMpU5jTyTGBG7j7sbMD1KqTtG9hkIQ5bLZqqbi33uVX7MS0klvGGDJCN5+0RCRvlbLBWCcOFBIDZ2y28wntopCDGzqHVCQCrBAWjJTLcbVO4nDrksQCrF5kRtyHzAUzCVQhV5ABflizBWO0qwGxcb1ZWUrTjzKLvaW6bSW7jyru766JXs9VprpRqKlKdOUOem3y1Kcne1mryi1s77WSaslraxYRo3SNo3VopEBTGGDEZCnaBgD5SGzkqMrkKTgaLepypBRgpUgfMB1AyzZySMYxuGVG1sGqZb7JLFImTFIu2aKNXckKmWuYs5Xeu7EiqNoBwqgAVeD+YCVIeNiWTaRgg8jG3jnG5hnHfjHGik37raT63vdttcrinotdVulo763Ma1GMFGpC8qUmuWTXwvS8amj1Wtv5ls3YxL+0a4kjeNJI7qB1Nndggq5w5WF1Xy2kt3kVtxfG0NuyPmV5YL6HAWcpHcD/RZ4mChlnZjuJCu/7hmLMkgH3htBywDabht8Yy+ACSwGVTO0EAyHGHIOCCN3odpBoXNksksc0JK3CpJiTLPtLBwsUmGUFA0i4bkoDlMMuRnKLUnODV29dH71uV3XVtarySStqjWlVjOMaNVuMUv3ck78rfdvaN7PX4fiVndKaaCFwwZVJjRZPMGVwVDMhRo+GRCxAVcDjAYDJot7hHKxllWRl8wx7k8zZhFViQZTIrkqGUZYsCpyc4oQXgaM/axHb3cbxwywrs3IsxbMqjecwS5OXHzLt4yG3DQuQsFs9zHH58qKqRJjeZtzKTsKqpATJ4WWMbQVGRhWFJPVbe65K2utml8PM2l06P5oJU5QtTqJu7apu94vazvd+7JO1010ZYaZEiaU5WOONi5dlwNiq4bO0tndjblc5ypAPNZk0Et1DAYpZhIJluTe5ZVQCMNsWDzISEO8x7MEKSzfOu6rifvJSrqR5ah42ZYwuW/drGcM4YoucJuYN/suildCLnccZ2ggMefkwuCD3I4C7U/iAPOaaXOlfay11Turaq7drPTW7W9yIz9hLmim573upK1kkuW/n72q802lfLiXyVaArGHTY8yR7Am1QFeaJnZmw7LkoOVPOQDkTvbi4SRAgktpFI2kAiUbVBH7sYDKPukMDu2gsy4Ilu7SRUXUL7UDpNlaIxGyMy3MrllxkBI/LiuAAixOHyxdliOCRysms6iZlbTNOuLqwVjteW1kaSVQ4xtMShFUAKyLufAbac4GW5Km+Wa0slpZyadkm4p3Sdvit+OprGhUxXLVo25k4ylJu0Iy092MnZOT0dk211sO33OiyxxOJLiwkcNGX+cgck+UJHIS5QY+UqVljjDqilZFPRRNbSI08MzSx3K+exBdlGxN7LEqDaCoVA8eWzgqMAginHNbavbyQyI5Y4aezkRop7chUKuy43go2TFKCeFIZhgYqW9ncaeJ42kkuLVmLbEj3u6fMXLwZXyJx5bHzkDxTEksqMS1JOVO3LJypSV4u6vCV1o3bVa7vW++t3K6jjUjaolSxUHFzjayqwXLr2baV99U77baMVz/osbT5Xzn8oRPtj2MBsjCDe5QPsJUuGKgZLDvJcxXEqKY3xJG6mEfvNjhOX3PGQZAwCMpAIcAqAwcVFJqFpuUyWt7OPKEag2YXa3KIULbf3igsFI5XO5SOcQR36bpZEsdSIkBDbwJli+WNcpuz+8CbeSc5wMbcCnzR+GTTi47rmvf3U9lby8k1rexzuE/jjTSad1F8q0clpdyT0T63WmiTtbYcH92MBkVw0m5QVaIgfdYurbFZN2Axz8gyRkiwrYUlmXAUcnoUAUs+7BUKAd2c/KSeMsprGbWLTaqGG6ym1XBtsA8ZZXQE89N2GOcDYvLbaNzqEV29r/o93HDA7NOpiKmVNhjVUbGVEe5iGf5jlQQWC4v2kU9Hdtq6Wu7jr5K97Xe+3Ux9jVqNKcXBbuUktftWTd07vSLbsnZ6XOjQC8QCNwbeZX3gAs0hORGY8xhVRvLdum5lUYZeo1EtIw8kyqRLMq+aXZ5DIIiQmN5AG3bFzx90liAwB5+21a2hWOJba+AjCqAtupUBeMBWOF5+8qgAttbaGOBpLr1oPmNvfZYYB+yrxkDj7/wAxwDnPzHPzDaeN6biviau7W1eisklr+G91o7K6eFSNZOShCfJtZtt2ut3s3preyS2Vi+8cjqQJRCMAtIBu+VSCCUAJU7AGZgwAwBk5BqxbOJljmjG6NkYoR92QptVmUsS6puDYL5ZuMBgCKpR6zaABVtLxwWAZTAoBYgKUILZCkZG3g8gL0yr49WhAKCyukSMosYEaBV+VRtC4wGY87AVyew79EFG6kpWSsnZbWavJJRtqurSd7dteZqahZJp3vd8tktL9LX7aWt6O2vBChjDiNgzgBg7YcZCABiowqhgME4wMZHGKlEeURUIdMqMgb1aMlSyhlHIzjLeYQpK4yM4ojUEmDq1rdFWwpQpwUZdpDEKDzwAAR6jn5W0La4tUVIo7O4jjC8KIjtQAEtgHjB6lsctyMHgdFNdItNb3s09l539Hpo2nre/JObjq+a97qN04qPuvRJp3T7+7fR2aSNCGLGMAADH8Kk/eUgAAHBHUDPGA2ccDVihGflGNyjPQjB2hsg5JTGRyRuZieVHGfBdw70ja3uU2/KXcIuPu5DbSMd855B7ckV0VpCsvboVYc5DfdwVwP4h04APQnIIHXTg3Zq2mknptu7vVttq7ST1e6dzxsTiFF3k7Ppfbok76qzau/NeRBbW/2WUugzbFz50IYnyWyGMihv4QFwTjALBehDV21hbCRUcYZWUMNo5Pfd8o+UgkZGcKSeuTmtZ2OWVgq/MjbkJ2qF5GXGBgFWOQTgA4O4EV1Ol2DwXMUaAm2mYDZjiJiy/cCuR/shdpLAlcEjNelhsOpTjFq17NJ6tX5elk7rslvqne9vlcfmDV0m1JWVrX5vJrTXX5q133safoE9zdQpHCzvJuQYQkEsioFBAY8khQAGaUkRrkksv77/sT/wDBLbQLD4Z3n7Vf7Xd23g74Z6FZjXtE8FavHdaY/ie1hR3h1LxJqIt5V0fQ3eOOO0tlhm1DWZpVsLCC4uJRGfRP+COX/BPzwT8TvEN5+0N+0Q+n+Hfhf8OI5tU8NWfjC3u7Lw34p8QaLbzajez6leskVsdH8Pw2ZkvUknCy3kclttP2d1a7/wAFDv2rdc/bn+IFz4J+DWnXVh+zv4G1rSPC+nW2jJqlvc/G74ktHPFpVjp9lcG7MWi2Nlaz6jY2O2KLR/DcH9p3phutVsIpP0HJcuo4epBzw9StiPZxq0o+zvCM5crpL3rKbk1KUnDn5Fo0pShI6cn4iynKqn1rF1cNi8ww0JYqeGnKE8NleFo2nOvj3z2p15xi3RozsoQTqzXuyiviz9uD9tm++M15pfhj4LWt58NfhX4SjhudAsPDbah4ZgVLK6k/si5t9Ltru4tdEtrGS5a3s2SWXUdR3R3k8i3MtvHZfDmk+JvHPibW9e+IfjHxZ4l8Ua3o2g3Om2esa7qt5q1y154gSbw/p8KXGoS3BSG0stR1a7tIQFVFtTKjh8Gv1V+LXhv4ZfsU/s3XHge50bQfiD+0p8cfDN3BdSX2n2mo6Z4B8NavHHaT+IILS7sDJZ3MMS3WheCYbPybq9uzqXiaeUadHplofzh1nwrP4U8BeErWe2uIrrxdrWq664uFCST6V4YiTw3pdwsQ3usM2s3PiiPBdQJbFkMW+Pnpx2AxixNXF4uvOpWp0/aVYRcuTDVHJRo4e/M1zU24ycFrBLl5V0/Oo+IVTjjCY7NpRxf9m1swq4DKcVi3y08yw9CK9vi8HRk+eGDl7OcKU5Riq8Y+0V1KLfN6FY+WIgqj7iqVC5wABzhSBzwBgEjAzkE7fsn4ZeGJF0+2VIna71uaNUTY3miDdhUx1Actu902lcAAV88+CtAm1fULG1VDsZ1eVgMbIY1zIxGDjaqnljgE4wNwJ/Zj9gD4CS/Gn43+GtMktJH8N6DLHqmrMEBgi0/T2RjGxDAZuJFSEBsZZmPQkB5ThvaVV7V8sIp1Jy0soQSlN+iir9Omt9vjeK+IKXDXDmZ57UknVjSlQwdL4ZVMTW5acIQTs3KUpxitXrLTZs/oK/4Jy/AKH4NfA7Sr++tBb+JPGyRa1fs6BZorJo/+JfbSH5WAEJMxHHMw+UdK/QZ5No5IGVLZznBOV68Y25IU5AJ9DzVXTrK202ztrK1iEUFrbxW8McahUiihjCRooAGAqrgeg4zgUXLqAMge2c85GAP/AB3kdRnBOcGuXF13i8VKrrGN1GnFpWjTh7kIrXpFK7S1b5rJs/j2UqscNOvip8+KxU6mKxFVu/NiK8lUqNNq9oybhFX0hFJ7GddyMSV3cscDpgDkHcO3XHAz09OMC6lJyCcluW64xuABOOR0A4zyT0Ga0rmQbmGckk9AAcDJO3sB0AHJJyT0Irnbp/vFcgdcHnAySMYIOPcYAY4UEnB7MLStbSy06W1uraWWumt+t+u35znGJu5e809Ot7N2uvO6vqr2S113ybub74Y+vBIwpYYbHrkDIIGcEAE9D8Yftg/FWD4efDfUo1ulhvb62lRAr7WClSDwuOBnuDyvGCc19e391HbxSzzMEjhjeRn42gKCTvIyVCgHIIOOoBHNfznf8FFfjufEPiW90SyvAbPT2lh2q4KFkDLggDlsKSOD0Y84AH12W040ozxdRLkw0E4tpWdVpJXUukU230VvQ+TyHKavFPEeCy2muanKtGribJ2jRg4Nxvo/3jtFK93eSsz8ffj746n1jVtTuJZ2kkuZpnZmcljlnJLc/MWOOV4ycHnFfnN4w1Nri6cI2QrMMnJBOTwOn3T0PLfeJ3AnHv8A8TPEX2me8lZyxy4HJZcszEEZBBHoeAeM8gsPk3VLh2ldiclix6jIbO7JGDjIODnHII9RX51nuOni8VUlz3TleWq9fuevp2P9Y/CrhmnlmV4WMKXLyUqcIxSSivditOVWsu7d3t0RhXJBcsGxgYOWx3XPQHoeO+OeRggweVlGfaQCCB05AxzluD2BIIGCW4IGXfMZOc/KcADgAcYB5z33D14JbqBoxxqEPuVzjPQAfN0B6lTwR6kEEAeZh6PNG7s1LdyV72s+vmk7rfVJtWP6m4fy68abadkne99F7renxdtt9vTkLxP3bNuK7eB6jHr/ALI+h45Ydxjhg4IVcAAbtwxkkqSAD1x15GONucjB6jVo9sblMHg55HGVLEjHAOR0J+XggkKQOStyrMScfL1BAHHyggZBIA4OCAeDuOCSPPxUeSajZ3fS1tFytd91tfrborDz6ksK4ySsnGza1Ta5V2sna1rpbbWEYMuQCS2ACCTyuVz/ALWPYj0JA4JmiI25xnJBLEAZwRjg87sdT/DjPTFOkIOQMb84HGSc7e2Qc4wMBixOSCwFVl3KeGJx8pzkgjjoOMZ6qTnPAHOc80JuMo8zV3runp7tldcydumt7pq0jzMBiLyUnLV9LNX0jbTVtNO11s2+htW8hR8dMHIHPJ+U9c89ASQy8fN3yvfaXPu2MO+CecEYBBHB9CNvqQSN2AR5vAS3qM4IPHU7eeo9CenfHDcV1uj3LBguT0IBIA5JAzwV4/DkcA7sCvpMsr2lFOXZJ9LpLW7W76t9dbPU+7yrENSUb2U4xaWu/u+7o1rbVWtZ76o978MXhhnhkUk5IBGeOmcMMqBwBzuBDegUY/e3/gnx8VkmtpfB95cgbkSazWSQkbwMSoBkgO2ASB945xkHB/ns0W5YbQTjBAUg9yfqMcg9s89cmvub9mX4lXHgrxnouppOypb3kLOCx2tGXKyIcEY3KWUcAcMpAJGP6P8ACbPY4XMVga1Tlw+Ph9Xqcz0Uny+zk+nuzS3+SSP2fgfNnl+ZYaXPZcyhPWzavFNPTpfVS0vsf1c6bcExgg/LhSvTPXkjsVJ4IBxlcD5lOestLjOBnlwBxnGDgAFfx+YhgeTyVFeNeAfElt4i0LTNWtpBLDe2kFwhVtwxIgJByTkqSQGyeeqg5z6nayD5QRgE5bP4EnrnjqSMkfRjn9czXCOlUqQkrOErrvok/ub3a0stFY/rjL60K1Gm1JWnFNNbWai79er0snZ6a9fN/j98O7T4kfDnxFoM8Ile7sJxASoZo7hEZoJF6gDeMqQSQxJyQcD+WfxRo+oeBPGd3Z3UbW95peoy28y7WUh4JiCRxuG5RkbgBgKcbcGv7AEjS6gkiIDq6MrBgB1BB9QCv3SDkYXpyFH8/wD/AMFDvgyfDHj4eK9PtfKsPESM8rIuI1vogNx3YG0ujA4wCTk8HJr43iPBQzLJZyjH/a8par02vjlhqjgpx0u2oTtOPaLlpd3X4J48cI080ytZnCkpyhGVDEWinzUqiSXMtmk7q6T+LpbX7f8A2UPHVp8U/g/c6BqBW5nsbKS0nichpNnlyKXKl87ZFAVl4YNGGI5bP5o/tHfDiX4e+PbyPy2FnqDNdWcoBEckUp3RMGCEMyFljl+9hwzIxySOh/YS+K7eDviFaaHf3LLYaoyWcqP/AKkMXAjZlYqF2sSpJ2lcBlOd1ff/AO2P8JYfFXgzVNQsLaNtX8P2o8QWPlxtvutGumU3qKQPMYWbN5o4Uqh4ztwfyqNFYqMoxi+edN14K2rqU+XnimtW7J28tz/JDLeF/wCweK+LuDZwj9Ux8K2dZXRnH3ZJv/aKUE9G2nO0Y2dor0f2X+yJ48039qz9ha98FeJAuqeJfhBbXfhXV7SZvNur/wAKXlhLbnzQf3jJNprzEO7EG509duAm4fzN/EHwRqXwe+K3i74c6ssgfw7rNzZWssgAN1pFwwuNLuwTkFLmylic4woYkZyM1+kn/BK/45/8Kg/aUs/B+vXIi8I/Fa3fwdrUFy+LVb+7Eh0e4lXdsG28ZbZmI4juJOmHU9X/AMFdv2epPBfjvS/iZptmVjt7qPwvr0qpkSafcs974U1KTaGOFja50x5DkefDGmQygHmpXqYTE4dfxMNKWZ4dNttxm4Usyow0VmqvssU+iVWe25/HuFoS8OPF3H5DiP3WS8XQjg8OpLlpwxcFUr5RNpvlV6SxeVpJc0vq9Hmvofov/wAEdf2jJbzwbpvhzUb3OrfCPVYdCukkkYyXXgPxPPc3OkTkEhnTRtVS7tC+3EULWqcJsB/qB8X6Ra+NvBV7ZLtkF7YloXXB2yeV5iMpBONrfMuDzgdwcf57f/BPv41r8Ifj94P1HVLxrfwx4vVvAPjAFwIUsdaMcemahN/BjStYSwvBIQCkUcoGN4Nf3u/s5eLj4j8EQ6VeyiTUtD3aXegtlnFv+7gm5JyJrfy5A3TJOCcV+SeKGAmqeVcT4ROOIwdSnRxE4p8y5JRnSm7K75Z3i23r7SK7I/X/AAQng8n43498H83UHw74hZfi89yfD1GlRWMr05YbOcHSUny89SLWIjCMbRhTc1re/wDGZ/wVx+Ak3hP4tv8AEOz077NpXxBtrhdUVIgsUHjTw6sVhq4kwFUPqlgNP1MEnfNK99KAcPj+e/xppjRSTKFwFZtx2rjqABnHoOuPcc9P9Ab/AIKofs3RfEn4Z+O9N0/TxNq32NvG3hLZGHkPiLw9FI93ZQY+bdq+ktd2OwD557iI8kDH8KPxI8PtBc3AMe0KzcbSOrZEbcggqeCOTgcHdlR9z9Zo5/w5l2bUWpSqYenTraXcakIU002t2ndXbbvHTXU/NvD547g7ibiDw/zWTjjOFs3xGBo82jrZc6rqZfiYp/8ALuphnBR6WinvofEOt2ZO9FJVsjDp98DgfKxBAA29Byc8kEk15Zq1m7FkR3iRciSb7zCRQv7mPKANKMDzCM7c85fgfQPiK0xJKgXbt+d3G1mRW6hAQB5i8E/eWPDFsYCjx/Wbbdt2Ivlo5zGxbaqgEEgFjmTCnLEghuHJRjj4DG0Wm21pdLdrt53Vt76a9nc/sLh3GqoqdpWbUXu7X0s3+FrXV7vZHkV/psjElLu6j28AlwQUG5dzDKHJAVjgkbgRt3Ekc5dadMq+a+pXIRCCXVS4Kk4JGx3JbDIQvJO0BsYJr0i9hC7mztRcs+4EAAAbidoYhQedowcZ4rkZXhZXMcLqZG2l5CoIjZY8tDGrRtGrN8waQtgKw28Ar4NajfRNp30V20m3FdOu1+npZ3/VMDWjKMXyt6xt5X5b67a38u19DkJbIopdtRvgBhmxE2WR24ZFBLlRxjCkAqQdoIqGO2kkxIt1fgBSG3KqsdqphgjYYp83Dbcg4AJGAOkZXAwJ3XLBTvVmKoVUkFt7rnA2jZ0yGAx0asOGOXOF6cOM8rtHLELjngY7KuGGK4lTd93Zab3eySt71nvbrs2rtWf0FOyV7PZP4mt0tru/k+u77ox0sZhgfbLvbt3cjLEsTtXOepJI2qcMBtDBuBch06ZwB9ru1IcIpCfLgEKCRvz1Ug9QAAGw2a1I4FLBixUk4B8uU/KWBJ2g5Iyc8YyCM84rWhtV4AkUbQM5jYg8oACcgsWJ5OcsBhSGODvToqTW/e9+nu7dOu2nV+8rJ7OSvZptadejt/eV9Lrd6bGbb6e3yq+pXKkY3fu2bG1kBxhvmyWIIG1WIwAG259Q8K6Fd+bBCks093fukcSspDLHIAo+UbdrNk7id25c4UFSKxtI0v7RMkrnMcY3dG2liRgYYAlchSVyQCcDFfud/wAEiP2BLr9qP4y2njDxlYTQ/CT4dSQa54vv7hTDb3Kxt5tlocMzr5YutTaMC4wcWtgJ3KqzjZ72XYSUppqLvsr9PhV3vte3xXbvfsfFcZcU5fwxlGNzTHVVChhKMp8rk3OrNJKlRpRbvKpUk1BR1u2tldn6q/8ABOH4OfDz/gnJ+x74y/b++P1nDZ+K9W8N3Ufwz0S/VItSe1vRJFpkNhFKFddW8VXeEhdF8yDS0kuWURfMfyW+Heo/ED9pT4xeO/2sPirrkWkeLPGU3inxHpHiXV4hc6L8K/Bnh+BP+Ew+Kc1vOCjaL8JPDt1YaN4M0uMCTxN8SdZ8M6Fp4mluplb6M/4Ka/tRf8Nv/tMWnwC+HerLo37Mn7OUd1De3enLIdAll8LQJb+I/FAtbZSlzDp0duPD3hezjWSW+uTbxWccl1fxxP8ALn7SXii98KaPYfsreDrF9M8XeKm8MXfxo0y1eNm8G6DoiNqXww/Z6a4tmkV5PBcd9cePPi5LHKIdS+KuuXlldJKnhPTNv6LgsPDLcI8XVj++k406FPS0qjSSktE/3b5oqy96pKpNaRVvzLgTCZjlmExXHWauVLjnj2FWjkEKkE3w5w3GMJV8x5J603SounCk5cntMTKhB2mqjPJtR8RWXx1+I1x4zaxu/DHwa+GOiReHvh54fvrh7lvDXgDRpZ57GDULliTe+KvFl7Ne+LPG+p4+0614n1zUZ5CRd28Vfp9/wTC/Zb1D9p/42j4meKtLlh8B+GWiuxbzRlbeDRrOR00zSYiFCCbVJomWcxn54Y76XPlTpX5+eD/hre+L9f8AC3wI8GxT3kKX9hN4wuLJGM2o6tPcQi30lGXJZ45ZAZ423qlw0QYZspM/24/sf/s76L+zh8GPDXguytbeLWZrK2v/ABJcwqq+fqssCKLf7ufs2nxBLSBCchIWY5eVycZzlGE8TWblVqTbW75qrtfmT3UNbp215VZJs+I8V+NKfCfD31DLaso4/MKUsLgVz81ajhpKH1jH1JtuSr13NzdSTc5TmpO757x/tY/HPQ/2Xv2fvGPxGYWlvqGl6SdA8FaczJGl14ivYmt9NhhhAAMVgqteT7FKrb2r4wu3d/Dn4F8OeIv2lvj1pWn6hdXWqan4/wDGM0+talMzyzjT5bmTVfEWrzux3Bks47qYFjguI4c/dB/Vv/gtV+1oPiV8U7T4KeD9T+0+FfhxNcaZdvZz+Zbaj4sugi63c/JlZF0xFTSYmydswvChYtuPD/8ABLb4ORyzeLfi/qFtmOyiHgnwtK0fDzSCK78R3tu5BwUIsbBJFxjN7HkncT9lwdkzxmNoe2i3ThJYrEXvpCPK6dJyu2r6Jq9rzbe6P2/6CnhHUx+Lw/EGbYaU6ub1qeKnOrBuVPK8M1WipSa5k8VPVtvVzpp7K31p+2V4jX4dfs2t8PfCoXT9Y+I954b+DvhGztj5bwWGrz29hqjRbfuxWugQXcDvgqvnR7sK24fGn7YVxb/DX9mT9mn4DaSfKuvF0Gq/HTxBaxAKz6ZqdsngP4UQyRKwcl/BujXWqrHI2BdX8jp8pzXu/wAe7W/+On7ZXw1+DOiXDG0+Hmn6bZl4GyLbx78U9QsdD0+6wuUFx4c0K4/4SBguXt4dNuJm+SKQj5z+N2saR+0T+39c6ZoYj/4V14J1vTvBmgpG2+zsfhv8GdNXRwIdwKLaz23hzVLwNzHI2qISd022v6H4dw6x3ENCc7PDZbQr46o0nJKpGP1TDwqLSMVOeJxVek3vPL248zjJx/1cTlnfE+Mo0bOnGtgeGMCkrL21atTq42UF05U403yrSyTWiT/od/4IffApdB1m412e0VYvhL8ONF8MiR0AV/Gvj5m8VeKpEfB/0myhW10+RuJFgdEbIIr9JP8Ago58S7Lw34Q0DwzdXq22nt/afirxE28KkGieHbKe4eSYE4WIYnuFJyu+0LYJTA6D/gmT8NG8CfswaF4mv4BDrXxS1PVfiHqgZCr+RrcwOiw4bJKQ6HbaaEVmwqswHVRX4v8A/BbX4+HTfCXxcFnfbJtbk074PeHhHJhiuoiW48VSRBSX+TSLXXYHdQADPArffGf5Swd/E76TGZYxWrZdw5iJYTDvncqcVlfLl8KlOWzTx9SvjoqCSspSW1359Crh8/8AG3PM0UY1Mm8PMrrUMIm06alkmHWX4aEH8KlVzOpVxNJK15Jy3bv/ACH/AB68e3vxG8e+NvHN8/8ApfirxJrniF1ZfMeCLU72e4trckbCEtLR4rSJSHISELuAXFfF3iJpLgyKZWWN93CIIxuBC5YkhlAKgEKcKOnXdXtvi6+DtMCeiuygI5BXPAwCMZGeTgHrg4FeCaxMu5mz/EeGADL9xi2MyN8pHAwCMjJIK5/pHxBxd8RUowsqdCEKUIr3YxjBQiopKySSSSS06o/LOJMVPE43EVqknKpVqzqTlu+ec1Jy1s1rd62XmecanHCgZnkKxoDG7EsFCggbjksCTj7mck9CCTnzW/IuRJlitojkIGwHmKhQrMMIyw7lB8vGX3f3V+XuNbmaaRkjXbDG+9kYhvNdflDyKMEgYYqg6cqRzxxlyskz4T5cBSdwIQL8oy43FRtU4Ck4AzgE9P5qzytrNSvbmV10d9H11SSvbrfW+p8TVkrtuTu2tdlbS3Vq+6V3fbTS5zs8LP5aopK5OCcgBQVAyfuKgUjPAG0BiRWLdTMFaC2KCLIMjjO+4KjJXorCDOQFJALY3EDldvUJvkaCDGzgSS4Iec5ICqRjbCrICByHblmDAKOck3sxKsdvICYG1WAG4FshiOCgAO4jAOckV+ZZhUc5S3eve9tm7q9mtnp01WjPOqyk3s0kk7P1Su1pZ3s0kvuZSlYkgZHygjgLkYCYZtpUBlB+YrtYg/LkMHFKRsyMGB25AQAYBUBShIBIzkjbkYxycN1sSqVO5csCQrjDEDBABABAzuGQRyuVABbKHJuZmlc2toF80YM8zKCLeLgMz4T/AFmfuLnkgE7iOfn68ox96yveyXnaDsrOze1uz162XPJqPvaX00Wqu0rJrutNLtaau+qgubiSVjZ2oVpnwJJiN0drH8o82UYBL8DbGBvcjJGQcxxQRwW/kx5ck75JXO55idzGaQngkgELz8vAw4yamRYYo5be28wCNdzSMQzz3BYqspztcxkjGCQmQVwSvAxZvvFdyjOQOPUgBnzySzFiAXUkEBsE+Y1zT5pWvpZ9I2a6a363ejs0tjKEW23LVWsl7rt8Kas1vdtN3u1bW9yu2CxBJCuCuSwJOeNrZBA6kEZIwQBggGohAkYGxCm0s0YVmVBls/cJ7tggAc7Rk/MzGc4bgdQ2QAM4O4HAOD1OMrkjAwRxkoeh4Iy2epx/Dnk8deQwK5wGPFKUb2el9OXTVaxd72bafRLeyaTaLaTavZvRbK+nLq3bmS7XtrtptAQPNBJcEJtUMW2jEmVJQvlmzggKzYxjHDUbVJAOC3JUgkDIxxySfqCDyPXJErDgBgGIO7HOf4cjAGOAc8N/EMcHiM4jHmMcY+5H/FKcDakSEEbsA9yANxZto3DnbUfisvtN2S10V0tXr83rdX1aiUuRatJNXestU+W1t0r2kmraXSV0mOLJEplkIRVwCzEjJO3CAkZZyeFXknoMlSRky6he4QQabJIsmGikLMu6PgguvlEh3VWYgMNqqpHDfM+CKa/YzXIAs9wMERQjJU4KISpyGWMNNJsRn2mOIi3DtLpNgnjZtK4UAbVz9EOAoJAIyB/ED0rjblVTs3CKaakknezirtPSOiVtN9VbW2bcp2knbbl2cnbl9/Xbu/Lo9L5B1C92b204mT5hhWOCyfeJHlknI6tkDdmMEkEqn9o35XjTPmCEht8gAHZiPLJyxDFQdvI6Ag1qGNwAN2OFbnI3OG4GGcdSSDjggDgFiSuHLnLBchlOzpuGNxOWBVSSdyjkAdeVFDhPRe1a2a92Nmly26NL9fQOWX/PySv/AHVtZfc/us72vq3iNqN7tG7TGAJ2sx8whuQAARExBJUjILc9mADgGpXmSTpb4AK7csCF4yxxGAR/d6su7JORk7QctgMTjG3HJAHy/N1BA5IBADKOTnlqaNz4b5gcAYIUMQNoyRuIznjO0klSrdMnN06vWtJOzbjywb5fca1ttdvptdO6Y4xk/d52ubVXjG2iVmnu77X6q979cYX94CVXTnYEfxNJtTaqfKf3Q6MCAVwScuoC8FG1C72Y/s2UH5eW3HDhxyFEZYbcMVOAoC8ZYYrUKHduQsGLbyAGIHrkD7wUHBU5IOecEMEBVZER8ncSQTwOqkA7nPyliwUjHOFBBwSclT/n9N20V4wWt0m9b2fV6vTX0bhJf8vNNtFG2ltHovX1Vlq0jMa8vJYin9mSDcpJdJG8wDjJBMYZW3Bdw4JIBC7vmpw1K+MflDSyWVfvmSRmABRWJzFncdvJJGXIKgybd2k42GRkORlfMLbiBuGC4BcDK7VXJC7TuB3biDUEisu9Mo9xLFH5hOd+xRv2sGQAFguAMmTAQA8MEoTTbdWbaa0UYWa92zXu2ev53b0ZcKcpu0qzjo3qo3e1rXVtdnrf7tYPtt+20DTJCQDHnzJCmOAesf8ACzBH3YBJw+Rkiv518gLf2aVO8sSMK2GOB1UbgNu0AfIxG0AEEDTWWVjdIFWJJYCxVi4b91K2BGDJ83mHmRlO8JuTHOBLMxCRMUKr5aSMTuI5XIXBbKoSHYocEeYFPQ4r2M3FN15t3crpQa0a01jZbWd7b6WsN0puLmqs7RdrtR0fMldaNu2mvnZ9nkx6hdZcppTt/BlmZnQhQRtbYWyB2JJQk5KqatpqeoIVR9MmUB/mlRgXALKTjKYJY8sEILZyFU532VlCjcUYfPsK7SRtIAByGHONzDcOFOMnJJkD4eJw6hdy70bcsRIZArIUbbnaR+8OTjJJ243YyjVSbWIna20owS2SfRPZeq10toZxdRU9K0mtHpFaL3Vzb6Oz3S/A3IrnV2Vnks7CJigUK9wxbBCHqAeQASpYKyhWBUlfmBLqL4Vre0RuQoaeZg2CCAMqAqsQe+CQTgEc6K+W0SSKyyRbS6OjDYVJyXDL1BB4ySd3YgsKqz3UEFubySQ+R8qnb/F5hUKqIoJ3kuQFIDHKnAXkZ8vKrupJ6btxUdOW/Tz3srX0ukz8xclKajDCU1JzUeXlqv3ny+4rybT5rtJvq9VYzxqWoRsENjFIUcIShmbcRkKwBznJUqrFiM58zgnDhqWqNMq/YY1TAcBnkVRkIQWkYIgQnPADASAgk/xaFtMt3GzqJVK/K0cq+UyOFEiEgAEjDHCjJKgZyRk2sMS+7dnOA+W5zgZwXBIIJy2MbsbzlTkUW1f2kpbO+l+m725d159dNBSqUYNweDpqaVneU21dRbdk9NHt8r6a5SaheSZBtYlbzAGJlm352rkKoQSALgKzhhGO+GUsto3N6FKmOx+ZVYkXUiJlsAZBjyXB+YsCpZgduGBSiC9sLmVoIrpZZFUlwpYqChUuwl2BXKbiCFfPygADIq5JFG2EZSFGApy6gkY2kZ5OfmO3nOc4DYFCi7O05T31TVrtJ/yvW19+6fZhKUISUXhY021F2mpp291396XXo36XMdpr9v8AlhaoyvkHzJpTtQbQxCqCBlOSFLcL5iBhmpVe83hpEs1YqQQxmJxlFI3HAlbOQDgEtgbiVyz7jULK2dYLq5WKWQI5VhI52MQNzEIxiQ5I3FhjlizENVojOzKlkVEK7SzYBIZGVgmNp4I5wnU88iUk7+/JtNXV1u2rKyTu1Zr8F1auVVpQk8NCEZfC5RdppKN2m7qS1W17XV07FOJtQVWdhbtwrblWTPVVRTgEqVAIIPIVSSrIxBsQ32+4a1fEcpB8uRSjRTDABMbAZJ+VwYx8rchNpUgMnmhtEkubqUpGwCBSZFPmvgbURS3muQSVw4Iy+fkwA1RBqcC+W7Oqq0alg8ckMyBSS4VVdZAzOSAxLBcnJA3VFWsoT1tdKVtVo231SaT+/V73pKE481Sjy02lFVacXZTtFK+lnbRta32WquaBiilhlgnVZIWR0lSTcY2AfBUjbltvUNnKcc7k45dbe40qZoJrljpk297a4kfzZIZZAVWxuXkf92hb7kmDkgE7XLK2zDdssiWN0SZcM0N2w8qC9QeawAc7sXBRfmjJG/7yDOVGi8SyI6MqyRFSpSQEo68MVYADjshPC5U4zwBwjUSlF2lFJejVrxlZ7bbu2t7trUhUqYRuFRKdGrytW1TTtarSdvjiulntyyXamqLHBbMjnaksaAuWbd5kYBJIO3GeUOSrJ6tjMpiyHVOVLMzgDIB7KCFz7AgjBOMDmsS+jmtLK4WEhLeJ7eWJ3LGWAx3CRtEGdwWiZRu3ZPTafmYituFnZInYbGkVJHwSSrsgLqTvYnOMlhwwIJGCxojJNuLVmoxTXZu0Xbuuu6WmrbveKlPlhGpCakpTko9Hb3JpNX0l71pLS/QrSQNI4cuNojkTO1zh2BAk3FlIdAuB0Cn5l4qpNaxyeSZbmQGNFAMbrFEzpvTL85IkVsMW3GRAACOS2o3f5W2YIIUAlkOMbctgrgNtbng9cdYH8sgpKAynAaNjjnC7CgTlmUkEAkBi2cjoW4xt3Utb667fE72036+V0OFSas43TTWyV7abffbe/wA9CuqvGoghCxQxxBdxCAvgqBFGGVDg7WbzCMAsSFGcVOjsjOrMwMcKjzCgVZGYZCoz5YsqqPNU5YAAFumXYLHYpy+8SbiGfIJGQAQ2TjgEEZIOVDLykjMqhFRndiFVfn2or7P3j7gVKBSoYnPDB+CWAduXXVrok9LPltbSy3SV9N+gX5ul7pdd3LVybbu27X10u11VnXiWUXxkZJBHGjKSzDbs3h18uPD4Vg3lYYq+1WGSGylicva4dctCWBkgjjDNGSuWngUnoA6tIoB2g5IHeVA7TPMXUqFUIixjKu3Mruwcsd5jCnDFTtYjOSKe8W52kQvlE2twxRWUDD4LqGPRSuHCjIcMCVpNKys2mne9lqna1rO1n6K99uptHEcsuWcYypuEYum72kkkrbXUop72Vne91diJLgKo8t0cZEqKHDchSSchcDy8mMcrjAwcU1zIMPGFkCYDK2MkkAsyMwUn5Q2eCNxxtBCk57TBbt1jkjYEs89qhLD5AAZ4mOI4pgzfNESSR82N7Lu0EKMN0bFlJ8wNjjKn5tu1ThgBtdSwxztAOBRF6tXStFLTZ7Xtbpraza269Cvh1BRnBXpSs4trWF4xfJJO9vK2jWq1dlUubGOcxywkW91AA8NwfvK4IxHMsZG9GLcg9Dgrh1FZ8E9up82/1O4tLm0m3HTndI7eMqESMxBBI09vMASFjXGMb2AHO2pVpY8hjHubJHTnbg4c8qWGfmAwuSAWwKp6lp0WoIpyFurcjyJyu8ELtZbeZl2q1vK4+UE/IP7zblaJxbvOMU3H7LvaT5YtXV+XmXZ79bdHQruKVGpJ+zeinaMpwTauk5Rdoy1vrzLV33RLb3CTxK0QEcTISnyKjfOI+GXLOqYbhyzBv72RzpQy+bLDG6FIkcbiU3OyRoHPGQSh2AElV4+982DXOx3BnuY/MkNrNZxNHdWMgGxmVi8bjy8M8KRIDFMWlICxByIzlNG3vfKmjLq6BJAjPKAcRybYgVLMHKksdrNkEK0YxgMdYTTSk1ZJpO93Z+7drVtO9/ivs9W1pnVpOLcV9qF0lrZPz2lpaSaTTT27Urwza9rMiXPFjprRSPAwdluLt8FYVRWIIWJQgBwdqPgFWAXpxI3lr5aGMBVCxuqRqEHzIVUMFCZXbGuM5UITwprB0r9xe31u6nzJZEmU7U3PGivA7oScsdqiRCg6Fgqr8wHRlmmiHdERCpy5V9gIXcSBuHzbQAMEKRwTinTSvOpe0nJpt6tcrsumiVk1rpe+wYyqqcaGFjTXs6dOEozTa5nKMXKSs7OXNd7XUkk9rPKv0FxH59sqDULPaYJVADyBQGezmKsnmxTK0m1QzgOiNlCCDNbgJJ54aQO6CZjMQZEaQBjACrOQE2EMrdQSBgg4suwjjadjsjUNNKVUjYFw2ACHYM3ChWzknaSQwzFbwX9zaJPJBMJJg8qAsFaONSvkK/zowZo4k8zzAGXawI2Dcat71rXb6JW+FxTfZ3vbXt0SduZznUpqO8YvkjOV22pa8u6ula9+l33RZZ5CCWVgWC/LmTLZyMncDuxlSUIzyo4GCtOCS2glFuieXLI4cRxxum5yIzlnClcuSCVbHOVPIGLH2G+ljRhFIJgFkjZpUVInBUFXTzshGychjuwwLYUDN9dMuWAwmFERY/vLcYYKHI+WThSSu4Fsgn5gSCwu17trVJW0a0dm7a79Gld/drjZwVneaauknZq1km+jTu9LNW0XcyWS53RyQASRbt0oZnjMalizSIS21/LVSRlcqZM4xkPoLvLBzIQyYQAqWDqnBJRFY4wSqneU3bfmBYgrJY6jhQlqCkrxmRHntwWjYYZ45XnVUIbbgOp6sSGUAUg0y5llt2FkystwyRTm4tkWOIbmxJHHMgkiZzllbnCq254wVUSs5NXeqXVWSsr7N7PVXSf3tmrjFOSSinaSkm5Oy+JOSb0tZrpayYnmXErlAfIWG+iQGWUFr2BYdzlfkJCg5wvyklQHIJrSjVt2MbhtPyuQMAbu4PPBO053AnbkLgh0OiXAd2VYlkLqAwvLUZ5DYKJOxXAkOMYAUgAknA0Le1ma4a1RYTcRKruGuLXB3eWwYlnBbaGywXcAoLtg5ReiEZbvVytZNPyslbqm3da2enkc9actIqNtNUrpq3Lrezu2m76u1trJIhRVIlWPEnysHUMcKSB8rBQTnDghSx8s5KkIfltxwEBYlRo0EAVGyQEzxl1LuCck4zuwMEHKk1ZXTr+MoqwwlXkAmxeWZKAeUBJEolXcScptLc54+UKF07fT7suR5cZUJz/pVkzDbjcABJgH2HCkd+o6qcFdpp6XTfLZfZ0u/e136aWslfXza1Rw5dbp2Vm09rJ6LVPTS97cydrb047XcY4vObzVCupyzNIoKByx+4VwDghQQNqn5gWrUhtcMuVOAQFIODuyuBkE5TnOADuAJyr4y6Kzv0mRmjgCEAEia3MoUOCu0rIMYLIPLIOfncfITjcjtpJPK2og2srNh42MY/dn5lQH7/CnIYBs7SNoNd1KF7JRa9E1oktt/J+r87ni4zETgl77ej63lG9r37X6rb9C3tPO2o8TPFIreaxJGEwu5lzyMHDKc5G3sTg3LKxeGZLaQKFwwt5eBuU42qzMSFWTG0Ej93Jn5tpVa6PT7IyOFx8uBgMvK4xy2eTkkgLkKSAR0wO0s9DW4Gxo8D5WjkwXCEcHBHBBZssozkZxg4r2MNhFUaajqkred+V2l8106Xu5Wd/h8yzn2HMpT92yW+ivbtrqr6O2qt0MTTtKYlYwm5hgZXeWBLAENhSSCAoUYxksAQOv3j+xR+zBrv7Q/wAa/BngiyspZbW51Oxk1JxGuUgkk221upkUoJrueNVkkkYR2tnFd3kwWO1ZT5t8GPg9rfj/AMT6B4X0nTpLzWNY1Sw0jT7aOJp3vbrUryOztlRV3GR/NcFyqs4RSSpGWH9gnhz9nf4J/wDBL74Y3P7QukCS88ZaL4MsfDN34b16W31fw54u8a3VnbpeahojywQ67oWr3V/HcQw3en6ndaVY6FDqca6OWvmnj+1yXIr1IV63J7t5UaUlLmr1IxUowTV1GN0uepKyjv0Px7jPxNyzhyhQ5qlSrnGa1Z4LIsHTpKrGrmD9nSo1MRFyjy0KderT5movnl7lldtfMf8AwUx+L0fw58LfC7/gnN+zhDZ2Gsa5p2laf4sutNuVsrbTvDM8YmgsNTuYZVS2ttV+y3virxXqmoGOaz8OxNJNOtlMyV+a97r3g39m74d6H4p8NTNq88VvqXhn4T2lyI7ObW1uLyCTx98Vb61ULcWdz8Qby28i0mJ+3aX4Ls9B0i0mhuXS6tOdvfEnjvX/AB7rHx3+JtjJcj9onxfqmgah8RdKnjvm0Tw7DCmreP8AwhpOiWsYvoJL2CTTfD19e/YreLT/AA6J9Gsrqa2u9UVPhr44fGW5+LPj3UtYEYsNBsw2k+FNGjRorfRfDVixhsIYIC22F7lVad8FjudV3siRbfvq08LlOBjiVNVMfVj7LDxs17JNQnOu4zgne7bilpzNaWgjGvkGOyjh3LOFsbjPrud8SUYcR8f4+NSM6lWni5+0wuS0a0G+WlX5bYhwaksLSdN8sq07+gaF438f/GD4vWHiLUp7fX/Est3BfS3moWLaq9xqWnILTQjHb3DTIIbO5bT9M0PSIvLsUkWziEflx7Hr/HvVLbW/ivquj6a0Mmj+Braz8B6dJCd0N0/hwSx69qKEJDkaz4qn17VzIUVpjfBi7kgj0X9mOD/hCPDnjv4x3SQGLwZ4eudV09JoTKlx4k1KRvDngGyjYAxpIPE16/iJYmYGW38LtIAEBz4v4T0O41/WLeFvMmub+6Bmlf5pJGZw8szttJ3P8zswJJbc3QGvNxrcMrw1Gbi62Nqyxtebs6vsot06V5K94ym6rejd1GWiTRvFyp1sJl9ClGlhcDQp0cNRpRUKUJ11T5YQhG0UqVCFJRslZVmuh7T8LPDLQWC3pixc6my21oQCCkOf38ikYIzjaWUkkZG4dT/XV/wTA/Z9h+F3wci8banZCHxD498u+iaWNUnh0OLctjGflBUXJaS6KjhlkjUfKFNfg3+x98BZfjF8X/B3gqzhc6Ra3UD6lNGpKQaTY7J7+eQrkB5lQxR5GWklA6jj+xjw9oVhoOjadpGmwR2tjpdnb2NnbxqFjitrWFYYkQDhVRFVRnJK4xycV5eJnHAZdCKdq2NXLq3zLDwac9LXTqzSinpdKaaTvf8AGfFfPJ5tnWD4cw9TmwOSQhicaou8KmNmk6MZPRP2aU60k22n7GWhdwEX35B45xz3PHQ/jxj0OXdvxnIzyF4xyeAep6A5z0BPHHJ0biQZJJxwenOCATg5X1xx3AB74rCupOQATzg+m0t6YyBjOOCcAc9a8ajDmknr0+e2l97W87u6vfQ/Gc4xSpU3Dmdl1ffSyS333flfRNWybmXGACck4YkZBXPzZBJbOSR0JbB7DFc9cSbieeRjHAAIHAU456nsQOOw5rRvJCAcNjk4zyVJw3OTnBH3toYtyy4w2Obu59iPLI2xVG8kkABVxkknpgA5I4wfQA19BhKVuWyu9Erbtvltq7Lu2l0Tsj8lznG3bjzW5m3q9fJWun1v59NbI+aP2pPihD8N/hrrF556JeXdtNBBliuAVbccnpjIB+bLE45OTX8g37QXxDvNf1nVbyW4aR7med2LuSw3MzAfjkfKOemOBX7J/wDBR746jVNWn8L2N4PsdgJFdFkG1mVduDtbqSCwBGMHPIxn+cT4o+JjNPdzF+AWC4YDJO4fT5iMcg/KCAAdwHqZ/iI4DL6WEi0puPtKtnrzyUW09VdRVldPe+mrR/QX0duCZ4ir/bOIot1MZVg6PNF3jQg48tr6Xm7ydtVeys7HgHjTV5Li5ljVgAGbJOSGY5K7mJB5wB77iG5Hy+QXUhklYnJBPA69ccgYyM5weDjnLda6LV7triV3LnJJbtyck8k8fxYzg9gRuChebjXzZeTuXcQTjrnGRzwGwMEZAA+booWvy5XrVm5WfNJO2uiXLu9tNGr3b22Z/p5wplPsoYelGHuxjCNtXquVttLR3a8ttlcjggLuN5+UnfuzgAcDaSQfXnnOeeRkm8yrsO3kbQBjnqq847hcYzjg5JBLVZEW1NoQk78kEDv94jJGcnI4Gcg7Rg4NmK13FiM4KfdKnrjJ64BI6k8g4wMtkH3qFBxUYpXbV1fSKej31d+726dT93ynB+xpxioXlZJ7u0bJ9uj3Vu97WOL1Eb7WcYy6oxAPUfKQNxPfkYOMZ5PzEVx2nguSrZ3cfMehHy8c8k4HIGS3rnGeq1KbyftcedxCyqQSeAAQDjIGMZGODkYzgCuZs0KCLIJ3ZY5I6kjPA4BxnGcZHTivmcwt7SEbaptS1u7ppK9l1vdbXa1XU+N4vny06aldSva6sm2nFvezfMtNPQsSqFG09TtwDkE5xkj+EDOcHkY2tkMOc9y27AJA2jngBj8vcDrkY5GPunn7x6NrYOisEPYqQAWySCeoyRjIJ6Y656jLubcqu/naMcg9uAQepJxz64J3ZHNcMqbvfl+G2yTuvda7qO2lt3feWh8ZgcWoyhebtzJXb1urJK766aNJMht5DhR0OcH0GD37kZHHJwo+YnqN6ynkWVGOPkIxwehwdpyQTnJI5J5J5bG7nY9ysAcqB7DDAlVAAIA7cYPPOT2rUhfnPBX68Z4HcADGRjGRjknNd2CxDhJXb3Selv5U9NG3prbW769P0HLMTf2Tesly9drOHm+1rLur62Z6xpN4TsI5I2ncOAGyMZOTgZySSRtPcNjPtXg7WPsd7bzB9uxkxjrjpkYwCvByOeWAyCMj5z0e5zsBbhCCeBnAx6jPzdcYAX13AE+p6PeH92QeVbC5wpIB5J+8eOCPUHnBwa/SeHsyeGxWHrwlJOE4STWlrSVut15Lz9D9JynF8s6VRS6wdlda2jftZtJ3SV23e2h/T3+wr8U08XeA4dFuLgPe6KVjCs/zNA2djc8/LgqxO3BUDHr+kFjKSoIICkAg9tpAYjgk885GD6ZyML/Nf+wp8VW8IeP9Ns7m5MdlqhSznDuwRTIco204AIJxlgQAw6t0/o40a7S5ghliZXjlVWJXABVvmVlKnIGen8J3fNjgn+v6eNhneUZfmkGpSrUIwrtWlavSUYzcmrxXNFKSWure5/XXAObxzHKaEXK9aglSnza2V48rtum1dddr6o9IsZQMY4UgAEYIGeOBx37c4yAME4r5V/bQ+EkfxK+FWsC0txNqWlxSalYFI90hktw0rRpxu2vGCPYk5Aya+nrGQLjB5XHQ4GDjJGSSfyHcnOeNa+todR024tplSRJYXQqV3DDoQQRzhWDYOQQN2cdMfPJ+xxL51elWjKjXi0kpUqsfZzuvSTatazezaR9dxBltHN8pxmDqxUo1aM42avyuUFaSvfVOzfTe2h/IFp1/f+DPFUF5Az29xYXyTDaGVleKQPxkq3yuuGVsBsdSpyf6JvA/jC0+LHwM8NeNY9l3c6JZrp3iC1ADtcabcQrbXsUsfOUMTtt3syxsrbQfL4/Gz9s74TTfDP4oa2La22adqU8mqWBwVQw3DFpI1PJxDIWUBcbcgHkZr6o/4JsfFeA6jrHwo1+6U6f4ns547NJXXYLhlChVBI5IAAIVhncQMkY/K8ww0smzavh+XSjiPa0m00qlGVn7umqnSk2raN2Vlax/kf48cO4jhTiDLuKqFHlxHDeawpY60P42VYirCniVJLeMYSU/8PNqkfKnxp8Jaj8G/i5cTaVLJHDY6nb6/wCHL2EEGXT5Zku7C4hcEAMgZWD/AMLiQNxnP9HPxJ0vQv25f2KPCXjtTBNqnirwU3hHxTKqmV9O8V6YG+x37sAXR7bXrWK7XPPkX8aZAZzX5YftZfCWfXPAmqanb2xl8RfCjUPsGoBUYy3Phi+mZ7S4cffaO1dwm9jtWGRQAPlr6V/4I3fFq31e2+KH7MHiG9AtvFGmyeKfByXDEeVqVjAyapbWwJUeY9sLe/Hl4+fTZSBluPNzSEcvxkMwoRUsPGTxUoxinGeDrwjSxlK0Xbl+rydXb4qUPQ/jP6V/Akq+DwfE2RxSnbD5plOKppc0HKpTxeAnF2fvUMfTp0G7+5SrVm37x+CFrZ6n4Y1rUdB1aGSx1bQ9TudH1G2kykttqWm3UlrLxgsGSeIqGHJGGwd2R/at/wAEuv2lz8Sfhz8PPEt/eh9TvLFfA3jhHkBZPFnhmNLW3vZ1JYh9Y01rC/DHmSS7kG7902P5mf8AgpH8HLr4XfHyfxZBZta6T8Q0mmvAsRSG38XaGy2OtxjHCPfRrZ6mhbBka4mZThXNfQ3/AASl+OsnhH4ka18L7rUDDYfEazttS0ENLtS08b+GIJ7qzETM22J9U0yS7s2Cj97NDZqykqoHiZxlNHMMFmeSzXNDE0XPD1Gr3jOEZ0ai2s+Xlmkr+9FddvxDNeJsVjOH+C/F3JG45twri8HnOJp03JT9nh5ww+fZdN25uRqnWhUUrNwjLS0mf2g/HzwivivwVcXlvEJL7TYxf2m0ZL7FLPHgckSRF0I4ILZwcYP8DP8AwUX+Aw+E3xy8XWNhZmLw74lY+MvDPlx7Yk0zW5Zpb2xjZQAg0vWEvrJY1AKWyWowPMAr+/8A+Fvi23+Ifw90rUsrJLd2AivIiATFcxoYLiJlJJGyVXBB5CjHOa/nQ/4LG/s2HVPAOp+MdNsg+q/DPUpNUaRIi0k/gnxJLBb6upC8tHpOpCzvsk4hto72X5Q7Z/M/DHG1MPUzjhLHNQq0alSVCnN2anCahOKT/vWtb+d22ufp/jxRwaz7w88cOHnGeS8Z5fgspzmtRS5FUxFGOIyrFVnH7bXNh5ynbkjTUXq7H8U/izT3jkkyuArEZAPIxtbnOSB0Hy5UMQQWJJ8K1m1cM7Z2ooYknK7SMHpjb0J4yxBGON1fXXxA0T7LNcZSRQkmDhfMZlUnDDOA33T1ky2eCw3GvmvxBZlmJKbMA/JxgNxgttwCRINqgAjacDJWvSzbDunVqRtpdrX5dOu3dbpea/WeDMzjVo4eo5c3PGDte9/h1sra6c299ndanhuoxSEMy4ETDPKg5cgFfMzjChgVKMRlic5B2jl7qF1wN2W2KGO0ncVUKVGS2dqnaOpbb1ypJ9D1KDhsKyjcAQuTjkEAMeG+YgdCFAGCG68JdR7y8SZ2oCsrEnK/6s7I9yjJORuYHKZY8EA18fWjyyd0m9Vayu7ta/ddq60d99W/3jKsQpxg2ru8dU3Z35btu97t2T217u9+cmkjjUo0sKkjA3SRoedu3eODnoX78cHqTGGjUqBLACoBYiWM/LhctktyQVPzHjja/IBOiLG3UZWGMkcNmNSwGdpJ25OSAMkkZIIOQMU+OztPlPlxgYA5RQFY445I9cAgFR0B5Ark5Jc13FaO1ry0Ta08ttNvJrRr6uFSXKtI9rO6u1y6a/p1fR2tFapEoO6SJizDDGRSQPlwhbIYbRk7efmywBAIrfsrUTsEiKysTlQjqxBJAJ+UNwMjgDgcqMdKMNtbYO2FFZdpKLCTlflHy4HHLcZAIJG8816X4Q8LXmpXen6bplhJe6vq91bWdjZ2kTSXdxc3ciQ2trBDEWlaWaRkjZFCsWKqoyygduFpSnUjDlu24rZ3eq6pve+j9e7ObG436vRnVqSpwhCLnKTlaMIpLmk5S2UVe70tFbs9t/Z0+CPib42/Efwt8PPCel3ep3urapZWrR2cMk0k8t1cx29vDHtB3S3M0kcMQbhVZ55Dsidl/ql/bb+J3hj/AIJdfsPeGP2Q/g3d2kXx2+LWhyL4q1rTGQ6hp1tqSrB4m8Qu8GZiXkZvD3hxDtdo0eaJWYFnm/4Jv/sy/Dv9gP8AZu8YftpfHuOyttS0PRNSuPDxuCjzz6qkUtneTaQJBtnma9kPg/wwYi4uboa1rK5hu7F4/wAfbHxL8SP23P2kfE/7RXjiXToLvVta1WTwi3iZnk8HeCdO8MaXcate+JtaEwMa+APgh4RgPizxKFVjrWsRaN4agim1HxFbLJ+h5Xl6p8qavyu9SW/K4qPPyvvSvypN+9Vto1CSP5wozp+KvG1Srj606XhxwO1mWdYq7dDM8bQtKnh47qqo25VS95yc1Dl/ewkqfwl0zTP2Tvg3q3xf8S2dtf8AjCw13Trbw3oOpItxH4t/aCWzj17wZ4dvYpONR8K/APSNRsviz8RoXaW0v/iBq3w38NahEz2upRDwHwfaat4V0u+8feIp7jW/ih8Q7+8k0ufUd11qU1/q85vNR1y83hmkubue5e7mY8tJJZWu4rNNjt/FfijTPj98SYdU09tT074BfBXS5tB+Hdnrjs19e6Ol/dazrHi/xSW3JdeO/iv4nm1Dx342ujvc3mqw6HAw0+x063T6j/Yy/Z+8SftXfHHS547GWDSFvFs9LWSJjDouh2ZEl/qLn7iyQQEtvJBn1S6CBsQbK9Oo/rNWNRPloU3KGFuko06UXb2m9m4xWkuu7V22fZ5zntP2macQZilgqEMJGX1ebSjlWS4SmpZdlUFdRVSUU8RjeRXq4irON5J07frF/wAEf/2NV0ezb44eNbD7VcQTzHQ5r6MSSajrku8XmpBnUmaPTQ7Q28nO67eeYPjYa/Ub9vP9p+z/AGX/ANnzxN4shuo4fGOv203hrwLbllEra1exOkuoKmd3laRal70sQVEyQI3MyhvqPwX4L8P/AA38GaF4Q0GCHTtC8MaZFZQABY4xDaQgy3ErnA8yVkkmnlLEZJY7icN/HN/wVw/a7k+PHxq1Dw94cv2n8C/D+S58MeGkikJgvbpJFTWNZCZAY3lxGY4WwWNtBD83JB5qajia0WlejRahTjZ+87rllo95yTnO9lypxkldH8g5Dhsz8ZPFHDQqqo8vdeFavC14YfK8POCp0ErOKnXdoSSablUqtWUVb81Li+1j4i+OLi+b7Rqmq6tqi21oGLzXN9qupXW1SWOTLLPdTBixYkuwckkmv6nfgj4F0T4A/AzQNBunhtLLwV4Tm1jxJeD5RNqSW8uq69eysw5D3j3bhmOfLEUeRhVH4Vf8E5/hCfHfxk07WdStzLovw+t18SXjOu+GTWpWe30K1Yk4LpMJtQVcfesep3ZX9b/2/wDx7deCf2e7nwlosjnxN8V9VsPBOl20JInltr2eJ9T8lFw5SS0QWPyjn7cAAS4z+68K4H6hlDxlSPJWxfvxutXSpaKzWrcqjaS0vZdWf75eCPDuE4I4HxecyoxoKOD9lho8rjahhaS0i9OVVq3LT21cFy73Xzj+yp4oudN0b9pb9s7X0K6ro/hv4hfEzQJ5wWFt4l8UfbPg78HLCMuSpCTal48ubRVG+M6XbTRhUIdfFP8Agnr8KdS+JPjzxDLaCS41Txdq/hr4S6FcqHeY3PjXUxceJ9RDqNxktfDumXc9w6HcqX53FRIQPR/2lJIPgd+xH4E+F2nPDHqXxj+IF5eXYRl8y48A/Aazh8EaZ5oUc2OrfFGXxZ4os2YnzUuJJk3eYrD9Rf8AghX8AXuvGPw/1zUbJjB4L8Ma38U9a3p+7HiTx63/AAj/AITim+8DLa+GLGW9gDEFTK0icDdX21fOqfB3h7xnxjVly1aOGxUcFKpGNpSy6nLC4bDThFq/tc9q4+mpSd5069NzfKoQX6rwdiY5LgcTxJjIpy4dyHM+LMXKavGWc5hBQyzDSu787rVcPCGq1e6V2f1G6lLo3wf+EUosoY7PR/BHg9LWygQBFig0nSxbWkEa4IUnyYolUZIJwAM1/A1/wWA+Llxrvj/wh4Dku2lfRNL1PxxrpLMQ+u+M7sx2vnhcqZbfSNN+0RklXWPWH2KVk5/ts/bk8XDQPhOvhyGZY7nxZqdjp4GQCLW0lF7dP1BEYaKGNycqFk2nqa/zfP2w/ikPih8cPij4zhmE9hqXivULLRXVgQfD+hbdB0KRCQCiSaZpltc5Ukb53bA3ED8F+iflDw+X8Q8ZYu8sRjK9WNKvOHvPki4KfO7O9SpXxqko7ypRadk4v47gWEsr8O85z7Ea47izOnRjUmrVKmCy2Kq1akZuzlz42vOMrNxbgluj4f8AE2pqTLgtlmZT+7ZsgNksqgHKjPAyzbmA9APFtYvpCZQm9gcqAkMg3ZI+bO1RwTjqOuAMkAeo6zdh2lIc7CCgyR0XAGGJBHUHOM8DBKivJtZnEpK7iMDLOGKgtgABWJJyDjOB8xG3buzj7jjPM1WxNZxbnzylrtq3FbX331vtsfl2b4znrS01bd9bNr1X3v8A4Nzz6+eSQl3IhiVSrM4GR90nagUlmGWwMlQSeRhq5S+lURiFMiLBwCxLOwBXc5UgHcdoVQCEBx2Yjf1WckM2053AbQG/1ZDKWBPoqjkj5DgFTk44+4l3ybBkeWmSGKMTtKAgZA+UbCWILZy31r8BznEc9SV3reVl5KyTXpa7vvez1Z81Vd3d6/CkrKyty9LX0SWt9Ozad8S8kAAyQw3BS2CSuQGGAWzu4wcDkHOCKy5CvKADoVLDsRtwqkk5bJyc5POQyt1u3ZIKvkGMjkbG4ZeCQAAMDG5NxbADMSQcVzU1w9y729r91WzcXJCmOBARuUNtAMnXaqtg7SxOCTXwOLqpSk7c0m2lBau7srJO9rvre34W5Jy5dXaUmr8sUnZtxt5p9U9mra3VyO6lmlm+zWePMUIbm4fDxW8ZKDLZwzzbQfLiUliAWI+VjUSwJAGjibCk+Y7ks7XD4ZWnl+7/AKwlfu5XBK4GMtdhgjgUpECYfmYHJcySDKvNKw4LtsGQTmPhV68wzDcAzEjYqhN2cE5UngkHJPA425yGXgNXj1IOTc5P3+iTukm1GyVrX0V7+XoYqLk+adr3+FO6jqr2tpe276aGfK2Zoh5iAMrbFxtOQy7skNuyqncikcjODg4pm0rwGGclgdueMANjIJI+XHBxljkAdZSwZucEZ+VQMkHA+fdjIIzjBKhf4gTSESbslRyoGTxgnauMZIPIzyQW5ILLmuRq2vWTv5fZT11Vt7NtX2vprabW9r3VrrTpaycf8trrqyE7sEAKuSDhQBgjglwpGR0JBbjAwemE5CgMA4xh8Kcn7p57jaP4myx6rxxTx8qkZyAcEEEgjAypA2g4B/h3cfMpxkVFNKkEYMhOJSEijQqrySZDBY1YbcbSS752xqrFcjAOUpxjG70jGO+mqurNq9r3t036szlOMd7pWV2vWOrWuuqae9urTGpExEhwzJHFJJMxYgJHEA7N0Kk4Cxr1QFgSyDeUzI4prvE1ydlsY2WKP5o2aIrGwwcKyxlkYyO0azSsNypHAY4y+FrhpGeYqyHG1EDtC4jZtkEHK5i3p5k7uG89lQABFxVslt5IU5KlsZZeWCnqjP8AKCQAnQZIwR04Zy9rJNtxgtUt7uKTvLVKzfLa7esr3s0Yc/tJJSbUNEo21lbltdWs7q3KnffSzaEeZYVgQKrI0ixkqEPlblUxkYk2fNgRkBeSN2FzTlKjJBZmJIKB8kkbdwBHy4Bz0wBkD2ESphsIHUtHvZyc8knBZfM8skgkL8uMc8lQGUgEHccEnfvOSMMAQDwB8uQS2F3Y3kghjTiuV3ezi5K90tFFWtu431V7Ws+l0aK6utXdLfZNKPZWvftZNOTXVJ27Hy8joo4I2sdgCE85B3AqAeBkdWGaVxe21u372RvN3h/JDMXXG0livACYJJYsGBXgEjNVj9rv7pZLaUW1nbKqvcqdyzzZVmCLtAmYgLgZYQ5ZmyHRRfSwtI3ciNJJGT55p8yyy4G0mR5N2N21RtGELDBA3HON5TS5Emlyrmlezso3cVbXRWTtulduztKfN8K096KnJv3r2utXrffmeitveyIDqVqpXdcQkgEDLA88AbsjqFwxAJCjDIWcGoW1W2kVx9pjLRKsjMMbSoIGASoLOMYOFOcEkgkGrfkWbEj7Pbk8kkRrwTjIOUOFG4DGTg9uBQ9vbrGcww5OTjyVJbIxjhBzglV5AOc9MEKSqpp3p2ta6TbTtHta3S+9vhW6ar95peUNH1Ts7adEmrpK/wAr9W6DaxYE5MyuMeWuwSn5gAc5YDPUjldwABO7dhD+07LeV8/scZUrwSNpztyFxjIBAbAKHIJqT7LaxBSbeDjLP+4AIbkEgqGAABwgzlcHOVqYWts2H8mPJ5CeSgbDEMGBGVJ+ZfbIBxg4GSVdtLmpR0ta0tLOP3tN6O2jS0tdotUvrKmlpqlLye2+1+3rfbMuNTtpomjjkKsicOvmtuZdpVAQEdVZQC7YIIOTh+aijubQITPKouV6BDIwACAKRlHBdyoLqWCs4Me5BgnbaztlUyJDCDg7sRIpAByACoPBO3KkHBBUggZMaWFsUVmghJKr5imML8p24TpgY4LZHQgj5dtTyV+f44JrlVmpWfvKyT2v00atu9giqiaalBvtJPlWzV07a6PYxLi9sy0ZilfOYRMGExyFDfOZiAzHoCSmCnygFCrLZTUrck+bKjbVMat5chDKBGC5O3d5uSSGYsSOQSeK0Rp1hyRawNvXK4jBwW4549CAVwMqcg4yoUafZbOLWEEncAUY4yRlsE4wRgfMc4bggchJYmLvzUUn/ifZWvfe2u+jWi1SBe3k23OCu43STa1ta8bbNxa0T201tfPXUrU5JkyVKoP3T4YAqSVICje2wsGIAUYDAHObMN7p24M9wGZ8HCRSqyliv3SseFBxg4EhkIwgVQKstY2A4FpARgceXtIYEgDJycFmyOoPVeGwXJp+njAa0gAJJIMbZB4xgnJBAOCwwVPAxk1nKOJa1lS1vpaWnwrZ2T666rV6apgoVErycHrZJyemiT3t+N1rppqdbYops7IKcfuYWwNwUADqFAKgDglQNoHIGMVleI4o0sY2LfN9v08ouSEZWfacncgyANwIUfNtU8AsdWwjeGxtInfP2eKFZCrMwI3NgZwp2rtA3FSVPBJBYjN8RKr6bEAwiD6hp4y2zcAXcZOFYAKOShIX+IEqHWom/wBy3bTlin0S+HTRW9U7N69NvzPDt/2jC0uZSxD1T0a5k7q2ruvuWvc1imJp9rD5hauAC2EOJUwyp7KuQMkkE/MMESuCqnjkqT07lQCpOCSWUMPlPzcMAQMsxUCvOPukJbkAsSWYtckKMg53gZxjBz1wCKVzgBSMg4J++wxtGGA+XjIGcHdyQNu3FaxVo2urXl2d3ffq9bK1nZnJq6kVfW8Lt6fZi9+t1vvayWnXD0Af8S7S5HVQEuJFByAACLjPVdxJOBuJIySu0FcrvyCILksNxI2/c3LkJ1HTaB8zYY5+8hAyowdDG7StNDIGUXLEOOMAfaD1XcVI6hgcY6DqtbRi2hl37lK5+dXfapwCvYDbjagUAE5bCjIZUldL0htvtG720tve+5vjkniaj5nf2tTTyVR2tbr/AMNayRleVG2r30eUIbTLPIZ1dtxkuFVDlWO1iyMVBBJC4JIBrUiUN5fO7/R7fk5Ab9whwFIAILY/38YYcLjLiiD63fks2Bp1ieGIAJaVeiqQMZBIB+XJKkZK1poWCQgEhTbW5A3k8rEu0cHIAIG7LFl68KCamk0tdmpzjtfTmXvb93pvpr2NMS2/ZxumlRw7s0t3SjfXdNrXftd98jWYonGmZUH/AIm9kpBIaNuH3HYQqsOMDA/hC5GDnXRfKV4yAQbi5YEJGMYQFHbYAflZlVsKGA2uuGAIydZZSNKyCF/tmz+ZihC/K/8AexgDOQTkEYIJOK2W8wRjES5a6kDrlWKoI4XlccrjABXcdwUH5gcYSotOU3Zt2jtZOzVui7u/a9x1nbD4RX92XtOunxU2r9r7O6vra2tzM1hnfS7rzUi3CEujqN/ktGu+N0LMGSVWBGVHBYjIfcDPZSSNaWTTSmVntIHaSRTmZ3RME7zy7ZCsDw3UYZQKq60udMuy2Aot5UC8Bs7RyQMkDkHAbjIPU8T2Jb7BYEguRa2mGwSV/cjIOVOV4IbaeAAeRkibNVnf/n3rrrdtbqy189d9HYcnGeAhovdxErWW37uGibe3dK3dop6ujvZ3gckiNI5UdGUEhpocZcnLZKrgbcNn5huC1qRKFhhTeHJghO9SZBjYpJBAA27V4B4A+dWxkVR1Ys1leHG5xbQn5Rj5WuY+SSpJ3HHIYFuOGUDFiyZltoRI3mN5IDE5bOMrnO5VZAqZVwMsBkAjK04v33om7Wvp0knqvJpJXvtfsyHHmw0Lu1qusU7PWFJtq275unl1e9jJVuY93BKbUGdgK5BLZ6lSwbuQMgEYELqpQt8/zYlQhioT5V2hQmVBDDO0kfMMB+QQ5mdIw5QuwLMAi4YgKCyjJKg4BG35tzEFcdazBcLIUlWRowJFVreRF2EER5R1UqwkDgHhgNqkjGJUWnNR2s27JqyWjkve956WWtt/SzbmlTcle9k7Xerd9GlZW3V091sy8X/ebcfKI1dtoxJuLBQoLc5AUGRVBweTIM5qRQ0e0qrSRsrPIp6q4CgGNmbH3tpC7MLk7skYqikQwpUyozXAkGCzMUkC5yFIVFbMedrCIk7wBlhVgxefD5TB4x5qgCI/PCyDdubGG2hgr7S4yoA3ZBxPvPd3btJLm06O17Oz2TbXnqjRKN4pStHROy1jaybevR33fXTTQkZyu5VARlaOXzJAzqkbufurtxvIYMRlRjBHIUFqzbyrAOHaIFRtSMPz95N53E5BADKWBV2YuEG6uhV7eZizKAgQ5eTcZ4BGFlZI3LsSxBBLrjaW2nKU55jbxtPcBnjQBC0cZLhAVVHw5OdwiYsykMduXC4JKvd3m/d5b2dmlqrPXay8rat6WK5baRV3zJNpu7XutWW2+uvlpppbgSJo3aJEV5B5ryA5aSQhdzCfO7cGKYTGCwYNlQBWbPPHbNgSB0Yp5tspBk3y8fabdXlUld0iiZVBB3EKTsLGzFIHtY3z8rAyE7wFMZXzXyyBlxk7SDjYEUEFVzVTTrmzurlZgR9rMYiQSRqjiCKRXiaMkOCUDqpO5ZDIjRsCq8qTT5EnGMnZxV7Lo9Fdbtry1+/ahzR9rKcZTpRVpxaunrpr0tb4ltbyNaFyzM0e2RFUgMiKVJDZ2oMH5shQwLZVsMRzUjMsQGfmDMACVOVY7AA7Nn057queeea0zSW8vnwkTwkol1Fg5ZERiLiDLIokUE71jXDhTgsw21Y3rLGjRFWhlfzUYLu4BJJX5cqVC4fcSFY4IwDtuEpNtNWa1a0aaTTulfXTfXS+ujMatKK5alN81GWnMvig24vkkknbW0ubZpJpq91n31gl5seMMl5bkfZ7ghgnHPkzbQBJbSEkHn5SSy5Gd7rCOO6mYzWyRzWiussDBMR5feDn55JIZVJMDqNq9M4ABv7No2qSd3VTlxuYoW3DdgkEfdyexDccwzJJkT27CO8gRkikZSsTxlcNbzhXHmQyljsIy0bkMpJyXa0fNu21dPZtWs1vtv3dmuzUKbnT9lzuPSnJv4Nm43V5KL1vHePxJ25kTX0MjbdkX2lUEe8bzb3MKhHX9xcfxKAT+7lVslDyrDmwssUdrFITfGSPafsv2NWmIAVmJkUtFnIC5fGBtZgHBaqNtdLeRSxlWtp4jIl1buVMsO5GAZWTDPC5LbJQ20qMgjI26Fqkn2ePzGIk2fvGy2CVUoiqGLSKyr99XyThsqVwKtPmaa1TV3tZP3elk7pPZvTWK0RhU5oQUazcnGSSSb2aUvNOPnFK6fXcjiE8oM86rbxBt0VrLiQllCET3D5xvB2tHAp/dbs4LDIsyPMyBhKmSV3qwd1ZQ4wgCt85AcABANoDKSozSeSoZ2KlnLFQdzsicqU8oblI2kEZO7A3hWyciMIrSK+wM0O+ONizb8M6BnRRjrlVU7srwcsuRVRTsk9rK7dnd6L09FZrt0azcouS2ina0YxTttJtJu/e75m767WZKLpJJPK2uGwrqzIvlMAE5EoBUgbtoUHLFQASeCyOKOJ58OrGedp3QhBtQhVPlKdpCAHIDD5WAU5IWnRIYtygmQFi6gbgIwoOVDsWGEKoQowMtuHJwbUcMKbpEU75G3yMS7EglejEgCPAAK84PX5SWNRu3rq117Xte6a0Vnvul2ZlKUYrTm5XGKcfiUmmr3bS5X6b6dCMLHKCjjMRTliMArwQELIMkZBZUPJDfMOtWVjQkoQnKdeFZVAO1QMkhlzksRnCgrkgmkZ2BhQIxDgncoHlx4aMZ2kgFjgkKWH95eppXfyFSTY7hmESoqhmlLlTlY8MOjFicZVdxAIPG6XvK6dtFotkuXVpt7XtfVraNtjF7RSl8TTSW9k46xu1v1V7LRbtXniRNqmPnC5R1+fzBsOV3gABiWwN3zZ6dOLdvBE0sdyYjHKAY4/M2F1jdtwjUABDv3sd/wAxO4oeQM1rdzIg+zBYlVmjjMybdjRFN6CEPg7xlg4KxhiSoAyK2IVKYG35ozhsAgbTtBYj5iAcMFBYFV+UqACRtBXcUkrWT72b5bNLRd+W9k7XWqZx1qjg5e89bc26dny6Ps2nZX02vd2ZejgDsowAcZAwuM8DhQrHaoOSuSTgHk9NGNUiCvK8cYZlQNJgL8zAKuSDgEsx3DAIwKr265ZV2k5XJPBK7goHy5wDxgAckcrnkHYhRQu0qCNoXOF2kEIANvGcE7QwP3mwecEd1OLckk1d7vzXe/y3srtt76eFiKzUdWmlolpeKfvdtN7K687pWZZt7dXdQdv95QdoPQgAjHLHccjgMFAHIxWxa2MkGoLdx4eCUBJiuFRHysePlcEDIDqxDYywOdwFLaWpf72ASQwY/ewNpC7mGc4K5OMHBzjrXXaXbbZUR1LxOuHABICkgfKRgFhncpwSOq/NuJ9fC4dOUbLVSjd6f3b7Ptu0ur1s9flMxzD2cZO97qzS17elrNX7rW2jdui0fTcbEDb1JX5my2cgElW4Bj4XGOAAcYIYV7P4b8PpfNCkiFuYydhJI57Aj5htGXKgLgZAxiuK8N6bKGjgdQYxxFKTuKqMsFk3YGHKgAnBBJB5DLX098P9DZp4AyKAhUENj7pLAlSAuQx28jdnJU9ePt8ly9VqtOm4PWUfO601vrr3W+x+Hca8RfUcLXq+0jG0HJSb929uzdlqrW6PTfU/VP8A4JU/DDXpf2ivCXivS/C+jeIrTwZb3usaifEX22HTNNlls2tdG1Fbi0Rpo9Sj1CSM6ZiJ43nWJ5sxJIU/Y7/gqr+z/wDtS/E7w34PvfC/wz1vUPh5oC3V/qFpps/9vTHUr+ci31sWlpIt+y29tJLFMs2nM9nHIZ0ckeVXv3/BIL9k4eD/AAV4e1HxBpfka54mW08Z+K/NhKyWdk8YbwvoUrOpdGit2+2TwMcpPc3sTAtGCv7i/tA+MbTwV8OdRW3MS6jfxxaZpCCOOR/tVyBBHJEjKyn7Ou65IKkMIyT1+b08+4ohk/EmT8O5Tl9DHYmpCNDGTnUqU6kFipRVoSg3CM4Qu5TlSmlTadnHb8M4M4Wrca8L8ZeNvFGeyyjIOCauJfCFKeHjisLmNbKaU6mMxNajUqUpVKVfFTjhMI6FanOWIimm5U1GX8BHxN1a28Kac9hctLe/D74PfD3T9P0ddX0eaC91mfXrrUdT+KV9st4x9m0/xf43t4/hhpGszSi1utOtdeFhIJ7ds/jLZaXe+I/E1np1hbp9v1/URHBDGm2KJ7uRJJZfJiUeXaWcbFlVF8uJVldQFiXH7S/8FN/2ndR8fePfHnwW8LLpqfCbwtrek2dze2KrFqnijxP4bOrvef2lrCW8ct3oVjrOq6mun2nmPBCtuZo/Ml8jyvAf2Sf2OPFfinw8nx28b6Ve6R8Lb2XVE1TxtKHt7Pwv4A0nzJvF/iefNtdrFPrywy+DPChVka51C51RoN39nuT9Lm1KWY5jh8PBP2OHX76WiUVzRV3LbbkpRu0nK8tpI93g/jPExyGtxjxTOODxWeQwTy/ATxMq9WNH6tCeGoJSjCX1itOdbEVMNTi3TUo04uUoNPjfi7Jb+B/gH8G/B2l6dc6UfiXq2p/EXWLi6vojNqvhfwnPceCvh8qabBLJOml3UyeKPEVrNqaWt59qv3C24gijYR/BbQN0E+tui+dIfsljlcZdwUkkUZGNqttyvzKx7YJrjfjn8QLj48fGrWfFVhpUWi+H55tP8O+BvDVrCkNr4d8F6Fbw6V4d0qCGJIkjeLT7WK4vmjRVlv57iTaEcIPvX9lj4Naj8RfH3gzwBo1s0sc13bwXLouUjXeHvZ5cLjy4YRLIzsSMKFDbsA+dUSxeYOjSbdGLVOHO7qNGk05yTd2o/FJKzUU5LSzP0apntTBZBieJ85hSoV8LgJYqrRgoxjSrTpRWGw0bNqdWjT9nQum3KcFLrY/ef/glR8Af+ER8C6l8U9YtAmpeJ8aboskseHTS7d83M8ZYZAurgYBB+ZIQQfm4/YJisSkBgM4Gc4IHoemfTnJ+h6ch4A8J6X4F8IeHvCekW6QafoWlWmn26oqICttFGjSNt6tK4MkhP32bewxmumunHOGGCD156nA4I54OcHPJweRivn8yxKxmOk4v9zTSpUI3+GnBqKa85fG3r70m1ufzL9Yq1IYrM8VL/a8xrVMXXbesZVWmoK99KUFCkkr6RTvuzNun65xjPsd2CeCc8k9ug4PJzxzt1KMN8+MZxk5z1GecngErwRgnp1rVu5NvHXg8ZPQk8Z6Yyc5+8c5zwuOdvZeDjblQW9ifl6cAYz93nHIAwCK6MHT1jpfVJXtZ7PTSz08rpo/N89x38RuVnrprqrRtdvb0aV2kZF1IMkKOgIbnoAeDjd1/h5BGQa+dv2gviJa/Dj4f61qksqx3MlrNHb7mCkMVIJCg/KQWA57/ACnJbj3q6k2pktgAEZzg4UHlueB1ycAAHPc4/C7/AIKSfHVDcN4P0+9UxWquJkRyE3KGDBgA24kg4U9/TOB9bllKHM69TSGHh7SV1ZOatyR1au3pdWfup23Pg8uwFXiLPcFldHnk69aKqWTlyUIyj7SV7aaPlT/vLtc/GH9pT4n3XiTXdXvZLgyyXU8+XZwcqzMef4jz26HPygkcfmB471h7m6eAOSAXOSSeSTgE56qeq7eGBUEEEn6D+KPic3E93KZCQDJg7gcH5guAA2CMMf4eOxYZr431e8ee4llc5LMzHPQfMcAdBnoOhYkkdSpHwvEWPeKxMle6c2kr3dlJPXy2XR6JWVj/AFL8JOEqWU5XhIU6KioUqcYq1rWS173Wu6utrbGHdOzMFzzngZXJYjIAY4zkgZxwyjBzg4fY220GRiOcgYIC5ymDnpjI7dx65FU0BuJ1H8JbIJ7ZyrHknjAPQANwDg5rqIrfKogUEgdR19BzjnPXIA3cAjnFcmW0VOSqfZTT6u791NS30ulr919D+wOFstcYQqSjfl5bLZyatrp30Vv1avB5IY5IBxjAIPBGB0JyTjHJGByenTcsLB7jBVDhVySByFBHDZyemM5AAz8vQU60snldIwNzHA7jqRkYI5Kg8ZzlicgDivr/AOAfwF1r4i6jLYWdpMQ9vJJuKnaCqOVwcYGSgIBJblioXJz+lcNcM4vPsbTw9GlJQScqlZxtCmlFSvOTVorTVuWnV3dj9p4eyavj69OlTpybnywdk7py5ddNU7rdtpJu/c/N3xVF9l1a/tipRllKgZJxuQMQT1PqQe3fqK5+1QeZEgXgbRhskFgBnPUAYHbhQT6NXrHxo0GXw/8AFDxPok0bRy2F+1rJGQB5ckJEbgrhSNsiEZ4yc54LGvOdKgFxqAQAMUl2scKCBuAPAByR1xj72T0xX5LnmHeGzjHYN/Fh8biMO9rJ06nKnve3u30v36H4p4iOWGxlajJNfVauJUk7ack0tLry1T66abHU21gXtyzLjDKqkjIIwBnOCT0yMZHQE5zWVe2JIbtgZPUZwVPPXPTg4B6Z4xj1GPSmj05SRySCScdhgcAE475GcZzxwDzN5ASWQjPXB+YkdOvbDZPLE4A6Y4HHKFklaza1eis/d3uubezberdmrO9vxTA5xz158kk1CqkrW6NJ6Xs238tnbt5VcRNGcEY5xjaAVxt44DYx1PVgDxnPDoOep4UYzwF4AIHB46d+O5JPNbmoWW7eVGNvXqVY4B4B6Hg4AzzyGBBA59N6SYwMDIxzjIII7ggcAAjPTua5oNwmttZK7Vkr+71ervuml67n6rkuYKrGHvLVR5k9f5dLq9uqfZJJ2vr1OlXBjlA3YD8YOCOT6n0HqAOwyOnqGjTqsi5brlto74PvgEfLxntjOMYHjETlXV8988ZOD8wI49epxk5HAUCvQdGuiyKwY5AAIJzkHnI5z8wIO3JzkYypr63Kq6XKr+8rJe7qrW731Wlttdtz9RynEXpqKlrFRknpq7JNPu7Nau979tT6v+GfiSXRdbsL2GR42injcFTyNrZP3TnHCtjO7kH5eQP6mv2Z/H0fjn4c6DqXnedcRWiW9yMqx3xKF3McgbiAGzx1I4yDX8i3h6/MUkThsgnoSAQTgnCgE8cd+uD/AA1+8P8AwTo+LUbpdeC765GXC3ForuOWUNvRMtyxwGIGO7EDiv6r8Ks2jjsvx2TVJXmqaxWGjd6TpKPtIRTe0qbbtZL3Vof0B4ZZ08Pjlhqk7U6yUVFytaV48t726uyelr9D9tbCbjcx5PGOSTgDqcYOMAgYz1CkCuls5AysrEADKgk8MDg/QcjB2gDjOM8VwVnccKMjaQCWJBx1BPXqTg5AJwCo6HHWWUu7ZtIUKACcA5GMg56k54B5z2x1H0uNouLlJR1XlqtrPvd3dr7b+v8ATdGaqUkr83u7eSS0013d/no9j8+P+Cg/wd/4S/wAPFWn2u++8Ps8sxRAXexlyk+cAMQh+cemGGBnNfh78KPFmpfDf4g6LrFpO1vcaRqkF0jBiN8UcgZ0cqAdjIuSAckZDYHT+sTxh4asvFPhzUtKvIkmt7+znt50YAhhMrKTjB4BIPPzZGRziv5df2ifhrefDH4la1pRtzGtpfyvbyEECS1aRpIWDAZZVU7CR0+6wwFNfGcW4RYvLcPmUEnXwbjhcS18Xs5NOlUla+qScG72TSitz+QPpF8EUswwlfEyw6lhswoVcLiVyppOcFH3nZ2bjbvy8ujP3f8AEOtaH4lg8G/EKUQz+Dfil4e/4RnxWmVeFJLy2jt1nnKAIptrhlnDM7MBbSlRk5r8s9L1LxJ+x1+1Po+v2bvFN4F8ZWt/DglU1Hw/NODLGeQkltf6ZPLCy527J3HK5I+lv2OfGsXxV+Bni/4R6jOratotumteGy7ZlV4CJHjizn7k0YUIAdySMTjNcV+0p4db4ofCHSPiZFAT4x+HVzH4L8dRJzcmzikZdF1a4O0sR5cX2eSaQlS6bWIXKj4rBuONwtXBzSqTwnvU1JRk6mFqqLS1esfig01rZJb6/wAA1OG1xX4a51wfmF6ma8KyxeDpX/jVctqL93NPSTcaTp1YvaDpzktdD9Rf+Cofwi0r45/s/t8T/BcUd8upaFpnxN8Iz26rI8t1Z2cM+pWsZTJ82/0OWQyIpO64hkJBYEH+Zb4W+PNY8F+J/D/irRLuS11nw/qthrmlXCMysl5ptxFcRoVXBwWj2SDhZImMb8HB/pX/AOCb/wAUYf2gf2PvEnwn1u4W/wDFfwavJo7K0nYSXE/hu9+0zww+W4LmGNXv7IgErse3jwOM/wA537Q/wzn+Cfx68deBjbtDpsGrjW/D7OAEl0PWHN7aCIn5XS28yS1faePI2llZST5ME6WHormbrZZXWCnzP3pYWUVWwNRu13ak3RnK/wAdPl0aZ/nnwDReW8Q8beHOcU37HFvF5tgqNSLUJTqVFgs6oQhLRU51lSxtKkkv3GJ59mj+6/8AYA+O2kfEPw1o1/pk6f2T460Cw8XaRCsqsLS6uQbfXdMJAx5un6rDPBKoycoxKk7sfQX7W3ww0rxn4L1B9QsEvdMvdM1HQ/EMDKrC60PWbaSyvInB++ESXzI2OfLYBxhskfzUf8EbPjzPZx6x8Ob28cah4Ev4/G3hiFpMPc+GNauI7Dxbp8IY8x2d89nqCqgIVb+5lwFDE/16Swad468GMPkuLTVdN4I5DxywfKRgZGdwIzyCc4zX4txxGXC/GWW8SYROGGxsqc66itFNOMa8HolrB3WjvJNrY/afB7JZcfeE3iN4F5xUU824TrYmtwzUrv8Ae/2fWk8dkmJpvV3oYmPsanK7QhKNN2Wh/mb/ALVPwe1T4VfEfxt4F1WJjdeFde1HShcSoEN3ZQymXStSTcoLQ6lpUtrdoRtXbPuBAwW/OfxRb+X5mQQ5d1GQVONyKck9s5JbBPfHKmv6tv8Agsv+z7NoHiTTviVb2YX7Q0ngnxRJGgXN7p6TXXhfUZ+hL3+ktPp3mE/8wy2QuWcCv5ePHlmbaa42jJDFCOT824cHlTgY3bixIAzzxX6Hn9KliaOHx9BKVLGUaWIhKK92TnGMmotX0Te6aWmuuh4fg3xBicZgaeBxydPMsrxFXLMyoz92pRx2AqLDV4zhZcjm4c6WrUZxurM+aNZgCM6sUjyQpLgkRqzL85PJI5xuHzDGSCOa4W6tzGWUPGwGRuTJjbBQGRQoJwcgAk7lABIxkN6NrUPmOyghSwyWYABUICknCsOSzYOcAbSBnmuAv4nchRkxhgSmSCxyoZiRsVeVIGBn1BNfm+Ki4z6LWz6ttKN9d7atNPZ67n9kZBOUoQd9Wkrpp8rXKtbddte+17WOdl8lSoaaJDjjMmVJO3hiBgs2f++AV4PSWKFpmVUkjfDhlClD8pKEDAU4UkggsRwOitgG20G4x28RC/MpURoGLAbAVThvvZyW6EqNxA5ro7TS7UMiyRLc3MihUiOwRxhtqKzMNjs2cqFI2ntuA3HClScpxSu7u3wp2ty+mn93vffp9vCqqdBylKLjFWd3ZtJR0Wt33tbXv0ItI0wTSLIyfu4dpZinEjKF2xozqoJ+XuRjPzDClh/Rh/wRm/4J8Xfxg8X6Z8bvH1hPYeFIPt83hYzo0MkWgWFxLpviXx1E748uWe8DeDvBFwiOz6y+u67a7h4RLP8AmV+xD+ydqn7UPxk0HwMTf2PgXQol8UfErXNOgaW403wrBeW1kdO0yIEpceJ/FuqXdh4T8Iacwzea3q1m7L9ljunj/rV/bu+PPhv/AIJn/sax+D/BkGj6F8ZfiVpVr4X8HeG9Kljlt/CdhY6Wmn6fZ2bJunl8O/DLQHjtYbqQs2t+IpLnVp/MvdcvTX1WU4DkaqSilVmpexTXPy8vK6uItrpRjbkVm3WcEr6n85+LfF+YZli8HwFwx7Wrmmc1KOHxU8M3zUqNeUYwouUX+7dZJyxEv+XWGjKUrKpFr8nf+Cxn7Ww/aK+NHh79jL4L6lZ6N8IPgziPxZdafIIPD1nqXhywB1K7umhHkDRfh9ocTwQxgtG+rSOqK84t4z8TfGDX7j4ceAvD/wCzP4EsLnT/ABv8UtC8Or44sMGHVvBHwce5i8TeB/hfftuLWXij4lX/AJHxh+MDuVngsz4J8JXaiLw/dW8mJ8G/D+j/AAK+HnjL4/8AxWtI9f1bTtS0q7l8Pa6olvPiL8YtajPib4a/CK7R2kmu9I8OwSWvxu+OeQbdNPfwT4P1MCTXZopOW+GkPiGCw8TfH/4g3c2v/E/4oapqtzod7qZMt7f6jrVzJd634nulkyTHctK8sIwIoLKOxtYm2TAn6+VFKEMJTvFuCde7blThF2cG9Pfk5Wlrec5VJtWcT26eGwnCeUYLg3LVGphsqq4etnVaMFF57xRWjTqxw3NG/NhMs0xOI1tGqqNLmaw1SB0Fl4PaaXQ/g54VPmxWlxFP4o1CGPAu9ULo86sRlhb2WQr25Zm+1JbwANPEzD+wT/gnd+ytYfs+/CDTNZ1LTFtPF/i7TrS4kjkiC3Ok6Gw82xsSSd0dxc7vtd/gAtPKEbJjJH5I/wDBKn9jweNPGLfEHxvZPdaF4eltNY1U3qMx1DWJH+06TpDyOQZW8wLqGqgnG5Vt2Cg7T/TrfX1rpWn3V9dSQ2ljYWktzcTSFY4LW1to/NlkZiQscUMSlmxgADgBSa48ZWdKMcLSd21FStbSFo8tNed7c2zSdtpNv+dvGrjWUkuEsFieZ3hic3rQmkqtWTjOGHdrN3bjUnH4VFU4ppKSPzb/AOCnv7T8f7PnwD1LSNF1BIfHXxIgvPD+iLDIFubDTTHt1jUlCkugjgl+ywvx+9nDKSUyf4etYvJfEXiKe7nlMkUUzsWbkPJuLO7FjgEkM5ZsjkAnOA36af8ABTT9qe6+P3xs8Saxp15I/hbRJp/DPgy281jHHpNjM0LXqICAr6jcRzXT9DtkUbuOPjD9m74UXnxX+KPg/wAHR27tbarq0V5rboD+40PTgb3VpGPIUPbRNao5IVrieOMAGvdyDLJ47HYPA0k+aVSEZSumnOcoqcn0tGK5U9uWPM9G2f1J9ETwqqYXD4XHYjD3zPOa+HqSUornpU6jgsPR1Wip025zS1VWVSzstP3b/wCCdXwkf4f/AAX07WdRtVi17x7cp4lvmdcTJp0ymPRLdiyh1WOwC3JXACSXkwIGRjyP9ovxFefFX9s7wn4R0mNtU034F6LFrkWmRktBf+Or6Szl8OaW6gHdNqviu+8F6HtALH7RKhGVav0u0+bSPAPgvVdeuxFYaH4U8P3V9LgJHFb2Wk2LyeVHwAFjjhCIuOSEx0GfzN/YAeDxL8S/iD+0h44Uf2da6544+NfiCe4OI08MfCGwbXNJt/Nk42zfEfW/AqwJuIc+GZhHzC4r96zNwwtGnQw1ONWGGpxjChzKLq08LTT9knFfHXq+ypxUU3KpUSim5JH+uHFGEp4TKeGuEME7PMcZg8JUhHSUsHhXGri6jSu9YqVSTtZ8rtdtnjv7c0Y8eftd+A/2cvDt+NU0X4M+HPhx8DbaeIfJcano2nxXHjfVpEXeDc3nibUtZvb5jkSSwpI5byww/sJ/4JL/AAstvCfwa8S+PxZpbr4/8QC00ZhHtK+FPBcP/CO6EkWAQluzW15PEAOVmDDO7Nfxifsm2Wt/GH9oP4lfGbUI5r7VrnUtW1GxYoZJZ/GfxM1ifStGgQkf6+OK71CdAPmQW6Fdu3A/0N/g94L034N/BPwb4Pj8u3s/Bvg3T7W4kCqqGWz02OS9uHyVXM1wss8hOMsxZssTj8u+lLnD4d8O+F+BcNUcsVnOJw0MXKnpLE0cqhQrYmcotuU5YnMquFxLcledSUpScpttcXiDj5ZV4cSwVBNYnjniOFGior36mR8PeydONmnLlqY2phXGKunye90T/Fj/AILJ/tAf8IL4N+Id5ZX3k3HgjwLd6XoxWQK6+L/GzLoelPGM5MtpNf216cZZI7CVwAUcV/AV4z1SMyOqyrtCFSA4IwpwTnHzAnBJwh+8F45P9JX/AAWt+OUviF9D8MR3CtN438Z67461WFmBddG8OCfRvDsMq4JEU1/qmoSICQDJpgwA0ZNfzFeJp1kklOyPGT83loBnJIAzxjJ+7gg8d8Y/R+CMnhwV4XZHliSp4ithadWv71pOpJJ1lK2y+tOvNN8141E7rZHGUf7ByfhvhWkoxjkeR4WliYp75jjFHGY+ei3dWrFN23jbojy7WdQhIlxMgbJAJcDOGUFc43BQc45PAJJLDA8x1K7iy7PKMsmQvmAMAdg3DOQflDZAZQm3cduTXb6wIWDgQQ5LF8+UuCQW2npwMnJx0yeecr5nqSo0jloIgoDR/wCrHQfNjCscsTk9CMDLk81+TcRYvnqVHfu2mt9bu1uzta/RPQ/C8ZJyqN73k1Z7WTilrbRJ6Wbs7a6XOWvbsDeBJCxcHbnYSwPy/OS3KBSpDD743E88jk74kQsxnQBTuDhkVeWB27lycehG1SAwyVO2tvULa0ZQrxrnkrtdkLktlQFViWJJXI6MV+UDABwLmwsSu0wKWA/jaRhzkHIONxPXvuPRcDB/Is0qOc58jV46Xbtq1Hqtb9bWW3W55dZycd1fyfLZqyVt27W2aV9bNo5a5lmu5TbW7goB+/uAGAT5huRGYEK44CozFuCATxUUYiSOWKAFfJUFhlQSSoPmkhn3uxLCRtjFGI+Ztta0ypEgjhVUjXJCou5cnqDgfMecHOT1OScVjyqXSQRyNHLhyjqGygOxmXaCEYOTgq2cEYAGCR8dWi1JylJTm07tb2STtFLZ99NbK7V21yNW974ndO6jo9tNraaN28lfUryOgkVpJXWSQAvE4PkKxbYedqeWQFyrOgYkllIXAqOVhknaW4ZiBnIOAc4xyewb34GGp8lvG37su+JAvnKo2GaRWVizucsoBJyARj7o4UboroyLhVClsKGO4MNo6lcvySEYBhjkgcg5rzZuUYyu9OiUm76q6au230Tta99Nm020tb31S3d727dUu19dfWGJMRfMWLZG4l85GE45AI2gKOem7AztNINpDKCFGScnOOSgAI6cfL1ye6MQOAEltoYFQMBNrAkqxA2lWwVH+8SecZChaaWjRm85hxG0wijAE0qjCgRqygKAxJMkrBI1DE5fCtxydu1lvd67qy30eltldaXTsZ81lZ6JP3k3rrba3dtaNdU7LQQschUBMhViFYqBsQruldmG1IosqXlxtAKgKzkBseOzMjtNPN5yuSFbDJvXCFRHGSrQ2oIyYsGWQr5jkghaueTOsshkmjaCVkmMatKN8kTOUGSUEccajaFRAHfdKCdz75XPyMBz8xwvKZztGcZYAIMktxz8+ADgcdnVfNO6SbcYPlS3Wr821tvfSz3OdtyXPJK0VdRb5W9Y+89NU9dk7/Cr31p3UjQxiV8eVvQvgAOP3g27RIwBQqx3KRgkfdXOKUIyKWUgl3ikZclgA4Xcu3ChQAoKnPJBGNuczBF2jHJYA4KoxJGSgdcHIUuGVQe42nkmkZC+BnI3BjtDjcwJbazA8j5lLYOAoGMOpBlwtNz5mknGyS00sm3te6dtOl97cq0ja6bS+HR3TsvdV7+6nJpra+l7O2hGEADJ1UoclTyxOwABlGOQQSpJQADaw5Jom0bUkkjjk8mztmEc12rAmWdCga1tcqzuzqA7yPtiiBCsG4jayqmcEbwLWKV45pUc7ptpU/ZLSQBWB2qBNOoAixtRfPIVLBIz5aosMYVhFFGHWOBBlAF2nBXBBZiNzY8xmJZyckvar+Snrfl05mrOyelkrO/VvRN6XLKSS2jtJprVNxSSbV2lqk181fluiiONUgtkKRLmKOJSW2jJUHeDy7A5eRxvJG4sSeKSXbzzSRWHklIMLLfzJ58TOGTMNnEAiSlfmLSPuQncFDKVdqslxLqEj2ts+yzw0d3epktMPlMlvasAMpwd8mMyBioO0/vNOC3SCNYIMKEB2hWJ4GFJLdSzY+dhwwHzENxUe9JpQfLTVk2nbmso6Qd9ILe+l7aaMG3OyTagmk2tObZaWduW66Xen2tDOayvZHeRtUuPn5c7VVS7NkLtVkVAwAGFUqBgeoqEafdn/mKXBxwAynAX7oYjzMk9RycHgHaTtrXeT5ggYLgBshsjcuMjruBJIJAOMEAHJqMSBwDtZSrIm0nJyMDJJJYqpIB6HkBhkCo9jTb5eaVm4tfvJc17xWt5X2T177tIUaMXqpT0S0UlJ9LpaXtbXR+vcyZ7OZYozPf3DoxCHa4UqSNo2gkMWAPy5BONpyuBVZLOdlSRdRuEG7aoYMWVSM/MiyA8jGCBs4zyWNbEjLJIygAhDmQEkAMQq5UZ3KV3/eI4PU5K5idfLViquW4wuflKKU5bLAlQAoYAgAfeUg4qXQgm5NNxVtVN3fw3d1frfRPW1tLat4aKd+b3bPRPVNcrkuztt08n2zzbyh1gfVblJMkeWyMCRu8vC4dgzdcLzgLn7y/Ko024DhX1CZUbJh2hwXZmAG7fLgAkMSAccLtYM3GosQlaOVgcxwny97tlQ7BgwVcDBYnaRyGBIbacVJkcbhJhJCgJYLt4xvALddxJbkYAVRySS1hoNXblurXqSu1pq/ebu9dn22NVhU05Sk3ty+83e6jro1ZvZei265f9mXB4/tO464CkOCD02kGYlj04HUEDaCrZVdMuA3GpXJBVSSA+QPlIBYyMDngAEnv97jGi3mEsiNtUDJZskZyoyARxu+ZVZWIHZgeDJEwaMDIfkEvkgs2FyTgt84IIx1wB1I3AdClflal3fvySsuV2Xvc2yV9G99VuR7GHNbW+jWvxW5drvVp9LNK+/bO/suZhk6ldds5HA+bkDD4zypA3cFSrHnbSLo8h2l9WuwNwyGUEFSwGTukwwxnAI4I5GdobUJJweRgkd+dpAC5IJGSRgEEdOjfNU6NkqRt4ZRkggH5lG07iTzjKkkHBGTuHGcsPSt70ZdEv3s9lbVu/pdXSfTW9hUY63bdml8T6Wur6Jb9b+VjpbRyYIHHK+XGcdVztBOMZKgqoz82QTkBlLYy/EG/7AjoAUiv7FlU5yo8zoyqMKCDkBjtQEMnyblq1p7f6FE+flOAqMTkKrbSSTsUoXYnhWbbjbiqPiBSbKE7thOoaeSBuUgSOQNp6NggspbHAIGVxnGpd0m9do3fzj+Oq9fkz8zw0eXHU0rX9rZLpa69el97b9VqbMRLXE+CM+Va4jB3KpLXOMKu4lO27OfXAyA+XJABjJIDZbacA7QcsSeSdvXO0A5bIPManDzk/887NFK8YYyXPcnc2fQYDk5BxyXsQ8b8Ywjgq52g/KoxydxIIOCPuYKrggNWis1psr/dfp823v93Xjf8AFWjteCXlpHR/jp2fW1zG0QlNO0oKAA85I4znmdRgrtCncAcHLHGVZiQDvP5hViQdwJBIBDbVx1Z2ySW6sF+fG1hu4rn9CZ/7K0rAIAnkGSN3VZiNpLAj7wJ29Tux8xG7fY5KllK/KcDO0scqAS2Sck8jAXKj5udpqaWtODWjcYJtdWoQ20sv+H1N8bZYqrd3tUqu/X+LJpdL7NdtbmVCSda1AqOBp9gDyRgCSXBBIyQvPBU8fKwwTm6gZY4GyXBtoAw2sSAFDHCjaoXjHyM2N3UjArNibOs6oQpyum2igFM5X94WYltpGeuTtPHOSedUcrCCNieRCRgAAHaM5CngHI3lcDJDcA1MFpe6aUpLTT7S087rbe7v2LxF+aCVrOhhn3v+6hrfW1n10tpZqztk6sGddMwFGNXs+WCrkFJMBdyBlBAyAQwPOCGwtaycxgoWKeYzvlnY5NvAxA4+7neB2ARdyg7sZOrO+3SyqHnVrRQSQzD93IvAfLAM2OEXgYcHJGdUCZQqysXZri4bcAxPlG3gEILAKpPlqAw2BpFDcYxRTdpTsnryauzt7t/v9Ni6y5sNhbNNL2nKrvf2kE2917q11d721uZmsEPpF46EFDbSgEsCrMqAjoNoJBG0MN3Hy5Aos962VlhQwaztQSu7bGREp3HLbGOFyQxVlP8Ask5bre06ZefLtK27Mv8AAzjZ02gDKgfvNwG04VgeBhdOkK6fZB4+Xs4FEi52sTGEQO74GCN7bu+CTgk5I39t0X7tJta3fMrRas7K+zevyKa5cDFxXMvrUk7u71pxu21e9tLdHdWfQg1DzFgvQGZ0ktrVhwNqMl0sUu1VZgynIyoUgkEkhSAbenuDaWpD7mMQUFs7SyuVBJc9GIZlPLABgcqCBDfOstvdZOPLsxyBgELewEMxICvgrkAgDgrjcFq1ZRD7Hbg7dgR/ugA53uADsGd3ILjgb8sMYBDinGpJxad4tpN3TTkr9Wnva1tLLZKxM5f7PGLST9pHtsoQ1vve3r5rqTq3AUHLkjacMrZwi8YQsFUHadpx0A5NQuF3kEZbacYYrjcCSJCo2gkyBsctwME8097eNmBZcvteIEbztjYEON25cHBTLY3AAYGAMOWM26BYY3lEaqFUOSWBGGJeV9roUVj8wHAABzkm9fsxskt7tuytdfr93zhNJL3vevFWd126uX+Gy77vTWsq+Si+SAwRRhQCdycF1ZtyqzEdASCAOeNtJ807CSJ2PEUqYJ2Mh/1qDZtRixRckkplPl3LlKu+VGQRgBeDkYwrYAYgoPvY4xnjGQRgYgEJhWZEcBJGJQMBtiQxqvlozHcEdgm1QMDGAA2N0NP5Wvo7WaSto9GtOq07dQjODTevPfS6umm1dddfntfyKdpPJcXeo288QDW5VI1+QOYjGoZ5Ao4ZyEZXGAWKhiMtukkWSJpIDE4IWQCRiWDWxDBMErK3zZMbsRsJweHVDU8caM/2pT5c5gaJmUtJmMl3CSqNvzAumGIycYAJBNZ8kwkvZIRKySxlVkWRpFV7OSSTzBFlgZiMoVbyx5fI+dQxqPeSSbUnJtJtr4ZarotUmr3tsbRUKkm4R5YxhByjZL34KMG7Kzak09dNXa2g2WZLQRy3PyNKyJbRwwOSY5MqbZY8H94A7gl4hGwRUVmYItWoUKlfMdRJHFG6kHG2PaHSHO1GLByGfJG8BVI54f5b7QqysqqioMRs6omQy3AErkCRGHJDAtllJXIKRHdGvIMu2CVWdiDKxRi25pNrosbKFDEoCCCxAOWDUbPVJpaL00utdZatXVtLa31RpzKcbQupP4le6ld2VrfD00bfN6M0AzvlMMokXcNqMxYMTjaNp2E7jlehXgtuJFUlkSCTMTeZANxuIolYrHMFUl42JCby0o3QKDngrkgGmxxTSRos7rE7hUkFuAdvyoyKG2DY3BMjiUq25XDMSxF/bHEAkOyM+aCVVBuVQQGlyoZckFA0hGCSQRhip1klKzWjTTW2mivprZ/LX77zSkqDlCT9pGVlKmkuVx0blzJXvF2s0t7a7kquhWNg6mJsBSPmDLnA+6ABjaRuPzLgHBGVM/BVcqF+TjgEbWAU/dDYVcDJUgtnKgYwa0yJEvmJuaL5fMQYJTanNxGpK8rkGRAORhxh/vPikkIVg8UgYKVZARtHAG3B2FQEJY5+UnAAGckbttSVmtWtmlprqndf11MK1NJKpTfNCTaW/NFq3utfzLq1a6s+ulO+s2kf7Vb7lvIW2xschJYyCWtpwAq+RKThS5OwspTJJB0LO/SWINKqWzo/kSRSFVeCYn5o2GXLA7j5L8BlAILc7bMY3LgbVwoP7zafmIQbm5wOQAGIJxgfLuyaFxZF2W5tmRbmHaAZgTDcABmMVyiNGzxkkmNihZGBcHbndSUo+9G2tuZPZu0dVd2vrs9LaN7GLlCtBU6ujjpCb6bXjJ78ttb7RvdXSNh1MuAdxbIPyliei4w20g8/xBQrglTghSsfll253EAKcjcASCo2sx6hdpD7Qcg4YFsVjyrqU0ag2SwsM7ng1J0d9hPBPlb/ACtyKzKWDADYGHGZhc6sHbdpsBiJCAJeKSgBAAMjjG1irMqsMFwWY7lIq1JSe0tLXai2t481nZadb6vpYxeHcUmpwcvtR9pBNx91R+2+Zu7fRLzNCNss4WJ4wGKszqFXcoRmMKhg0p4cbgdwKEnnAFqIv/Gi+aEUkKFwEIXDcMfvEDdxtPUAHOcpbm+IA/s1nUqqbDexFTtIzt+TglcgknPYEnBqctezKqPpjAR/cAv4Y1VgV7xqCQWQDaSR1GQRkaRaVnq3Zackl20V12366/NZSho9YLVX/eQdn7q0bdn/AMO7WsneyoeVmKtEHVpGMbBFjXYdyuBgKm3K4UEh1LnOKsW8SStJco7SfaIh3cABFjYPGm5Gj+b7+9TIOdrFcCs6RNQmiMP9nxbGygX7ZDkxYB2bvKyYyeHBO4E/KcqMXgdSRUB02NU2ogVLuAlR8pVclTsVFyuDkgEEklTW0Wm9pWXaN3zaLqne22t7t201Rz1F7qtKKeqaVSnrFcvRyb969/htp3bLds32wJLEJoYi7IXEYiaUr5e5digsFALguSdwO773yrpW6usjKgEkZLHzAzuVzjdEpchXdeeSeGyy5QkVRRdQ8sxrZQwRSBWIS5iTdt2sEDJGCAcMxIPzksylSWA0LWK6wwFquxflZTdqwwwUMFbBGScpvOSNw25JFdVOK926abb95Rdr+7dL3dtOi16rRnl4ib9+/Ko+c4uST5dW0023bZJbSvdLXZts5VN0WABwpRpFBKYLABhH1+cHqCCDzx0VnHk7QvKlcOAAuPk4y2eueMA7sAkKMViWUd0m1Y7OMLwDtnXgfKMFlQFgDg4bcRjOdmdvV2UV3xi3jQHDA+emVO1Tk7QDgjbwT0zt6Fq9OhTbtaLu/Lvbq7Xte10t+mrt8xmFdxUrSirWveSWmlk7d9baX66dOgs7QvjCuSWUkKSfkyM7QRwcjGezAbhgGvRdG09XWNl7spXdyV4Q88E5C8bRjAIYcAGuV0qG4zHvtQ5YKAVmU72+7gg7gThRzxnaM5K4PrnhzT7mQq/kRxAMimNWyAvybmwu1Sx2nhcMMFt20Gvpcvw/PJX1XuvZr3fd6Pre++j130R+Z57jZQhO8o6Xlo9E+1+ZvTfy9NTvPC2iSSOpmIZTllXaARvAAwVALcAnK+m/huD+s3/BPj9nxPjF8afDllqVk114T8LGHxV4rZo2MFxaWM8S6Xo8m7K/8TrVHgt5UPzSWIv5kwYHx+e/gvRTO1uNoUKAZtxVdvABBOWxuHHK/KM4wMZ/sc/4JBfslHw14A8N6rrmnmHW/H0tr448SGWMiS00CKPb4V0hyfmUS2cpvpInyQ+r3QI3wA1+j5dLD5Nl2IzbFXjRwlGpVUnbllKMU4QSlvKUkly31dlo9T+PfFPM814hx+X8GZC5TznijH0MlwUKblzU5YucKeJxU3F3jTw2HlUqzqK/I1GT0Wv7tfs6+CF8EeBob+5iEWo62Fv7oFAhhhWNRaW/TKLHAqs0edqSSyBcDAP5f/8ABTn9qaH4d+AfHXiKyvV+0+HrWbwr4LjEmBeeONdie3S5hBI3jRIfOvnbkRLYTbtqud/6x/GXxrB8OvAOpXsBVb4262OmW6gFpr24HkW0aRjBcCRhI6jnylY4O3af4fv+CoH7QE3jr4rwfDLTNRN3onwza5XVZFl8yK/8daoEm1y6kZQFkOkwJFpqvkmKWK/HLSsK+P8AD3B1M1zTNeNsxipP29SnglLVe2qNczi5P4aFJwpxu37spJaxPr/HOphsiyjw7+jbwxUccBg8Dhc44unSbTll+AnCUKWI5Lr22bZi6mIq31U1CpZxlr+afhn4c658cfij4X+HmlGSTUPFGshdTv3UzfZrQs994g1y8cNvaHTNNju7y4kbBLK+3dJgN+0X/BSrxppn7PP7Nvwt/Y+8DRtpF74i0jSte8bWULeXd6f4Q0hBF4Q8K37RrHJ5lxcLLrGrW87SpJqovL1VDXoIwf8Agkb8EtHt18c/tO/ESP7J4U8N6Tqdzb318AILfwp4cka91i7R5QyNJ4i12xg0uEF1W607Q/FNkpxOufzX/ad+MGtftH/Hbxz8SdTeVv8AhI9cuDpNmxaRNP0O3aO10XTYScYS00+K2iIAAkkEr4O4k/pOJmqdOUeVc8l7atLa9WqmsPTb6qFN1MRNa+9Uw8lqmj89yjDVOJeM8Hh4tvJeFWqdGlHWlPMISh7ao42fN7OrClh6T15ZYfGQvZni/wAK/C5mv59alh3x2YSG1LDO+6mVlBAz8xT55CRjYdhzX9RX/BKL4Af2N4e1T4va1YP9q1MyaZ4dedfnS3Qj7feRbx1mkxAr9CI2HBYivxG+Avwj1Dxf4t8H+BNIt2e71XUrOC42IxHm3ciGaR2UbtttCH3FvmQIcnacD+yz4WeBdM+G/gPwz4Q0mCOC00HSbSyVUTG94Yl8+YgDO6WXfI7HJYknknI8GtU/s/AVK+ka2MvRoq6uqas609ddVamnezU32svtfE3NpYrEZdwlhp3pUFDMc3cXZNxlF4TDzSfWqudpvajZ/GregE+XGFB5AIIzgHHOMcAAnHsMYHJrNupflIyDw3Izgghck9VPpnpjgg97k0m0Nk8DjqPXA6dOehwcc4yOKw7l/vAk4JJHU4HT2PHIB6cHoSAfmqMG5J63um3e75mo9o20/F312PyfNcUqdLki9Ix5UtFZKMdflb3e2t29zPupTkknJJ5OcYPQYyc89B0+ZemMY5y8kGNq87s4YHIBGMZOVzyeeoJBIAxkal3J1C7fUg8jPGAc8cdWHXrznrzU8xGSenIPQYABGM9B8vQnoRkDgLX0WDpX5Xo3Fp62vdctt0tbW0Tt5bn5DneM5pSinq90mnso6a6bpJ37adDyL4zePLP4f+Bta125mWOSCzm8ksRlnKEjHTJ5JGByOuCBX8hH7UfxVuvF3inW9TluHkNzdXDAtISVQuQu0bsk9MLnAHQ5r9tf+CkHxzjsbI+DdNvFASOQ3ISTHzBcENtYAjP8JyM+uAK/mH+Kficz3F0xkBw8hzuGTncQccgnnOCANwJIwQB6+bV45fldOjHSrWSqVej95R5F6Ri20rO933P2X6P/AAbLH5hPPMRRb9rONLDtxvalCUeaUd7KUr6p/DbXc+dPHettLLJGSxyXLnJ5GCVBAPOTj5iTgY46Z8QvJGYkHcoy3PHt3yeedz8E5Axwc10muahJcXEkjsWLORksC3BY4GM9M5DAk8dDnNcqoaWXavJYhSAeAeCN2BgcZZeORjDYPH5fJTrVnJ6uTXK11Vo+em3a+jfdn+ofCGUclKjCMFaCgtlq9Nb3etmkl09C3psPzPKVCjHy5GB04ByScH5cdPlOTuJ46u0VjgsOrAAEZbHfp1+6CQc5GCcDg5lrblF2cKDkfKc8LgEnGO46+rdMgmuv0iyNzMkSqxYuv3geTuyQOOAeMksewHymvrsowM61Whh4Q5pTnCMUlf3pSSu9bX966VtVp0P6KyPAWhQpKKumk2lvK8baW3srfrqfQf7PPwY1P4uePtI8PWMEjQGSOS8dQSEQckEgNguVwm5cZAxlcCv6av2eP2WtI+GGmwyPbwvelV3v5algrKQylip6g4JHfI68H4i/4JqfBb+wtNm8aajaDz7/AMuS3MsSh40/eYVSV+XOcnHZkUqoOa/b3T0RkTaQoCgbQRk/Lngj0HHX5eM84I/qKng/9UsowmVYeEIY7F4eGJzKva9XnqqDhhk9ORU6fKpLS8nK+iP6+8N+GMPg8tjmOIp81apJTptrRJJJNJra8b2u9LH8Pf7fXhCXwj+1x8YNHkRYVg8SXlxHFgBRBdLHfREAHnKzg5GRjgZGAfjrwmTLrGd3HmPjBLfxHb8px3GCAQDjB+U4r9Rf+CvWkrpP7cHxGKxKial4a8La4cDgm78P2SO4wuQWkhblgSTuOdu0V+WvhAs2qKzHALDDHO05I4OcDc25u5LY7gYH8icY01HinN2rfvcwrVv/AANwnpprrLVPdNvdH8L+NtFU+JOJacVyxp4vGRir2STqu33q3a61tuj6tttHS90WKSIblVPnA5AIBGBwSpJGc57jHy8HzbVNM2SSKBgKSASBjggBTySDngcEfNjA617n8NrOXUYrjTOHEqM0IPzZOcAL/Dg8fdB6EdTxz3irQXsruaKSIgKzHlcNkMBgYBG1h0HIzyAOa53hOehGooXTSTaV0muVPZ6XbWuiufxlgs0ng82xODnVTlGaqwUnryTad1u0k9G1s0tT5u1OycKw8tgGBXAyCMkYOQMgYHGcseDksQa4K7jaOTaVxjoRnpyRyTznqMdMj1AHumr2YZGIBO0E7m59MDB+YAdRj1znPNeS6vbFWJxzkA8g9+cjnBHUZ9Bn5ctXh16XJNbLTa93a60Wi1ad7dNu1/2zhfMvaSjBtvmsm/73u8rs27S6adTDhclscDAJwevRTxk5B5z0wcMpJPFdbotwVl8okBTwDnGGGT1PucjAyCdowcmuLDANk4+p4IXjdwRkdiRkAEZ5zitizn2SxkE7gwyOmTnIHUnkHPGM8knk13YCtKnVhd3u0r3ve6iuqvrtqr3t3Z+2ZNiNIJtt3UW9E2mopve6+Wl46dD3HRp9hTc4LcDrkbQD1AAXPbgDkMCVbmvs/wDZ4+I954H8XaJqtrP5Jgu4SxDE7kL4IONudwJA428kEE4NfCGk3W5Y3TnOM8dwMNyPQ5GQSVGB83JHtPhPUWtp4X3Y2uhHzAbSefcYwVyCcg5AAO3P7LwFntTKc3wWLpztGFaDmn8MocyjJNO104tx10d33Z+p5BjJYPGUKkJtSjKMk03F2vF6barq7qOr72P7FPhj4utPGPhXRddtZUkivrOGZgp5Vyv7zoxxh85HUYII3HcPZLKXawAwAQRggZ/hA+nB9s43E5yT+Un/AAT6+K/9v+F5/CV5chrjTsTWqO+TJExxIqZbnaygkkArkAjJIH6mWcu0KeSSOmO/TnA4UED5RgZ6Gv6gzenSquGJw7vQxdOGIo2WnJVipct7/ZldPo2mr7I/sjhnMY5hluHrxkpOUIqo3K/vpRTTfRX2sktfS/f2MgdTG5OMAbT0BPyg8+vTGAOmeTX5F/8ABST4S+ZaWHjywtDujb7JqEiLx5bEeQ7lVGNpyu7q2eeV+b9Z7FyAgBJJ2jPp3AYjdkEEnAHOc4xXmXx58BW/xH+G3iLQpYVeWbTrhoCQpbz40LRkHhs7wvJxgnGTuJr5JUKdeVfA1or2GYUXQctLKo1GVGbvpeFRRenbzPK4+yOGfZBjcK4KTjTc4NbxlTSlFpvZ2Vn3uk7Lf+cv9lj4pT/Cr4u6DfSyyJp098LDUY8lY3s7wmGbeOCylHEgU+hOAyV+oHiZNO8LfF7UNH1Lyv8AhXPxt0yXRtT3Mv2SC7v4hJpd+OqBre5mtZVkDbgGJPLcfij480a/8G+K7uznRoLvTb54WGwK4MbuI5GwCRyDu2nIIB5zx+pvhjVT8d/2edInineXxX4cs/sasjE3Eeo6KxmtAX3F1aez835uWJgQ/MQa/H1Ktkmd0o1U4KhVnhcTFpKLpTkldra0J2km9Fd2Wx/mZm2V1OGeOaOPVLlw2awnlmOptPkqVIK9L2ido2qR56V5WvdRu3e1j9iTx9qP7In7ckHhDxHO9n4Z8ZahN4E15JSY7WSHUnEWlX7g/IUjuPst1FIwJ2ebg4zXtf8AwWZ/Z7Oi6n4e+Lmj2Xy6DfnRNangjBEnhzxBKbnRZ5GGMxadqYmsdxOM3GC5BUH45+PSXXxM+FXg/wCPWliSLxr4Iu7Tw148EWReRX+mShNL1aYIFkjMyQovmMuSTtJGXr93bW60L9u7/gn94f8AE92YbzWbvwlceA/HDgLLJa69YxLbW2oSqMsssGqQ6XqqFhwLmUAkgEmaU44bM4r4cFmkPqU53/dxnVkq2Bm2tlTxKnTu76VoK9tV/n59JrgypwJ4iZP4h5PTksJSxEMdWhThb2+AqReGzal7tlOdTLZqok7qMstc2r3b/nZ/Y6+NqfBP4yeBPHjyMbLSdUXS/E0KE4u/Cmto2na3C+B85W0uZLqEHIWeCB1U7Fx/ft+y942tdZ8LS6B9uivRo6wPp90knmpeaPqEK3mlXkUmSJIp7OVDGy5BRVzg81/mi6gmqeCPEmseHNZie01Lw9qt5o2pwOu1xPZXElrJuBxlQVLKxBG3Yy8kZ/rG/wCCWP7b/h9Pg/4L1r4geLdN0Q/DyW1+F3i7Udd1S2063k0fDT+BtWknvZIvNVbAvpEsq7ih0xN20zKx+D41yKfEeQ18DRpupj8uU6tGMY805zoNPliopycnHmppJK7qK97JLnyvNa3hv4j8H+JeBjPEZBn7wnD2fvDwlUj/AGdm/L9Txk1TTi6dDEVKVWU2tIxUYu0kn+hv/BT39n+L4q/DjxpokNpGZfF+gyxaRMyqFtPFmkMNS8O3Jcj90JryAWc0mf8Aj3nlDZDYr/PM+KtpPYalqNlc27215bXdxaXVtMNskFxbTNDdQTIfmWWGWNo3DhQrKwIRVIr+379q/wD4LNfs7+I/E+nfBn4Y2lx4tubrxNp+iar4/wBWgudI8M6BcNeRKt9Z2N1DBq2txQS7SZJI9Ns5EVmjluoTk/yT/t6aX4n8SfEn4m/EDU/C1joeq6R46u/D3i+18OaGdG8PQiXcfDOv+QjMFufENtZzPf3WxVvb8R3TBbm8lLHD2WZ1LgbDwzPCVMPiMudSEadR3xDwsFFxlOmm5UnBPWFTlklFuUVdX+wj4dYvJvEfi/xDyqthV4f8WZ5gaeG5pVKGJo8VV6HNj4Qw06MbYTGOMJ0685xjVre5SjNKUj8tNWBSSdchlbJI42q2SwViCCMCNeBkEZKgcmuBvUdt2AzbWx0G5gMYOSDgADCkhgWIyCRmuy1OQyMxJYYI4G7C4OQQBwAS3A4OMEHiuXmRgRJINzrxEpA6YRlkYsoYoAPlA5Y8ccY+GxCUpPo1a2lru8Utdt7rpddb7f0tkmHlTpQvp7kW3q2leLuk9b2u999FZ6mfCi2yCV0LXTsNkeOFUAYJBVdq7VPmHILHhcqCx9F8D+GtU1/WNM0vTrG71bWNcvrPTNL0+xgluL3UtQ1GeO1srCztoleSSe5uWghhjjDSSs6wwhvMRq5CwsXuZzLICwJKMTk7+TtjjJbGMDr0TBydqk1/Sb/wRj/Yc1jxFrnh/wDaG8Q6ctprWsXWraT8Cob62V49E07Si1j8Qf2gJ4Jl2m18ExzDwr8OGmjEOo/ELUEuoH2+GJ2rqyvDe1qxlNctOClOc29FCCTlJ3W1k7LXW7ujzuPOK8PwtkdfGTkpVeX2WDoXip1cTNWpp9eS/vVJ/YpqUlro/wBhP+CeH7L/AMP/ANhP9nLV/iH8UZtM08eAobnx/wDFvxVcvDJaav8AFPRtMvYZNGsLkMIr7w98GNPvb7wtoyQGWHVPiPqvinU7GR5LDSpF/ny+KnxV+IX/AAUM/at1f4z6vZ2reHrXX5fDfwn8N+KWkHhXRLXTbS+8Q2moeJXZ44ofCfgDw3puofFz4r6iP3baZpCaNzNqtjFP+g3/AAWU/a2tvG/iXwp/wTz+AN/BYeC/Ap06b4o30N6RZm90m2OoW+h65qAOHsfDtok/irxjc3MrNNqCxpelrmCUn8wfiJqE/wAJvhZ4f+CfgW1uG+JHx30HT7GS1S2kGv8AhT4Da7qVtrWi6Vdp8s9h4z/aQ1y0tPiF4wjaJb7TPhlpnw/8MTGKG81OzP3uCoeyUsVUjKM6nLCnQT/eRptxVCnppz3ftKiTf72b0apWPx3w/wAtrZNgsV4gZxONTiTiN16PDqxEZNYehOEZ47OnTm17PD0aStSnJxSpwoUabSxDi+J18WP7UXxc0rwp4XvtWj/Z1+DFrqw0vWdbVbfU/Etneak2r+PPix4tjiAh/wCE8+NXifz9f1OH98+jaAdA8G2Eg0nw7Y2w+1tG+Bet+O/in4E0GDSpFur2x05tG8GpaMH8N6NdyxDwzp12gJEWoa1bJBrWpxsgNrb3MFvKRslMPtn7Mf7Nvh/4Q/CvUfGfjSxtrzwr4G1S2fXYWUeT8VfjU0fmeHfhvZuDi88M+CTjV/GbRs8D/ZjYSYZy1frx/wAE8/gDfSPrX7SPxAikvfEPi++vp/Dkt7GBJMbqWQan4gVGCiJJ33WWlqAqQWKStEFWdM+pUjQwGGq4ivJTxU5Rcld2dVJP2Wj3gvdfRPnbiuXT43M+OYYahmmd0JOeVZJSrYTL6tVtzzPOcZZzqK7vOc5OWLxVVNVFD2cYvmlWifdfwI+EmkfA74YeHfAumJEbmztVvNdvVUK+o65dKsl7cOwwWRH/AHMIbHl28caAgg1+fP8AwVc/axh+C/wdk+Gegal5PjL4l2l3Bd+TMUuNK8KQkLfXBKsTG2pOwsYt2GeMXLDG0Efp9438VaT4K8Oa74s1+8isdE8PaXeatql3KypHDaWUMk0pJfCglUIRQ25mIABLAH+Eb9u/9qDWP2gfi94t8b3NxKLbUr6Wz0GxZyV03w7YM0OlWaLkKC0KLdXCgDfM7ufv14VG8r4qpG83P3FJO0qj5W5Wt/y7TTW1moq7Sdvx3wp4Tx3iTx6quNU6+EwuJjmOaVpXlCtXnVjLD4Z20fPNOco2aVKnONkpo+S9e1aXxHrju2WjEucKeSzFsIMddoxk4yOSApOa/bb/AIJi/BwW+i+I/itfWWJ9Wm/4Rbw7K8YJXTLB45dWuYNwIIur1be2YjAY2LgEkyV+JXw80DUvEes6RounQvc6preo2mm2UIUu8l5f3MdrCqgcnEkgBJ5UZ4CZLf16/Ab4d6f8Nvh34R8E2EaJB4d0WzsZZVUIbi+aNZdQujzkvc3s080jEZPmNnAFfr/AWXPD08Rm9SKThBU6CaunUqK0pK6s2oaaNP30+uv+8/0euC6eDlHG+wjGjltGEaacLReIqLlVl9pwppuy2bi3Z2R80/8ABQ/4gyeAP2dbjwtpcpTW/iXrFh4WtYYyfOeweZbjVVjA+cq9tD9mbauc3ChQDjPzz4xWP9nj/gnv42htytt4h+MGreGvgNojrjzH0Xw0ZfGnxUu7R9oJivfFeo6t4f1B1A50O0SVyUBrE/bF8Wt8TP2uPCXg23VtT8NfBbS28TarYQjzFu9Wt4o9VXT1j+609/ex6Po8KZDPcXgiB3NtPKf8FIdTv7Xxb+z5+y3pkqX198JvhzpK+IoLZi4u/iz8ULuLXfFs8qjBknn1G4RkPLbb11Uc4H6VkWFq5lnuX03GUqNOv9ZrPl/5c5W6OOlUUpbXzSeVUJ2tKVOVRLRNH63Xxf8AanGGdY2FqlLIMDSyjAJXaWaZnUVFzpa29rTXt1Za8jT2R9vf8EWvgSninxn8Hbe9svMg1rxhq/xf18FMgaB4Fjl0Lwckm5dvk3PiBNQu41bJdSsiqoYGv61v2sPGY8E/BXxItvKI77XIoPDenBSUZm1N/s1yyEYJMViLqXj/AJ59RkV+XP8AwRn+Ctr4Y0vx34wECfZPDWm+F/hP4auNmEaDwxp0cniGaIqCD9r1mdriR1IZ5Hk3AsDt9b/4Ki/Gqw8BeHLq4uZ0XTvhv4N8SfELVIiwCz3dvaTQ6Lav82TJcTxyW8SnIeS7iGCSBX8v+KOJl4h/SIyjh+g1iMDw4sHQqRV5U51KL/tPFRnyqSUp1KuHwE1FaulGGr907eIcHSz7xg4R4RTjLLOBcpwLzFX5qXtsJRWc5lOS0jF1a06OFqp9YcstVY/iV/4KRfExfHX7R/jtLW4+0aZ4JFn4A07D7o1l0NZ59daNQSuR4k1DWkJBIPlqG3Yr8oNfucvIAeSCxPCgMOxIJwoBAIAxnaQAM17j8RvEV7rOp6lqep3DXOp6pfXuq6lcvJl7i/1K5lvLyV2O5i81xNIxJByGBzuINfN+tXZ3MQfvBhsx2yMNwcDAAwcng4wT0/pDjfGRwlGjgac1yYShTo76P2dOMebuuZq73bd7nx/G+ZSzLN8fipN/v8RUmk2lyxc24RVtrJJJNbLa7Zw2q3LMxcgjll4JB28KP7xOOD2GDhsZavOtTkb5mUZyCcEg4J5A2gMWBOBknOTkfIOet1K4+YhSeSN2c4JYr8pBAGT0A5PXDZwBwWo3DtHIFkIzuPmAnKkEH5ceg6nnAUqAMjH8651i03Jp3d9NZX3Svv3vbyvZpXPyzFO8lZXvK6Wul3FPTbz0Ss1qk7nK6jLCAJbkiMqw2u7MmGBGCowAMF1LLjbkZ3DArIu2/dyAHaG5ViWdlJ2lQTlW5X7xxhuD1Oa0byXy4+oIJCDcFxIRnaTuDqCGYEncu0KX2kkGsC9kKwswGW+QlCCyojbSwDOwUeituCncpBwwDfnGNqpTnbdLXl0etl7zb5dX892r3uefNaNbbPR2a0jpdvXXzWl11Mp2AkWMyAAjbtYks4DKMqDknGRtzGGAyRk4zRuYbe3jkJWKNcl+CQwZtqowLBiedpClSisoYnIxWgkXmSeZIMOgZBtOPl3Agjr+82t97cRgFWYgrVO8jMu1o3aIkgoyqXPB+4ykhHB3DA+YKrBm4HHzWIb5W4qLldqKcbS5XZeq3Wl/Js5nH3LLrdR7dL6aXd2uqbv5MqERW8DMZWkMvzylneSRpHCBiq7VBEZYcqpI3cnJ3VSBFwsbRNujOH8xcbgx2tsbarEMANrruO1BtTcdxNtYGjkkLyNI8kSruZcx4KNGUWJXChGG0sCm5x8yv8xqspNvElrCgaUligMZSCJSwK3N2No2BtwPbzMAAAZI8qUtNUoxWq11XvQ263d5S11Sd72szmlKyjd8u2976NK1k22903snu2mME4EkkLoxniVZEjCsYhuaAK007Kqx26q6yyA7jsCrv8yRRURiSR9z/vvlytxtVBdujBo5FXyUKWsQCpDGzL5ioruvyoRMyQMmxf3qF2eSUgCS6mADCRmCoyWqOoaK3Y/OQCQoRUVFfOSwKyMXVVLDBBxswTkADO3btyFADH5VDc7TnpJK3NeKbd+VWTv0v0VraeW+Uk5PRaaWveSfwpt2Tje+mr7b3Y1y74A3kAjLENyRgnbknj5hjoMYYjByK5VtwbzGztw6qAFzuQ5IBBIO3BYMGJAAIA5m25fPmAHbuYknAJKZBRQMrxnjJGeOGao2AbMCqzSSbhFhTgH92PMYhW2hAd5IGBnKjIFRK2rsnts9dOXRavXq076beaXNZXT6crT+JKya0d21v7zSa6J2QyNXmiOwkIWxuVm5ddoCfLvAUP1AyVz8owC1NVEmgO6UG3T91JLHIRNcTKELR2suAViUgrc3JLbWzHETIzSRugjMib/OKWqfK7K4WS/kQKrLaMm3ZbhkZLi4BbeQ8ERJ810ZPKXdmACBVCoseFjiVSFVECfKkSqFGABxycA4OTvKKb0g0tL6ytZtXelr301v31uact48vRKKbd05KyatdbK7vZa2s+yY7hioXbGiYWOKNfLjiiRuYxtyFQZ5B5GCTnfk5EssmoFoIj5djG22e6RsfaHULvt4HUZCHBDuFOeOqffc/mag7JGxjsEbEsyHBusABorZlxth3KweX5dxyqMRuzolUiURQ7IoxGVVQoIbaSi7QPmJUsC/yIzHkkNzXJZ1LJtxpWSbV1zNWTSu9ErN+7bmSuvdTvN+ayS5Yp26rmS5VZXtpfdpq17a6JkUfkIIYQojGNkacFFLEYIYhRI67dxAUsSGU7skxSSE53bozuKgkjIxtyCQ5bk45HBHBwTuqVJCGYZYkIisxfILuQyocqFZmzycYxtQ/PkVHds4jRo87wyKwKowIJUsDyp+QAE5yVTIUDBxUmlBKPL7r1UW00m4q26batJae6t01qXaytGyWyWy6LXVaqz16dnbWIl40eRYmkOWlWPcRgYUlDuxuU55287vl4CqaiWdz5YePbvABUbMqpKjcVLMS0ZBjkfKENjAbgjQUEIBjdhFAIAIDgAbQyZGMsNpH1U8nFO4RmUPE371QwZmyAUIzJGwLKpKgAgY7gfLsLUnF/FG7cUkopbL3b6bLTe1tfkXGUo3s3qknqu8b6d1Z7bp7q1krMm5CVOS6gMrfKQSCCSMKw6/MT0OOeACVXdDHEFVidgZiMKu4BiBg/NgcHJHODnOQqsSrcKdgQOibcno2/G4DcDkMQZEIBcMUJUSCVVALghjwMKSOSEI7hSrHB9xkjkmnaLTbuuZq7TaXRau1tGnZ3ta3SzKu5N3emjv2dt29Nbr8baaMkyFCKcGV8KqhQN2NnBx8qgbj94LkAZPOQnmAIGIxkLGwYbd7fKcKMEsMZPqcAc8GlYgEPxkxlRnGPmG4BXHAPzgZJBGSPu4qPejqOu5nRsgPGUkbAG7YuAoV8swYZIHOAQNLy5WrJ22vvytJpq7vu22nb11u+q6jTbbtJp8t3a0Xyy137actu76ptUlGVJAHPVWjABd8BfKfb8wYBHG4AAAKBhioDo4lSMJGm1Rk9dwQyEbjkkZ79srweOKmVdpA6qVLHOWG7OcrtAKgDIUKVyu0joxLlBGDktgYHUnhUznJAUjOe+0/MM5IrHlknfS99JdWrxbTbTd2+tnvrdI50tdLrftt7ujve1ttn0eqIJCYghQF2yo2IQHK7iS4cltuACu/kE9j2ihkFzIrhLhZA67jGgWKNSYSoZkLhy+4JIF8yVGCALguBa2LIArMcMBnDEFTjGBtXjALZAAc8Y9nW0UNosccWECSbyoYgbiV3MxdsknOSxUkZ+mM3GTa1SVk5Lo7pNW21tdOzvbuJRl1atLV3tdvRpWST01666s27B1FnGcBFZRuXIBcYiG4K28lWySX+XdkgqBnNPXhGlhChyS1/p55YbslwX3AbVIK5xknaR8igEk3rE7rO1Zvl3QRlyVIJzwdzAlgCDnzMcjAYAgkUNdXFpEASAuoWJBySFJkAJYbB0JwRzxgHJytck9KNtb2V29ndwfyvdaPsnsfmNBpZhDSyVVJJW6W1eu+/36dDUVmzLgBsx25BA+YYe4GSAWJIGVbPfPbo4yYB5xhWZgEYkgKvJ44IOcMCBgkKDzTQ2JGAH/ACxtMoMKAS1yc8FvnJ77h3JG3ACSYAxyAFY4AXOduRzg+u3GcZ5Ubea2ivd2X2rNLs7PTolq/wAmjiaj7XZ7wd9NuWDst0t9NNvNGfomW0zSSyjy0uJcgBSSW87HIOAB8hwdpBwQSA2dsOu3aSCSvy4GMD5P4sMuwg8MMZwSQATnB0Hcum6YWZQRO5G8LnhZmx1xtGX2bV5KlSVb720SRwyruIBB2qPlO1iGG5hgYBXPUn5SBk1FFXgneycY3725IddO+rvot/PfHW+tVbq9qtW3/g1731aXRW8ttDLt8jW9WwRvaxsh8yrgAJKwUk8NnYQEx8+AcjbWqqj9z8xbFrbIEAO0EIDvUZIJzgLkMVych1xnNjAOr6ixIObGwO0DDjbHcDoAT9TnCn2xV1fMBDHGwwWmwYwquIFzypUA53b8KQcgqdoIMwtaOl1zy0Tdk+Za6tpqys+10ysRrKDbSSw2G9XalT0SS2v26JXveyy9VZf+JaqlWJ1e0BEZIyyo5YbQM7lG3OXxuzjIOBqMyqjgfMr3BQAKCys1vbgEh3P3N249cYJGVBNZWqKqHS40Hlp/a1qwUbRyyyF2IJKFiRk/KVzg9N1bUKZjlC4INxLgAbhuWONCTkYA+VwDgk5KD5/lF0lJym09+R+VrK9r9f8AK9t0OtyRo4VpN6Teujd6kLt27pdtFbe9zF1dXj0i6UnzmEMi5DOWJKrkfMNu1DkDgHaMrnk0tmm/TLNAjQhrOEszAsflTkAoVYAkgOxOMAAEPna7WH3abfFRKx+zuG+6FC7U+cFx823d1A4+UHoQX2qIlnY28QdFFvbfvJyON6AsoXOPmfIBChWCqWwcVNuWrNW0dNLtrdOK1Tdt0+yub8yeBgtFP605K1tV7ODvbq7NJLy6WZHKwWLVEIYvHayDaQARGXRl5fLMpkY4GCwWMbwCcC5p4P2QBmYkSzAr8xHLltqHCjbk8LgZwQeWAFK/dvs93hSWNhOGZWEYWMSRkbwGYuCWOGYrkYH91jc08j7HgqcgyKoUp85VVDSFiz/eBdicjIPXPFOHu1Um9oab2tJq12la/a/4GdX3sOnZp88brfVRgm1bbur9dLrpMXjjLkyAKoPmgkqY1O0M5BBYKikAEZ6nduAyrY7iKSJJd6bJQTFIzxbWX5R8pXIMhH3l5J2nNEse6NlVIQzI3zyRiQNlCpZULMJTgAMODtdjgYwa8dpAkSQGJWRVA2MMrlQwZgS0m0FyZAFMYUuTyx+UfNzNLVLVNq13dW0XS121s+mmixUaShduTk2lb3XeKSu9o2bbVldXbvqXg5BwwzuzgHB2jAJBDFQQA24dCewCkgVnMcp8whtiZWOTOMORGxbCAOcfL8rcrkncAQArRmNzIrkrkMA5BSInA3Iz5KghVX5sjcT3BIzBq0McxS4KKJJTDCqL50q/cRmuAhUKG3fIyRkkHJVQQA5O1nJrlvvtezVteiu92uysEKU5JumuaXKnpurtaW6tpO9nbsy95U4uzO85aEoM27R7UJ3Iu475FeQ7U8xcMSGOwECsq/LqQ7RoHjkMsUip/wAfcKM7sA0MhkQl3yQNsZXdK/Qk7LRCVQjKQiHcrs6kBldsKxIIVWDDCIe4JIJArNvBOZLUhh5QlPnxsgMWCin70smcONxRQygyOpZSoKmJxi4dVreXezcVpe2ivvpbqjpw826kVJR1gopJW0ST5W1u3ZrXrZ9LF23neWMl45IpC7xiN9jOq/KNzMRlgVw21gCVyScEkRtHGJ9nkkuXZwQSiyIQFEhmjLFANxPICkAlRjkltIHTfEzEspUFgVYZC53rtb5yW6nO5SFBK5q4Rj5g2FWMpIGBAkDNlhgBUDqxAzg7QfRQBp22atHdK7T5Xd9bO219L76EN8kpWSjd2STej0e6u7LZq9le7sivArxAIoeVcbiSTuQqELbXywdW5RE4QDJKqVJNlbeKaQXKM8Eu3HmRM2/CYfyp40Hl4yUyOCUAA+XdVa5trkzxz27kqCElgbcEkjQhvMVwwCugGCdmSMlUGVBvRRfvmkkLFyu3yyzmLKuG3bSUI3Lt8soWOVEhOT5apJNJa77P5K+ivrraL1V3vYJTUEpKablH3rb3TinGS21303vo9XewZBFEA4ywATOBl8x/f2uWyu3BZR93aABgEVQJEcpVH2fvN4jG7ad0nKoWYAiQlWUKNrAMAA3zVYkeRhGY2RkWQK6upZRG67WZ3cqcMwIV1H7sHBU5xWRNHdTOzWsKzlzK0UxaJCAiZEZRjIhVD5Z4cFgzKjEDATsls21a1tXur66u3R/c7ImlHmbjKSUZpN7OP2fO1/uaj53b2o5w0yptcgQmQSAAxeYWVTFl1VlOFO0DO5mxkkAC2CGIBbKuSY1IOWxjHRc5Cg5B5VRkYIxWJb2l29nbW/myW92s4ee6WSRwseT5gaRQyqYPJVmDJIZQi7yvEp6G40+TylVGT99tVFSdVaN3U7HkfbuSNig3EcKHyBlQRtC7TclLZPXW+ifo2rW02d10OatRV48klJOTi1Hm2jZuTbWzttrotNiOGRZFZlYiN22MW34L4TO3gHaCT8wG9dvqDSXFobuB4S0sfyKytEzbldCHjkyWQBNwLFCSMAhuSQLkWi6tLFHJFJa7I5I2nxe2qs8SIp2KWAYFlCiRidyOdjNyNuvHoWoOeFgARSwH22yLBWI25zKcY6ltzAkkLuBxW0feumrXSV7K1m0n0vfo3bXW99TGVKdO01q7pp8km04tWctrNt97Wvs7IxLeGSOOJJpGnmAG59u1nbhVYru+XGAG3AkZzuz0vx7TuwdzjAcZO4cD7wGSVGSBg5fBVhjkX7XRNRniikitt8TkhZFuLEg7QOQRMMjODkHI5JG0ABg0nUzKc278hI8RvE6BiqNudo3YSnYM7QjHgNGCCDWkU4xVlo+lk72S0Tu2trXSbfnq3y1FNKUpxULpvSKSd3F2SelpPTRLZXT0K3lbS8kYYSvGVZzv5CAlHYZA+UlFwDghCBkbyJtOSYRIs6yeYvDb2BbdlQzZYv8AIWBwhBKgYUkMNulBo94kkpEV5OZzE4VkYxxAKqeXCqgYTlXYlSpLP8u7itCLTdQH7wWNzhWAVRCxBDkEcqpx1LMpwCM8rggbwg7czvZX0vo76XStZN7u1rvV3ujhrSai4LlknaXPZ6pJXjrbro72b3s9CrbxkI0ciqxYnkIy7kdAFQjAGIwcEKMlsjG5VNatlaoMfKy4GeWYgFdu7az8DJBCjPG0qx3cNJDo+o28YeSwu0iZvNaRkkkJeQgnD8Hb90KNpIK5DdQdqzsrrJP2afcWA/1bgfwkKSUx1IOTnJzkDrXfQp81m9LJPrpqr20Wzsvvbvu/ExlVxTtJWaum2vK997bPv3LdjAzjcUYEkbSSdqnanIAUH5gMk4BIOMnPHUaXYbJ5psljM6MvDYjUABUG5urADoOhCghgar2WmXMcUQENxKDJlgVcEBghcEkHCIeNxA28HYV3k9fpulXZKsLefOA4Gxgo3ENggKRgkDoWLnkY3ED2sLSvyqzurffouiStuvPpa2vxGaYhwjNpqzSvqrvZtbPV62V9fwOh0bT/ADQAE2t8rKWDEKcoNxIAG3JPDKAwO3rkH3XwrpjkQpMgdwo+ZVADMD1wSoxxgEfMQ2G4NcBoOl3CvEGtZsEElvJcEdsHj5jwdqnbnHPK/N9IeCdEluZYNkcqnA8wMGG0EnLg7DgEKRuOdpwu0jivt8mwbqVaUVFycuVdHbZa6pu1k1a1k/kvw/jLOvquErzckopOV3vdfdpdX07366fdv7Dn7Ps3xy+M/gzwXJau2hpcrr3i+4XiODwto7w3F9E+wrsk1Wc22jwMfl8/UIiB8pA/0BP2b/h3B4N8Fw6m9rHaXWqxQyxwogjW1062jEen2yDoka2/7wJgGMTeXt+UCv5//wDgjB+yo+neErfxxrVkYtY+JU1vqO+WH9/Z+BNFkkXTIATh0XXb15r91Rgs1rLpVwAfJwv9KHxJ8T2Pw+8Capqh8tDZWHlWcC/KZrlkEFtDGFycyzNGnyg7Qd3QZrzPEnNKk55Zwhlzcq2JqUZYqFNu8nOcY06TS7z99p62gm7KTPifAHJ8Fi81408cOJXCnkXBeDzHA5JXxCtT+s0sO62bY+lzpa0qKjg6cotqbqS5feiflL/wUl/aXs/hf4N8YeKEuIpo/AuntZaFaeYDHqfj3XENrottsBPnf2bue+uFX5o4IbrfjBr+JFNK8T/Fz4iaP4V0+aW/8VfEPxIbea+mLSyrJqNx9r1nWryRdzLb2lubm+vZ2BWO3guJOI0LH9af+Crnx0u/E/jzTfhNbX/2i08HSTeJPFrpLmK88b+IIPPWGb+AroekOiD5wLe4vLyJ1LpWL/wSS+AGn+KPG3ir9pHx5Etr4O8E2Op22m3N/GBZxaLpFsbrxZqzNMuPLuGSy8PKwZY7iwvPFCId1m6r+kYDLqGTZZl+VUkvY4DDwq4mUHZ1ajjGVS1lf2lSpKUKaevPUUe1vwLDcQ4zN58X+K2bWec8ZZlN5NRqvneGwUpfVslwibv+4o0Iwr4hxsnQpzqNXTa94/bm8ZaR+yV+yH8Ov2WfBp/snxL8StK03UvFUIKx6hpvgLRVjj0nS9Q2bXju9XuU+16orDa+py664XbdHP4sfC/Q11PU21C4TzLexxcMzAktOSfKiIIIJaU8rznDlejNXc/tifH7U/2lf2g/HPxIu3nfTb3VpdO8MWcjuy2HhrTGNpologJCg/Y447i4AAD3M0zAdq9M+B3gK/1aTw54Z0+1kn1XX7213wxrmR5rmRUs4DgliArlyp+6GLDvjCpKpisQqTS9pUqudXlXuqpNRc7bv2dONqULrSFOKT7fs3AOS0eF+HVmONcoyp4aWa46tW+OU3FThCpJ71Jt+1rWdnVlUmtZXP2i/wCCWfwH/tLXtV+Lms2Ze20ZX07R5J0ysupXC5up4i2dxt4SkasA2GlbnIwf3kZMJgAYHBHQA4PpjAzwMjHQYB4rxX9nn4X6f8I/hT4T8GWkSRz2OmwtqMyKAbnU7hBNeTuwX5ma5d1BYk7AoAAr2WRyCdxPGQRz0GOnB788jj1xkV8znOKWKx3sqSXsMIlQpaXi40/jns3+8nzS6NXUbbW/N5Ympja2OzrEt/WMzrOvaW9OglGGHoq7vHkpKLkk7OcptWvrnXT4BQAjrnnoCAAR153bh+HrzXP3EmQSARt+Xp1AHfbnPJAP0PbNal67EHDYyCVyVBJ2+xJx3I55Jx/ePO3TbBkNkkHcDkHjpx1PJ6DocAbuAZwlO7V1q7b6u7st+vbXo3aysfnmf4xe+ubZXe600Xz9W1pd62Mq9kzlAQDguTuxkDaQd2ed3Y4wQMDnGfIvin40s/Afg7W/EF5Msf2W0kMRfaN0qoQuCTjAJz1P8QHzDj0y8mALZ+7k/N05OR26E55ycEdDyRX47/8ABRz46Jo+l/8ACFabeBSI2e8ETgEMwPysB6KD1HJ5zgcfV5Zh4ymp1NKVFKpPmtrytWjfe7a1TWzWjsfmNDCV89zjC5bQUpyxdeNNtaqMG1ztPWyUeZLVatd0j8Wv2sPjBdeM/F2t6jLctIjTzsu58rs3OVCjO0EYyBnaOQvzHNfkr8RfERmmljjf5pHbdlmPBzz0DZPOCewKY2jNfRfxW8Umee6dpM72kYneQcncfmOQef4iOM9ODmvh3X9Ra8u5pCcr5h+9/CNw4GQeRnAHAGCCw3Yr5TiHMPrWJnrZJvS+m6VrNbJbPR7JaKx/pt4PcG0cpyzB0qdJJUqVONktXZLy7vf71slz9zISzYJyeSCcnHJJ7Hkj/gJGBnGA/ToSz+YcDbwpPc8A4JHUdCT1APzZODSY+a6gE5Y4Gff1U4DHkkjGD3OQMdHbwlFSMZ3D7xHJ3dCcjkgAHAPHTBAwT5mAoOrNTs7RatdPd8q2V3ptda29Hb+0+E8r5YQk4p8iTu3J++0reS0V9Ul+BqWkJbkg5BwByc88ZwQSO5BBPOCSGNfT/wCz/wDDa68d+NdD0iO1kmSe8hM4SMEpErhmwRnCkDaCeCxBAxXgOjWTTzQxKuWLKMk5J2jpyRnlWPRi3HqRX77f8E4PgCkVk/j/AFW1OZWEWn+ZH1Rcs8ib1OBkqAQBt5AwMZ/ePDHIadfMf7UxcE8HlcI4mrzLSc4OLpUv+4lTljumo80rNpn9C8C5HLM8ww1PkdlOLlo9FHlvJ20skr77206n6g/BzwPaeAPB+kaVFEkJt7WMPhQCX2LwcDHGNvJP3SW5OK8L+O37Znhn4WeJ7Hwlp97DNqi3EI1FUcMttGzKWR3GRGSjEksDubAOzg17X8d/iJYfB/4Z+IPFl9MsBsNPmSwifC+bcshEKRg46tjj+6OQTg1/Mg1rqfxe1/xL498V+KF8OW+o6lex6ZqN8k8yajrtwHktNLt44T5jNhUWeRUIt1kjwu7aH/WcRjfbVZ4/E0FjMZjKsp0KNSUYUqdCEl7StOU2klFONOKbSct1ex/QnFGfSyDC4HKMtajiqsIOSvFeyowcNeb7LntrtZtvU6f/AILK3dvqX7U9n4htWxB4j+AvgLWYnO3MgmOpWQfIIJG23jAOT2Oc5U/kh4WURYm6Hzk2sRkHdgZz16gfeJ4+8ScV9q/t9+NL7xNc/s963qhd9Qn/AGW/CemXkj7t01xoXxA8eeH3lDbpCRJ/ZW4s7EMAWzggN8YeFsyWUaqpLttmLAnIVQM4OM9FcgL97HPav4845dOfF2Zxoa05Yh1Kab97lnCm0vV9F92jR/CPi5zYziHOqsbuOJrKolJaS9tCnUa2b5k209Ve78r/AGZ8H9Rkh1iyndRII5VLnnhTjIY5G7hSeTyCSVLcj3j4weFolaPUraJTDeQpOnlpkAOpZgSCVBViRgnoSCADXy58MdVSG6tivBDKrE4I6Z544ILMN2MkcMPX9BJ7JPF3w/dVKSXOmxFwSA7tEynO3aTlRg4+XgEDpxXVlMFiMHWw7s5qKqRTt9lJOy80ttb2a0W/8C8exqZHxNgcdyuFGU1h6zSsnGbiotu/R6drSfY/NrWbMxtJHgA+gwMgnvk5I6EAkc5wdoBryDW7TBZcEEk8nJGNxxkYAxgrggls5GAAAPpbxbo7W11KuG3bnyABg/ORypxhj19wAo4Oa8P12zwHKjoMkfL95T6jBw3Gc4PbIIBr5zMaXJPVaX95tb2cb6O+qaV1qrW7H6rwxmDU6MozTXuNO7s1eK0vvZ6X2fbRHi0qeXMVIyM9O2B2xwOvAI5OduODmSM4wQDj8OAxXjIBI9ucA9OgBu6hBslLdixCkkZIOD8xb+IElcAEFcc5yKzo+CCDgHHzcjH0JGcEckAEZ5JGRXl0pcs172itqr9LK2jb8/LTuj+iMjxqnGlNtptRT3T6ddPi6Jd9bWSffaBckr5bZzGd4OT0xgnBJO0Hrlf4sdhn17QrsAIc4OByCARweoyDxyeQFB6+o8G0q42SrzgHCtknkHj7wOT6/N0BPXGT6vo07IVUj5T83JJOOd2MjtjAAz04IHNfbZNivepvW8VFq26ty6PW1073Tur7q9z9VyyupQpzu7xUYvXXRpxeibb66tJ9X0P1B/Yz+Kcvgj4h6FcyXBW0uJ47O6U/KrW85KEvjqVYg5JwAMk5Xn+mDQtSi1C0t7mF1eOeKOVWBJBV1DKQeTyCAOQfu5Lfer+OT4da6dN1K0uFdk8qVJEI5IKNnPHAxjnJHTI7Y/p+/ZV+I8Xjr4Z6JObhZbywiWyuxuDMHgAUFzknDJychgWJxgjFf11wdmCznhqNGU3PEZbZRbt/AqOPo+WE9F25n3sf0r4YZ05UpYGpOLldVIq7Wq5VJdd0k7JrTdW0PtqylGMep6gkkHjIAz1AJBwOecHbnG8As8LwyYZXjZQuOoI2kHsNy4DfKQTzgkYHF2s4DAORngHnp8oB5HGfQHkEdQTg9PavllIJUAqf/QT/AHQCQOCRgDOWx0EYqk4yUlo078yV1zJrX+ayaV+nVJXSP29qNek4tXjONpXdk00kt9Vfaz76bo/Ab/goJ8GZPC3ja68Q2VsIrHWhJcAqgCCdSDLF2CsTl1wc7iSo+bnzj9iD4hP4f8Tal4WvZCbHVEiv44pH2q09k7i4VVJAZ7iyeZc42kjeQrKcfs7+2X8KoPiJ8K9SuLa3E2p6VC99btsLsfJUs6fLyA6/wngZyM5r+cjw5qVz4A+IGm36u0f9m6solwCCbcy7biFycZXymlQoSFKkqdwIB+E45y+niFhs1grRxlKVHE8uijiaajCbdk7OalGd9Xq/K38O+OXBqw+MxFajTsq7+t4Z2aUcTSlGolFtaPnWtna2l9T9U9Q0nTPA/wAXvEngDVwo+HPxz0yS1EjACzs9TukJsruMEBA0F9JEylDn99HhiOvuP/BLD416b8A/iv8AHL9kz4x63YeHfCniaw1vVNMvdavIrKxs9Z8O2txczyQSXLqmdV0Fpbu2SAtNc3FrbJbrJNJGreVfFDQ3+JfwKh8UaO7SeIPADwatYTxkG8msFWOeOTzFXcA9qV2sGHzQhgcqu74b/aC1r/hYfhTwL+0JohX/AISfw3Pp3h74gQRIfMafT3RdJ1W5EYVgs8Uf2aeQ7t26BWYbc1+fTrPH5VPDYlyliMFJUZzi/fhTo1ISpVo8284yhCcW01zRS7n8h+I/BWG8SOCKuBxEuTG4SlUq0KjhGpL2PK4Yunyu3MkpThUjdN0qtVXSlc8d/bw1vwreftA+NfFfgye7fw/4jvpLmG/ubP7Nb6te2dw2nXms6WEjjSfTdVltjqNrJsjlX7UYriKK5injTzTwF8UWuvhH4z8Ji+sbC48F6/onxSW3F7Jpuo+JvDwgk8NeL9JiuILiFp5NKtrvTNetIN3mQi1vJ4GUq8TUv2ltetNe0jS9RtpxqGoJaXGrxRossa6d4e1hhdC3S3RWtka11QXYYWywl2l86aPzHL18E6d4v1bRNRF9Y3ZR0KMyPGktvchXjl+zXUTgJPazkBLmFh5dxE7RSgwtIleVjM2WXZ1LExc5UqsJtyhK0pe2goTnfVcyb5mk7tt3erR8pwXwJlnDuQ5RkdqmKymlk+Fy6FWs41cTTpUqVOEJucopPEYWpCEoyVmpU7pn6F61rqeOfF+meLLO6sfAel+LbXwvqfifXNaZoNKsNeewvZfEGuaXEGe/11LmKzm1aO00oXEq/aVt1KSPEX+w/wBuHV/HnjrRfElxoHh3RdG8P3Hwa+FfjzWJdHjuL/VPiz4deeTTH+JWratBOkfm6BrUN1aal4c2KdEluLVL2IPbs8n5tXc4+Jug6bqwEsp1Cw1HVfCLvcQoNB8VeDtJ0yLxT4OsrKAC2stO1zSVfWtOtobdZZbtNPTzXX7Yr/c/7JvxqsPF/wAN7Pw14pibVLv4M6jqHiO3tbmQzNrPwa8cTReHfjT4MmidsT6fp1hd6T45063cmOyfQr6eMJK6sPYweO9vjquXutUjQzHA1FhZRqv2bnUjTb5k9JWja6k22vdvqfqORcF5dmOY5hwbm9aeIwmPlhc7y+pKo4Ua2Z4WnKpgsZOjH3JTjTqVZRp+7epypWlZn4w300P2hmMCFVVhbqcAo24GN3JZi4UbcK3GVOcdBgPEbiQgFt7Mo6sQcEhQDkkLlhgDgqcADaa+gf2kvhVdfBr40+P/AIdyHzbfQtakbSLlWWVbzQNRjt9S0K+QqGV1u9Ju7SRnQ4Z2cEnaS3l/hfQb/WdTsdO06zuNQ1LUrq3sNPsbOB7m7vLy8kSC2s7WGNTLPcTytHGkaB2Z3WNOSK/KcXhK0MdVwtRN1KdeVJ2veUoySS5dNNW07PpZ7o462FWVqthq1P2VXC1KlGommuWVNtNPa+qbWrVrK7Pqz9iP9le+/aZ+Lln4f1GW+0P4aeDdNk8a/F3xha27XD+H/A2m3Ntay2WmJszc+LPF+qXVj4V8HaUN8uo6/q1oNr2tveyR/wBdH7THx+8P/wDBNv8AY81LxnDo+l+G/jH8RNB0jwH8IvhrbTJNB8P/AA3pOlSQeBfBVruLSSaP8OdDnl8SeMNScH+3/GWoajeXzyzatbrF5D/wSz/ZwsvgX+zlrHir4lR6BpHgLwj4lufib468Ry+XJbePfHfhrSZ4bCC71GeCJZ/AvwVtjqsGkW8Es9nqHjTUfEOtRSXJbTWg/Dn9pD43+Pf+ClP7XOo+MdG0671j4e+G9ct/Avwd8JahOLXTtSeSa5vtOOry3DC20+x1KLTr3x/4/wBWmdYdD8F6RMLqVbeCNG+jwmF+qUlRShVqyqwXLFKUp1YqnKNJN+61SX72UVde0VKGjcj+aM0y7E+I/iDOnmVSeF4P4WovE5tW9oo0Y0aclJ4eUtYvF46cHCdmp0cNCUU41VJS8j+C2mafoGjfEL9oD46NdeJLK2n03xf8QrfVrorqnxD8R+Kbq51f4b/BCK4Ja5Oo/FzxBar4y+JPksJNG+EXh7Ube4khk1i3in+2f+Cef7OnxQ/al+MmpfHXx7f7/GHjjUda8VTeK9RgRdP8IaHJKYPEfxEMUii3toNNg2eGvh7pn7mFrmKBIBDp+nXE8Xx9pvh9P2n/AI0eGfgz8O7zU/E3wH+D2tXTT69p9qYLv4xfEnxRf21r4x+IK2mxQ2p/EHWYLTwx4C0+Vmbw18NtG8O2aohS8M39FHxLMf7MPws8O/smfDe2tbn41fFy20V/im/hwozaNot1Ell4a+Gmiy2+JYbJbGT+zwylWfS/7V1eQeZ4ixH9BhHKUoVYtc0XKGFcvfhzU2lWxU+ZpShh+dRhfSpVnBXXO7fN+KvFOJx+Pw/D2Tr6ri83oxwtOjFxhDh/hahGEo0p6r2NXFU4/WMZ8CSUaLi/ZxNfQPBGkftV/Gbwp8IvhvZ3Ojfs1/A+0NnYFGkddS06O4Z9a8S31w6otz4j8f6nHMUu5lF2dOL3sqxPcNHJ+31lpum+H9J0/R9HtILDTNKs4LHT7O3jVIba0tYljhhijAAACIq8A4JAwTzXhf7LfwJ0v9n/AOFWleH9kE3inU449Y8Y6migteazcRoxtI3AyLLTY9lnapuC7EMhAeUmur+NHxU0D4Q/Dnxb8RPEs8cGl+GNJub4xu4R7q5wUtLCAEKWmvLlo4I1VSSZN3QEjx8VXljsXChR5vq9F8lNSk25zbSqVJSd+ZzleUpPdtybu2fz3xVm9LGxwmQZU3Uy3L74fCwjrLHYurJKri5Jazq4iq3y3TfI4xSi3I/F7/gsz+1avhHwfa/ALwtqQi1LxFAur+OZLeZVkttERw2naTIUJw2oToLiVScmCGPICuQP5ENXvZtc1ppTlkWQuAD8qqCdoA5AGCNuVGWbJwM5+xf2vPjfrnxc+Ivivxhr121zqniXVLrULkFyyW0DSFbGwhywCQWtuIoIUAxtUcbsV8haDp0juJW3h5XZyAASQOQvPzFSMHIOSOvv6eEo/WcXSoQTdKkowjZO0pac0rW1cpNuzu1otlc/0D+jT4YR4byTBPEUoyzDHThjswquNm8RWULUVprGhHloQ2bUG92z9Lv+Cbfwkbxp8Xk8X39qJdF+Htot+jvGGibXbwSwabHg7hvto2nvM/eR44WJG4Gv6P5dWsfCXhbW/EmpyiCx0PR77VLqVztWOKytpLiQlyQMBUPXGThf4efgn9gL4P8A/Ct/gtoMt7btFrni8HxRq29cSKL5VOn2rnAIEFituvl5wJJJccHDdZ/wUO+I7eA/2frvwzYXDR6x8Rr608M28cTfvzp8kqz6qyBfmIa0iMJK5+a5ByeMf0ZQwlLK8qwWBa5HSofWcVo7qq4qrKO1lKKUaSSV/dSW5/rtwpgaHCHBbxVWKhOGDqY6umkn7adNOnTSSTuk4U1f7Xqj5a/YL8LN8Y/j/qfxT8Vp5tn4m+IGqeP9cluU3pB4I+E/kePLuNix2i2u/Fsnw60CUNlJLWW7iwCrLXz14P1+b9oL9tvx58ZdWR73SLHxV4q+IymQGSNdL8NvJZeD7U5GwCfUjokEQIwSoXDEgD6+8CyD9nH9iL4+/ERZBaa3eeD/AA9+z14PmD7Jf+Ej8Zrb+L/iVJaFVVzLCfEWh6dNICHil8JS20h322Tg/wDBKL4Cz/E7xFoGnm1L/wDC0PiRonhl32EFfBPgDb4q8XzrJjAhuro2dm+BhpbZIsgqQ30XD9ehk+V8T8UZhUjTw2WYN4fnjLmcaeHof2tmtWMbNKTeIo0asPekqmXSi+VxcTh8N8FTtlWNzS0aNfGZlx7nM5rSOWZbCbwcp2SdqsKUpOL15puzbat/Zr+wr8NX+FX7Lvw30m8t2g1nU9GbxXrzSL5cz6l4iZtXmM4PzmSJJ4oHycgRheq4H8yv/Bcf4/iTwz4q0iyvR53xO8fW/hhFVz/yKXgXy9T1ORAN2be41G00WByBsYX8wI2sGP8AWV8ZvFNv8Mfg14q1uAx2v9jeHXtdPUYULcvALCwiQfdGyeSIAHAG0ngc1/nef8FVvii/in45weEYboz2Xw68NWtlcLu3KviTxQU8Qay/LHMi6dJoFnKc7opLNlfcFNfyp9HHB1+JOMeNPEbMYSc6uMxU6cpRvFVsViPrtWCk9lRnPBJRTtyXhtt4PAGMrY2h4leIuMusVnuNrZTgZyWiqZnWljcfGEm7r2GG9hCPK/dTsm76fkJ4p1OOeWVjcKvLMDnGNpbII+YnPI2jA4OOQc+K67f25BHnoSQc7WOQo5DMMZBIXkjkYIPGCfQvEV4zeZ03HOFxgqeM577eWLc46nG3BHkeqSFBuxHkqcqBwG2jedoDEqF4YknPABCnj9O40zGVXF4h3u5Sm27OzvZXW+i6a/8AA+Bzeu6tWpte7lfpdvbZq+u91t83xmqX8JYqsqrhmUk5yAcHL5B5PRgADuJ681xdzdwFmH2iP92GXY25twG0E7iOVLYUEZIbOcZNdFqMocSEADueOSyqT0zkAZIJ3YGdq8c1xt+AQCrqjbgwYomeNqhMAfeAJA5I7Ajk1+GZtiXOTad1bS6a7W6Wdur306as+NrK8pSvfSz33jy20dlJp21u0r6PoY9xeWh3qZCxyEIG4HBwoJITBBIDAnkkDftGAca5u7IROkd0iuqOULKzSA4Gd+5WL8gE+rDAO35qvyxzpJtaRWTLEOFxLjIwhzxyikseSc5DNjii6RhnJWMAkgnYGDlsAoGIB2swHBBGCVB6qPjMTVnNyd4p+alzJWT3T3tbXR9O6PPqOTS2Sdruzdl7qbWneyu2vLsZgvLMQoDdRHYFzIXJGSq8OGA5LY2ggF1GNu4Zqg1zYLJKxugWwwCM7lQoKgFPlTLYTAcnpjGCC1XLhYisjeXGQqs4+QggDoQyr3JbYTuIYLkZUNWcot5PKjWLdlfP3vHGvOUHzg4bJOSqEgsNuOXyPErylzKL5GorrzO/Ly2aSv6rd6aXZyylJWjFxS0Vnd6pqz89NVdXa0emhHc6nZxRArJ5ruoWMRKDsY7NruWVVAXqsYIywAjyTgV7aOWaHMoaGNzuWN8vPI22Nt87rtkZQVJ2Nt7fKqhTWmIomK/uUDAllPlru3qSduC3GC33flAIJyuSSMTubI5wRgZHoCFw/UKRtx1HKjJ486alKfvyTstFHbVLV+t07u21lpY53GTacmnorKKezSu9mrtPort3s1uVHViSMp5ahii4GUZduA6l8hQU+VBuwwBUZZgKjzCMIzFVLbShUKAwYqqhi7cMxBwSoBCkNyCKvDBTABAGAd3Q8qBw2PlJY5OMkAgkMeYJPm+VhuK/MCUUQgptxIWIYFQDljkAg9QemU01qtNrXd1f3W+zfy3S03Jt7ut1rdS7t8t9tYpWst7qNlpe8A3gggmXfuyFBAVsplMqCgRejg8/MCCFPDY2jaHzuluwZcgnzb3AG6O2kQK8diCpE1wGBuGUwwFY/NuFkWN5Uju2LGxYMUUMBLqLqoZ2DAow05HVlkkYq10wMa/IWdqt3JI8vmkHfKNqqoKKg5VVUINqRIFTYmwbVOSDyi4yd2223GytbdppXavfd6av3r2827Sdmkmturk9E2tb7N7bXVuWT1GXE5kA+UjBKRxxKwVIlG1EjSMFY0UMoEaqFChcbVIWqRzeBo/lFovE86nd9qkUL/otrLGM/Z1IP2mXrKwaNHK72KttmJt4JWNvu2zzrjzLoAxq1pZug3pbZBE864RmzDGShdnvAhjEu1VCxiIJGu1YkTCALHvIwsb/AHDh+hLMDmufldRq7aitE9UnZK9rJ6dLpq97fC9W22uVSdtE303XNG7TVleKbvFaNWs4jIwigKAgUEKiKqoFCklVKE4UZIBXaANoZOTih13HOMuudvzZ25cMegjyc8ZGCzHJABqYouMghskEHAG3oxyFHfOeAw4AwBmmSArGxWPzHKEqpxlmG3cDngcADcXJKgbfWqaSTurWtaySv7qvpdXad+miWiTQJpOOq2S0Sbe1+yctVdtKN01q008zYIZGQlgvmGWFncL5kjMgBTLt833k2FQrnJ+VkwdB923cPmLKN3AwpJ5XkKcHJKk8hgc5ORUMciTMI2jdSu1trIirvRypcEK4OxiQehYnj5sgWJVLKy9WZTgtk54UD5jnr2IUEkA8Fc1jCK95pt639NE7PVL5WbSW9uZOlFWS31trbR6avde7pbdpL76W9MLtnVVU72X5WMiDyxtYkAIASCTuZVYKgIO01IGBJIIzlUPIULI4UJkbWIOGIJJbcfug84FzuYY2kHBIXYvDDK7Q3LZLMMDDAfdyAaMZSVcHDgMckhdyhCMYKbdxHc7QrFQdmQCOjdnd/N6RSv136qydnfUIpuPM2rXdlra7S062enp822RqFj4ReAXbcSwU4PIIODlgduMYYZ6ZIqRJlJ/un5c5wQR8hJUYJPJAVQu4epOKrO3GQTgbUyFzkbhkZUlxjgDdznrwRQGwY1lJLyRscsVARcJh2ySxkPKA7s89QBylJ69LNK9ttIpvdW1203TfezjPlmtrJReivpo2uZWS62v2el93xsokczRTKyBTCWbYHjBjZXjAAaSQ5DFgpDIRkkpgLGSsmxdsiSFpAQARDIGUFSXfKocBFUoCNy7QCQavmQT2quXxLFl1K7gyOsZJ+VWIO9NmQpB3BmwwyTmKN9wBl0fLOQGPlzAyKpREJOwtsDFZOCPuldoNEkkoSVpXcWna0nqm20rLS631+SOmrNJQUfeuk+bS9na9+ierunr52LxQJyQwAYAknPJx8rAfKCMA5BIGQwGOA7BYHblQRkbsDIBXaN2CB0zg8Y6fMcVXErl44iqlSxffkkD5iqRv5jAKx2lgQXwNxO4BgXhLhwGaRVCEMFVfmIwM4fKkgkEckZBO8Y3LS5r6xvL3t0tfs9Vtur+mmxnzJ3STabTduuzvvqtn5O/V2EkaQbUjVQhyzOzDKlMEIsZKE7wp2k4GTnLMSKliDNsAJGSnKjLB/k+TCEEkFiQC2RkH5gTSOrId5cMZFjiCgAIHyclQzbFUBctkFhliuMrhI9wmiKkFTs3QiIfKQYgzqS20JtZQCCWlDbWJBIXOScfeabTT0um07Rt3aS09OlraJt2btJbXjfZaO6W+/a9tV2OhsQTa26gEsIo8kxjaCCATtJAJzwjjOTuVhkDNDXHxaRIqg5v7BMlf3YIlD/KWCgbvujlxggZJxi3YOslpbFDlTEjksxDDaxLA53sFbPzEY6DgKWrP147dPhYEALfWJQ5bfjzOUPDBiMhtoIUdRuxkck2/ZyTStyrZf4LX3ta/e++mrZ+YUEvr8U7qSrWstr+b01TSstbrsairtkZQCpENsNpJJAEl0CWChVOFyMEDadwfgGpeiuACCFc85YEbeOAMEsVOOvovXFG7fNMdi5WK3AYgjCmS4I+YnLEuBtyq5AAbJHLnGEYDk7GyQFUj5McHg47EDHOdp2jNaL4dd/e6rR3vfrpvo9N31OR39ols1ya368sPu0emtr3bWhlaHg6ZpjOpG2aXkDB5juTg4IB9mzztOQu0VshVKg5xkA7sc7iAcdxzkDA3cDj5cVj6IQdL0sErjz2yMEkgJdZB4faBn0OcjODnGjGrLGyk7hkkHDEBCTtUj/ZCjp/Ad3ApU4tQi7tq0L2suX3YbJd9Hrt27a4y/wBarO9v3tR2trb2juuuq9Otk7mem3+19SySp+wWeHLHI+ScKuAOQcc57cjk7hou4WKKRjjEMLtuJIKiJRkHBBdSQBzxjGCFOM6A7dY1ME5zY2R2knYdolGQxG08MwGQMlsDcxZav4cGIBQ4e1hQvuBCtsA8ts4IyMkfLuJXJYq2DFNprr8c9e/v2962vTft21ZpX+OHVfV8NLftSg3Z7Xtpay1vqr65Opu7NpyQMDIdUtJHZfLYRsVfy8E7A2VJ2qrHIJyAGXO3Hlo2yDv8+43yEsFLLhflBcvjJAJIO8few2SvPa08KDTIAGkkk1O2kjWIrkRr9/ewCFXctGgIZQdpAOQtbatMVheL5/8ATLoSRMNxMQIGGfejlQY2JVGOwkZU/wAdU3adXXmfu3teydoq2v3u1/W9kaV4qeGwjtZP2tnK12k009Hrd6aaXX31tYBXS70sBgWsm0FGbcWUDGeD8g9/lHzHJUkOgYPbWbKQd1nbFQAFZWMQzuGWOAT0BzyBnODTNVaQ6ffK4yv2WcABBkqIwu4sSVycKQx3Z+5ndgGG0+W1slUkEWtpkHcMqYUDD5eMZOARkcbSTtBpN2m9Pd5UnHXR8yVn1e9/xVkxwSeCi7+8q8nGz6OEN9dNlb8dB9yoeO5Rd2+WymUKPMLOzSpgABSQ3LjOCoAKkMBxY0+M21pHA7gFcuQHBP707lTJwWZdxUg5zsAY4XFQqim9c7GO3Tk2MSSuGnfeByu3O3him5MbsDHNlYQHJIcsAQQXOM7s5zwN3YADBxgLk5InzS5kndNw6rZq/S+rt62er1RlKVoRpOTtKMJt21cnGKsntZL5vfRXZOoA+YbgzZPJ6HKjqMqFJ+bB7npxikXYGLqxwylmXcxUkcjoQAu0MOCSNp6gkVk3CsSFZpCkIaSVY8IZWjkQIgYuso+VGcuOQBIHGMVcjmyu99zm3mELqAF3BFUGZSzvuTIDEKWAABfIJaqjJN6xacdW07P7N+q0ul1v1Wl7y6TUYzUnK/xJapX5VF631e97aaK61JU8ogycgB8sS4xkKodARlV8s4IH3l27lGOQtykIt7m7jjRZ/IY+aAWaTDK/y9CdzFdqjljgnauDSYSNzkKHlYrsLOwM5k4ZMgqobb0VSCMgH+GkdEJlRQ3+kqTMjGR1XaMtsAxs3EIcdWVSF6ir5VZ8qV3ortOzurPVbvz1dk0t2TGVpxblLRxvotUnG6dnvurWSWmiIEuImdtpBkSJVaFQ6El0V1KqQWdUH8X8JALgglhHLbtM0rTEiMQGOInG/lAzTEBY5N4KbQUYE5K8puyyV7t5Y3QQQjypTysk0hIUogZtqukTKAWXcUwzMN2dtLHI8nmW1xCqvCVkDxtH5TqqIy+UrZZBuYbo2wQgBbYxxWeuikpWvorcsWtHZ2u189VpfodMU4rnhKKtaUle8o/DtpZvTVq9ldbXFC3DQ28v2ld6yRtOGjKJLEFIKbnKusqiMMuH3OcurDOCqND9qO1D5g4RzLtDRHCDH7xmUZXazjduOVKkbc3pGA3mUeXEFEh3EAMNxO5sIVL7STgHB6jgEVnMjz3PnBIzB5QxKxj2O5IkKwhowzsPMHEgX59zg5XINmra67b2SVtm24qzvfvu+pMXzt8zUFZ2l8NnzJ2e/TRXu0npsX4DA291YTMjBHZnztJ8slDuAwy4AZiSQOpJyA55IkDLLIuTIygEsjIGKqAqYJIG4AlRtDYwcsKqwQyW4MTSNcjeHeYR7GXzOSjJwsh3JlGxuRTjOSQzZDEJ8IhL+YYjLmIKzuwaNWJUknG5pHAwQihSFHL5mlHVJvS0tbarqrvezurtO/qZunGU3G7kkm7pLVq2j2fRNtp2fZ3ZckxdAwA4yATLuJMcI8o9dhjErqVKHPIzkjcGFkRBWl2gESgMcg7dqKU2DczZfCKQWACv82BgGq1sqQjYi4IUtgBiZCGADlvm3l3AVcja4UHGBxcJcxDZGg3FS6kBlVGUFyDuVvMAXIBIZQcAEECriuqT5tNVrdK11d21V9X97szGT+xHSLel7Wfw66XUVt1267jYpQLiWN3iARYikYGJVhkChnmYqAGZgD94NkbWIOCdJbgsco5JCKd4ZmUL94ADPOWbgE7RkHlWINGMN5shC4PIDHYVKqoCgEEu0Y3EAkkN90kPyWXFylnEkjLks6xxxJlmmlk2bY4VIwWz8pOQFQdAOW1ukr6Jb7Wsnolu+mie9/REO85xjBO75UrbacqbXXVO/W1nezRdMjxI/kPKm5mkCJJKN8pGCWJyMkuAxPyqqj5wpqNdRkD28T38qXDhTHC0zLLKPkLoqJldu19oZWK4Rl4qG3jm2mR1ImkwzI33Y8lR5cI+UKE2jOV3N8wbcGGLLhVktpXiBBZoRIUQmLzVDAKWJYI0g2/L8wJHR8Cmm7XWm3ZaNpW0knqtrbaEXSk1Nyk7NRknb3uWKSd7+6no+ttY67aQlnlWRFubiASoqtJBIwl2EgsFckLyqFSNoyDkMrcmeOSSMeVHMwBiXI3SNkBAMsVbl2IywwCxwxwciq8UchVd3ysQuSA5YHgBCcq5ySc5AyF6BzkWQrDy40VWJYFi5VxDGio7s3mBd7EqAiiQH5txLBWx0xu2mr9L2te2j/X037O3BOTbcU7q7u27aPlW9no0ko91o+tr1vcXLohE0yqxO5PMlDgEAsSu85yXBHIAwCwJBI1rea52BRNcEBh8vnSK+XxnIXJB+bC4+UdWFULMO+7dG0ao5C+YV/ebPLGQeSFADEZJJwOcjNbVmpaQbSjgAbgqjCE7MZI47gLz8nUBgcV2UYptN3d1bqttdrqz3vddV1St5OIqXctVpbRKy1tvvZrVdXvZPc0YJJ2TDSzE4J8syucE8kk7uclmIGMeucZrobGW5GzE0yKVXlZJBglgxUDjJHGdxAUHOSDk4luhHl4iZlbHzqMBceWQWGc57b+Mg7uRyOrsoz8owMNgMOcAZUnhcDODznp1+7kD08PT1Sa2s76d1d3ts35tN6W6P5jHVmk9VZK+utpWV013X3Ptc3rAyqybZ5BlQQvmPkE4OflOQDnj5gCQNuBXf6KskrgPLOwDdd5XPTGUL5UKW2nbweOCVOOU02FhJEnk71kGWk4IXaU7AYPBBBIJC8qd2VHq+gWDMY2KkN8m3GBwQm3GVyCMggjPHGNwzX0WCptyVop6rS1tLRUlZJWt01X3o/Oc9xvs6U29XZPmul0W/mvXbTuegeGbe52QF5ZDIzptRZmkwF8k5PR2fvICRzgZXDg/ov8AsgfBLU/jX8VPB3gCD7UbPVdQW78S3sbPnTvDGm7b3XbrIACzy26mys87o5b67tIVBZ2J+M/B2hPPLbFI8Fiodyr4xk5wAx+Ut82SoC8DoM1/Vn/wRt/ZUuG0E/EbUrJotR+It4unaLMYtktl4I8P3W68uomKkxprOrwSlGU7XTTbGUFllBP6PlUKWXYPEZpimoUcHRnWcm7L3E2rWtf/ALdd7q1j+RvFPiHG4mWF4eyZSxOc5/jsPlGWYem71J4rG1Y0YSSsvdpJzqtu0Xyb6n9F/wCyZ8NbHwR4Ftb2DT4dPhuLKysNJsoIxHFp2h6VAtpp9pAgUBIkiQFApwYBDnOMD5j/AG/v2h9I+HXhTxNrd7Oj6T8OtKk1a5tjIAuq+JLhUtvD2ihQC7vcX1xbRuqE7EuPMb/Utj9AvGWv6b8NfAN9flY4LbSdN2QQJhPMdYhHBDGFGQXlKRqAD8xHGMV/HV/wVc/aFu9b8QaZ8IbW/MzWdwPHnjwI+Vn13U43/wCEb0iXHQafYXEuotCTtR9StSfmtgR8FwJg6nEfEmacX4+EpUMNWm8Mp3alVbiqcY31bp0eVXVrSmpLW59h46YinwL4d8AfR14brKOOznC0MdxbXoW545ZQmsRj6tV/GnmWY+0dPnunGk6Uvckub8hPF1x40+NPxIttLt3k1fxt8UPFTvc3DP8AM2pa9fNJcT3DceTZ2kc011cu6qtvaRBiwiiav2m/a38R6R+xd+wp4L/Z68GTGy8XfGDTIbW6dB9n1C2+HekyNPNe3qqS8Nz4pv72e/u4XKtFc65rtl832ZSnzX/wSp+AkfxL+Kms/GTxREsXhfwoNQ0u0u7oFbRLWCzW78cap5zOyiG30q507wwj44j8VzSRMH06Ux/Jv7eX7QN1+0l+0b408Yw3EknhnTbx/DXgq0Y/uYPDGhu1rYyRxjCodRbztVuFHS4vGXJCoK/V8ZWkoXb5p1OXEVG76PmccJS0vb31UxMu3saDfxH4xlGXQzzijLciw8FDJ+F6VJ1KcU1SlilCm6kNlFqlSdHCQWqarY6PxQcV8r+AtBbXPENuZULW1oftN1IVJBA+cKeSP3hYKAQvy9c8A/0Sf8EvPgUfFPjO9+JusWQk0vwp5cemCSNvLfV7hP3JjLgo32G2G4AHMcjqCQRX41fB3wRctDptrFbPNqWv3MCrGEZpTE8ipBGBnefNZwSvIYMu08Aj+x39lD4QW/wc+DfhPw0tukWpPYRajrTgBWl1S/UTT7yAWxCzCFcjhYgoPArxqlZ4DAV8ZJ2rVl9WwzejUqi/eVFre0YN2elpSi1a5+peImZNUMu4Vw0rTzGaxuZOGjhgsO4OFGTSTtWqOFPlnvFVV9k+kgBHEsagcKqnGcYAA+gx249hxk1n3Ep25DADBAbjtt74yOBjpgkEd81dkkPB2+gzx27g8n0HHGQfUCsW7lJDEYwvrxtOBwBjGDnJOecMCex+OowcpX6tu7tpZ2b0u9Xey1Wnd7fmOaYmNGl7ONoxhHliu8UkrW9dPQzLqXcWBJwD+HI59zjIUEDgjk8jdzt5IGB5Ix0AzhcrwARjpg8gc8nrzWndTAAnhSQR17A+o5I5zuweRXO3Um4nGAoDAgspwTkjoTg9ApJ4HzAkGvocHS6rmvdefSzsrX07PdN6aH45nuMcnOPM1J303dnbtdPpa1/KyPN/iN4ts/B3hfWNdvpFihsbSaRNzbQzqjBQCcZzz90ccrg4OP5Kf2u/jDdeM/Fut6lLdM/nXNwI1MjNiMO4UBd3XHQ44Gc8MWr9sP8Agon8cYfD/h9vBmnXu2adJHvAkg44OA4HI3HHUnuQCAK/ln+K/is3l3eSNICztIWO4bRu3f3u7A55PJDcsvT3swrLL8sVP4a+ItKf+HTlitb6LVrrfU/SfAfg+eZ5tPPMRTcoc6o4ZSje0FJOU1e93Ka5bq+kdNz5v+JGvmZ5Y1c73d+jYO3JOTwR6AHso4OOK+frl3ZmJJJJ+UhicqMfeB6k4ByDk4JIxnHV+I9Ta8vZW3ZCsVC5P3d7YZgDg9+Bkf3sjIHIndIeF3Bhk44IyB1HJBAwDlsjjAr80qSdWrKT1btru9eV6W7vf8brU/1K4MyeNDD4amoaqMHazd/hto1qun66ElhCzSb3GVXbjHq2MDGMdepzjlsdAD1tlC7NuIGOSNykt7noD1xgZGMLk/erKs4WiVUUA4OZCc8eoAAAYD+Ec98cAY7HT4Wbyoo03MxXBwMnOcLnk9hjqcdB0x9NlWGu6cUt5xSUXa7k4JXXne+2vWx/RuSYJU6VKFrSlyuT03bho0tElfr807XPdfgX8P7/AMd+NNC0Gyt3lmv7+3hKhQcISDI5KggKFXJOeMHHygCv65/gr8P7DwD4J0Pw/YwJEmnafbxOyqi75UjBkZguCCW3MTtyQVIHQD8bP+CZPwWS61C7+IGq2YdLIC200yxZzK4IklQkY4BxuOMZILHnP7a+PfFlh8OfAWveKdQljhg0rTbm5y7BN0kcbGNVBC5LMVVVGXbIAIAJr+ossyz+xeH8BlkVy4zMlSxmKWzjGSSowktGuWMnOSf8y7Xf9eeGuSUsryupmmKioqUHPmlZKFGmryafm0730032Px//AOCmfxN1Dxf4p8NfBDwpOLiaW7iOoRQt8r3VwypCkvUKkS5kkf8AhQEtkLivxT+Pvjix0HXND8E+GJh/Y/gMi2E6k7NS1lXWXVtUkAYK8k92GSGR8MLVI4mJ2jH2nr3ja91GX4o/H7XSZL++ub3QPCAlJYjVNTSVJ7i3BLD/AIl2nOEVl5WSdMlSMn8iPGF5LqOr3EzyM8ss7McFizh3JyvUsCx3AknORkYGa/O/EbiSWVYOGGwk+SviXCCqRfvU8DhprlV09Pb106sk91GPQ/DfEDi+VbMMXjI1HGVWu1Rd/wCHhaDj7Nb2s3Hmfezto9PZP21dTtNV0n9my4sYo443/Zp0GVkTbtSa8+KvxRv5ogqltoje4MYB5AUDHJz8weF74WT2rEkLGsZIYHaQFw42nAIKnaOuSCOSdtdD8WtYvtZsPAFrdBWXw94HtPC9vtcsUjtPFXiO/CMcbw4k1Viyk5XcnIJ44+0ieNwmCdp+Q5PzBQBzhRjHUkABv0r+eM7xssfndbHxb/eewndWSUnCF7XW3Mno7aPpe6/CeI8fDOMRicUmmsRGm1NaxcvZU4tpaa3S1V7u/Q+ivDt3HYapG0J/0a6CzwnoFVzuZAc4BRgU4PGATnoP0L+DPiOJ9lhNNut7uPyXV2ypWQEKzL8q4DbTwQeucjK1+YWgXzT2Q3bfNsZFdcsGYwSHLdtxVHGQuFCnr3x9a/CvxI8TWzIQ2xoyxVzjODnjqoU7sr8vbPJBPt5Vi40q0KkfcjNptJ2i7tc0U7XdndXt5eZ/L3itw/HM8rdVQ/fU4+znJaPmhyunJW1u00+92vQ7H4yeGzpmq3ixoBHvaRGwNrBiSnPHD4A3e5GA3J+SNfgyrnb3OcZJXG0j0JBPOCOSQSDzn9F/ihYL4k8PWutQRxvIsPlzYIzvVTtJAyfmYHIOCwKkdq+EPEdi0byKY9q8grnI4JC4UcjkEAkHr2BzV55hoxqynFe5NKcGmkrS5Xa/z66eVrnwvAeZyqYehSqytWw0lh6vM7y56fLFO2+tou/X7z501i2IZxg/OQQMYAJ4PAz8pHBySTkkAdDzIGGCsOOgxgnBAxg98H0zkDucg+jazaPlz1AzngngqQeODkYBAyM8bOvHn86bWIOAwOQeqtjaAARjgnPO3BwOhyR8bLSWr7WstLc0LddE73fZtu27P6f4exr9nTSkmrRVlutYJ7aWWj2TVmTWrlHAJzznAPAJIz0wdmdvVT3IwDmvTNGugYoWJJfIRiCDgg4KnBHU7dwOMk49x5TGcEMp49wDwdoyAeTkqOemR3AwOx0W4+UR7/mBBXk9QQcHgcE9Soz/AAgA4Ye5ltdwlFXdk0915art1u9XdPq0fsuRYpyjGDb95aJ7ppLXTTfRtLa3z+g/Dt95DwOh5BBOARxx8pUYBI569/unGM/sl+wF8YX0LxGnhi+ucWGsIkaq8gCC5APl4PAJcZj67SeDjqPxA0S7z5eGwVwGJwec9ixGOuM4I7Ajt9ZfBzxbdaDrml38ErJJaXUMgdWIyVfd2wwCngksATxgbeP6H8L89+pZnRw9WSWGxkVQrxlK6dOajFuzsm4tKSa7an65wjmlTL8ww9WM7RjNNrmtdXinFPrZOzvtZvu1/XVp1wskcLqw8tlDA5GTwcZJznI7bj0ByCFx2NpIwCd2OB6/LgEZHpkdzuU/M2flr5p+CPjq38c+BdC1iJ1keeyiEwDA7JlUB84Jwd4PHIIBG3NfQtjNj0bsRk5B4JOOAeBgDpxgkA1+zZvg3QqzpW92Mm4tW1Ts4yXVprW/yWtz+t8sxUMTh6NWEk41KcZxad/ijG2i8na611sdZqFlDrOj3umXIWSOe3nhKkAjLoQQcZJRgwzjPBJxhjX8zH7X/wAI7r4e/E7WQlqINNv7ifULMbCF5fE0YOOAkhJGBjBQ5AINf006fJhlBxg4BJ4GMjOcYGDwOCeMj6fnb/wUM+D/APwkvgj/AISzT7PzLzRj9pkdVJLWzDZOuABuJiCv1HKN1JCn5TFYSOPy/MMrmvflB4vCdLYihHmlCL3/AHlPmSVleSjfVH554qZAs2yOeIhFSr4Re1h7qcpQUVzJpNtLXmduz3sj5y/Y98ewa94R07Q9VfzoLqG58J6tHKwILBGk02WTzOQstq7wZYhmMDkABBj4Q+J1tffBb4r+PPhVqYdvB/im6MclpIMRT6XflpLO5iBKjzLJ5Yn8xCGTyX6Ij41P2dfGMvhfxHq+hNMUN5a/brIB2QDUdGk+1RLGckbpbMTxggBircnBr6F/bS8Cj4oeAvCnxt8PxGfUtAhgg1t7Ybne1dLWRZWMQbH2a5bejAFPLnZhgblr8OnRrYbE1WtI1VySbunKaatGWtm5Lmjq1dqL7H+fGYJ5VmWKy+D5XWlVxmCTeknNp4nDSjs4VFKbUdW3BK13p+YPxA8O3+kaH9mv7Mm58HSSw3cN0+DqvgvWykQ1NSCUnt7K5ltb9UZ3EMZutuY0BX4A8Q2r6bq15aSIVEEzIp3H7ifNG25QFIaMxMSuQORkjr+7HxU8NWGp/Anwb8ULm2W/vrCwsfCupaTMAkOt6D4ksr7RZLK5KPCzTWd7cWl1bnzFZEm3xshiKt+LvxQ8OT+HNVtbK+Nz/aUA1DSdSW5i2Mt7ouoXGlsqsWdJXa2treaVoyQssuwhSm2vi88pz+rKc1yypVZU2nZuy5ZRaa1s01FRu7N66b+Fh5ZdisFXjg41YSw1WNbEUK0Uo4epVm6M6cLNXhKVOLinaVmtL3Z6r+ztqWoXdh4y0m3Z2k8L6bbfEvSiNzNBeeHbuDT9YjhZWEkaX+kajtu0jIFxHZKku5QSPVfAc2pfBH9pS78NXKq9smsXmiahagH7JqHhnxTZPZ3ls8BJWWyvPD+teUyMMNEFIyUQjJ/Yw8Ovf6v8VdZMaSQWvwwvNAVWcDOo+MPEOhaJZRxK3+tm8uW5mCDLiOCWQEiPI/Sb9vr9lfWvhx8dPCfxpttPuU8HeKvhT8MPFRkgs282G50/wvoOivcXf752E+vXuk6ndWMXlJLdQWssqxbVcL6WU061TA5TiITnDFYbF1akZTcdcLTdFKNNf8vHzTfN2UbbIwxefUMp4n8OaM66pY7Na+YYbBJNupUll1bC4uCnKyS5aVXERgpPVLlXRHw/+3PbHUvEHwa8UXTvLfav8G9H8O6hdyyRyS6lcfDTXNa+HsGrGRHeSZL3S9B02YXEzDeP3XJjwPtX/glx+w54o+KHj7wZr95bXGl674yt7i88JS3FrMkvg/wDZvJa+KPihcGW3KW15eQ+boXgGRik0+o3Fzq9oym20+4k+MdLtrvXviR4Zj8d6XpPjTw14Y8C3F54Y0Q3lxcaR4euPEGr6jrVu3icWKWd1rNza32qeYnh5JzLreozWljcz2um+eG/qn8P/EG1/wCCeH7FPjX9pf4vvC3x6+LOk2dxZ6JcG3trqyl1S3nHgD4daVbQLDFZWdjakajq9tY28dpaW1pPGI1i0+CSt80o82b43MqSg3iXFYSErNU6soRjUrzskuWlJTqLre2zaZ874xcV4TB1sbUy6NR5ln2Y1cuyTBqKlVxGMkqca1ZRTtUo0qkubmScXOdNSajKTXxv/wAFmf2r7Pwz4d8Jf8E5/wBnA21hZW1joul+PRpkqxpZ6NbxR3Fl4XuZoeEF6IpPEPiqeTGLWFIrhi88qt+O/idLj4EfBfw38JPhxBLP8Yv2itCuNE0maGJodZ8M/BbxFfiHxL4vnZSr6b4p/aJvrX+ztPkdY7zRvgtoQhjbyfFsxFz4LaePE998Vv2q/wBoy6vNU0eOGb4hfES5mlkttT1+HxPqM0Xg34XaJcu0bW3iP4067DFYJ9mLXGh/DfTNc1bZ9mTePpb9iD4N6/8AtSfGPxf+0f8AGnULfQNJuzdeJPFWvvGbHSPA/gG1hW2NpoERjxYI+kWdr4O8DaVbqjWmjQJNBAPNV30wmFp1PZRSnFKMmpu3tFBtqviGtZ+1rT5rPVtyfL8MT8SzjFYXgHhqeV1MS61XCOGZ8V1178s04gxMKcsDkcJKzqQws5wqYikndqFCFRN1Kt/ub9gb4HeDP2L/ANn66/aM8aabZ6lrEEs+kfCPR5o/3njj4k3UMtlfeJoISoY6J4e/faRoUiKY4LS01XU4nF7cac9feH7BPwN13xz4w179qv4rGbVvEGuahfP4Xm1Fd32nUJ2lg1XxHCpBRbe1Uvo+iLGBDBawTPbbEMZHhWjaFrX7aPxr8KaTounzeFvgz4Ktk0HwL4bt4XgtfDvgXSPJt9Q1hoBmOPVdVhggt1lcvL9vmgtVkkj0tnP7p6Toek+E9B0zw9odpFp2j6LYWumadZ2yhIbezs4VjijjUAZ+VVVmJJdizMzuxI3x+JWFoxw9PljXrqMIQXvfV8KrxhC6v73M5OUtHKrKpJPSCX8s8TZpjsDRx+KxlWX+sfEq9tmNWTvPL8slaVPL4tP93OrFQdZQUVyxlF3TUndu7xYI8E7ePl6ZwBkdf4ieScAhckdBX813/BX39rmPVNcj+BvhrU86F4O/4mXjCSCVjHf+I5Yc2umSMrFXTSYJd8iNkC9uGDqXgXH7H/tfftC6b+z58HvFXju6uYDrH2aXTPC9lIyb7/X7xHjtURCctFaqWvLkrwEt2Hy5Gf4VPjx8TtU8U6/ql7qOoS3up61qF5qep3k7M8lzdXcrzTyyMxJbe8jdQOoCqFBNc8KUcDhlUtetWUlTTd2ouynLpu/cT1VufS6Pa8AeCq3GXFMM3xNNzyrJ60I0XKN4YjHJxlfVe9HDwanJvRVJU2neFjx/XNTl17WJHdt4klaRmJHCbsjuSuBkjkDBB6cn6m/ZZ+FcnxU+LPhDwqIGlsJtRhu9WIXPl6Tp+Lm8DMegkSMRgkBN0gBJLAn5K0CKSeRpmXLyuNhPLfeAOM8n0PzAduq8/vv/AMEvfhILXR/EfxRv7MLJeSJ4f0OaQEMbeAiXUJomYAfPP5UW5SAPLcZJPH33h/laxWZU69WPNRw6eJq31TVO3s09tJz5ItaP3nfZn+0ng/wrGvmGXYVUkqUHTr1vdbiqVHkkuZWSs7KLdtXLs9P158H6RBZWtra28Iihgiit4okUKFijQRxooAyFXHJAxj3Ffkd+2J4vtviV+1l4T8G3Mwl8H/CSwbW/EarloI00+3/4SLXHkUBgCunWMNsxKlQ0qqcFsH9jdS1Wy8HeEvEPivUWjh0/QNFv9SndyI1RLO2knbqRuOEAUDksygLkha/Dv9lHwnffH/46ahrmsRNcj4t/FDT9AvzJ0XwjYzXHxC+ITK+TshXwP4UudFk2lRnWYoZNolBb9UzDFQqV0q11SnVc8Q4tS5cLhV9YxMkt9IxgtNGm1vof074kYuo8syvh7BzUcXneYYfCKMd/Z+0p00+WOqSnOMm1olCV9Fc6b/gol4iuvBPwe/Zc/Z2kVofENx4f1b45fEjTwpWdPGfxC1G+1WOxu1yHe40y91jUtIiSQbxDptuoUNDgfvT/AMERfgauh6qdVuLULF8JPhzovhsO0eEHjPx1I3iPxTIpIANzbrtsJXDb1XYjZBJH85vxk8Qr+1D/AMFHdfvJ2Fz4R0XxvNp7uCDbw+EPhdDc6nq8i4GxYry+tNRYZGzdexx5LHA/tv8A+CZfw3k8E/s06R4p1K3NvrnxR1TVvH2qB12usWrXJGlQkYOEi0uG0MYJONxPQ18n4+55PhPwYnlbk6WZ8R1MLgZw5lCca+a1p5pmrcUk5RVP65g2vdUIypRlGzUR8VY2nw/4f8YY2helUx9XLfD/ACaztbC4aEK2auDuv3dSjQqQlyt/xbS0bbxf+CkfxJsvC3w40nw5d3a21lqM99r+vuzAJDoHhm1kv7uaYlsCMAeaWORmAk5wCf8ANr+PHxJn+Inj7xt44v5l+2+L/E2t+IZkJJa3TU72ee1s8heFsbNoLSINnEcCRj5Biv7I/wDgub8dU0nwR8TrWzvds2oR6X8JNCEch+eXXPPu/FTx4IOV0KDWraUp0JjDHBGP4ffF155k7c7ApLA8DOGYDghsggkYwcgHI5GcPBvJo8J+EuX1Z0408Xmyljqzkm5P6zy1oStdNL2E6FKS70Ff4Vbx61B8OeH/AAjkMYqGIxGDqcQZgm/eliM1kp4eM10qUsHCjG71s7LrfyPW9RgLSN5y4KnCneMliCT8oGF244OTwACBmvLdU1G3QFmnUqULDG/J2sDyB8oGCAMMRww5jzXfaxcKfMIICkkPnkDHXnHGSFU8+xyflHm2pTE5BUHIIA+XIUAYOVjK9yWUk4yAQV4Pw3EmN9pVqS59W5XWq9Hdu2q3130fn+R5hVleT5lfz0VlZ/O99Oz6nGX2o2oZibuNR822NlcAMMDkbem4YCA7SMlcsoB5G81C1Zh/pSK6ONvyy7SAVHzAHBBwGXcoJUbWydtdNqEwALNGjksp2sI8Agjcx+9hU3AfeGOwINc3cTZ3kRwuS4371UEKSpLEjdg4YKGBBGcklcY/JswrtykrrTrvtZ+iu+u638z5itWldpOL0tq5Xd2krP8Amvf/AMB2VlfHlvrbJxcpgj5smQ9cHAXGQOOi8qRxjmsa41SyCyg3C7hlflRzgbQF52AtyMEIQWwNhDZJ3ZkDhQqqEUg4CRncQQSmDnAyQxAfBO4jGaqlR85CxqMHKhV28A4Cqy579SGH8J6DPzeInNtqPJdO9rN77vR/he/TbV8k5zb3gru9npr30d7O7veyb9DnJL+xcIrXKkBhHyrFWxjBkDHBb5c7R94MSFZtoY/tOyTcjXAO1WUAowB2jAwW3EY+YKGG1cEMVUADWdBlnATpnHlphWPBJ4POWXLMykMqnO3pXc55xGxI2sXihbaCd7HOxiqkEEZIxwykxkZ8qr7W7k5RfnaVlsr9bvfS93ZaNs55e0Ul70LaPVPf3Ur2111vZ20WmqMRtXs0mBFwhDsVkbDHYwZcNhguBztOAWI6HHJSTVLKNsJNG251yQMhA207gG2cjkbVLEkgYZq2BCEkLxohLqQ+I4uWY4Mh+UA/LjAPJwQOctSPDjJLIChL8RW4JySSCSnG4DjkgbRjaSdvntT6ST1um1st31+dr3Wul2mYOU7/ABRtZK1tdHG6u9E1ZXV3JaXd2r4cmo2W5WM6thDjYpAKjB+YhZGBAXeeGDbQpJYDDrRBfItzLE66eJABbOixz35GCSxRF8vTQQd+TuuPucRrIRo+aoIVoIz5LfIdkA3sv3CRtGYyQ5CkEFiQdpwBFJeF5X25YupLMQ/lqdwZwCGVfLQNggDC/KG4yKzu7rmkml0WiumtZXd2k+2m/TQqnZu9Sa6Ky+1bltF33ulpbTsr3tBqFxPPmZSiRrtyoDCJIon2JFHGGZI4o0xzgeUVQtnKouEZBe/KZFWycgGT7kl5IAhEcI4ZLUbSuVyZdrRoxyzVPKJb9jGcrYJt+YAob0rtbEZCpi0Gwkg8ytllxgYviJPl/dIPKGyMhWAVuQuwLuIwMbSNoByWXcgrFp1m27KGj2spNKKevWN+6Wuuq3ty53aKtFNLmTcb/Cm1pbaSb028tRgRQVfaDhBCoQsqKgIC7FUKqoPlB7hVwQqDAU7lwuVO7mQFQDkFQdpyuCQvysCWAztUjpWLmJpMksfNBAG4nbJghFwxX+F2bcDkICwJbFTquFUAkDIlyzqo3FUypKgt7EAFScruOCapONuVJKzV1orPRt2i31SdncltPSPLflTdklo7S1Sbv10a0srXdmPBx7BdvXJBA2kEDgYz0zuIGSeTUbsqZJBZZMBgqqWDHbheM4JAOVLAtksp2DBcCXJYqF6ADDE5+UZySDz/AAnGQeD05jlhSdRuJaMH5QpZSCOVbKbeQSDhiWAAPBAImTk+zbel2rXXLZXavfdrRvS66ErVq9903dK1k4c127Xvo1vsl2tGuD+8LyOCOVYt5akOHBjCqgwQASxz0OQwPDmcIp3OiqwGWYggMxVcZwQDyowSdxJIwDTmAUAAAhk2opAYldwwAWZtoyANzEYbJVsEg0Lm3+1RbGBUqVcHkbGjYHoGXCsDtO/JLYJUAgjJaJ2Sb0UtW1zK2t5e7pbS1reppF9rPTq7a2hezeitt5NyeqbakAkkD7VVSQNrEg4GEKsBjJOf4lK4PygAgEhLIgEsgOBsD5AbdhcAnOeeAAV24GGwCSV2qDnBU7CQV5JOQQ7t1LnjO1sMpzhscQukkmA+QA+c5ZtijqT8xB3nO7oOvAGal3s5NJPRWfLbVRT2t97WqTu1ezcZcsUrNLS23MvhXKtVZ3aWuuj7DmgU73VdjKQxJ3ELtCsQFwPlKkBh2ZRkBcbYSSdpB+V4928KTgNgkcBsfMCCV3ALhh93iV921VPMb4jk67yjbVY7jkgrg8/eByoBG2mkbZPLRQS0aqBtPyqNgZAZGwdxBIGODkhVA21KSatstE7aNNpb/hvr12SLlBJNq0WrbXTu2k7266dLXVrWTQsRLK4O5UdwGUFlJwpBGABlVJxkH5flXBVsl5Un7zFRjgZ5IYq2zLKGPJ2pg4AwW5ByyNDwVBwJVYglVBDKRkjjIUghs/w/L825alZQMsSeMpwNuWyobAAJO4HcVzj5lYHHNJN2953S2WqdnbS7sra2u2lq0vKIcyjZvms+uqto3to03ondp79iCO0ZEEazyPGjhjG43bEzkokgIbBMY3kHliC44Km8DhQSQd6gZPYYUcZPOQMlcctySoYVBG7ANvAyrEk85YDYvXOSoyTvwPpgZE7OjjjAUjCEgZzhSDsAJGOASD0GRycKRgoQSV1opO7V7q23Nrp2td3tvs4WUE7OLdrJ/FZPttvstOvmiMbHEqYZQiPGxVgN+Qp/dFQxyxI3FckYHTcVFYM1k8cdrE9wGaN5gSZSp3QxqWjJRhJkFAFZY1yUUGQkmxLM6LFHEqvOzqibNpCqDGPMkC4YgdJGzyzZJDKQHxmWG4gEiDYksWJg/lxlFkiUAInmYJfc3V13fNgsSWzq6RmkmrJpytJ2VlZK6sny266uz1vcuSvHS91pezTV7XTdraq/Xol5mpYs629opj2xlVjldQiqh3NsdQrrlSBgs6kqCwG4nFVNfObOABXUG+swAoJWTbliU8vbtBxlSATxyBWjaKPs1sFKlEiUgLgYKuV5CB2ACsCw3EByMFxyc/V3Y2kTNG0bpqVpEBN5XzhHGJAMZIYgjzBgjozYXI453dFpyu+VSu9V9n4dWtLvpq9U7H5rQaePjJL4a0lbZt83uuzbd/NdU7m4u0yTv82fLt9mDnkSXBLY3BxwMMGJyCQeApV7AFTgjBUkk4BLYHruJJ6qckgbthPBEZdUkmMjAfu7bhsAbjJc7QAVOXOcqTllG1icg0PIqx/eJJVyAhBJ+Qk8AbSvIJOMMPu4Awbi7R2TtdSXXRp2vdJepwJc1RNJ6uK1v2hezduur0u29OieVoB/4lmlYVgDdS5bDBVKxzglQWIB+9zt25B+U4ONoHjGMg/d43Aj5cAgnnBC7QM5J4wDWFoYYaVpTAAgTyAg5zh0nHBVSMZDEBt4OTkKGwdpJAygkMm9CfLfYjAAgZkB+Zc8HJx1AbFKlb2cE9eaMdO/uw26bq217dzoxsU8RVcW1erNb21dSV10d0l173skjMg+bWdTAIUfYLQFyygA7ZCM/KdykZGcYwDuAxmtPJEcByWXyYctmRjwgwRx0wQF+UfNg4IznLtmJ1vVVBZyLGz2oobOWjcdCoGdpKkNnJJDAklauSBHKI8qiP7HbsYPlDPK0nyvuAUt82AEVizFg2GyAzg+WLfXnn3Su31u1ps+r6NaFYiLdSlFu3+z4Zu2rsqULOyv+Nravppl6nGm7TGaMl/7TtNsrYIQEFhgEjcnCkYwHbJB3cnRjv4IVCT/ACs13dQxlYxtdhMqgR4ZtpKyH58bcjBIYfNS1Rt/9l7CGX+1bQggliVAdcnA2kEgDuAfu54q9JbNMwJkePyrqd9gTcHG5HZXYKpy5VNr9UQFVKZJaIcyc3G3M7aOzT0jq9Vrp1u9dr76zcHh8NCp7sX7R3Tvy8s9EtHe7fTRK700GalIV0rUkaPM32SbcfkdfLaNVDIQVJI3Lu2jBGWOMLuqWqtIlkVbaq2Foxj3YBCQoSwVeSCOxPKjjaWzU2qtmxv4dvK20iKMA7l2ryuSzEgsdzAlTuHzBzkwW8zJDak8gW0CYxncoQZ+ZcgEDjkYCs3UchSalVs2rci8n8dmns9NdNFZdhwg1gtFq68tldNOENbvyW+nlo9LwcLdo0mFV7I4ZlGCsV0AQXJHykMChOTggEk4zeDYTnAUEYAUFiTjJOPl59iMHL9OBz890scqiYOr/Yb542ZYgDGUgcck9cr5jN86gnGAcAbIO5FcA7mQEKTu6orhgwPRuXBDZUDocYW4TjJyS1ad7tvS6g9rdG913ur7rlr05Qp0ZvaUbXSdm1p7vfo322Y52O4BfkUAhTgNjkgjgc4ByFJbruI7CrHHNCiRxx748uAVYR53Y2yMCXWQmLcHYBRhVBJ3g0hdluJIgpc9QrFBlW8qLeuHA8zLMSFXpwB97EyhnihdXKHK5aSMPuQqu9NoCnytoBDY5EmHVATm4uTb0badtO91q0911X/A1aTgk201JR3Wu0bJpPfpporpNK2rZTcJKVEayxmXduRAkioiOwRcSquDgmPOF3HzC2AFMUcE0iYz5MbSNJDLI3mTMgChQVdiiDy2IMgJy2VwMAVOk+55IXikj2gyiQlHV4d6hZFkGfmzuIRiWGMqSQBUkjoERS5G5lHLMDlu5bnC9egGDg8nNF0ndN2j/MrNfCmm3ZrVWb3vpfdN80lHl5FzNJprteLj1trpd9dnsZskVwks0Ks4UYdpNzu0durJiMIwkRZQodkwwCrleCxYEXmRvbxQyKqooa4V8vLgvHHlFbcS7qCxdCqRBmBGwBjcnXylZ4iPMlaFZCX4LFWTLAuo3EHKLlgCBywKkQQGFpkjWQMRHK0bbgiPE7BmxlRukZjIWAUxt83LSZWs9E7XtZpu7vZXVkrvZ90t7K/U2Tc1ZRjZRS06yUVdtK1910dncnSVlyrxqqspWA5TdJAQ3mTfNK2CNoZcDn5VTDHFSJCgtEjR9sXlEbxuOMfNksWOCzMqyg7c4ZhgBQIknSeFJrVkdXcQFnCBABhpSYyEkBwSBjJ2Hfxjhk1rJLClvI4jRQspwq75hHtAQMpjCqSqtHh2IHyAsWZqtXsmrSbTS15d7a3vovlbXrZmF1ZRd6dp2krNtNKOtld3s7JN7rVK+qIsqSFVVpo/Mdij/KwIG8SQySsd2FU7UKZcsQVBXLWHV5Y9hY2rSEu23ymlAIADJnywsXJLhWJ4BOTnbSmnYySRSL+6R023G1HDuQFjQ4kfjKMHkUAybHychcSxz7ljaTzjH9xYzl+UdMszbnQiNj8w3qAWAK5KkkLO8dknrq02vdXKktdLdG16K19Jc65ZJJt2aaW603s0ltqrPTpfexbRAI+6N0KzPIp3kO+1iFAQuTsYhirZ+fb5eN+JKvxupJAUgHHybizJkIclcHCnO5eSeQB/EDBHPbFggkjd1wwXcpCE7GDhdu0jDJgL2xgkHivDbTNO0xuZVt1bdDCMKHVgjZYlEQq23OAMyAFSUC4rWOlktbWTV1pe121olbtvre1t+WXvuTnanZc12mm2uVOKtdt6u76aq/bVZj5iqBvXHLjBYsF3JGCSoIbawc7cEgggEDLVgieT7TKiSXKEFPmDLAm0ErEpVRn5Rvm+VyBtbAwKWNwVIC7mXcAB8uAGXLb9zkIMAcbgTyecGp4Ec4L53gHJUkEKEUhQwds7geTgkEjgtzV2u7Japq27WnLa6+56+bOfn5U2rRdkr9WnbTyVlruteokka3H7hnJVmQs0ed4RH3H5+Ttc7Q2xwfvHnBI1o4wwPIUKASuV6gAqCW3AkZG1gRu2njcOc2C3mSSaSWQPG0nmJHjDRhmAyWeTB/1YBVRsfO4qWBxoowVtjAD5TtG7HBQMCzAMqk5ChSRtLAE5JNaQXVpp7a+VvS6Td099PW/LWk2lGMou1pOzaUXJRv22a6tJ2aV1e9mNect6DYDkk8EBQWUkk5BUYBXqeeRJbRKgSONz8qkYy0rZ6sGcsAQ5wqlip+UgYIyKsEryLGxjUnb5hCurlECKwzLnZ+8wxB253LtwAN1akRAwzhQJcEbAhfayooSVlOSy4LOAh2hdykjkddNX5Wk0mtraJLl20tt6N9U3dR4KsnGLSdrP4d7vRbLsn023d3dK7atvKsVZSDsKkBSDtAZfl6ghyCOqA4ODg1s20aRKFUBNxXC/N8ynaSOSAACASMEBeM/ezkwv5jyRoCqxMiyS4XaWBjXYm7bkgB+cA4HB3KcdHax9MjOAoLksem3C5OTk4yckE5IPI576MdVbVJK7fdW8+nR238jxsVU5FvZv9dNbXuu1reXZa9pEQwGCNxTZgEgAbTtU4Uc4HXgkYH3gD1ljATIMjIAzt5AHIyq4IBzhsYyMZGAMVh26CNFIBy23GVcqrb02jGDgdAVyPlLAHAy3baVbPIE37WbILOo+UMCudvJYc55xlucAE5Ps4amr97uy1v21X8ye3y80fF5rinCDleNlddb9N7bpX9Ol3odVounorIkYwNyueS2CFXgDnrx8uAMDgjqPbPDWmF2jBU7gyYAVsgEjcSCuSeAzYAxgAjGSeF0DTA7ICpJVSqkg8425OT0ZsAYXqwBPLV9DeDdGkmuIlCAElFJOcEfc5yQeB39QOM5NfY5ThVUnCEVro7Wvo7bbdmlu7NH4pxbnSw2Hrzc0+WLb72stNVo0072+6zPrD9mP4N6r8XfiR4K+Hmixv9u8Uavb2Ut4qF10zTIs3esatKRjbDpmlQ3l27ZG5oxECWdQf9BD9jn4RaN8P/Aul/2Zp6WOl6bpdh4d8N25RQ1touiwrZxk4GfMuGiL3EhGZmQTNuZ9x/nC/wCCNv7Md1eyXnxXvtPxf+J7g+D/AAdJJF81toVnNHL4q1qINnAvLu3i0+GZWUvDpeoQglLnDf1p6ve6T8M/AVzdOEtdO0LSGOAQpVIIMBVyRliVAHUsx9Txj4kZnLDYLAcL4K7xWYTpOvGm25uDlFRptf35tRWrbtNO97v828BskwnEnHfEXinn7hDhnw6wmLWDxGJd8N/a0qDqYvERbvB/UMHGSk2r06tSnOOup8F/t2/HLRfA3h/W7nVbsLoHgHRbrxb4jhSUKbuW2Aj0TR1UkAz6nqEkNvGhGS8sTDPNfwsfEzxj4v8AjV8Tr67Ik1fxn8SvFwW3tYiXkm1nxDqCW9hYQqWXZb263ENtCASsFusQxtTC/tJ/wVh/aJvtQgs/hlb3pOp+Kb5PiD47jWTEkGmIXi8G+H3OWZlZlm1WS3YIVC6bJ33H40/4Jd/s+zfGH46T/EXV7dh4e8EznStPuWykQ17VbO5n1nU4ZXDxq3hzwrDqTwTHP2XWtV8Ms7LJMmfvclyijkOS4DKY2i6VCOJx1SO8p8satVppO9rtQe7jyR3sfh+J4sxPGPEXGvi9mkZSeb4qpguGMPWaXscqoTjhcsw8Od3h9anGnUrRjaN06y0lc+7PjVqel/sMf8E/NE+G3hy6jh8e/GHTY/CtheQgwXx8LRSTX3ijxGoZRPEPFF/f6jfRPvZlsNb06066fGE/AfwdocviPxBaW7p5kRl+0XM3GFhQ73LHBAGVCgEYJORjgn7W/wCCkv7Q8Hx+/aN16PQblH8B/D5F8DeDra3+Sxax0VzbXl/aRqBGsV/fLPMjKvFstumQkapXkHwc8LvHZLe+S/2zV5UgtQo+YWqv8xXOT+9fheSGwAuWxSqyniKsaXK1OpUdSpBJtRnUUIxp9rUKMadBW+J021rJn6t4ZZEsoyaWbY13qYxTzDEVqkeWUqPvVozqbP8A2irOpXnFv93KvKCdoq/6t/8ABOb4Dr8Rvi3Z+JNQsvM8OeBUh1ObfGTFLfJ8ulWgGNjEOrXJTGcRA4IIFf0sxKsMKLGuFQBApwMYIAAB5UADHyncCPl6c/GP7DXwZj+E3wU0JLu1EGu+JY117WCyhJle8jBtraQ4zi3tfLTB5DF8ck5+znI4JyBxgAnAOCOcemO/bBAySK+b4hxSq4pYSm1KjgoqilFtxdW69rKy0d5e5q9Ut+/xdbG1c0zDMc+rNt42q44Tmt7uCotRoRjfaNS863Ktb1H20qTsQrZyOgCj8Ofc579uh7mucuJS5KkAAEkAkk8jChunzDAbpxwTk8Vr3UvPPy+24cLkA8d+nvjnHCg1zd3MQGK55P3uSQPfJ5AweOntjBHDhKbbWmrsk7Nrda30XVvf7LTPhc+xqjCb5tErOzve3Kuu1rN+W+90Y95IfmPUgkg4x1wo9evJHPf05rzH4geKrTwj4a1fXL2VYY7O0lky7BQXXLKF57nuckAEHPfvrmYksMjCq3BxyewJ6Hbnr0AzuG7GPyj/AOChnxvi8MeG28IWN2qTzpI90EdQVBXG04xzkngghjnPQqv1+V4dTqxcv4VKKqVJK1lCNko3ate7suv4n5R7Gtm2aYfAYeMpVMVWhTVtXGMmlKTXZR7O3zZ+K37YvxkuvGfi3XL+S6Z1eecIDJlQhZ9oAJwPlJ45CgnAJJUfjz8RfELN54WQl5WkyS3TG7d2IHuS2F4IAavpP4ueL2v7u6dpSd7uRhmBCndlsZOMD5jxwehGa+FfFWrfa72Uh9yqxABJ+bB5OQQM9BzxgkAnkV83xFmCxWJlGLfLG0VqnporW/w6X/4df6R+DfBtLKcswVGFJL2dKldKOrajG723dm+vlu2uJurje5Yn5iSwyeWwcEtnJI4Oee53A55k0+MSTeZ2XORy2GOMYPIAIxgZyAVPXBGVM+WwM/MCCcgYJPoG5JJPGWA5yV79Pp0awwgFQGcKSORwQNp6KCBjHU9h8oyK8TCUpTqKVlyq+99dvuSd/N27LT+1eFssjH2TcUuVRlqldfCo67Nt20sl3epq2kZkdTggnnr9CNxyRzyfoxBJJOfX/h54cufEGv6bp9tEZprq7it0jRSSXd8LjADYG7GTg5IHAbnzfT497IijPAJbBGAB1JwMZ7nuexIzX6p/8E9PglJ42+IUPiG8szJpWgFbqSSSPMRuScQrlgVchgHC4LADBwTX7B4eZCs0zrCqtH/ZsM/rOKm9Yxo0Vz1L30u0lFX3m09dj984QyapmWY4TDwXM5VIX9265bxbb0srLdN763eh+5H7LXw0t/h58NPDmkC2SKZLKKa5fZtLXEqb3LZHBBYgn7vbcRivjv8A4KYfGWey0nQPg/4euHl1TxHdQve29uxLsjypFaW5VTnM0zgqg5cgck5A/Ta5vrHwj4ZvtUvJI7Wy0fT5bqYuyqqx28Rc5J2jA2jHXB+U9K/nQ1Lx7/wtn47+Pvjd4iZZfCvw4jvdYsxOwa3kvYDNbeH7FASVLNcbZxHgFvKyxCsAf2zNcd7SpisbpBVpPC4XX3aVKMV7WouypUI6NOybjZWdj+jeP81pcLcJU8Bh5KFbGU40YxjZP2Ciudp6WcnaGujblv1+a/2rtbsvBuj+GvhVYTRrH4P0pZdbMRwl14q1ZFutSlkxjzGt9626sWZgkQU5wGH51aZBLqeqo8kZkQSeY+E3japByQuQMDGAT1bIAHB9N+LHi3UPG3ivVNUu7h55r++ubqZsk73uJXckqMYADBEGC2MDgkCpfA+mjTJI76a2hubmUN9js7g4W5m25UuhKh4VBcuu9VVkB3A4I/ljijMnn3EE5Rm/q9OcadPX3Y06XLGGj0V42eusj/PXxG4mqUcPiXB89WFGcKNOOkp1YQTskm7JOLv0Wr7Wh8b/AAZ8RHwJH4uvbC7tmsvibpngFLaWFlYXGv8AhjTPFtiqQkRXP+k+aZIWFsY5ElJjkLPsrxLUNHubC8u4XR91rdzwOhVwUaKUxNvV1DLh4yNrj5SMOc81/R/N4G8Pah8KfGHjPxJrw1fwt4E/aq+CviG+u9F062li3+F/2f8Aw9f6laTPdNPHK9gbY6ZLFPI7ySRXEqud0m38w/EXw58K+N9B1LVtKlibxJdSXXiC/tYWt3zc6rd3NydslpHFtRU2xP50UbCcPBJbxMoQufCKxs8SsHWgq1GPLTpTtGpWdGUoS5Y6uUpJKSt0ut9D8h8GOM8dx/TzHB4qkqWJwUcPOmvsudfAYXEvDQlvOVOVSau1e1ldpq/wP4fu1tdTjhmwsFyDayhgQAJMqjEEhSFf5gcsNwyB3PuXgfVjZXpt3cjDhQM8AqwGckAYyQc87ic5PGPnrW7GfSdUmtpVMUttMVMaqAwdGbnAO4HB52nqVGCOa9C0m/IlsdSQ5E6IZPm+ZbhMJKCTwu/BbByQCDlSDXyNKpOjKdGa5amGqXkrWajdRkmn/eSett+iVj6/iTJ3icLjcPOD5nFtKUdFUhbVq27Vl20u/L9K/BerjWdBvNHlbd5kGYVPOJFywxnI5UAHjDAnJPBb5j8e6U9rdzqU2t5j4G1iSpJBDcjb0AzgHLdjknsvht4ieKe0kSQYJQMSck8nIPqpGcru4zjHFdR8VNIjmH2+FF8u4jEpIAxkIc/MCVUggZJ59MDr9LVmsXgIvRzpe69XfldmkvNO3ys9rH8q0aLyTiWrQtyUsVNySduVVYNcyeltU03bW9r7nw9rlmcvgEHPKsc4IOQCTgfxADgknnC8CvKdTt8FyoCjsONwGVDHj5uMndkEEAEqeDXu2u25XeGAJyxGThtwKg8n6AYAHUgEHp5Bq8DI2dm7IIPUDoMgZHJHXqDkYxjmvjq8VGbbspXulfRpqzstnq/x8z+heF8bdU05PeN03e7XLbfVLa1/Pqcgmc4yVbpkZHI2jnLAg5GDkepHNa1hL5cg2lVIPqD35GeGwduG46ke5GQQY2K9OQCQcfMdoHA65Oc8gABQMFuLET9MHnucjHbt1A/2cnb6g0YafJONrq1rO/Nppey2tvvbVq9z9zybE2VOUW3KyeklZ7Po73a33Vvnf2DRrjBUlhsbBBB55BIGTuxxx1OAM8kla9w8J6sLaeEk42soAzjseNxx1YjBwT/CfmyD82aFeKyorEsyDAHUgEcZzkEHLHp1znaRmvXNCuwDGQx4IJPVvlAHIJJznJIwDjBJyC1fo2QZhPD4nD1qcuWUJxkt0rpwS0Vm99Vvq10P1LLq8oypVISaVozS+aT7q11t103Wp/Q1/wAE/PiylzaXHg+8uvSezR2B65EioATyMAkDOcHjmv16sZdyIQykY+RuME8YyQOmCOMc9etfyrfsx/Ee48FeOtC1RLh0iiu4EmG4qrwyHYwOGAICYJ3AD5Q2cjI/p98H65FrWi6dqdq4livbSC4VgwwVkUNzjGTk4ye464xu/rnBZlTz3IsFmMWpVadOOGxTur88EvZyerfvU7K7d24aLof1D4fZysbl8aE5XqUGmk373L7rTW7srPbrbsj1ywkOFB6kjAGCeR0HJPGDwB0AJ65qv8QfD1r4t8F6tpFxFHOJrG4iaNlBMiPC6FemclSSMEneAeMCoLOYoVLYyTkcjGevPY8+wHI6gYPTW0wlDRsOJFKkHAALKoGV5ByCQePmzgYBr5yq54fF0sRC96U4zV+vwt7dHqrN7b3a0/RMXh44vC1qNSPMqlOSknZtpq1nHRNK70+8/lM+Jnh6/wDhL8Zp7Vw9vFpniK3CEhgstjcz+W5AA5R7ZwrjdtYEZO0EV+l37I1za/E/4U/EHwhrcaT21lceIdEljlAcCEFFspDG64UqiOsY2D7sK7SI8jjf26fgvLrXxr+HsGk2u648a6vp2hiOKIl2ll1qztY3QAhiYopwzFcsiJkjaK1v2cNIuvh38LPir4htw0+oeO/iP4o8OeC7C1kELatLFf32lae1pLI7IlvNJHLJPfM5jtbaGW5lZEjlaP8ALuNsJDC5jioUEowrVqOLwrWkYRrL2vK000lBya23v0sf5s+MuWQy/i3CZPhJJ5hXxjeFpR/iKnUqe5Ubb92CtUTk1ZpPfW/lHxa0bQfBfwG17RfENxdQ+F/Cmn6p4gu2sru3guJAYptF8I21kzpuk1jxL4tnsbPSohHJLHCs+oJ5NtY3c0f89/xS8dXXjXV7T7VpWn6Zc6PYzQXY0+NFa91K81CfU9RurydCBLcrfXT27zqp8wxoFBAIP3T+2N+0zH4xv18A+Dtbh1jwN4Q1e6ceIbAhLT4i/EK2S50/UPFFkSwmPgfwJZ3Nx4W+G8TIsNzE+seKii3evSR2/wA7/smfs/8AiT9pD42+Cvh54c0m61qXVNZsZb+3t4pJZb2Fr2G3tbB8K2H1jUZ7bT0UkKsV08vK28zp+SZxiXi5wwNBpKydeq7e/Je9Ko5WXJCMWrq6fLBc3RL5Z5dRo1aGVYG1WpObeOxcdsTiqlTnqJf9OaDdovZyU5t6xPsf9kn4D/E7T/AWoauunagng7xBoaeKvE7wabqRZG0bS9Sn0u2uLqK1tU0uHSjPbald3st6beG81DSdOIl1bUtLsLruf2pv2hfjU/7U+q+DfGHjWT4jWekaDoHw90Cd9CntPDsngvUvAMcHh248I+Hrx0lS6gj1TVFj12RZZruW/ubu3LxXSTn9Sf8Agp34rtf2dPhT4M/4Ju/BDT7DxB491rQtJ1D9p74gWE1vZ6lptp4huBrvh/4c22uJ5o0iDWtWY+M9dt4SJYdFtPD2lRwyxfbEb8nfgP8AC7x3+19+1vPrWmXl74s8RXmqweHPDNzfOs9rNq2h6VpfhxNYefyRGmg+FNAtH1S7uJVVxILL7QX1CWZa9zA4nmwWE+rxnToUqkI08TOSUa2CjZ1p8jtanXtKcP5oOnJq8ko+DxPlGU4LNMHntTG+zo5HhqtLmx1GmlgqUo08VjsxweIklOk3Toum4Qs5Jpa81j76/wCCWP7HP/CxfiNN8SfiNbPN8PvhLeWni7xzqOqiE2viTxnZxtceHvDHnOBbCx0KKP7dqMK7LW2REgYuHJr58/bm/ab1z/goP+1gPCng22vvFXwa+F+vp4Q8BeG9Nd0X4keONUvBp9rHaqCFWTxPe2v2K1uGAXR/BenXurSSRpNKW/Qf/gp58d9B/Yn/AGdvBH/BPf8AZyvhcfE/4kafEfHmv2Uypqo03W98GvavfzW5322q+MrsT2FgJGjOmeH7e8ljBi+ys34oWt3J+zV8F9HHhR2b4t/GzStb8NfC2a0JXV9D8D63NP4a+JnxsCJ+9s9R+IMkd18LvhMZf9KsfCUHi/xFbos2q6TeMsTiPa1ZygmqcrNqKfNCi5R9klG8nGpXlyPlSTt7OLd4s/BMJmMc8zbEeI2Lotc7r5F4bZViFG0KcOaGIzqdK3N70VOvWxDs3TVWMeZOk31/xElg+KPjHw/+zz4L1uy1X4XfCvxBdaz8QfG2lo0Wh/Ef4t3a2tl458fJKdxfwf4WsbdPh/8AC+xfFrY+FNIbVY4UufEepef+oXwvtbjxnoenfCnwfb3vhv4U6FHYa74pvbaCRL7xM+nW9vBdX+oiJf8ASU+3RrY+ENIdXi+23dvKVkunby/g39mn4N3Ftptt4Uism25sW8R3MMZEt3eybYrDw/YMg3XDmbAvbcsW8wFHBJmJ/pr/AGL/ANmm10+/S/1e0gfSPBd9Z3mtL9+31jx/awpJp3h6JiW87Sfh7byJJfoC8Nx4tuZE3SLpEYHfOrHLMPUxFd8mIqwUqsV9hXiqVCCWkbWSbS+O17Lma+X41p5bkOTUM0zubxuYRrVsRlGCxE3J4jMa0uetnONpN+/Pnk5UVO8aas4K7jyfV/7L3wTs/g98P4bi/wBOh0/xT4pgtbzU7MKp/sLS0jxpHhyOT/pwtmQ3rLg3GpzXczZZgV9j1q5CpJ0RcNzuCrgA5+Y42jAyQAAATxwDXWardjeyjGAMHoCCTkHn7wxwNowfT7uPzP8A+CiH7TEHwH+DmqWul3yweNvGsF3ougLHJtn0+1dNuo6sOd6i3t3MULggm5miYAGNsfPZdGtjMXPE13bmvUk23aFJJNJJvRRiuVLrZLWTZ/F+e4nH8R5xDB4dyxOY5nio0ab1vOrVkot9X7OCu/5Y04N7R1/Bv/grD+1enxL+Jl14N0DUfN8GfDk3elWnkTlrfUtdJCaxqChCVdY5ENnbuRtEcJkTKyMD/PrrOoXGsaozOxfzpSqgclVy2B9ODgY56jtXtXxn8YTapqdyDcNLJNPJJK7yl2YsxZmbOSXdiWYt1ZtvPbxPRIGnuHuHywiGFUjjcdw3DkAkMDxnKnJyTwemdV47GpxTVNSjTpxTuowiopJWe8Vq3Z3cm3fmP9QPAXw7w3CvDuV4CnSi6ipQdeq4pVK1apyTr1p/3p1HKTd/5Utkj1r4f+H73Xdc0jQtOhee81C8tLG0iXl5J7qVYYwAv3vnZcHAIGSSRX9fHwA+HNj8N/hz4N8FWMKxro+j2sd0yg/v9QlVZbydshcu1xJIz59skjgfz5/8E8fhYPGPxi0/Xby28zTPB8H9sSs6kp9vYtFp0ZJyN4kLSgcH90CByM/02eFYTmJiMgqEAOOAwbqV4+6PmBPB5wcjP9DcK5dLK+HPrMoqFbHz5opuzdCj7qb62nU5nbZ8seiTf+nnhBw/HCZdXzOdNKeIkqFJ21VGny87V1opSfK+7it1v8i/8FFfiQfAX7Pc3haynFvqvxD1S20FCjgSLpsbi41JsgZKNHGsTv8AxCQ7Sy188/srxWvwL+A3xa+Nt7HFBJ8LfgBrL6RLOCGb4ifHe4eLS4YAQF+26b4E8I2qHBLiDxMIyw87DeV/t8eJrr4t/tP+CfhDpcnm2XhltI0SZYmLqmq+I57Z7yYqDgPa2c0RcsG2+UQw5JrV/ba8WWvw6/Yk+GngjTHW0uf2iPib4p+KF1bIpjf/AIV54SSLwL8NYMABzZX3hfwvpusQsRsDXcsseA+6urLMPHMc4weBlH2lKti8Pha7U+VexgnmeZQqWlflrYHB4jCyS5byqQjJWbvy4zMqeZeI+JxTtUwnCGAxGL5G1KDxVKLo4eD5m1eriqtRLS7lST6HkX/BOP4Z6v8AEXxnr+ueXLca1468Q6H8MtKndTI8l74x1RfEHjW7Rj85aHSreC3uHUjbHqhDkK22v9CWKPR/hT8J4reER2mjeDPCEcUaqAqxW+kaUFRAo2jdtgVVAwNxXgZr+VP/AIIX/As33iz4Y3l/ZFoPBvhXVvilrPmRggeIfHc8MGgLMCMLPbeHbbS5oQfmQOSueWr+iz9uLxk/hj4LXmiW0vl3ni+/s9EhwwVjaLIbvUC3TERtrdopOR8k3Bztr8O+kxmU+L/E/gvgDCyvTwssPWxkI3fs6+a16XtXNb2o5fhoYhWSUI156tO5vx3hJ5tnHhb4c0W3OpCjnOcJayhi+IMTGvXdWPSWFy6iqmtnyVG3aL0/iY/4LJ/GW58VfEHwh4GN55sml6drXj3xAiSbhJrnjC+ktdPSZGY4mtNK0qa4iBI2xavn5UfI/no8TSyO8pW5wSWBAAJUsOCAASMgAcHdnORtr7o/bJ+KI+J/xt+Jvi+Odp7K/wDE1/YaM+5ip8P+H1GhaJsIyAk1hp0V22CUD3Dkgh8n89NdvSxfa4Iz83LEKzAfKqhhggDG4k46AsAAP3vi2dDJ8myzJqVqcMHgqceSFoKE5RUpx5Y2SScpJWV7Wvexz8f5jTxed4+VGS+r0an1XCxheMFh8Ko4egkkrW9nTVtNLva1l57q7OWYG4fhWRSFXqCAp5fPHAIIxznhjz5zf/bFYgXwJAIIMQXcc5IBIKkkEAHIz8xOCu2u11R97MckK3KjI4IwenJwoUEruwxwcjk1wV1GATK8jvJgoNx6R/JlUCPjAwThhwCCDtAr+a89xN5STejfLpot1vrezbVr+fVH49jaqlK135u+nRa6JO9vS7fZHLXa3aNtF2xyrFxxkFmcsgTaQWKq2wqwB2kjCACuaniu0LtDetu8wgqxUAbzu6MGXfv4ztCgnaTtIrp75pNzeZkDBRTkkZHyAA+YG2yAktt5ywycgg89IwcjIPyk7lc4bhUD42BixwSFQ9NoDADLV+f4uak3d3tomnZu/Kmu/e7te9u934FSS5nFylzW6vRpKPw766Xb37K6MmSPUCmTeRj92dwARW6Z2oTHxzkKxx84wFA5qp5V3JErR3z5XlwQMqw2nZu2kqwOQN37tgcjOQK3CHEZGAxVwVbcQ5jCggYDMG2Dg5+/kAk5qpmOMJG7ojPyFZipcuVXeSQVyxYfKeA+NnK4Hh1Layk3FtJPmk01ta22st7O+1lszl5UtJSla6STlpra0lv7y3W99WrXRiNaX+SRqEmdrMVCg9GIJXKBQOQqgkE4wxWNSBAba/8AMONRkwTwAikrkJw6bAAedu0nKjBXKkg7zuSOMkknZnOCD94E7lyzYHHRgx3YGcVY1XDOpZSCQVLAAlcb3A3Ar83Cg/dbIGVK54KkI82jbT5bPmlb7NtddW766XejuZyim2ot7JW5m7L3bK93a6v2bbVrJq+OtrqIBU6kxyFJC7QpbIIX/VAAgDORnIKBV5BpDHqX3vte47UVsldpVgvJJjPBUKSBt2D7wZCWOwduMZYjKZUB8AtjgAEhcD5cklVbIIC4IjJ+UMPugBMDBAyQdpAG0HB3cnOThSwIB55Qi18TTtG75nqmo69H1T3a2XmZOEXZXmtE9W3uo20T6q0k20t77NFCP7UGAkuGbgbgFj3biRuUADKqCC33wSB5igZAETB5Y2ik8vZvC4RYvMkAUFVdsKBGxUhlQlZAxzlwHq/gfMASDkk56PkKxO3IKgscFiMLnaMcVCyjaVx8pzIeGwDwxBAG3OThhggk8AMwFYezVmuj0eu60ur636tpb310EqMW1JN2XLZtvlXwpX5tNO1ne6smyptG0KCGCMFCqMYIIABUHAUDKlQAM5wAxAqsJTI0gKhdmQpJ+Z2/d/eZsMFHByUG4YUkORV1g0m5CpUDKksyscgKo2MyAh84wSAGXnOQd0C2qRFtq/MVK72Y5Y/KAWZmBBBwCCADwoywAMuL05UuWSd3fXpZfOzttvsuu0ZdtZWi+1lpdtau1npa3VX1SdVUdCpG35dpcgEhSSC4yApVtzMN3ysuQMYxTnO5cIwZFK4wV4YFcr1JGCACpOCwPIyMrh2bdtJOWIOVAyMFpDuKsVGCo7A/eJzzGEVlLFADlSdu4Fi23Odu1TngKME/MQwxyc3KzWiu0tOmrir7efz1aTe0p2T2snGyd9GuWzejTWitr1s01ZJG+fsysQG3biC23bgZbPzEfxY3NnBztGFJwQcdV4JH3j8hIAZhhjxt+8dpILGjJjzlhyy4DZ3AgZYE/OcLjADHIXkgKWw1lUHcSzMeQ3TptAClMgqccLt+pwAKhqz5bPZWXTTlaW0na6enMl0u0xqTTTabd1rfW6cVe2ttdlp02ciIDllHDAhjk4GBt+ZQOqnJBBX5jtJABIIGjSZEYYZ43k+8MfJ5akMTwQBjG0HHTKsVBdIWC7o8hgN2CCy7QRlCcAE4UckFcsQGyCKrTOw2lQSwIiRtrBRkqWOGKgKRktGQNxYggsBWUnyd30TTu/mk9mm16yVrva4wXut77Lfsmm7aWvdp7XfR6C4KKVVi4yZNzB32pzkb1OMPlQMdCWGBkgoojO1yzRERqAjkBjkgZbklwGJCqRluRknJqr/pEkEbAsZUdt+AyiXYF4EW8Eq6qAGH3s/MCpDNM6s0YIHyhcITtUgbBkEKM55QAYAAOAFBAEKV03aySTV9E1aOrbd0tHfe+3Y0StbXS2i0d7pN9ejSv9l6a3SQxXLpIEGGDMg3EElkUFSsYYnJZcfe3K5KAMASGtIR5ayr5YIViTtILmQH5sksC2dzqoG0sAw4JpSJWT5fmIiQqGUZZkYFQ3mNkBcN8x+8cBsEq1IyyFY2KgSBlcrj5AGA3FlUk7lwSwdiy52gkqtZqU20tU0r6aXs4tu19bXbWuq3uO8mtNPdVrtJN+7fbdJ37Np6totgtuwNjfIwwEBHAGSTjBXJIDDByQB1CmByA+VEh3KZGJKqGO4DG4ZVQCPlIBGSQSSdtKDMC+4YbYWQHO3AxsH+s2qWwd3UEEKATnCxlzEvmKBK2GITAUYYAKcbyDwQ6HKYXb1FW/f11V762j0tdva2nR7N6bWFytu97WVr2Ssnbrpv1ve+m6um2F2xuxhHZUyVJAZgoAAG5fuZVhnecgAkH5bcmHURp93yssVKErkDYgYhcD7pJQ9OhVmANCNFLF2YqSH6oSOdhUxKm1sAlQGYArwoHNWoUaOKISM0jKV81iHO4kLuGGPzBdvO/OHOW3JywpSso8raslZdNY312ejSunf3Wm9XaoKXLFPV2TutP5Va63Wutkrtb3HwRBjHcOGRwjIis7ZjV5C2AqkYLAZyDlUAGOcl8/mMI1hUjMibnVQGQBoz8mSud20EgkDjdz2eWAxncVzkIMhQBhTluUACj5SAArYx8p4lV13p8rgs8eQgYEBShQlVwNvRQd3J3EblNKcU6coyaXNu9tdLteqta2zdvJbW9y12m1q1ZO9lvqlo10vfay0RqWSokECxoVVUAAJOARIScgnJwOqkB1IC42jAz/EDBbK3cZHl39m21SdoAYEKVxhSQARuJXn0ya0bYN9ntpA25QjE5JcqDNypVfu5yQCC20EEFlYNWdrxV9PXaVG68sMBgNuDNwyZOQM5A4I4YfKBXBP+A3a3ux11S1UbX33TXVWd09Ej8twz/wBvpt2bdd6tq7tKzt1u7XbtrZuOiV9Pess1wWJQAWkeyUIqs3mXDJMFzukRgdoYkE8nkcqrmMI25htZXIGQwA2lgQMEAEkEMAFAUbTyQEU5aQFWdUW34O3bkyXALEsMgoQCuAFCgBh2Zz8I3APyMACOmFIxwGxkZCqvA5YMc8WrqNla1mnutL+d2nZO7WzSeml+bT2kL6K8VZStty72V23bzvvsrmRopC6PpTE5Rbo9MMIw32n5mAK7VGQWIUAYY9TzoRyrcJ5sLgoWO1kdtshRUBVA2XGCGD8nPyjgACqmjEf2LpxLAnzshW2g/ILhlYl1H3SMqcHdtVMcZqdZVKgRKrKVAYofkjY7WZiqqFyA2HCneHBwSpAMU3aMNWvcjdWWqSha7W61Wttb301v1Yl82Irvl19tU1u1Gzm7pp21dkk9NrdUQ2g/4neoggAPZWABYHbwHAAUkE9OFyWySdzZJKTW0NwkaSmZkRYGUh5UKhA3ykFwCpYgnaANwRlAJJp8LD+1b8HDD+z7Ejaq7zhu+1iMgc8NxyVOOTaSJGEJI2kQwHDEHO0nnJB5J9sEDBw4FCjemlo2pT912e01u+9rN6t3ejCc5RrRabj/ALPhlFx30pQ/rb5aozr0SZ00sM41KzOSM5wj7du5iQCOnZiDwCpzqF3QyGRXMZupEyoUFBIUYF8uf3eNxbuH8zpgg5uphC+mYON2p2oB+8cbZMsq9VUtjIQsScKORWg8gjR25YPcTIWChQd4KjzHbAYL85Y8naCwDEsQ4Npy1s1yW3f2Yq1vN9NN/m1X96lh7rm5udOL03nF77u2uz+bsUb6FjaXGJNuUZ2DliGVmj3xoIyqmJlBOcbSRjgEGn6fGv2WIyBJSEIOSGZVWRlCjjAKgY34+/8AMOG206/k8u1uGAYlYNzEMPkYNHIGwpClTnhSAD3C/eSlpd209u7RsAYpZ1kY8LhyzptUZCgjGG4AYHkHmoT5aq5km+RWXTdK621W333b1b6eWpPLZ8n2MQpN9VZRWreqVmktl36XdqWnyXFqGt5S1zE1wYlkBXzLaUbZrYF28pCM74lCqpbG4YKsudpniOCOMWeoEwTRZi8yVNoDKFGJB8zAod4ICqGABDAg7uhbzUhaQRtLt/elFGHI3DflpCSAgBUEKSwOCCKbNDbzHfPawTyFEYGSBJQGDfNGpCMQyMTkMCBgk4CgMODjNVKbUXaPNGSvCS03krJtJLve2xnTrQnRjQxFKVWHO+SpB8s4SjZySVndN62fVrXYyb7V9OkCiLUFjVHDtsLsZAgM3l5REdWkkKbH3gRlXEgVZGK349a0koP+JjZBjGjMoZo+Qu3B3oTvCkEFc4OSpcYWo4rCykmcRwWHkocbVt4pXM22LzWdWUFVQNhFJIilBK8HAkbSbLYiiO3yh3AmytmMhG5sOBHuZWKqAW4AGWbDKocXXvKS9k9tbSt7qS0tJWfa1l83Zup9SUYU5+3XL8N3G/vqLtL3NbXsu3ktHH/aumNJKW1KAtl9rm5JWOIk7TGuFDfOAXQBQyYJAbcAh1ezhjQtfWMu9lillhmQFdwjZZvLYFVVFDKxAUswKrgly0sOm20rb5rOxSIPIoi8iF5cgqiyNhIyiA5IRiSjEjnKA2v7O09PkNnZN842FraEAplixnBGR8rAlsfxYwBghpVXFO8E13UlfbdNt6P0fp0mTwULL99LVJ2lTslb+blTvrd20vq9G06c2saOyOjXts6bSh/ebmckABhtUMcZPO5SCW5KlgWDU9IlVt17AF8t4418wxny2zhgCGZdxIyoJw6h2XJ31ovptiFGLOzT75Qm1hCvt+cM2M5UH7wbcDgEYzgxNYWhaPNtZkKgJxBBuUAx7ViwAGAbcAzZYgkMCAMLkr2TbpO0V0m272tduT03XVLTaybiNTB6cv1iCT1XPBa2TT1i9Ho9Fqu5Qj1DTYlAi1S32bD8zOitGcFRCSVYyqylFkbO6UpvPHKtTVbX7ORLeWpl+ZDIJAn7wBY/MUNuIt8HkqqEHJRVGGq4thYMrKbSxdd2FIt4d5fam4NkKAYy2ZEDcNnDAbUA+k2TyLJHa2hjjy+14F3SuSh2FCdpiQAKCWGCMZYA4ajXTT5oWdo2XtHpp0cn0+b6aWT0csFJWkqz1Um5KF38KVmkm77PRtfJEUGo2EIhUX9s7DCrIbgMdxKktIzHa6K7kYKKxADDJAYXI9S0xWdBf2gdiXkPnR4GQmFGAEdF6KhUhtoJK4VQ5bO33kfYLEQkkiU28QJAdRgR4IHzBjgspVfnBI2gyNa2qqp+w2kvzYcpbQbo0OSpBIXcSo4C5JByxNaQjVWvNBarpN78q011dnu1ZJ9jGcsM5JWr6q9+enps0rcr6K6a019SFr3S3WPfqFuVQggrcIrlw6sC7KgY4zl03DOAq5EYJtrqNiysBf2pCjKbJwhLDBU7cgEEYG0YxjJ5yBCtrZs7KNPt0jDsHlWCEqoTAC7RwyhnDb43II5U4AFWxZ2Sx/PZWmwEAObeMKqqVG7IDAffwVKjcvKgOADaVTWzp66J8stLdb3slfWyWr01VzCo8O0k/bX3XvQbSaitVy7tpPTdXt1BL6zL4F3aq2MEiVCGJPynewdjxhmJUFxld3UVaOo2kLoiSJJhcu6bHjjX5SHydjFyVbCx5H8JGOKqGGw3pDBY2s7kIXdIUWKJdyEtI+xegkPyIWOV2yYcZGrFpNiUCiGNnUEqFLxqxBJyF8wqFyFABC7l7ggY1hzyaSUb3Tk/e3bWmut0+i+7Q5KvsY2bdRaPRuN7Xjdu2vV2VtdHru1XU7EZ23AYKwwoWTC428kFHIGMkksSDgnJIAkS9s4o4wtwjK8nm53MWjdyrMGLKQ0YAGFCc846ioksLOOYobaBkwjrvLh1JKqA6q5YAEkgnIVmUZKkKbkem2TbsQARk/NkysyDKkNguPkIIXOCASXU5xXTTjUb+w7e60r7NRv6b6PbS3e3BN0YtNOqlJKT2t0S0tdPXdWSenQktryzgVIUujIAXdy6ySMxcKzENsHqRGAueFLAdBsQXVg4I88MDhTuDHbk7ssCuEXLPkL93O1XAyKzraxtvMCzWUWTuVX6hlVkUlvnLKxwWIIBYEKFztatu30+12ri3iXLgxjLENgLlssygAE5wcggqMKxyeyjGbaT9ndaW97tHvpom1Zp21d0eZi61LWSdW7Sle6a+y22l3i+ya162NFLu2B+ZxIGwAoLbsj2CjgBt3PzDbgkcGtrT7qFPLRnicbflY7kYFgmEbeshcbujA5HHOQAaMGnW7SxqIRtIOcbiqgMgHysQOQ27OSTkHIAGeptNMtFADW6lgVCgEjKkAljtJDAdxkMTxxya9ShTm3ula2iXmtOvbfs3tqfL43FU4RacZvzdtfhs9EtVd76vra5p6bJDKy/aJonc4UIittjHyYbgAu2Rje3Tk8E16XozWpwd6t8+FHztt5X5/u5yOBt5AJZQwbNcrp2lQMyr9nAwq4OGGVIUqCFLHJGCSuMg7gDya9W0DQ4R5e6BA52kA5zg7SBgkHJJBIBOOVwGOa9/A0G5qyjb3bt2X8qu+6WqVnp30PzrO8wjGEviateyelrpq1lv5WVz0TwxbQyvGBKDggN1G4fLjjAJXkE84GMt3UfdH7Ovwu1X4oePfCXgTw7CZdU8Vaza6RaOqlhaQyv5l9qE4A3C20ywjudQun42xQSNhutfLng/wAPRyyQhbcAEqFIHodoIDZChidpYrjAO7LZJ/ph/wCCNX7MkuuavqvxevNNJaSf/hA/ApeIsrTSeTP4u1mHKtujt4Da6Qk8ZA8mTWoSNyMK/Rsnp0sHQr4/EWjRwtKVacnaK9xJ6u9kls21om73Sufyb4qZ/iXSWXZdCpWzHM8RSy/L6NK8qlXGYucaVCnCCvKb5pqTUVfljLrof0mfsO/BDRPhv4F0aDSrAWmjeHNHsfDPhyN0Cv8AY9PiWO7u5MY33N5cq0t3KQDJci4kOGkJqn+2z8X9G8LeHr3TNRv1tdB0DTLzxV4ym3jbDomjRNefZypYb5ruSIRwQk7ppvKj2t5ig/Z6Jpfw28BnJW3sdE0tmZjhT+6hLu7HglnILucHLk5BJNfybf8ABWT9pe6k0X/hAbS9ZNd+KN8fEniVBKWew8B6LdY0HTJNv3BreqwmdkOzzLfSFIVhcgn4Hg6hPi7jDH8T42MngcuqOWG5vh51ph476OEV7RuP/LxrS7PsPGOmvCjwb4J8Cchq8nFHHcVX4nxFJ/7RHBSlDEZ7iqs9ZSWIqy+p0nPWph6VSF7pX/En9oP4k+I/jH8R/EXiy4imvvEHjrxCH07TICZpoReTrYeHdEtI+XKWVr9lsrZQhJ8mJcksa/aLUJLH/gn1/wAE+ntLWa3t/il8SrHUPA2iXds4F3LrWryNc/EXxRBIvzvFbTRjRLC5GVbT9C8N3Fuym4c1+fv/AATf+Bd78c/j9b+Lry0Z9A+HdzbLYyyIHh/4TTWre7/s24jVmEbjwlotjq/iwnDIt7pGk2823+0I99L/AIKf/H+2+MPx7n8F+FbhR8Ofg3af8IB4TtYHDWk82lFI9c1SHHEjXF/D9mWckNJaWVqWLH5R+vY2slFzerqNVp3drUqckqFPS6bq1482ujp0JrXm0/CcryWnmee5Lwfg6fLlWRU6OIx8KavBzVKCjRlpaXscLNU2naSnjYzXvULn5/eH7G48Ra7FCcyS3lyC7sST5TuGeUkscZOTuIzgkkn5Sf2t/YI+BI+KPxY0GCazaTwx4RSDU9SzGTC0Nmy/ZrZz90tdXaBnXJ3xxyMAeo/Lj4OeGXZJNZkiZXkcWdk2Bu2ksJpFwSSE5XK5OflyCQT/AFq/8E8Pgmvw0+DOneINQtRDrvjUR6zcM8YE0WnspXTbcnG4L5BWYjON0z7Rg4ry1W+pYXEZhKSU0nTw99516t/e109xc1Rvry76n7Bx/mcsFlGE4ewb9liM5qKjV9n7sqOW0FH29uW1lKLjSTs9asWrpXX6AWlvDZWUFvAqIkESRRooCoqIoACjOAACCR0Hy8DHLHbavJGMcKAM88c9RnoMfw5AxkkVakcD5QTgDHTgEYIYE5G7p9OeMZxlXT44yTkdSeCfu49sDIzxnqw4r4OmpVJylJ8zk5NtppuUpX1bd766ytu792fmmNqQwuHjTilGNKnGEYxei5Ula3Tbbrtp0y7qTkADDH5iAcEfdB+u5iM4yVwRmubvpcbguemTz6YPGWPUd+eSRtbnGtdTqAzlj3IOOmFJIHqSdxBJBzgk9ccpeTbyxDEnHPAUDJyTnJxjce2Cu3oCQPoMFSVoNrRKL12b0sunW19lvfc/IM/xl5Tim29br+6lHS1k+l0luleyRwvjrxPaeE/Duq61dyiOKztZZtznGWUPtU54O4gHOCcAdCK/k+/bI+NFz418Xa3ePdtJEbi4ESlyQFDMqjIJH8OQSSPRRk1+2f8AwUJ+NkXhLwlL4WsbsR3d7FI1yqOQVTaAFbqQCScrgdQep5/lU+LHi4313dyyy7iXkKnIPVjklichjkHJHBOa+lxdWOW5TFbVsSueV7X5bLkir7rrrq72aVtPt/BDhKecZ1UzmtTvSpTdHC80dNHH2lRqS3b91Pyt1Pm74ieINwuHEmHkDqPmztBLfNjoAdoPUlcZLV81XkzSSOzNlskfNwxJwM8kjqSBnByO3Fdx401U3d26FshXZSoY46lQw5646DIPQtyQD5tKxZjjkD72c/LkjgjPHJ7HrjjFfmNWo6tSTd0m3Z79lolpdu79EtL6P/UPgrJoYfD4dcurjB2Sdk7RSve1kt/TT0mtoPtE4LZ2KQxPUAdD8x+U/NgHgbgexKmustYi5AI3YI4AyAARwSOv3TgsBuxknBJOLpsBSIMRywIBIOSADgc5wD1wCCQQDyc11+nW+4g7T1wSRknPVwDgYGCTnJA4DenuZZQlP2UdW5pN6aJ3VklLztp13Ssf0XkOB5KVNKK55pa2+FaWVrWb0s9urt1O08LaXNf6ha2kURd5pI0Chck7jtXbzuOCN3UZOSCRxX9Vn7EXweg+Gvwl0Iz2ix6rrUKanfsygSlpk3xKzNtICqVGDkZyOmGH4MfsX/CGX4k/Ffw3ZSQvLYWd1HqF+23Ma29qwkbcduPndUjAPG5sgHt/VbotpaaJpMaYENpZWoVcbQixwRjJ/hwuVy2DgYySMrX9OcJZYsl4a9s6bWMzipGFN2TmsLTcbtJapVaiWtldU3a6ev8AVnhRkahCpmVWFlHlp0XJbO0XJrTdK1ne1m+l0fAn/BRz4yr8OvhGPCWmXYi1rxlM1iEiciYWSAG5ZVVgQrYEYOfYEnNfhf8AGLVz8K/gp4e8AI3ka94xnfxf4tBc+cIXVRp1jKByRGjKwic7RKGYf3q+xP2hfGyftC/tUXsLXHneB/hu00tyxZTa/Z9IPmTM7Z2L9rvUjhIJIMaMuM1+TH7SfxBuPHvxB1a5iZjBNdi0sokB/cWFufKtY1A+6rKobYoOO3UY+X46ztZfl1ajRnaag8DR5WuaU5yhLF1E7J3elK++jW1z8u8XuKlmXEFXC0q3NhMtp+xXvaSlCyVraa1Oed93aDvqzhPh14ek8aeJoYZG2QNM0k88rERRQqGkmld+dqRwKQHJ2xblPcA+qadf6GviDxDrK6lZaDp9noutaX4LNxapeR6lrUNpHAsf2dsJhLGe81KeYtE0Y+ykH+EZGnr/AMK9+GlzelFTWPEbfYLJ2V98dsm37fNExyMybltFOAS+VUgDn5c8ZeJop5rWwt7h/sWmW7AmOSRQ9/fqH1OQfvQHYuiWgIUM6QID0UH8Ow7p4T2darTUqyTxM+azTqVFFUFPmV3GC56jTupNQT3uv49y2k+KeJ8yx1e9TKcC54LCwv7tapBw+uVXzXi1KVsPGS96KhVs7NpfpvpH7Vekr+y9498IvIyeIvE/xi0jxbf3OqTQ3V7eWll8Pk0Vruzd9Sj8nVtSeK6tJIFtpUhN6sxihTyobn5x+FXjWKK+uNQ0W5SewW5uZoYp5ZZpxpgEQksJ1lklAuTBsnji3OQsU8qlnZ1r4si8QWCeE7iya4tPtN7rDX0kQhMlxD9liBhUXOFMEMjFRJGN7hm8x2JhXGn8PfE8/hvWLaUvdGyaaKLUPKldlfezyRXELKwAkeBpovm3GQeYNp3ulWs4q08ZgcSq9qlGEHJxkpNTlJS5pWfVtXjK6tpserhuBsr4U+u47htTw+OxuO/tqrBSjJe3hSow9jTjBLkpqjRjGEXolo9N/qX9ojwbbwX1t4s0hA2ma5ELpXQb0SVmBZTgfeVs5HBDb1GMMK8J8Nzu9tcWJYeZGftUG7k/J8sqoPlG1lUN8q5LDkjBA+wrSKHxj4O1rwpIYrhLS3k1fw/cI6yNNbbpDJGCOG2heituAE7vnEZPxrBFNomtmJlKm3uTFIrcfuySCp/Nick9QW4+YcfEMKTzChmmHio4fMY3rRjZxp121CtDbZS/eR3urNHvY+tQzOhhs3oJKnjIJ1qdn+6xMbQr0pJXcZKV5JWTSa0Wl/ov4d61hoom3BkPBzjIGcYyfxOM+2COfq+4xrnhpo8CSSCPKLuOdrBs7So5wecgEDg4yMj4R0m7bStUCq7bGdZIio+Ro5OUIJAUAqdowTgkk57/AFt4I11ZYkjZ/klRVY84w24MeueMbgQduMjtijL6rhKVCS0knCS6pNxUXd7pXV7u7V7I/l3xMyKWDzD67RhyqFVVo8sfd0cVJXSWjTave+mtj568YacYbmdQpUhmPICjKkggEnqdq4OCDySc4NeL6vblt2V3HBUgA88LyM54z6kHPTcCK+rPiNpgjuJnRRtdi24BgCpDHoBzkdWUsPlBzjBHzfq1scsAML8w5weOM88qDxwGBGejclT4+Po8lWSt85LppqrLTVXtou/RHt8KZkp0cPLS7UG9bbKKcXr0t0u9noeP3UJRiORzlec8/LjqcA453cjAPoMRw5DY7ZPzHgDlSMDkjsxA6ZI7fNs6jEUJZlJO44OCM4IDDn7wGdxzwxO48EisWMlcf3dy8bPun5SQuOc46/NkZ446ebFtSs7rX7/hj0W+iura9PP9/wAgxvPGm76xUFZ66Ll89dHe7e3yOp0qYwyKc5LFcDnHO3B7dscc5PHzCvVdHnwVI5JwcgZwTgtlR04wCTyCO4wF8Tt5NrKQxAypIyT0PXJYnn2AA4xzzXpOiXodVbccjAIzk8cDjIGCODwcZIzjGfqcpxFnFPWSatK1lK1rd9rPV2Tvfbf9dyjEc0eSzv7rjq1ZNpOy62bei1380fT3grVmtbq3lDNlJFPyEZBBHJGcYAZsgHp09R/Sb+xL8UE8YfDq00u4uQ+o6GEt2UnLtblcxMASCRjcOB0CgL1Ffy7+H70q0TBuRhmxnaw6gHDDGd20YDe+Oo/VX9g74sP4d+IunaLLcstprKm0dGOEL/eiwgZVBDfLwFyCSoBJU/0/4WZpTrwxWTVZq2MpKVBNtpYinaUFq7e+rxSu/jXRn7NwFm/1HM6MJzahWkqTu20nNxUG9Heza0e93o3q/wCiq1lOCACVzlcYIAyCF7Z6c45Gc9FxXR207KVZWIHGNvU469wvAyGBI5446jhdMvI5vL2ncXwR1zyNxBYckr0OPbqK5r40/Ey1+D/w91PxbJbPqmszvaaF4O8PQljeeJvGOtyix8O+H7KJQ0ry31/JGbho1Y21jBdXbYjt3YfVZhTpUJSdZqEYRcpOWyhC3M9L7LV233t1P6VnmGFy7L8RmOPr08Pg8FhqmIxFerJKnClRh7WpNzlooqCd9flbb5Q+OXjjRpfjRr3ilQt2PgZ4PRdKSRWeG/8Aiz48+0aF4B0azMcEplvLXU7+HWZvJzNbw6RcyTBY0BX8nv24P2hE8D6Hpn7Nvw+1l7I+G/B8Gk+PNdtJ4/tXhzSNRtg2uaPBcWrbIfGfjprm5m8UTWz+fpnh6/j8L287PqOvG26z9pT49x/s6+B2vdR1W08T/Eu41/xTeeGkcQXFl4t+N2qC403x78U72PEjzeCvg1a3c/gLwNASbPV/Fp8SPb+da2cwP4Nar4t1zWGu21e/vNQvdY1O413WLq+keTU9X1S9LTS6hqtxIzO0kkry3KKSVjVlDA5VF/nbjHiCljMdXnTm5vm9jSjeyhQpwjCk5N25ZyjFTaTspSkt9F/l/wAR58+MeNuJeO4KpCnmVf8As7h2jOyjhcjwvNGGJjH4oYjH1Ktao5StOnCfs3ZxRfu5rjXdUjgs7UpG3lWWm6fbxgmG0VlW2tYYlB3zyswLhPmkkcnlnIP9gX/BHD4JeDP2L/gn8RP20vi5a2kDfD7Qr/WIZb2NJVm8aLby6ZZabYruSa8l8N3erW3g7RrSxJm1b4keKNUtbdhH4bvbzTPwO/YK/Zf8U/FP4geAZtNsEuPFnjbxDHpHw6tby3aW1slgk3eIPiRqkDDYNC8GaeXurSZgsd1rawRI5FrcFP3z+PvxE8I69oPhf4G/C/UrfTf2WP2UVuILTxRfSxNp3xc+MPhqK4TxP8SvEk0TFdT8JfDO7l1abRrdGlt9e8X3tzdQecmqwLF8jh8lq4unToVU1UzFP27acXQyxcrxLlKycKldJUKcFqlUnU+wxVcRR4awkcZjpqjjMXFeyjOyqUMPJRlFwjJN/WMTooJxfLRcpbSR+ZP7RPijxT4x1LxH4/1zw8mj/Gn49eMfEWuavNql5HfXVlrl3btdaxLqcflMLGy+EfhSYRzrZvbWuk6tqc2nx/abrTwkX65fse+Bfh3/AME0f2IPEX7YnxWsms/E3iDwwbfwFo+o7bbXZ9FvZXHh+ytoZgk1v4j+JeryHW9T8tfNtNNktI5SYLBq+Mf2CvgNN+2f+0xF438Q2F9F8GfCGjWWt6ymsNKTpPwu06+fVvDPh3Urm4I3+JvjD4hhXxt4ulcm5bw1Hp8U8r2uqPGfOP8AgqH+1BqX7ef7SemfBD4WR3usfAn4J6xbeH9K0XQI3eD4h/EGedNDtrTTYLfaly95emPwz4eiiYkWKahf26KLg497HVaSqxw2HpRVGjGLnGDupL4aGHjBS0UuVXipe7ShytWkmfztxfmeL48zejwvHEyw2T4aEMdxJWTahhslwtSFVYR1laPtsXLmU/Jwmm6cZp/EPg/UdW/aC+I3xX/a2/aP1fUk0nUILzxv8QNYt5PLvtJ8AzznR9F8EeDGnP8Aovin4nX0dr8OfAMFvHI2k6EmreI5YDZ29zOd/wCEeieK/wBob4n67+0N4w0uytbnUJrfRfh14VtIzD4f8K6Noenpo+i6No1sVxa+Ffh94dsoNG06SEZbUrf7Q4lkknL5fxL01/HHi/w9+yl4E1G3vfAnwq1wa/8AGvxp4fRJ9N8b/FtVi0vVY9JnTel/4Z+G9s8nw3+GttGz2d1qI8ReJLaMf2y9ftB+zX+zdptrb26arBB4f8GeD/DySeJ7+ID7PpGlWYMsmi6bOFBkuZIHW21Ugtc6lrylohLFC3nVgcK4qWJqRlNRrP2fM/dxOKTU3NWabpYWM1BJJN1nzapnkVcxyvDKvn2MawWR5NgYYbLMIkqcMFlcIQWGwtKKWmMzWdOFerDWVPDQpU2oTc2/Zv2VPgNc6Wnh260u03+J/EN/PY+BEvIVlMepmNH8SfEbVopQRJY+DrR8WM0oIu9ZSwt97M0sY/ezwh4b0j4eeDtG8IaGjR6folmtus0rGS5vLpy0t9qN7KcvPfajdyT3l5cud8txNK7ElgB4J+zp8PX0rTZfiTruljSNZ8Tadaaf4b0B49n/AAhngG1YyaLoipjEepamG/tnX5AN8moXSwMxS0jr3nULstI65ORntxgAEZbIPJ+uCOFzxXlZlVljsUqF+aFKXNWnFaTq7SSercafwq28nOSdnG38a+IPHuN4lzXGZnXqOnRlOVLA0FJuNDCRajCMUtHKy95xV3JtrRmN4l12y0jT9Q1fUruK0sNOtLi9vbuaTy44ba3jaSV5STjYEDkkkYXBXkV/GL/wUW/apuPjV8U/EeuQXbjw/pzXGjeGbRnJW30iykaNJhHkBJb6QPcykYz5gQ/dGP25/wCCqv7U8Xw48Cf8Ki8O6ksfiHxdbNceIZIZcTWGgjmO1bawZX1GRWBQ8m3Rs/LICP46fit4wl1PUJo/NJDu7SKGLbQCQBgsR0weDjO7J6munESjl+CjRg0q+JUZT0ScaKt7OL1veo/fa1fLGF2rtL7v6Onh9Wz/ADl8VY6i5YelJ0MtjNN81pRjiMSubRPT2NNqyVqu6mr+YavqEmqX80zEt5kpAAIOFOWAwDxnBAHOFDZwp212Hh7S5JHtrYLhnYPIwAzzzzuGThc9upAwSK4rRYFuLtXIJRCWJzx8u35Tgf3huPQYJPGRX1r8AvANx478f+G/D8ETTPqupW8D4Bcx2wkV7mQjqAkSOxYHgA5DA16/CGT1M0zXBYZRadarBNva0muZv59LaWfqf61cCZC5zweHpUta06VGForVNwi9Lae87efVWsft7/wT7+Ff/CE/C+21y6tTFqni64/tJi67XFhFmGyjJ252vGGl4IH70FWJINfqLHqlp4d0LVdcv2WC00rTrzUbmR/lRYbSJ5pCzMRgBFJJ45PU9K8f8B+HbfQdK0fSbCBIrXTLG2sreJAAqxwxKilVXgjIPclu4wBXkX7eHxI/4Vr+zX4uENwLbU/Fa2/heyKOFk8u/c/bfL5522SXIbByC+cZ2tX9K5y8NhaUcPS93C5dhoxSi1b2WGpqUpPe8pcrk3pdu/Y/vPDLC8McNVajtCjluAlNtOylOFK/VtOU5u9ratu19T8u/gi+u/GP46/Ej4mW0clxrOrahqVv4VkKl2i8W+OtRTwb4MWFgc77G91mG6jUAYXTyQTgKNr/AIKK31p8Vf2zPCnwB8HytL4S+Eej/Dj4A+F4UYmO1i0ez0/T9Yn2rjEluZbkXLYzugkZjl/lwPgp8SNV/Zy+GPw3+IXh/TdLv/GV18QND8c2FtrdvLcaWtr4Ykm1aCfU44sXD2VhYRyanH5TApqD2Mg4iG7z/wCEt9eeMvj9cfGmz03xH8QtX8afEPxh4b0yw0bTTBe3fxJ8XW/iSVZdMDrKs9poulzWt3NJbNM8b3trPGY2VWb5/gWpKhiaWbY/2VONdYuOHnUa9o5Y+rh5161SMlFUqdGlhoUoVVL31iq0JKMY3f8AOPh1jcPm9bH47F1Y04cTcZ4TLK9eo+VRyLKqiq4/FSVr+xWPq1l7RtpuHL8KSf8Aat/wR7+GVr4f+EfjP4krZrBF458Rpp+gnYRs8LeFIF0vSEiyAViSMNDhScfZwAWIrwP/AILOftBf8IB4K8ZmyvBFeeCfAGpQ6YEk+ZPF/jhotF0QgBs+bZyXNneABd6xJMRxnCf8E/v+Ctv7EkvgH4ffs6QeJdd8C+P/AA/baj4Vi0LxV4fnWTVdd0Y3D6hKtzokmrQWX2yaC9uIpdYOmxFopYfMWVdlfhB/wWv/AGlY/Gt5a6PbX8EreOPG1/4wnhjuEkYeGPDdlHa+GBKFLhIr2bV47u2B+WYWCumdpYfi3CHDOfZ547cV8c8TZXjMHluAr42vl1fGUnDD16EKiy7L44eu4ulWj9RoVIt0Zz5ZTi5Si2mfquBhi6/iB4geJWOoypZXlOExuC4dxb9nPDV61aMMkyiGFqwcqVWVPBQlVnGnKUqfMpVLc3vfzqeM9R3zSqJN2wMrk/MxC5ySM/MWPVickkgkcmvnzWbtGaQKSGUqGBAHzDb8q7l+YZYpnAKnAwpGV7/xFqYmeZ2bIYkld2MKGIAOAQM8k5+UEMeSOfF9X1BzPJDtLMSHDja8RX5Qf3hwTImSm7CrgADLKAfrOPM++u42vP2icOaSVnfZppJ3Wi3101tez1/IM4zB16kpuSd3Jt3T6rZpq7u01f0VjD1C72yfLuJY7cDcoPKjGTjAwDg9zwcCuPu5iS7Y3EbiUDYC/KrEbV3Ec9ATycsP3ZO3WvnyeMkkZHDfKR1XGSMdVCg4YkZ9a5eZwpd1LDcMOMN8zIEJY4ONo67s/JtOAADu/DcxxXNJpvRaKzTvomtdui0u+2uh8ZiayezSu11tpZNL1ulr6Oz2ePfuVWRgWYjLgD7zHAbbk5UKVBVh0HRuASucpdgrnaf3O87cEDITg7XKlhjHmAuhIMcmcEm8+9clgC5bau0A/IMAMvzYKkbt2FLSfKNvFUmz5qq8cmR8wdfKKvhlVkX5uAGDM4+ZW5GQwOflcRPnbla9muVWWrfLZrfW9lqm1bfW55c5Npys7206dFva9/k2+XSOupUdAq+Ym4B2XJwMD5kwuE6YHygnBXhgGDfLHJbiRAGUbSwdAVJ7DyxlAoIbPPVTk8jnGnbWUt68hlIgsIh+8uHDL5rBoiY7YlYxsjfqzMSQGVQxRVMs1lbGOIrqcI2S4JSGRm8kHJjdmOVZihCqpDEDGAQWry6sr3926TVr3s37q2a7u17apNpPrxSqtuy1SWrS2bUU32+Jt+m/S2G0fVFwW6Zxlto2jbgkktjgMTyeDzgCs6KX5Ujcudg4BJwFdQASAO2Wwc+jZGy9najlNQQpwMeRMVxu2gE8kDID9WAyRuJyDUWxieczx6tCUKrDInkzFHUSBiwA+QBRt+YKZMuVI4yeSc3eyik7au7VvhvZf8F31fXVOpKy0v5NPVK3RJ9e6tpb7JlPtd3jAO5MbuFC72CnaGkVdzHJ+VhuGOnIwGNMAMeq5AG35DwVLbtqhcjAUAlTg5H3TvG0tGcY1CIKWSMDyJljLICrShsBXAIIUvhiMLJtIqQ6ZYAqRqEQVU5xEzbT8vOC2TjrlWKqSpBYk4w1b1u9d7WejS7pW09Va9uolN6Oz0S6a6OLs7N7PbfVbHLuhbBZe6sCQqggBcZZmYkngA4AYLgA/KTXI3BhsJPKkE7lJ+RfkBIIGSV37RkArncFNdI1jZ/OpvHPDbCLRt5UgAuMFcg7SMDGcq3Y1BPp9p8m2+UqDkgwvuYAnhirO4banU8OSMDC76ybStpK7tftZ2Wmy89Xd7rew+dKz5X0aulvaKVu1/K1mr3RzhztUJGQCyx7lwSF2qD95gSoxtViAwyByAGqBkV3YA4G9gSSQztlCApHmNyeFfIPGxwDjO40FqGkQ3KkIpZJPI4lIAJUqG3KEZG6/KSNwOSA1JoYGJXz8EFVZjG6rjABIZcBiGG0Fgp2/LguSTm3fdLpbXRX5drPRW5tWldaruEZL+W9mnquloJ+6tOmrab3baau8hmXA/eRh8oAvyhmYeWNp3ZIK53OzHlTjn5gIiA2SxKsFP3imC6mMfKMjcAflCgbuQxO0ZrRe2hAZ1mClJN4HlyfKykhmAJwofGzq23ZhhuJFVZHhhiaeaUIhZELpHJKy+ZtA3oofainILsQWYDccEVlJpe9LlSj1utF7r1vZea6JqzlfbRSjyqOl2lZuzbvZ30ta+109HZtt3arEd+MEKrbuQW+UkEZ4JGev3c8BlBFRZXD4PO4jceRkAEbcgDLYyMAKenDZzajSK5Z44JVdlVZHRhJEYzJtMW9pI9uHLMI84wQpyCUzSludOhLRzahbpKibXQpI5GG2ElxHgsGXDc5CJyAducJztyy50lu3JpJ/Ar6NNO+60+TQ+Zaq/vdb3S3itXF33V+u2tncGlZVXd94sqhsAEMAPlbLEdd2SFBON2ABk12WJ5QsiMAwLNxGFJDLhuRzGp5AHzfNtB2sQLksMUccVxJNGkchK+ZLII0ZkALAcfMcKzAn94cEkbSTVLzrSHewvbIkFmDCeNmDAgnnaSpGBu4O5idmfmrOVWCa53FNa7xWj5eicb+t7Wtvu6U4rraLlo1ayXurVrVttNLffVpETmSSFykyJiRV35T7kZUvvbbhHVBjaCQF3gkrkiZ1yY3j7BGZUDMuwAEkLuO4EbGIZ2C5wCyMAa4utOUysbi3JdDEyJcBlZTyzYGCoZgGY9FBA5U4V5ubOMLHFdwLGUDrulVirEANy27JcAFiCQVGFXcSKiM6baanB6LeTaTvF632WlpJbpWXS+ntKbu3NNp7N630vby20Wltnsx4HmO67TgI2GIP7xDhlIPzEKNwO7HIZQwAAxFIfJ25JVXznKs7Kx2sxbgKqqM7cZOchRywaB9SgV1aK4tzjCSbpE2BA3GPkBYjDMG3DgpnhRS/arOZ8Nc2xRQrYkkQlmXAwQQVGAw3BWKEAhW4yF7Wk2+WUOdXTe6d2tLXfTXTXW2jum+ely2Ulzb3vpa6321s7eWl+ye9xF5y24wNhVnkGw7clQqZO0nJY7jyFOSRzgzlftEUiiQIMkBkAL7iFO7MYOEYgA7SWPByDmoxc2LsXaa03lWVnM8RIU5yrELlQeDnllGNwBC4ikulw5juLILGGUZnjZ8HGNnyrt5GAX7FgWDEGiNWmouM6kZOWkeW6SWiXo0t3rtdtFKpC0m5LtbTT4Va+lkleye3W5djaPdtyGkTCjkbmYFVU8s2WIwSWKn7wwz5YySPIrsqxxsFHyF3IZgVDA4RGwxUljgluoOTlRmNcQRhmE1uxPzKVnVmMuBgZIJBPJIbAUDG4kCrNzqdt5ai0kWe8nijCxjDhXYIhcn5VAUnAAfgKCSwwREq9NLl9ooySTXLa7cndJRervdWs5O61u98q1WUIxVGVpcy1Vm2lZ6369E1d9L9yS9EBDO9pEGHlHzGdiCBxwBuJ3BgQSApyCQoCgtNVga4it/tVid08YGUmyWeREA4BOcMRkAkYwoweNVYontEjlhV2+xpkMkTKss80YeQ4Jbfs3spz90tlcZqOG0tEvrGQQQo8V5aDzBEqKVW4t9u1l2kbcHkYGCc/NyZrU8Q4ycJR1SspKTdnbVOLSum9Lxta2+5hWxVahJQlJtyjGXT7XL3S0ut/8AM2bXctrahsnEYG3PQiYnooJHTJUkeWWAG5CTVHxHk6fFvAbF9ZMQpAYL5owp2KxBIHzDgEkFRw2btn8lvbnduAj7kFVAkJX5RwpGABgsEJUKCp+TM8QyKLGJRkM17ZAbtoA+ctkqWG0ZUYIBXOckHaK56jfsZPvFWbd7tcq0ta93o/W73PgcOr5hG1/4zbvq7Ju/fVdettPI1sjzGOBny7ZQp4I/e3Gd2AW2naOqDOBux1IQyo5Mm4FWOSu1UGFDABexIPJyMjAwMAubLTSFhgiO2wE+7966O0rtwSc7TljwcLuxihuYyQrEKpCgcA8AZHAyQfukcKeT83TXVxVm7arWTW739Ozd7WV9zljyqa91NXi3ZJu3u9d+23nvrbO0dgulaUcHBnkJI5OfKvB82AAD03NjPI24BzV6OJIYykaKobfKFBby8ufnbkDBJKFfQrgAZIrP0X/kE6X0z9okIGBydlx/eBBxubAC5POcHBOkDwA25twOCAc4+XOBkEAdWwBnduA6iphZQTtuoWve9nGNte3fudGJ0xFWK29pWbv1cajs7dWr79NV1M62CjVdTAPH2G1zuUkcJ8rEYUYG4uCACoG4cmtVRlEOCBtjxtwRwM/wjBPK7uispPBwDWXbkHVdWDAsDp9sFzjOPLUbg24FTg/KeeO3OK2Ihtjjz18uNjnODkFhncMHG4bRjGF2nBAwQvZ2vZznp58333tb1u07LdYn44K7v7HC6JtO3sY9VrtfTR6LV7mTqTxo2nGVFk/4mdrtRpCuB5UhyQBk54wrEggkHlwRKZpBHG5iBWSSYFDtMmUuShKkmQkIeu4AxklS4+bdHqmGk0ruP7WtxkLuYkI+cZGcEnjGWBBzhiMzzwhirxsyGK6um2jco27lZ0YAIFMjDkMSAnydyRK5r1NrLlvpo9IdW9eXdt2fXqray5XSwqlo3zvW7W7VttNelknbpreG8ia7gkgO5mkRlGxQCSNrZ4I4xtUBjhflODkEZ1lofkQyTo1687MWbyIEWNQphMsciswYYbcS7sYyMKpAZturgjouOABkYyqlcZZi3LYzyGBBK8MeASTKpdWdDlQWBb5hlQRlSNwJJ4IY4ID8bcDjGXLJpPlSV+bRczjtr+O1nq9bGlPEVadGVGDioTalJWd5P3WlzO91Za2VnbTuPTz7ZkYW0twhY5V28l3I28kQwS7DkcqJDG4Ocg5zHcXInlX7TpU0KruUkaoIQNw2NJteASSFS/TbsjVOAQpzOLpGJGcOFG4OzLgkDIJycg7sAZAHPG0KarTJBNLbzuheSGTKMQ7BFZUOxwSFMYYqSCzMQQuCCwNvZOM21dW5mpJu8b3bV2kuttVa3RmUGozblSSlZtSXMneyttKKV9bvva6vtYsRpcKsttbSRK+3kXVxfqNqqBgxWufkKgKjuhC7gw4q1JGJkwLjyQxXcE0+9yWITaPMDFtvyLuDc/MBjcQRXikVT5cbgBm3KoAUhvkVxsjY7tyMqglTkAlicBqh8tCkrIWjzdMJmyzSKpDL8qJKHG3kxnO4P94beQnJcqjaMk7J8qsr6Jpffqr2evXQzdpT52pqV4+9NuUtWld8yejtez1s7a7rRishJM5FxI7MyP8A8tLYtho+n2x4gegwAGLKQzDcuDda0kQkkDLHYAbiDIUhfm/1jgrwzMeSpAXJywGLaxSqke8xSTDYPmgXc0bBSuWdt5YnflzxyFfJBNSxEyqWEbQkSNEVeOF2LR4BACqSVYNlWIXqwUdWNQa0vFq65l1in7t0nstN9tNbd4qq7dmmklF+V+XSzcfNdUtmnoaxs5IgDlX+VFJ82I4wck4BZdiqNrbhgAjaGDKaxraWO7YiO7VJYZCZFeeBQBIE8tIzGWWSNwUTeqjPPl7k+ZUF1aTTNbxywySZYNAqEHqFYOWjIKZdlwhHK4BIIDIbG2jjZIYIIyA/+riKl2Cghd/mKEU7E8xcquM/KWJ3aNqXK1yuKtfXouVqzW/mnfTW15aqnGNNe/zqpKzheMYr3rXclKzknd2t0Wj1SLsVn+6OxN0XJYCTfjAUbyV3MqIVDruUAD5mO4ipBaSGKIkOQXSNWV1ZdrAABmDZCsMNtzu8vLv947ci2jkuIoZLmI20qybJoFIUeWhjwrKivIsTsqEksH3Eg4ADDVVIMFPIicIpCgrhWXb8rAFscDHIJz8zsVy2XFpq8U1ZLVu3a97axemi738xVF7OVpTbad2klbmur6ppauzTW2i1bZcTSpfvBCFZeUDRYyWBVTtIBAPQnPK5xgAFGtZIh80cicqAcEsWJU4DbWG4kcZOMnnIO2qLtgqwC75CoIWM/Mm5TwQTgZYDzAQeScEgFRdhwTErxlQFjCM7KzELjeJCokWPbnB25+dR0zaej0u1Zat76Xeqvtrsuu71eDd7NtvVK7T6ct7Xk+990u17FiK1vhJIWgeYM5MGNm9Y8xlQPnIOMkFNqbGJJwH3Cwml6hJeF7nyre0jSPyEllijWZmI3yzlZgwKum1EII+VgSARuplF+YhVeUMoVVjJTBJAJAcDADZBBJP3GG4oBLE0EjgRufNWUoy5aJyqsAwcAFioZipeMgbiUVUG16SVuWL5nqrLmV+mr7tfO1tWloKU21KTgtlDmS+FPlu7Ntc2trtNprSybvuR2IjZQJ7JEKs2Be2q4JyxxwSSWx2J9D1FSywzwxv5At7tlLHbHfWKlsc9WdSOOSEBO0cgFiBlxNc+dICQsQ2tCUctMx2hnLiRmCqNjkJwwznkCtCIPIf3rFgm7arhSrMQvyqrYJYkkZIHUAndkV0xUZKyjZ293RaXcVdxd1r5rytqjkm4re70u1uuV2dna10r2uno92ym8UUuoC4hinKWtp5N6wkAi8/zgkURRMRP5QDMzIzJjYxKMuK24o9+9hlcDKBmbBI2lAScbvuYReAUHzMGBJoyWSSkuu+K4YBRLAQk2NrBg20CKRQXXOQAOg5BItWsrWxjhudiswCpdJhYZMsQiyj5milxuIGdpBG0ryDtRgk3dbtvmVra2flb1vJX2vs+LE1FOEXDeFNRUJfE43vftLe9k3a1rO5pCKZifLOwOrbi6PIVlXBTytw4UEAFiSRnJYkEjXt43iRTMqpIijeyH5BgAHA5cZ2sW3DBI+YAEEU7ee0Qqv2rcB8oA8yQq2FOcBQAqgcrgcjkYzt1oJLQ5zchgSMhw7DnBwUCgHAweDnB3AnpXpU6dratOOu+j2t1Tab3svW+589iq1o2ako6+8otOy2S+9WW99OqNewiUxx7UJyw+V1/ecbegGCOfunI44wwxjtdPtySpIJ3EEEnJwVUkcZGAOp6e+01zVhLbyKjJLGNxCElSGITaemwBTjkDjgAnGfm7zS1g+Uecg3Dq+8jgj0B46ZA4x8qkMcV6+Ghdxe9rXs+ujvvfz8tOh8ZmmI5FPdJaWtq1o1du97JWsnda9mn1mjWW10GCM7SGxnBAByf4Rnbt+8xwcDAxXtPhrTS7xZQ8kbSfuqB8zc8kngsW2kFiMgCvPtAhgco6yxlsiPGWVyDhTlX+bqeCeBgBgADn6H8GaUZ5YgqqzfLkDc7AEDHQBucjawJJJAzjFfYZVhZVakIpWcmtmk9GrdF629PNH41xNmbo0qs7uyi223stEt31sn2cl930L8F/h9rXjbxX4X8HeG7L7Z4g8U6zp+haPbhD817qFzHbJJIfvLBbBmubqcDEdvHJK+VjBH+gR+wD8AtE+FHw78M6Fpduo0nwRotroWmXDQiNr/UWQ3Gu6zKAvNxqeoXE93Kw5WW5uIc7EVa/md/4I//ALNs/ifxpqHxfvdONxFoc58HeChJFmOfxBq8CDXtSi52EaVpVxFpgdc+WdXuSGRrXI/tC0LTtN+HHgWC2eRIbfSdPaWedyIw8gjM088hHAMkheR+SAWI+6CKz8R8yeWZPhciwj/2zNZxVSMH+8VJuMZJpbc14wS2alO1rI/OvA/h+jxx4pZhxjm0Y/6reGmHqY2eIr2WFq55UpudHmlK8JLAUYTruSfNSqxipL30fKv7Z3xY07wx4Xfw/calHY6e1pe6z4ou/MVRp/hjRLd77U55SeEEkcTJGDjzmBiG5mCn+DL9p34z6r8avir4v8dTJM39vaoIdA0pCZHsdFtpFsfDej28QJYmOzity8SAs9y0pHzSMK/eD/grN+0zcN4cv/C9hfyRa18VLyYTIshSTTfhroN1gIR8zRHxJq8aKVyvnWljdKPlYE/kD/wT9+BV/wDHv9pDSNQmsnufDvw9urHWp2kiL2k3iq8uGh8H2M6kyJKmn3EFz4pvrZ1kR9P8OX6SDbI277XhbI4cP5BgMvaVOvVgsXmFTWNqklGpPnvbSnCKje9rQTW5+N8RcbT8ROPOM/FfH81TK8PUq5LwjRaldZRgqvsaEqKeqnmOJ99RVpKdWUdY6v8AUfwNYxfsAf8ABP8A1zxXdxpYfFPxjY3nhjQWdkW7f4geLljbxbq0fLmQ+GLO0tvDcMiMyJJ4RedGH9qyqf51Y7e98Ra5FHvknutQuyHZyWkkmncPI8hJLklmLsCNxJYsea/Vr/gq58ebHxz8XdO+Dng27LeA/glY/wDCLW0UM3mw33iVFiTXr6SSMrHNcQyotjLcHLPPBcvu3TPn4N+CPhc6jqtzr08I8vTysNpkfI15NwWU8/6pOTgkgMDnOCdq85V6qjZqVaUJOH/Pum4qFGk+7p0lFzjsq06jXxXPv/CvIamEwFfN8byyxea1Z4qpWsv4Lm6sqnM18M5yqSp3tbD+whb92kfoJ+yB8DZfiV8TvBHgW3tmbSLOeG+1yVVO1NMsWW4vnkYZC/aXVbaNmIyzMuDwK/rS0TTbXRtLstNsoY7e0sbaCzgijXakUEEaRoqKo2rtUBQMKMbeCGr8u/8Agmd8ER4U8Daj8TtXtMar4tkFtpLzIRLFo1pIy+aoI+Vb25Eku7ndHHECMCv1R7deAMkgjGBgnOMA5UcjHBHsBXhcSYiMqlDLqbtDCxvVs/jxE+Vu7V17sbR1WklK1j5TNMxlnPEOZZs2pYWjKWAy7XmUcPh5KNWrC7a/fVlJ+7pKEKb7JxTyBQQOAAMjqSc5wfXcOmBxnbkferCupyeFORjHPPUcnPUEDuefYjro3Uo+boOPXqwHAAyDxgYz0GSCSeOcuZQqEnIxx0J65xnBGTn8uBzg48fDUlLlurtOKu3bW0bt67drX3Vtj4nO8dZSSb6vT/t211e2/Tpv3M28nKfLnPBIOMgZ5LHnPHHYsdwP3TivO/FviK08O6Lqes3kiRQWFrNcSOxAHyRswHPGMhVz8uOgIzgddeSE7jjJyW5OAW9Ce+S23kd+OvP5m/8ABQL42Q+CPAs3hiyuvK1DVlY3AR8PHCFAKnHI3ErtGCSOD3FfX5XhI1qsVJNQgueq3soxs9VbeV0lo7uzPymtCtmePo4KjzSrYqtCjTtdtKUoxnK76Rjee+tmtFv+JH7bXxwufHXjXXLpbovbrPPFbr5uR5aNIFCjICqcDDE8e/Svxr+IXiFi9wzOTvL5UM2MAnBwMfMOCBnJ4IOOa+j/AIseLDfX13M829mkkfdnJLZZiWIyue+R8p6jJyK+EfGurm9uZUVgcFgMHjksobBPds5PBO485FeFxLj3iMS4QlaEPditbJKySUW9kvuWunT/AEN8GuDKOU5XgqUaXvQp0nJqKu3aPO5dXd6uy389Thr65FxK8hGTzz35OSSQeT9Djg+ynOt4vOmCrli2SxPQcqCMEEjGec8AkYAycwSuccgHjPTkkehJJJyQcnGcLgZ67GkwkI0uApZtqgYIAIG7kDnOQFGc4OOAK+doU1UmlZWtv3elmtNVey81frc/tPhjK01SXLolF6JStBcqsuuum7v23NaCDBUKchT90D7oX5sHgHkDgcY79Q1d9oVlJPcQRqFLO6AAZGSzAAcZxg4J45wcA5Fc3Y24YoeMAqeo5PIzydzYwAACBgEcZAr6n/Z1+HF38RfiF4d0C1t2k+26jBHIAu4w26sDPK2Mj5UViSTgc4zlQP0vg3JKmbZtgcJTir1a0IzlvywTjzSejskkm91Zb2TP3XhzLZYvFYahSjJyqVIU4pdW2l52urLTvpvp+4H/AATa+C6+FvBE3jjUbVY9Q14pDYvLHhhZRFg7KxGVE0nmMrDaSqqMkcH6q/bN+MsHwY+CHiHUobhI9Y1e3k0fRowwWT7XeI0W+MAAkQIWlJAOAAMBgRXsvw78O2HhHwvo+hWMKQWmlWNvaxqqhQBFFtY56Ascs5B+bqctX4sft1eP5vjf8etA+Emj3TS+HvCcx/tdoXLRLMPLe/mdkJRTDAot4ycgTSqMZyK/ofOcXSw3NKhFRw+XUYYPA07JRlUio06TW6u3zVJ22V30Z/UWdY7D8C8E163NCnUp4WUKctE5VqlNtzV7NuPvST30S3PjGfWD8OPgfrPiPUXZfE/xRu51SWTP2pdCty0k0pyS+26LOykgo3mwOCACR+e/hDTp/Ffiw3blSXufk3qWSPIYtKy8gRW0IaSRx8sarvfIAr6T/a68dLqfiT/hGdKYR6T4dtodB0+3hAESLaALdGMYxh5QYhhiZI4lyODjyTwtp6eH/CEt3OFhuNe82zWaQlDb6NbqJ9cu4nIIDXKCHSIyGUlL2cK+5a/nHiPG/wBo5mqDbnRwqald6OblFzk5bJ1Kj3a952elz/PjizO8U8sxWJc5SzHOK8o4dXTmp4i1OlHlTbao0l7SStf3ZPdu/GfHXxjFd3MFppZS30nSrCOx0wlSjC2iRpDeTqSfLuL2XFwwwGKiJchQsY+Kr+6m1G7jtoywaaXbFnO7EjMzzyEDlto3kjOxSDjLEV6r8TPFkfiDVblLSIQabYsemVNy6ySLCHUkBFEZKoilSygkoC6hfKdKQvcXmoSkD7MPIgyQAZpwDJsBzuMUJCArhhvAzwa+BzOq51nTjNLnlzTcbpKMeXTRaWSsto3S5W0jThzJ4ZNlWGwNJuLjTjKvKUW5SqTSnUbe7nKbcpS+1Jttu4+6jt7UGOFUUooAO0ljglS7HgtnksR16KeADa07WX0+OK58mC5t4xJbX0E8cb7op0kMMyAlSJ4t7GKZnADoqhTHkti3krSSso4OVwxO4N0UAjjrzgj5fTDYFGnt5kr2khVYbxPs7E5AEhCtA65G0Ksm1FbBIViqnIIr52eJft+WLaStGL0kt48rs3te1076PZI6sRdJ1o/8u5Jtau8Fy89rNOSs3a2rbStoj7j+CPjOaG6sbGSdrrG0aUGKM0kbK7eUGym+K8tZJoljUfLcqm4SBiGT4x+HotL8Qy39kB/Z+pKt9ayBNqtHOittwCF+RnZWCkqrAZAIGPmr4b+Jrjw/qVuZJMXemTB7dWUNIsQkaR9uSWJtp4/NVVKDymkCspAFfoJ460u18aeAbPXNNjjdTZHVLQxlWdPOkKapZAIzlfsV95jRoAFSC4t1ILAk/UYFvMMsxOBkn7SjbFYWS+JW5VOC8rb7XfLutF8zGp9RzCrlsrRwmbRljMA7e7HGUoKVWlFt2viKDc7Jq8qUk9T5qtbn7Tp1ndKQZbT/AEaU8bjtH7psDJPB28gfMoChhxXtfgTWyVjG85UjPXOQCCMckDGM4UZPU5HHzloc0iXlxpkrBVuQygE8CeMsy7R0DbgQBzjcOnbv/C+ovZ3fkb2BDkEPuwMsTtwQORnkNknqDu68FKq4yo1G3zfwql1qpRtZLpe2u/XurHyfG+TRzHKVXUOapTi6c/dTd4OLtZK6tHo7d+yPqTxZCuqaYl2q7mWMqx3d1U4JIBPJHJJDYwcqSTXy/rVrtaQDaCC4UKuAeSDyRkjOMkDAwOMg19M6LdjUbCW1ZvldCUznhsMc+mCAexfJCjkceOeK9IMU0xCbcF8MQARlsMScA9hwQTgcDvXbjqftacKydrxtJ7e8uXfXdyd0np023/E+HpvBYiWFlf3anub6RbVvOy1sm79T511W32u2QM55BGTlipK4yeMEEcAnkgEYUcYUxK0eRuzjJ4GCy4O7pznII64PIYYr1TV7UEvkMQcnOCx7AdgCcD6kY7kA+ZX8flS5AIwSNwOVJO0dTyc8Y/hOeSTg14FROLcrN/cn03Xmk9EnfutL/vXDeMtybq7irJuz1i99u+y326CowDAEAYAx1GccDjg/e68Z+XnLZFdVot2VkCEnkjBOQBtwxBJI7jHsSuTkYrjkbdjd97ZkYYAYyM+uCep+bJ46jitWyn8uRCBg5DHB54CdQDgjop55ByAQOO7BVnCcFZqzXkpL3b311T66a7ap6/s2U4lRlTk5PlaipLSyvypu62vutdtdLH0Dod/9zcwAU4XqGLDjjPUA8gehySa+wf2adRlt/iv4KaJmDPrVmMLwygyKSBtzjIK8E4OcfX4Q0W+BdBkEEDC91PJIxuGcE5x68jgCv0Y/YT8Dan8R/j14E0fTIpZI7O9/tjU5kBKW+m6aBNPI7AsEUny4EPd5UwM4C/uXhpjGuIMrlFuMYYmlVn2UISjOo3fRRUIycr9Fvdo/WuF/a4nNsuo0U5VKuKw0VGN02/aU9dHbRXk30Sbb0P6jPCoeSC2eQ7VSKIyyMQirGFyWZmPG75eWbAU5JwCR+cnxx+Pnh3xPc+Kvjl4k1q50P4P/AAh0zxJp/wANNStWzc3c0jzeGPFPxS0KNykE/ivxdqYk+F/wPEscy2aXPiXx0JLSOK1lb6D/AGmvF7vDafs/+ENRvLPVPFWlx6h8SNa0liuoeGvh3c3L2FrodhcJh7TxV8UtSim8MeH5IhJPpmgQ+JvE8sa2ukxTP/L/APt3/tML8WPFlp8Ifhxd2sfwm+HF8tlDJpAMGk+L/FOmWh0d9Xt4kcg+FPCGno/hrwFbySSw2+kpe6yjm51+fy/qvEzjClTlWweClF1JNxnZXvKTTULJXXs21OpdbuEXvI6vpDcc1MdKj4YZBimo1Y0sVxdjaTi/ZYNW9nlMJRvaviZWlXi7uNKycW5SS+Z/jD8Y9W+N/wAQ9a8d+IbGHTNEtYLbSPDPhbTpFXSfCvhrTlkj8O+ENJjba7W1rEfO1K6bbd6neyalq15M97ezSnX+BXwzX4j+Lpr7xHdSad4J8L2zeJfHeurEZPsGj2rhVsrVQB5+qancSW+laTZp+8utQuYlU4Vtvkuh6Fe6/qOlaBoVrLfXV5dpZ6dbRgtJe39zIitPtTLSb5iI4QylkQF2G5WFfuD+yv8ABf4eeFPCvjHxx8Sx5v7Of7Lyaf4x+MmrWjokvxl+NNy/k+DPhH4elk41EwarKNHtYofMhsmm1jW7sEyWM9v+O5Ll0cTUqZlmDX1LCNVZubd8VinrTop63UbXla3uqyd5I/F8rwmW5XhZ5xjqUVl2UqnSw2Fnoswx8klhsHTva8Pd9piJ3TjSg02nNX+t/hI/ib4V+BvDmg+FrKLwp+0p+15oceg+BbKFxDL+zf8Aso6bCyap4iebYH0jXPF1pDdGK7lW3kujFc38ciT2duj+b/GzVLXx5rfhH9lb4K6Xd6v4M0mTw/4bvNJ013jvPGup3V3GfCPg6Ao3mRyeLdVguPE3iKZWR7Hw2Jb27kiXS4ITk+JfiX408G+FfF/xs+IEVo/7S/7Uy2EWg+FYwIrX4Z/C2eNIfCHgixjYKNLsDoMVvd3sTiBNP8O2Nt9q8u8vbqSP7f8A+Cavw78Gfs/fCH4n/wDBSb9oKYt4I8AaTr7fCF9Rt/K1Hxzr9/KdL1/x7p9tMN0mq+NNZax8FfD6PDSWmiRxSkqVu55Pex+IqUP3so8mKxFPmdKO9HDuUZYaioq/JUxDcXNaOCu2rxP5s464yxGaYjF51iKv1lUsWsBkeDiny5jnuJk6XNTpxSdWhhXzQpcvLFwhOdNtOEX2f7avxUj/AOCbP7H3hb9jP4TahBqv7UH7Q1m2tfFrxRo21dQ0611vFjqtzZ+Qoe0W+n3+D/A9sVjjs9Dsby+ghh8q3J/HTQ9RX9lH4IQeJNIkE3xq+KDeIfCfwhkt1Mt/p15L5nh34pfG2BNrz+V4ctrq6+GPwquCpebxldeJfE9jMtx4fgeXc0Lxf4i/am+NnxW/au+Pmtz6PYX0OreOPEurwF54/h18K9EEWlmDw3FJ8g1KWF9P+GfwzssobzxPqsN7hlFxMvKeENR1f42fEnVf2ifEWg2+i6dpk2ieCfgj8P41eTSfDNlpsD6b4H8I6VC6P9qsPBujRjXfEF7IHuNV1mSfVb9pL3UZnk8ujRnUklzKE5qdWriGklHmtHE11F3aVOCVGhZJtqCivdsfLvL6uVYKnw9CbxWd5vOnmHFWJesp1J8tTAZHCfwxpqTnWxqXuQw0JOagsTY+5v2EP2a20eyi0z+zUu9djns2vJHCTyT+KriJX2GYLJ50HhGxlaxt5mYr/wAJPe3c8skhjIX+hD4PfC2x8R6/Z+CbaBZPh/8ADa8s9U8eXgw0Pi7x6ixXeneGpJRzdWHh5iupapEzOrX0ltbyjKFY/mD9mP4R6n8H/h74T020s/tfxg+JkSab4ZsbqJWn0aK5UXep+JtYRVPljTY57nVtRaQky3phti8jxux/YPwB4F0f4YeCdJ8I6SzyrYxNNqV/MAbzVtYu3NxqmrXr9Xu9QvHmnldmYjeIlYRqgXozPHxwWHp0aMOWc4exwcX7rpUtFUrqK2nK8lGT3qSlK/uH83eLPFNDH11w5leKdTKMnqyqZjiYTfLmuaPl9tVfLK0qNF3o4aPwxhF8rVkbmoXKqm0FVHTCgYVQBhQAABjC7QMAkHgDBrw74u/E3QfhN4C8TePvElysGneHtOnvSrsEkurpVZbaziJ5aW5maOJFGMFwRwjGvTtQuS0rAtgcg4I6DPqcnA5HQDAOTkA/zff8Fa/2sE1jWE+DHhfVN2i+GJGuPEkttIDFf64U+S1YqxV009CxZcECd3JBKKBxZZhadGm8RiP4NKKrVm38V2uSivOcnyy2ainLVR0/nzKctxnGPEmByHA83+1V0qs4puOHwlOUPb1XulaN1G9uepOnHZs/G79rz9oHXfix488W+N9evHlutXvriZFMjGO2tslbSyiBPyQW8IjiCgDYqjjrX5jX97LfXs08jMzSSEgZzxknAyRkAAH7pHXGQ3Ho3xI8UvqV9JbpISodi2DkMAcKBxg7iD6Egkt615hpsZmuFDDIjJZmOMDaAUUkscjP3RwDkkcdfGq4meNxkpz1cpKy5dN0rKKWkYx91bRSXu2P9afCfgzC5Dk+XYDC0I04UqdCjTilpGlCMFdq27td9W7vU9G8P2bIkahf3rsC5x83JIwCck4IBAAPQqTzgftH/wAE2/hat9rmrfEC+tla30iAadpjshx9suhvuJUYAYaOHALKf+Wmeua/IXwpYy3V1bwxKXkllREUBmJdyFUKBnJO7JOScHGAdwr+pX9kb4Zp8PfhL4U0uW2EF9d2ceq6nwVZru9VZSGyAcxRFUwSSNpAGRgf0D4X5XGj9azirGywdHkpNrT21ZcseW+l1Hnemz5Xoj+8fCrIFWzGlipw/c4GnGa0VlUfLyJ3WjTTlfTb5n17oFqFKfKCqYOQed2O3o2OSATjk85r8bf+Cpvja68W/EL4X/BHRJmmnNxaTXVtCSf+Jn4ivYtP08MqEgPDbiSQAgnbMGIXKk/trYwpZ2sk82FjSGWeQk42rEju5PXAAA3HHXC5x0/m31TxZP8AF39tDxx8RFU3dh4Nv9X1PSWcb7f7ZpyL4d8JRktldp1e4sroqSAUhmkGAhavR4tx05YP6pQvLEZti6OAoRVuZxqzjKtKz1sorkdtff13Z9p49cSPhzgPE06Un9Zx6nThTg7SqRp03KNNLdudZ0acVdNuaTWp5H+1346tfDbR+EfCt6oj8JeH7fw7awRbmjUavcS6fJLvVWRX/wCEd8PGQkkybtULI/LRjJ+Dn7RFx8KLXwt4t8M+GItYtPh58MviL4r00+JXhU2/xc+Ilzd+BtN8YWFkHCnT/Dst1Yf8I75mWvn0ma4jAIeWP56+Pev2nivxV4W8N+HxPeeIfFfiHVNTuZZJAd9lq2o2fhLwDp6xpxtXTNFfXN7Biw8Ubo1VE2nf+Ldn4W0LwhezLc3U02teL7nwz4QEflwWt34B+DGlHwxb6ynlpCkqeLPG+q6reSOVDmbw/csxEsrbPExGY18FVzOhRrYaODyzL8JlleDk1UeKqa1vZS095TlGFZq8k3BLls0vwbJ8Lj8jyWphcLjfq8cqyrLsqquD5KlbMcTOGPzGUVK7cniJVY4hpXvKMXvY+zP+Cc02jH4k/Fb4ra1eQ2DeBvhlqFnHqlxJaw31lc+Io72DxN4nZJ5oozNp/h+x1y9SbzVlu766tLe3WWWbaPnX9v74geHNbu/g/c/8TCD4pa/4I17xz8SNNvZruOPwho3jXxPc3Xwm8Bw6fOzpZPoPw3sNF1SQWszRSW/iKzMSxIoQfT0fwI+EPwq/ZV+G3inxf4Wi1Pxv4s0+X4l654mk1jXoLl/CeiaHceLvG2jvpMMS2UsdxpNx4O8A2BnEyvqviLVAksMV5fGb8R/HPjHW/HXiTXPF3iG7S61nX9RuNQv5LeIw20TSsBFaWNup2Wun2NskVjYWcIW3s7OCK3gSKGGNVnjbiLHZXhclyqEqdFywsMdjp05t1a1SrzunSna37uk61RuL5n7ZOTsoo+s4vzvN8Dl3B/BrrLCYbKoYjiTN44arKTzLMM2ptYGji9EuXC4apOo6abSq+yldtNGPf6o04JyTg8NuKgleBgluSM54GFztJ34auJvrglt5YAuSQHYkfMcAckDawbuCWYheDgVLdSylsLuVQAckgKThSFyQcFjgN24ZeCATjTxTyEHKoMgsWJDFW27gC53YIBKgqpIHzMGRTX4rmGZVsS5T5pSu7Pl1s7JNW9PPttY+Nq42dVtq7bS1jd6NJPR9b7+bWm5m3Lbzznrnhc5KlQoJ+RuTzwCOOPn4rnZQ6yMEQ48t8uSXCnCDywp2rIW6gLypIAbAwOqktVYbGmiU8HOQzFRjIwcuCOFz7dCc1EulPIFEFvPMWHBS3YqoOMnLKSCcHIJOeG28Yr5XEUsRWmlCjVm3qoqDktV0smm3eyutX5M4p+2nJWp1GlZfA3d+600rNbNvRJXe63XGyQMcIB85UbQFyxb5cEn5gzZJZcFQwH8IGakWxhjj825GEBVXUKHMjMVLKjbAGY8l2DLsGEGRuau5t/CmtTsgtdD1ScnIjSC0lmkI44Cxq8jlgMngngbdwK46rSfgV8avFUwXQPhT8QdYZ8RxLpvg7xDeDa+BuSSDTJg7EDOVG8jpgdedZPm1dWp5djJX+G2HqtXSjd35ei3W9vxj6pjqukMLiHF7qNKo2muW+qVrdb6W5b8t1c8TuZDchY9qxwxBfKiTGxQRs+ZcqGY7gDkAcHABxWc9tu6FQB0JxtbaykDLY44IU4AK4UEEc/dXh/8A4J1ftt+MzAdD/Zg+M16rFQvl/D/xLbxOoJOTcXOmxKu5jhidy5BJA3ll+g/C3/BE3/gpN4sKG1/Zj8d2Ky4w2sx6fo6qTtA3yanqFoQBj5lOWxtUoGArCfD2aR0q0PYqyXNia1KgrpRbb9rOPV3s9ldN97WW4xL38PVpK6f761KF7LX95JJd3fZ72bPyKe3DAZUsm3aQecowUYDE7scknHI2gEg8MLbEEIqhQq7RjIGMIMA53DOdpKhQ4VVYg4B/oD8Mf8G5P/BSTxD5bX/w78M+G4327pNY8Y6EGjU4++tpdXDqwCkkBi/IyA2CfcNI/wCDYj9sBgs3ij4n/BPwmrYMq33iW7uGhUYBDGGxKnZgkhGY7iwILDNcU8mndqpjcrpt6K+ZYSTVlorQqyl1aS639LYzwvK7VMVgItWbjPMMIpa8t2k6vNtv1endn8xvlqVJHBI67Tu4xu2lxlgSxyuBjoSqgGmtHHtQAktlWBBfg5jGHY8FeuCAG3AlflXI/qPm/wCDb/8A4Rr958Rv24P2fvCyqA0zNrFmhQYGdz6vqukDcFGPnIAxgk44zf8Ahyt+wJ4Ucj4h/wDBT74MW8kPNxDpWv8Agl3+TAYKIvE+qOWyAB+73dFGFGyqhw/OcVP+0cus7aqpVnraOzp0pJ3ava90l12OeTwdNXqZnl8H1Sre1atyO79lGpda3SWvyufzBCJndhtySpAUK5Yg4PEnXcQSQcN8oJOSpDRPZzBRhSwcBl5YZHylkxtC8HOAAckHHysQP6o7H/gnp/wQ28FBJPGX/BQu38TvFxLD4dur66L7OCqDQvBur7s7QB5ErjspKnFei6F8F/8Ag3l0W4jstL8V/Fv4tas6+XbWOh+HPiNfXWpyBSVtrVDb+DoGecqoRfMiRvm8zC7jU0uHqdWrCjHGRxFWpJQhSwuGxFadSV01GMZU6erb011vbda8axeWOpCl9dVWcpRjGNHC4uq5SbikrexhFyd7R967lZn8hMts5L8HBDL91jtfCjqqYXliCMZjGSMsoAx5UZACdqEYGCTh2OxgACoJBJyDyWXGCTmv7Mfjf8Mf+Cb3w18IWX9h/sVaZ4CsvF3g/wAS65a+MvjJ4qv9S8ZeC/B2m28bXnxQv/hZoup+KbLT7LTFH9n+FLTxZ4lg/wCEo8baz4Z0ay0u+3aq2n/ybftD/EHwz8UPix4q8W+CfBGk/D3wVcT2emeEPCOjWNtp0em+GNCsbbSdEl1RbCNba88S6lZ2K6t4n1JVC3+uXuoXqrDFPFDE+IOGP7Bo0frFdrF1ZRawdSlGFSlTlFT55uNWajbmXuySkubZWaXTiJUcNmSyiEcQ8TTwdPG4v21B0Vg41pL6tSrJvnVetBVKvsrKUKcFKcYqpDm8LeXgEgDBKAE5JAIzyxPIyQBtyFPzEnmq8rMttdsA2Whh5zxxPGQcBeSWI4GC4HIHKiWUMjEsDyQpKAKWHUOrg8EbQMsMgdWOcCq4P2a96szRxkFiQhH2iPB+XcBlfvE8tncoyPm+Qb0knZR5ZXduvKrO1tV10vdxV3dabxguZ8y0fVbRainZppvpqtX7uj01paSI0vbgqNrmO03MWILZWVQAoAZwzBcjHAY4xkEQansFvJmJSQ0h3GNM5W8gw4z824AlBKxwQdrAkipdP+W+cHJPl2pO1WBKvFMgZl3HeWJUAg4O7IDAjDNXJFpIVAADXJUkKf8Al5hbKgbiQNmW3HjcGJK1wz5Xh52XvKU2+ia0u0tt3p/29u9sX8L0a95bWWia1VrrXZdfN9LbJG1tCpEbp9qvSImCnbu2MSVAYhsEjOT8wJC7QQkTQWxYFYYcbThvJTbnggeuRuAz8wXdhW+bJcigW52gsPtUpOwk/eQE5AKqGyDwD94DbuwTSptZQeMKCASRywC4DdcAAYwDjPzDBxm1GLjF8sNYxbUrdOVaNq+u7d3ZvSzTZvHlVKN+W1k18Kvqm73X32TtolZ2ZkXFjEqPJBbpuYgsjD5fLLEuE/eLgZUMCuwhzljyopsGnRgB50ViDuCALhFO0hDtUZYHI2bSgG3BCsRWuwfOW3YIUBtpYAcAkseCW+7kYIHABw2GchhwWAUAjBGM44YDAHB4GSM4wGQ4ELD0m+bkjovJfytvW6u97Xe9tGmC5btOMHe2qad9I2dm+z1d+nVtXptbW+4lreI7sLjyVJOSTkdeQW/iPXJBO4golhY5Ba3tymCwyiFtxz8pBGCSWyVLEEjKjGSbJBHyBevJB5U8LjOMDc2CRs6qDtxkCkzhCGBByuCGAB+5grtyMt0Oc5UA7htxWnsqe/LHpbSP91XWm/pq+hSUOsUtvsrRJq6Ts1o9Oj8upGLO0wCLWBRhvlManc/ToQFP3zt4IyTgnkUx7G3JDfZoAvByYlycMflxkjndls7T1dRxVsAkjc2WGJAcnAJ+8u5icgk5UfUg8ilLYG8ksMBWBY5YHaByAfvY2puAGwHIJUU3ThazjFLTeKWkbb6btrfo77GihFJXUW1ZvRe9d7q6s0krN6a+SIEs7dORBGAQWB8teHC7hhs4KgksFGck5Qk8lgtbfIPlJlSSFYDABIZ8qpUZL4IZsspUIc44exeKM8NKoZGJUjKowGTydrqu1gAo+UqTtHygPCsxUcgbV4ORwNuAMY5PG1QGIIIOdxAxUaaaUoq8UntG1vcs1a+its221e9uk8kU0rJW1+GN0/dSbttaz89eljSeZBFJCERSfsjRsygPtjWV2jU71xvOT8ykrsLsAWCVUkl4UgoCskLJyAeHRl4AGd3TCHBHzDjJFae0trqUSzqzMsOxQJXjUqMgkhW3bg+ARnA6SZ4apYdG0d2R2tipBA2i4l3jAUsxUOcgAgcnILADacqYqSxDc1CnTaafxTtJJW15Ixb19XpbySyxOGWInCatFxio3VrtRtq9NJK/y0S0227JR9mtSXYMI8rGSCpDSE7COM5GAoG5ACQGZiKz/EChrO3yV4v7RQFAVhyRtfKszdeDnggZ3AZrSsvmtLQkEHylIYlcjLkZBbP3nJHAG45IQHms/wAROGs7Y4P/ACEbJWIyWLBmbIBOcYXHAOMY6kiueaSoO12nGLvfRN8r63u++u17q2p+e4fmWYwvratJea1d231SV0unbsay4MsgzuykBViCektyMkHngkjI5YlSo2kU53ba6gAFVcAgAlsKMYYtjrwTnaSoGAcGooQDLcEZy6wjDF8fLLcYIBXIBBwMElSAp5FTNnyyW6KHAJ28nZ1+YbiT8wBxjHBJYZrS/u66qzt6d9XfZW9W+zORaVIesH5Jvlut+mqukndbJ2MjRsNpWlA4CiaXJBABAWUfMACc8qcnBxjO4gGtgptGQQCVJ3MSSc4YDnptAAHX5SMHlhWLo5ZdL0jI3h7qcBcNnkPgdgDxuXOT3UhWNbTK7BWV8IVBYAYyRjIOBkEYXaN2F5YFiQRFJpQjt8FPS3eMX80ra316LozbGJ/Warba5q1W3l+8evre9ns/kZtv8urasFPWwtjhsBQyxEjI2hSck7emdpPXg6gHEa4IPlxZwQM4XIAAyxJGD6YHQEg1jQn/AImmtHGR9hswCCxILQsMFgGHOMnk4G1jn7o13ZYkj3EuTFEu7nc7HGduMElQGLDO4Y3AEA1VNqzveznP7SvdyW7vvpddH1bKxMXKrT3d6OG001/cQvutbp316X20MrVJf3ukAgtnVITyDtJEb4ClmBznoP4hgcnAGgQzh1c/MLmbYu0HPyjn5nIILZwD95i2fmywytUIMujYZMHUoSAMDAMbAgEA8DcMkMQWyynDDF95ijPFtwWmmlZgu4iMlU3gswJywKhiDggjacGiDXNUTs05wsnFO6cYpdL33e/RaPpdSD9lhnFLSFRt2/6e2Wi8vvstG7CArIpQlSVBwQSoDggochS3BIJBwoGOh5AVddrFh8inJZSME7Su4sGwAOS2ScYJBJGIJbh4bq0g8oPDcLL85CjbLHtZIwh2qfMUZXPzZy23gKZ0JJMbbnVlJHy5PUgJzw3y/dAHJyy7CAomyV0leUXre1k/c2X4NK6Se21m00ozaSjNc0eravyu9tVJWd00tLNNIriVN7QKf3khwpZVRJcrGCyMMlwRINwChD90AbQtJZyzNdXkTAmGKQJFcFAgfIjVowXPzNH0RQqqgDgZIJptxF9oCRuZPJidZpAjcOI32Kg+6y5xl3UhM7yAGO2rNs7K7xvEyAHYj7FO8DYoKoXdsk8N13bCPlZRmE3dczsk9LK19ErPXZW1TWr1tZ3dScFTkoR5pShq3f3fei9mld3W34lmKGBpZJhFGZOEaTBMjcLwx5IYEINwwcrtUDPM80MLTRK6jzAoeI7mUKyvx8uAjAByhzjduChsqCazS2xCFriOJ4SrKXuFidmJJAkRthZcOS24AkqeVxuVDdQqxWGRbqZ4w4VZYFUECM7nBOI0JLbUjZ8jI2gkAaJx0UnGyd9LdXFu6Tu23rZdbPRnNJVZcrXPdKzTjKy+FJX10envJW/AtMqGN1k3oqoS7LuDgHALBjnapycDjccchlGK6+QpXEoQyQbEQTFYXaRlYE7jkzkMOFBLFWw2AM0pJZROZTMj2oYgW6MkSRndGjMxE4kdUKsxLgg/uz0eRS43FrMFEk8EohmVYkW42kOhYeaiRkMrjd0BCsOWPQltrX4U73Sk0na61TXR3d9l1asaRpNfzNS+JwTaTajo9NbWu9O9t7FoIsDytCsarvVXCROd7HczspUhgzFULKxJGwKMgAVYJZl4Rgph3YbY0hU8gqXAz94EPk7GI8wAAbcSGfYhglu/OkWYhbktGWUiMGOX774jTgOzJ5zjhQTgm3HckxpuKSONvnTo8YQjbGVc5d8hgw805VgMlkDklahKLtHRXSulay0ikm09LN3fTcJ0p2u7ytZQtdO3LHVNpq3SzStfXXVW0gBZcSyOiiRwG8wbmklEkRdmYkmMjcoIG9CcHHDWHmWBBJK8aRkqoZgSAzMoCjcG2huirgYALEY3EVYpVZVKmLazKwVpIcKPlyrnrhiy7AQAcHPPzU+aSKZFDyxlEeKVk88D5kUbEUIyFn3H51BBCPlCTgVacUpJW1Ss5NpSaSi11t311enc55KUpR5lJw0ulG/Ztxe2ru+/e1rNjGJV+aQSS+YkuIn/AHkSuqCNRtbZ5eJQQ37tODwp5EiysZ4lj2kAeXIqoMb/ADUVWE5IUMsZCpJg7nDKFXKiiH7Ikkka+UkszebKRMr5WQIRGPvnG88QrlSVOSSpzLFPE80iLGymFTK05jTynd1jJ2FcF1QH5xhlGd2FIyC9+VSaWquo67a27O/ytra5LTvJRpylaKSckk1dRV0nbVN6auN9dVclUpMfKQlNr7n3eX85Vl3wqMMcnhmDZEi7d2CBtnmWRZrUQQKyyMUnIRgsFvujdt/7xQGJ3bZirSBARjciqayTO1us0EywNJhlM4j+UKyiRZI8MA5QE5Y5YtjG3DC7byQIgQTozFQWeSaNSXAVSWIYggkjapAHJ3ZIBFw5ZO91qlK6bukrO8fVN6PV33MXzw15drxcLSbeiu3aKWjs1Z9N7amom1skK3GAcBcjaVGcggMOTtLckHnoDVqJCGQhcdlIGCc7RgnJwc7s5xg4PJGRQiuolgebKbYQxfG1mwgVgGIVzkk/fKgEEltp5N63JuoIX2+WJkSYorg9gFAIBOw7Tn5htBXA4Dntpq8klJNuCeibv8Oml9LvR6p2+7zanNBScoqMU3G7vp7qukrp2sui9WpMvxCUnIQbsja5AP3cAD5sZyeEO3DKTu+bGbmlxC7nvvPLOkU6RxRodqBGiBcgMo5QoB8oyCxzxwa7xh8RgbsAbmBJJTaBs3B+MkDcAfmAAPzYI1LdmisXli+8NQUZBLYXYobJBy65IA5PBI5U11Qhqm1dJp2a+LRXVr2/Nu1uh5deo5RfIlFytGLavy6xulbXW1rXd1pdJGzbWNqowIXkAZQGLAng4II4znAweMgjkDIGrGkErRJEjrGZgLiTy4gAgAOyN8AKMjIcAj+EYJwMpHSZTGCSu/y2ZWCOSjJmOMncwGOHGQOykdR0mmJysJ3byijcApUxkJgeYzsSTkMCWJYnDAMBXqUYptKyW13qtbRbV7q11otWtXfU+ax05KEnKb5kpKyfTSztfy0vrd+h0VlbWCsoEMgYnyyd5AUbhtBVnZd2f4RgEjOTkgd9pUNo8sUEULnAZVbMYCqApAO5iFLZK5UBNxCqNxzXLWFkXaNQG+bB4JzlmUnGRgbmGSDnIA+6enpmg6WxkjZpN2QI+oIIG1iCoAJZSRwcAEg5YDFe/hKXvR0svd17P3Xtre+zervr10/Ns4xcYwneo3u7OXV8vKrrXfZ79tdH6V4b0mGSSM/Z2AaPIB2qkajPJIG0qdxXawGSvLKi4H2N8IPAsviTWdE0DRdJk1HW9b1DT9H0mzEe57rVdTuYbW1gfy5FU5lmQOQN0QLSErGDXzz4P0m4YwAIpZQu5jE7MxGwAdMM5CvtHAKgq3IXd/QH/wAEjf2c5fGXxIu/ipqGltPpfgDytJ8Mo0YaO88ca9CYRJEoJWRtB0Z5Zich4b3VNLm4IBX9GyWhSowli6sUqVGm6s20koqKUlrLT3npr59D+XfE3iWpgcBiY4ecqmLrTjhcJRheU6+KxEoUsPSio3k3KcleMVdJSe7aP6ZP+Cdf7OWkfCT4feGdBs7aM2vgnS4LI3gjVV1bxHfq154i1g9GY3N9dTtCzfMLeZICcQivoT9rT4kW+g+Gm8MDUYrCPUILq61y9aRY103w9psTXWq3kzswEcSWyOu5vlKlgPmAB+gfCOi2fw68B2lrI0cf2Gxae8nJ8sPcOhmnmYtjG6RnPLEKMDooFfzV/wDBWT9qZtH8B61oumX5j8R/F25udDsVSUiTTPhxo0sZ1u+wMtGuu3Zg0tSwCzW8t+ImHlMR+c8O0qnGvG+KzzERcstyur+5bTdNezdqCV9PijKvy7O3LrdI+v8AERVPBjwG4Z8Ksrqez478TXOtntWH+8wpY5Qr53iKrj7zVHD1KeXKbtaF5x96LPwT/a++N0/xm+K/jDxnE8p0q8vV0rwpYcl7TwvpTix0KxjiHzLLc26fbLiMKWN3c3DDO/Nfr7+zxpFl+wP+w74n+LuvwrafEnXbOeHSILoKLm4+KnjGyNvHCFcCQr4F8P8A2fT3UNIsOoQ+LotqtOc/lP8AsO/Bu6+P/wC0XoKT6eL/AEDwLcWHiK8hlRnsL3XpLtLfwdpF2CHR7d9VA1nU4uS2j6Pq7ONqNn6r/wCCsnxwtNa+I/hr9nnwdembwh8E9PNpqjiUMmqePNVRLjX7+7EeEnvLVZI4JzjK6jNqbZUyMq/tGY1ouEVayrJOSb+HC0JRTjZPavU9nQ13pRrrdafzzl+RQxWZZHwZlyUcLlaw+KzJwSaUowTpRnJR1lSo82IcrrlxFbBzfU/JTWb/AFLxNrF5f3k099qWp3s9xPNMWmurq9vLgyzPM5+Z5pZZGY8kc7txLcfph+yp8Fbzxp4o8FfD/ToHMl7dQvqcyocR79txqE7uOqWtvlQxzhgqH5itfCnwo8NNrfiCO/nhLW+kgSqcZWS8dyIFAIYMQxL7M7ht4yME/wBP3/BM74JJpWh6l8VNVtALrUC+laI8yHeLWNla/u4iQflmnVIFcfejhYgYLCvKpVfY08TmNazjRUpRT+1VdlCC/wC39XvaKbta5+5cZZjHh/h2ngMvUaWNzJxyzAxgmnRpcsVVqxjF7UqMZTT+FOMI397T9TfBvhjT/B/hnRPDWlQJbWGjada6fbRINqhLeJIgQBjrtyx/iOTkknO/KQFPvzjGADwM+vOCe+MjOAPllLbQc/N8mBtIBJI64J9fU8ctknGc+4kZVy3Oc+xxk8AEjHPbIGMknivhOapXqzrTk3KpNyk29ZSk7t6+bbu7K+2uh+P1nTweFhQi0lTpxgtHf3fO6eu99nrfdGbeTcFRng4x+AyQO2BgHaM5OQRmuZvZmwcEcDcDg5IOSR35P94A9sLuAxr3ciqOxGCTgZ5JOT15IAHXHPHOeeTu5izsMhgP4T0DdlAAJBxxg8fNycV7eDpfC0tFyvTyatZ7/ldPyPy/Psc05pu3Vpa6JR0Tv2snd+fry/irX7fw/o+oaxezJFb2NrNO7u2AoRWbBZsAYw2ASBnb1zk/yo/twfHm78feNNbuVvC1pHPPFaqHyqQoxWMAbgoDLjBBPOeBX7V/8FAvjYngT4fzeG7K6WG/1hJFl2yKrrABk5wcjceMHI6gnrn+UX4r+KpL+6vJXl3GVpGXLAHktyx5JIPOTzubnK4r6jEVo5Zld04qviveeqXLT0UY33V93bok+lz6zwY4TlnedvN61NyoYep7HDtq8XNyi6k1fdppQv62unY+b/iB4jfF0xkIMhYLgk4zuA53FeOCTtyvoAxx8vajdPNM8rkks79cn5mcFc4OcrkHovqcHNd9441d7m6eINuAZgVUnAPPXBzjao6k8ZPcY8ulY/MxP3yeCc8nHTa2OSM8knn5hwFr8wxFV1aspPV3b1Su9k7W0697aPu2f6gcGZJHD4TDpRSdoppx12i231t1T266IhUGSRV65Kk45x7cA7gBgglecZwcmuutIs7EAIAwueWLY5HPCk8jBA6+prA0yByWlIJIOF3epweOgx8ozyG4C85ArrbOPrkAHIH945xzzk5xjbgk+v3sk+pl9DmcZWu5Wd+qSaaTut7ve1vi06H9DcP4L2VKLcXzTsl/h921r63uk0+2rZ02l2zSskYB3EoARjkBuOnOB2+hz6N+83/BMr4JGKK/+JOpWpOAbDSnkjGCxDGaWLIIHAVCevzMCeQK/GT4W+FLvxT4p0fR7aBppr+8t7WNEUsWknkVQzYAbIzk4wARnjAz/Xb8BvhvafDf4deGvDVnAqNYabbfa3C4L3TorzSMPd2bLDn+AZGTX9JeHWWQy7K8VndZL21VfVMGn0dSK9vOKlu4wfKrX+NfP+mPCzIPb4z6/Ug3TwsU4JrR1J2UVe28bN30evZ61vjx8S7D4OfCfxV4wvJoo5rHTZ4tPjZgpmv50eO0iRRgk+ayluTnGCu3kfzt+EtduNI8O+OvjF4glaTXfEk9/cWlzMwLm2SeRpHQsTkXmoPGigEfu4cAjivub/gpf8VLjxP4u8H/AAM8PXAlb7VHe6zHC2cT3LhbWOYRnkQqzzuCG2rGXIOBX5j/ALTGvxeGfDWheBtPIS3jTyQI3wHtdMQR7iFG3M92ZmcqcMQpHIYDk41ziOFoSpQdnho+0qWdk8VWSSTT35INJrpzNX2Z8V9IHi2WKx2D4Vw1R+ypTh9ZVNtWcVCdZysk7x9yDTvtKLtex8hvHfeO/G6IxkmN1dvc3cjZYBpJg8jPkkhUVyQWHyknaGxmofjB4jt7eB7Cw2RWOm2cOnxqjfNO8UkypEuwsCbq4Vrq4VflaIZ4ZUU934Ts5vCfgfU/F95CV1HXTLp2krJkMytuWWePIY4DbizDoI0yAMV8keONYE2pTIRvgsJJ3lDA7XvHk3zM+WACwqpROPlYELlXGPwivOVPDVK82vaVPfk20neTXs929N5y0als7Xuv5qwlGOc5zUxtSMZYDJUqGFi0uSeOkknNNu16UU49Enz26W8d166aAmB5Q8uGubliQWeVyVSMjAJJfPyvyTgcdmqPsNhHCxxIEaSfsrTzHMvZSwXPlgkZGwDHYU4V/tTWGmkBaOIvfTsWUBVjLLbRuPm2lpG3hCxQoDt2gBqTUp8syk5IO0qDjg9sZLE8gdQcjcRgV8VUru1WvJtubcI6r4bxb13eqX3b2PrnG0edvWb6NPRJJtPXrr5a3dncyZisj5fIORtyfmb7p+82Dg+4AbjJDbSHRrtIcyFdiKykEgjAU8s3zEqwU5UdiGAIzUIIPA2ZIBxgfKxI4YAEgMSNo5DEkgqMmlVlKgMzeYAGAwQWVdmEycnzG/hwMHGDkDjxak05K70tFppp3d1e7u7J26Wtbdo5XC942snGz03b5d0nuvKN7WWmt+luLpre4tNVtRta4VpGZeR9pRDHcRkZc4kwzMpYlg5yCDiv0C+AHjeG/wBMbwhezobDW/8ATNJaXb/o00ytbX2nM5YfJLM6RiNQV81IixJUZ/POzlW8sruxYsZogL22XjKsoIuFXILsHjCsu2MLuXexyoNejfCnxNPYXr2CzNHND/p+mkMVdJhgzxoQQcnZ5iLgKGRiwYsQPpcixajiqSldObSjNdZ+7zQeq0l081F6ta/O4nLI5hhauAfuYvA1oYzLa+vPTr0mqlCz1bhOK9jNX99c662fsfxA0afwj4wuYypUQ3f2iHsNu7lMr/dwFY7scZz8/OndP9mvLbUYMfZ76GO5j2dBvH7yPIBJZXyCFYAZwxya9J+JsUHjjwppfjSzSJrlrdbbU1RVMiXSAK5kVAcI55XgkIyENzgeQaHctqvhyeyYH7Vo8hliU53/AGaR/nAHJIjcEkEAdhjBrtxuElhsZisOkmpv6zQe11pL3XZXTi2vOyv0RyUEsww+KwdWm4zqUnNxkldVoRvONrdnJX0vZW6H0b4M1Z54oSrLwB6KT35x8xyBg5BII5A+Y1t+NLISwLdImS6lmKAYUhWYgnkqVxk84HpgA14v4E1SVJkiYlSpGBxn5skg9WOTwMj5uhHGK+iJEGp6TImE3IjP8vXBBwDxux1IwBkjpkZrbDVI18O4NJyUdFfTnVr7at2X3667H83Z/gJZRnfOo8sJVNWlaybW3ktHrfXdM+UtZhYGUMuAMgcN2IHzHIxgbQRgnJGfm5HlGsQ5JbsfpkbdnU4J+6MHccryeSTXvHiWxaOaVQoAy3pjhvm5VRhgO+c8EDBGD5Bq1uzb+OgI5P8Au/MBwATkHvjAByMg+NXg4ykm02n1tdP3dOy673v5n6Tw5jIt0pKVrxi7u3K9Iq/Xrfa2626cOnyuAV54zjABOVwOoHTjoSccDbwblu5VgFHJz8oz7AjGRnPOMHH0GM15VMbnJGSRjO0HJxuGAM/hnJPoMYs2qs7oOpyuDtLDkgDgc59+GPIAxyZw7aqRV30WnqrLTre3p8rH7bk1WdSNON5bRs2ves1Fa6Waa6u6Vrpno/h/e4iOPrwe+OoGcZyFxkndwCCeP6T/ANgzwVpv7K/7OWq/tFeNtKmvfF/xFis7LwV4dRVj1nWIb64Nj4S8NaYXVjBeeK9V/wBKln2eVYaPC+sXO2ysZnH40fsQfACT4/8Axo8NeFrtGi8IaIf+Ep8fagzrBb2XhrSXWeeCe6lKw2rapME06GSd1jhWaa5f91aTFf1D/a9/al8NaT4eHxFGIPh/4Msb7wj8B/ClrMbCTxVJfWkmk6l4vFsIw9u3i+1tZtE8KBkR/DXwltte8RKkep+MtIMn7vwh7DhvI8TxHjGoYjEwq4TLIyV+WPIvrOKkm1enC6pxezm5wV3t+14TiLD8AcO4jiutGOIzzGKplHCOXy1liczq04xqYtwvzfVsHGS9rUdo2c4uSnY+YP21v2p9V8FeE9f8C6V4gg1H4yfGe5v/ABB8SvGGmySRDTtE1W2Ol3LabhxJbaW+jRDwF8ObOaR59L8C6dq+txxW994xtrqvxXtrZ+YV2xO6K1xIRn7LasyhYyTytzPu8yUKTuVhHkliAmu+Mdf8ceKNa8Y+Jr3+0fEGv6i9/eXTqwhe5cIkUNvApKW+m6VbLBZ2FlCFS3ghtrK2TZFEo9x+Bvw4k8feJbVLuOd9Esp4LzVSgZ5bt2eN4bGMnHnXt5JEqiIfKofC4VDI355Ur18+zNyTclWqtx52rU4SlzTqTs7KUk3OTb0uo3so2/H8swGLxVetXxuIlis0zOvVx+b5hWlpKvU/fYitOcrKNGjG6jeyhTgk1Hr9gfsRfs0+Pvib4s8NWPgjR3m8fePrtfD3gSWVCLbwvpc8jQ69481CQqVtI9M09phpd07Iou/tlzDJvsEr9TfGmq/Bqa3j+H3hu5Sf9hz9hK6udQ1nXFRI4f2nP2mFR7LWPFc5VfK1nTLDV2PhnwVZCW6iMMryw77fVbYR9xrmjeIf2YPhV4T/AGdPhtBBpn7Zf7XmgWOl6xfWuYbr9nb9nSWDZclpYwX0TxH4s0uK5V55vJubWzF1cLFbXttbSTfmh8evEvhTxVrvhr9k74Qx3938DvgWbZPEc+gqZb/4i/EKa8j00x2pt+NQ1nWdcmPhfwnFAJPs1/dazrUBlNlb7PrlUpU1Ro0k3l+BajRhJW+u42dnzOMVaSivfqXuo0+RWd9Pyvi3i1cRqVPLMRKjwplTr4TLa7TpfXfZtUs1z9ybu6daqpYPLW2ueMZ4iN4ezZ7T+yz8IPiT/wAFH/2pIxr7XWn6F4tW+8S+L9StVkNr8N/gdb3jWGqy2bAKkfiT4lTWn/CF+FpC0bLoMep3dqsdjeWkie7f8FSv2pdC+OXxM8N/sc/BGJdP/Zn/AGXpLDStXsfC5Lad4w+IelhdFtNE01LUiLUbXwy7y+GtE8oyfbtcu9b1RGmMdvJH9Y/FPWpv+CTv7CFp8O9KfTk/bm/bAhhn11NGES3fgOyu9PttKWz0mOJXe00X4W+HprTwf4SiTZbz+LZbnULWSSOyuSPxm8IWcf7PPw8T4hqqah8RNS1a/wDDXwgtpxDdNrXxaEEVv4s+JFyJzK1z4f8AgnYakkGlzTfuNR+JepaVPumi0nWErzMRUVatPESrOXPzTnXu3O2qlVi00v3jl7OklvHWKfOrfjGQYqGZ4urxriaF8oyWrUyfgfLJwcYY7MuaNGpmcab0nSo68tdxaUITqS5Z05N7Xjux1bVr7Q/2TvB5tZW0jXdI8QfHm+0p0bTtX+JllbmHw18NILq3xBN4S+B+izS2N8qMbO78aSeLdTd5kstPnf8AVj9gb4HeFvHXjS4+JGrwiL4C/s4afI2j3VzCotvFniuWVLmfVyHAE7ateQf2lEgDkaSmkWrHfq6hPy/+Cnw01zT7Tw74B8PW9/q3xI+LkttZ3c8bPLrcHh3V7yOG7uxcsr3Ca18Qr+dtOiuJSbmHTG1FpW/fySL/AFn/ALN37PGh6TpXg74BaTDBL8P/AIQNp+v/ABb1S1RBa+N/ihcRW99F4YV0wJ9L0ORYWu4uUisbTTdNdQ43Hqg4Uqc62IfJGEI1cTtaFOnyOlhKaajdpyi5K/v16kG1eMrfH+JPFMuF8leDw+IlW4n4l9tKeIUrV8Nha1oY3HSbcpU6mJb9hh7NulhouMGoqJ9Mfs7eAdSla9+NPjK0eDxJ4wtUtvCmlXCNu8J+CFcSWFrHEwHk32sAR39+4VZDGbeJ9u10r6I1G7cuyhgNg6ArtycAAEDk+gGM8gDIFbOoXKRR+VGqIiLsVFAXaoHCgEEADaNgxjgj0A801zWLTTLG+1K/nS2srC3nu7q4mcJHBbxRmSWSRm6KqKTnccL0x0r5ynOvmuNeLqR1nJRpU0lywjeMacI+iaV0tfek9ZO/8b8QY6nhKaw1OV+s5d3pe7d5Pzd22/evfV/IX7av7Rmn/s9/CPXdcS5iHijWILnSfDFqzDzRezKwe9KkhxHZo3ms2Nrv5Sk/Ma/iL+O3xN1HXNT1fVNQvnur7Urq6urq5lkLyST3DySTOXLEsxdySWbc3THy8/pl/wAFH/2rp/jN8S9VOn3cg8KeH2n0vw9AJCI2gicrLeeWPlWS6kjaUkg4UqN24DH4S+ONcl1K/lzIWUOR94gA7jgAEZ75UenzZ6mu3O8THD0Y5bRafs3GeIcWnz1WoppNaNUkuSOlr8ztdtH9TfRw8NXhaMeIcxw7WPzP2dVRnH3sLg/ddCjrdwlUu6tVJJ88lF35EcLqN7LPPI7NkuzEt2+bdkZ6A9QccYwMA5B6fQrQiOP7uZiXY4PI7Ae3tk8kHHBFcbbQGedFI3hW3eoA3HJ79TzyV+Ykk/dNeo6FaguuRjlFweg2sVwOcE7s7RtwMEZ3DbXHkmHliK8IpXfOktNNGr317Kzb6aK3X/SXhHLFGNOfLZWjCmrW0Shd762tpvvoj7Q/ZG+HR8ffFnwlpEsHmWkF/HqF6CCym2sz57Bjg4DFFQk8EsB82cn+pzwnYRRR20caBFijjjRRgKqIAi4BBXCjaF6EehJy34v/APBNb4Z4XXPH95bhQqLpWns6AYGS9wyEgnC/KnykHjnkjH7g+HYBFGp28hfkwMAjA7H+91ZvTJ4Oc/1fgsFHJuFsvwyj7Ovil9brWVm3UtGkpbNctKKaVre89NWj+4PDTJ3gsmpVZwUZ4mbqtvRuEVFU022lZ2cl011Xfif2h/HNv8OPgf8AErxT5whmsfDN9BZEkDF/fI1lahDwdwnlQjvlSBkAV/Oj8HyPDPw48deLLpwmqeL11qHSpnVjJPdwxQeG9IVSDwTrPi2e7RgQVuLCKRWSSNSP1N/4KmePW0L4NeHPB9vOI5vF/iaNp0Rtpey0uMzsGB52ec8O7GFB9mFfj98XdavPCXwx+G/h7Tldbg6f4VvjFArPJPqU9j4y8eGMoAWIlE2hSSDJ3eRC5X5FK/n+LrRxHF+WUnKTpZJg55jUpq2uJnyzSt/N7OEJRsk03fqfg/jnjlm/G/DXDk2p4XD4iliMXTvdKlhISzColurzlRw1Nr+9azPinw/qYvfjR4l8cRuG0z4b6ZrviPT/ACiBEsPgLRl0/wAJJHhiii91yPw9EuCQbi9dsksprynxF45vvECeH7KW4nnsvDXhjTvDOnmY5cJbPPd6jduFZgJdT1zUNU1OVgC5a8w7MVLDqPDF9ZWfw5+I9raXSyeKfFL+CPDq6XFHJLeHRT4guPE2v34ZQ3lwC+8OeHdPk5UyPcOAp2uDyem+APE+oERWHh7WdQd8AR2GkaldyMSSfuwWcrF2J5+XLn0r8ux+Ox9enCnSjKtUxuMxWbYydNOV62IrJRouUbWUadJS5Hs5J72PicfjKkqGFpQlGpPE1sXm2MdNqXLiMVX9mqMpK1lClRpy5ZaqVSSW9j96NE8Y/BL9qr4PaD4F8S/FX4H/AA20DUfhboHwrvPGnjPVL6D4s+D5rDWNI8a6rrFp4cu5p9G1GG71fQbHwPcxwaxpsF54TNveRpaXWn/Y381sf+Cc3/BPnRohc+Nf+CjfgOeLLM8Xh3QdS1S5IU53iHS4b+3hklADNFHfTQxuxRZJkUsfyt039n/4y3MaTW/wz8e+WwG2STwjrFnD2y5uL6ytYenUsypgglu9dbB+z78SginU9O0fQQFG7/hJvHPw78NsMEZ8xdd8UWMkS5PKNEHBOCM4NfQZnneZZv7CrUyahTxFKkoTrVqEMWpWjFXSxNKfJByTahzON37qit/Yxuf4jH1I4mpleXyxsqVGnUxWKp1MTKapU4UoSVOc+SHLGMbxcXDR3Wrt+mC/s4f8ERPBrl/E/wC1L8YvHksJ+eHwv4I1i1gm2gfJG9xZQOd2ONs8YwCS2RW9p/iz/ggb4FZWt/hf8ffiRNGQVbULJbSOcqAvP2rxEqDIAGDagYIJUsK/Ka8+B0tru/tT4jfBHSQCd0dz8Y/h/fuvc5i8OanrlwzjIBCRZ9BnCjAl+GHw9tAf7S+PPwctmQdNOPxJ8SSAAg4VtE+HN9A+OMBLjGdxB718/WxOdrmi6uV4enbaGGy3AtLT7dGlQq6J787fdrW/E89zmCXsq+V4WN9Xh8syijNWtb948K5rV6tTu110uv2rt/29f+COXglFXwX/AME8PEXiFos+TL4l1zTrRCQAFaSGOPUIuwzmI84ByCckn/BYH9kDQgyeAv8AgmP8HLYo37ibXz4f1GQFQCjMx8CzuxUD73mDlSAASBX4inwz8B7Yhb342XN/jJEXhP4ReMdRDNk58uTxG/hJGPy/eCIAQM8Yq3FZ/s8R7can8etfC42rp3w48G+H0kPPAk1Dx3qzxDG3H+iSE9QnIz5lStmDVqmb046ax/tGpVi07X92Naqu100zlqZ3m9XmVfP8Tyu3uQxahDeLso0VGKV9opeex+0N1/wXa8T6Qhj+H37G37NHg6EKDC58PrIYQBgFjbafoaZUYJ24yQ2BxXBav/wX9/bTKyR+GtC+BXhCPBEf9leCre4eJCMghtQ1G7XAwcsU4OCR1A/KqO8+A8B3W/wc+OeusoyJNU8e+CfD0b9CGKWXgfUnjzkfdu3I5w5zUzeKvhjaqBp/7MttKxG5JPGHxw164OASd0kGh2nh5eNp3BQhOSBtyK4nR503VzGhK6i7Rp4ud9I3+HCyjfzveys+x51TFRq+7XzGvWbSUlLEVpvVLq5a9dbpb97n3V4i/wCC5P8AwUe1rzBF8ctN0GNwcRaB4R8MWflhsj5GTRZ5FAH3d0mQcZKjca8U1/8A4Kv/APBQnxEHF/8AtVfEJEcFmXT746cFVsjC/wBm2Nttx0AXAGBjGM187y/EPZ8ujfAH9nzT2ORGb65+Ini65DY4Pkz+KtQWVlxu4tHDZIZQvByZPif8UkYrY+Fvgb4eQZC/2d8BNP1PyxnGFk1/QL1nAGMeYxB6tlmxXN9Swu3ta9Scmn/s+Enrbl61HS1b3dkls7q5z+yyuUlzU6lVuyu4zqcz91NpuUlvo78vforeg6x+3L+174l8wa3+0f8AFrVFk+V45fHXiIR4IIJ2Aqo4x8rZI4LMwzXncvxJ+OHjOeOCfxl488QXV3JHEiza14j1M3EkzbY1AhG92kY4AJKknDKvWom+LfxrQrHH8StP0VS5Aj8O/CL4d+HGC/wrBHFp2j30uMNgwW8mCQBISOPcfh/4P/a8+JVrcap4d8dfHi50SztpL6/8Sx2dz4O8J6VZ26l5r2+8Tza5pWhWFpCAXa4e4wpCqqMcI+9DJ44h8tLLc0rN8usaeHp81uVv/mKqNX3Wl1va1jSGW4Kq17DKas5/Z/cJRbVmm/dlpbvax4h8SfhX8cPh1pGheJfij4B8Y+GNC8WFx4e1zxZouq2Gma3IkKXEkWnX98s0FxcpDNHLJaiQ3EaNvkjRASPC5JtQdsQ2sMjNtMaobdizDkAKls8hLDBIEY3AqQDkE/f/AMUvhJ8WvAPwxh+KHiv9oDVvFNrqviHTdI8KaNfax4j8S23i/UZ4ftGpXOiatqtymg6tH4es/Ik1m9tNNutLtZ7iLT4tUmupH2f0O/8ABJ74F+G/DH7KFx+0V8ctHsIrLb4t8YnxP4l0Dwyk1l4I04NaWgs7qTS/OiN1cWc9xZXsbtN5caS2+2aeB14XkN8bLCYiOIwUowjVfN7LEcqlKEYL3ZQ96U7JRsmlprufjXjJ4lf8QgyDD5piMko5xmGPzLDZXl+T4bFRw1bFYnEJyVNNUcS06dOE3UtGTulonZP+NKfVbu2OyW0Cs5ClSXR1O1XcsIolMbKrEpHKDI5CgAsRj9of+Cevw48N/Cb4beLv2xfjTpVxeeHtEgisvAHhpbYzat4x1zUb06XoXhvw7Zzbzdan401uSHRoFiQ402K+mKi3upGXzu98CP8A8FFv24fG/izw/oVv4Z+GU/iOLVtWl0yxtdOstN8JaVnTdFsf9Et7e0/trWbK0iM91JGGN1Leai6hIJd8/wDwUA/a18PaDovh3wt8J3tdP8IeB4NU8LfAax0wiG3u76C2l8MeNv2hJoNuBaWCLffD74LNJE7edH4l8eQSpdx6ZcT/AFeQYGlwhQxvFmYWnGl7bB5BGcFfEYiSUamPcNbUqCaUJXalWkoxkpJM/buF8ZXyzhfLeNs2ymGCzrMMNh6GRZBWcKzlnWKw8alR1JqnT9phMq55VMRiFTjG9PRJ2R8U/t0ftReNvib4n8ZaNrmtwal4p8Rapp+tfGHUtKu3udHGr6K/2Pwr8IfDNxGwjfwN8I7GQ6fKbYfZPEXjeTW9cae+js9HuoPzEuZ3ZW3KhMjHeAg8zBCswRC2URclF3AEE7SMksurcXMksF3LIwbzIrf5mJYNm9jYB5C2WdtqsZOC5yW5ORzk8m1k3LjB5yXBxvCncefMIAwScLhu4LMfxXOs0xGbY2rjcROU516jm+eXNyxlUuk29kt21Z7tN6nBRpVoTxNfE1J4rHYvEPFZhjJ61MRi6vK6lSTd+VQ0p0oKXLCnCEIWjGKK04HBDLu2qQMkEbsZBUEgtypOMhyCDxg1RlRpIpoxJ5TuqqJAuCrRP5gU5AUIcY2szZfKkrgA3WYNkD5MnqSAcKq5DBPujHICnHA2KARVV25U43AqAXXbwoKZBDHJIBPzEgAYYbsAHw5pbWVpJprVXTSTWln1S1VuuilpvdLdq1npfS7SV763tfXpvbdFCwtWtJp5GuGnZwgR3UhkMRcoikspzwF+XCEHEYViaZqVtPcxMsM5jR2PmoQMSK7ozPvCMw2CJWCkbskM7FQCLYOwHf8AOxm3BwdzMpbKcsxxtyGyyqcYQhZMAO3g/NjJKquAF3cbckliTkZw2V3RjCkMfvcfso8vI7pNX5XJp6uD37JPW+tm0lfZOKaS2Tta7vd6O97aXvzavZOzbViJF2Qy2+BIkxSQmU/MJFj2l1JKgeYyhlAXAGMZO4M9ImwCu/aylUy2S3CDaAFK7o8qG2twAWyuNpXB5xktncp4+U/Lx8zbdpySAuVcqVyrcC/dM6aRp7fN+7v9TViGPA8uykx8u0KoGWBztRiQMruxUaaak+ZpRinbXZuEbLW63vv0sV7H2ib52uRaK735oqzau01d79WrvZGW8bR/L53LKCcopJIUbRllAOANyjAZssSqnJMI3gAK/G3kbFOWyvQHgknGCcgEkH5alLKoKth+dwYA5ZjgYJLehJYADJbIxxloYlV+UgsAM9B/DxtyWA6tn5S2eecUuRN3V1f+aT2urNXXlqmtGui1WSoSTb5ppq3wyet+XTd2t677aEDx3LB0WReMkExKzdQQSQB1ClSFyB1G3bhayx3mEIuUD4Ab90pwhwSAzBcsSpJBHzgBH2sS9aO4vlVjbIUruP3QPl3BC2GZmHTO7dgZJbOVK5ChuMFSOylBs+Y8k5yoxgEdcmolTX80ul3za9NG3+bvokkmjRUWtVKV2t72vtdNNLpfo+lkrlaOObG1rg4UBidiAnBUMCuMheoJHHBUgYYs5gzkDziDjKkBMbhtHoOhyMdGJ/vHBtlQzAlcYON3clSowfmJHI7ZBGFAOFzH5ZxhR0IA3ckj5RgnjaG/HnqA2cw6bVkpvW1rtu6Vu1/x7LXsvYzfu+0k29NW1vyO60s0ujvpouhU8uccedhSeMxxEAkYLEuqtkg87kyBkHJzljW15wyXYLDJH7iNwochivygEDHOW4I4zhia0gqglhjrjO7JK8Dp/COgBOcEEY5FVJGaQyxIrxtEWTfIV+YsincqhSSvBVs7BliSVOCmcqKik3Kab6KUk20ou3MtFFa9dbNeQlQlF80qkm3ZWTb1XLbXfa6WqSW9rNmYTqCdL+3O47WCwAhWJySSFbYVXnOPYchcWIYtYLJi/t1UsuN0IPyblUjbsCgY+bBGASOASAt2HZFEkSIFZQC3GQGDbHZlDkszEEqCSf8AlmpO0VNDM/nom0qiSBQ7ZzIqsgbndkEHJ4G3BIBBGTlKimm3Vq6pXUakrXSVvl20S22NOVqKtOV0mkrt2dovV/drfV7bWNeycm0tRgKDEpLAYKgORjlgdrAjLFcnLbRkFqoa8Wa0tFCgk6jaDDDOF3Ngkkbhg/d3A55LcYNagU7VjTAAQAKoGABwVBUAYJI3ZABJYAKcZrz26XKRpMpdIpElCK5RWaPBAc8MU5YBV5yc5yAxUo/ulFct7KL1Svayv1fyt3fU/N6Ne2LVeSfLzym9U3rrorpPdXV7r5FwBRPKOTmOFwQCuR50wBJAZSACNhDFWzkbuTSuSMliWJVsAAghdnzDPVsggNjJZgMDioInEaMRGRJhRveaZ22Ku4IyleVVnHygAqpyxI2syxyNIFyqgEANgA7V2qMcqw3BG4KtgBucmrV0uXyvv6N7pXt33f54KMnLmsrQlHRtXdnF9HZ311vt9xQ0lX/svSsISRPKGBDAKGDjIJIGc8qRnDDnjg7PTczAkEHKkc8bRkZOeASMHJGee4Mnl2SLFFbrNFHDuaJdsO1JGjcbCFGSrOVLZOf3hCjZu3U2lcYbkMJSrEhQFTcEyVbduJC/NkYIOGBOCEo8sVtpGEW9Xtypt2v2u297dbF1air1ZTScVKpUmk1bSU7pN6tu0ulte17GZbys+r60rIAFt4YxuIY7ViGEOZBneXdkGOxwPvCttwR5RKklURXwMEfKRgcMu0k/KV7nryVDWS3y83lOrzRJFKyOsf2gop2NK2FZiDsxuAAwAMcARXEqLGiqGW4QwoxlbzY3Xc295SHBU5VMEISANwGeAuVQWrTs2976OWnXWUU7K/a13c1qVFWnFwjKKVOlB3VrclOEXJ26N7K+zsznNXkmfVNIhjRliSZZxJ/DLK0ixNHmNOJEjBbaSMpyRzsOnfq3nweU0n3LqRSu/YzCVZAsgDBwG2lWywRiy5UZLCysYIwskhiws2WCMEnUHaVwU2hmY527VcncwxlazpS1zcCUXaxrBu3QwoqtJOgQs82XTEMmAjfvSSQDt2gAc7TV7tylUlGSS5b2XKrbq6suiu9NdDshNTdGMUoKjCUZSak+Zzu03ZaXb2vbe9lsjmaaCIXQa0kZlUgSIPJZVOyQzFmkEbsxLRnaDtWMngGr0afIqq5YKFPmFnZsIirtZgzb2ZVGZM7c/N0GKoRrJdxSw6jYtBgLIV85Gt3AH7to2RiysW+YBmYbBjd82TdQgN5e1hsXYrgPt2ZUKqnJGFQqHPIKKCCWApwsrO9lJRT5rxldSXxLpor6N7O1yKqkly6c3M5cqtKFpctnGV3fW67rS2qRKU3hG3ltvMYV3IxuQhSfmBbjIBBG1WB3Hk5jSz3k8ttZyxwxwEJdX67CqbiitBaFkUfaDu6FiFY/e3c1FLNLeM1jZSbLdJNl1qAYsEQkEwWrIEDsVBMrcHcCqscgnct7CKG2t7WOJsIytDEhZQ8oLAPKUOJZXcoxDYXAXDAhd7j++5lFWjdc8tEpOySUZW7Xu09bpX00TaoJOpaVWVnSp2XuRaj70oO3vX+GL62lNaa5q+HtLBz9iNy00h2tJcTPI5YlMgRkjzAx3MpQbOoPO0TweGtNudvl21ihjkZDGbwJJtVgC+2aWLO4tGm4lWYgkIihSdaS6Fs00NuVecxlZ7xWSRUieNt9vbB0HmAuGFxdZEh/1cTKod5au1YyoRRtkhB3LECQu4napDOCdjNHliS2VIO1ht19lRTtyRtd3Vo3VuW6Wm/m01d9VvlHE4q3vVqqbas+aT917Nq6tfpaz08x6eGbIEFbTTVVQQ264tHLEj5VK/ajsALAAMd+VAIYliEm8L2DQyG2ttPSVpIdp82CRcM6GVCRcbclCAigSMrBzuQHFCyw87fKPG4oqqTgLu3OhUsCC4YK7bVbaSwJ3K2JLdAIj+7BLJGHCp5yvIpJYkyGRmV0yECgouwgbV23y0f+fUWrKN7pLW1torW1ul1rfexMauLjd+3rc14vltKSlopX0le2i0td37JWn/4RTT3DlrK2KeUcHzFDA8MBuFxwyhk3McYY4yy5BRfC+lxoR9jswvlsw3SK2wnbnJNyNzAHleNm7eXwwNOaCBFYwpsZ2SWYBWZpmBLDJPKDDKAqEKp4UEGQmRAQQxUAlATuRcAbsnaoyBkgjk7VxsLMBmrjSotWVGMbJNPTurbxaasldXXXTTTJ1sSkrYqs02lZOUXfTRe/Zb21adr6bFX/AIR3So23i2035/kA88sFDgkNgvuwAFcZJ/jAbaPllOjaUiopttLbK4Qq64BBIXJzJuVQQzbsNhc4wOJIiUDKFbDlpAxUfKvC+WXd2EhKBihIAHOFU7gZEIUELgKYgRx2LHA3KAob1O5gQQVJGBSUYNq9OGyT91a/C+ZbbdE7brS10lOvX0viK1mk178uy8++nWyfnZVF0zTTI8Yg07dHk7RIQVDZVSyjAO4naAPQN8jEYkXStObKiyhdhnPlOxK5GWDKHdQ4LBWDyKOOVI5qTaBcQyEEspbDgyh9rsGYuzMMksVG8oSELKqlc1ei2KSI1VWkG9wqMF5YbicEKVK4KDGFIO0hc0404vRxjbo0rpJct9uu76dfnnOvV5Vy1KrUoptc17O6urtvyelnvddCv/ZOnqSW05HjKsRiMM27gogTzgw6DAB3FiAOMgxnT9FjVnudMW3DTqqNLCyxAN9zdMjyABiSzB0KhQw+QkFtDfGEHmALyNmFjGTlcMFYr97fhQRgnJB3YWr0EayIu8KEC7XUhCMHAPmDoWcMVHyErnDZYZO8acZ6RUW/OCktbNa66bfNOzfTF16sE251bOW6qNXty/DZtX66LvfXUrvp4ixcadFGGVNklsoCQXdugcbHBJUyYCtFL1JABUDrsaZIksRmjfbBlyYHyskMhfcbd+SYguwlAgA2sQpIOKpKHsXCsGNjM3E3LGzLbyIXZjn7ONwMUnBQkKxA5OmLRi/2y1KiYkI8RJEd5Gm8bZMFUEpGTDP2IO75TXVQi00+W1rc6vukopyStrrqlZp26NO3m4mblBxm7qSTp1HrzXSdpvR8y2TWqd+ljWhSLD7kJC4KqxGcHYd2NgbDDAHBKnBADdbMA8uK5t/MOz+0LZ41bLFRMrHALYBzsUNkDb8xA5yC3b7QI5YkUeW3lyoyjzI3BYiORQC3mAqFDEgZKEgj5q1rWB5Wd9haOS9skeRVZNvlpISpba2XXPylmznkEg4r0Ix5+VR1k0tF526W11d7vro09l89VrKDlzN68u7vZqUXt1eqtfVX1Zt2VsoOwQjPzNhBgMu4YJIMmQpYHnJI4U4OK7HTrGNRGBGikqpO1AADwMlmU/eCDIAxwB23DHs7ZYyGO/G4sSCzElcFtoyMBtwCgZCsAGIGSO1sIyqRvhm3FQAgG7LBMjIyCoBUtySrfxEDI9mhDZWSsl03TSXzV076dE10b+JzbEtRdpXUt3e71aTTf3K2tndrU6HTbVnZVYFiCAPl2sAQACG4J6AqeW25JLNk1694Z0jMkTMhxLzGQSwQqImb5QOCM8oxAIK7RtANcZolhvlTK7gSvIPQthzgYcDAA3Z7k9BkD3/wjokss0JwjIw2lTlwsi4IbaxwwkVSuMbjySMABvrsqwsqkopLVpXs3bdWt1v5a39LH43xHmf1enVcpRXuy3e2ib+7z0101se1fDXwve6vqel6TpenzX+paleWenaZaQRb57zUL65htLK2iHLSST3Esca7V3M0gxmv71P+Ca37MenfB74c+EfDLWkUr+FLCO/8QXyqGTV/HGtRm61m+D4/eR28sht7NnBZNOt9MUY8ndX8z/8AwSe/Z0b4gfGAfEHUtOa50P4Yi2msAY1Zbzxvq6SwaJFHkFJJdKs0vNXAUB4L6PSmGTIM/wBxXw78NW/w+8C2tvOscNxHaveX8gwFNxJH5rjOPuRcRRbslYo0XPGTt4g5r/YuQUsqw0msdmr9k1ByU1RfKpWS1SaaVuvOmnpr+YeEPDi8RvFt5tmMOfhTw5pLOsxqVbPDVc3tzZfQm37l8O4PFNO/u0ZQnZuN/Cv2sfiXF4a8Jr4ZtryKzu9d8yG5uWkWNbDSLVDPqt9K7ELFDbWayF5HKhQS/wDCa/g//bT+PB+NXxg8VeLbaWX/AIRqykHhzwbaOx/0fwrojm1sZAh+aJ9UkEmqXeBu8/UHUk5GP39/4KvftOtpfg3xHbaVqDR618Sbm98GeH1ikCyWPgvTSo8VavHg5QavLImjwSlQJILm5EbZhJX+dz9lP4Q3f7RP7Q/hTwq1hJqHh3RLyDxH4niUO0N3YWN1BFpWhy8jCeINcmsNKkAPmLZ3V3efctG2/U8G5DDh/h7BYRxUMZjEsTjZu0eWVRQk1JvVKnBKMk/hcZNfE7/mHGPHD8R/EnjDxLxc5T4eyKNfI+FoXbpvLcunKFTE4eL0dTMMTzOlKNnJVI09Uk1+yv7FPh3TP2L/ANjPxn+0V4ws0g8XXmkvr1ha30aLNdeNfFNi1l4T0gBgWJ0LQLu1eeIgmC41/wASwyBHtG2fz/8AijxBrHjbxRrPiHV7ua+1nxDq15qeoXc7mSe7v9RunubiVi3zbpZ5HcggkjgEcCv2S/4K2/Ge00u58D/st+FtQWfTvh/aQ6942ltyqx6l4y1iJrkfaEiOwSWkF3NePFgLDNqZt1RBbhV/Jj4SeGH8ReI45Joi1rpzi4lZlOxpSVEUbdc5cdCAAoyGz16MVVWKq2ptpVXBU4vTlw8Fy4eMle3NJOdeasn7SvK+quvrfCTIq9PC4riDMY8uNzevWqtySbhSlUUqlv5YRtGhCzSeHw1Gx9l/s1fCbUtf1bwt4S063L6pruoWaSkRlj51y6Eu5AB22sBd5OhXZy208f15/DPwVp3w/wDBPh7wppkSQ22iaZbWaBF+9IkaiaV8DBaWbzJHY5LOW7mvyI/4JrfBQXOtal8S9UtCbbRU/szRmkQFW1CdAL2WIkYJgg8uEMOhdjnJIH7YDhMEDA5xkDqv+V6dOnOBXl8R11Qp4XK6T0go1sQ1perNJwg3daxjeVr2/eO/c8HiPN5Z7xNjcRGSeX5RF5fgVvGdW9OWLrRave8lCjFrW9OS1iyKRjnJOMDAPGDjqBjaDxgcA+gyxArDuJ+CCD1xk+vYexx7Zx905xWhct746jPQjnoOMAck8gHjHBwa5+5kwST2OSCOOOuOvPHGTxgDIGa8LDU7tbu1kr9tNvN6bdWtrXPgs4xnKptuztq1dOVrbfZe33Lz1yr642grltwJy31xxyQSRjPGSe3BFcJ4g1i10bT77U7thFDaQSzuzOAAUDN1JHUfMD29DxXS3spMhJbgHOCdpbPAyCPTBHXHoD1/Pf8Abn+NEHgD4f3mj2t0I7/VIpIwFfDpGUHmDA+YDPyjHVvun5jj6zK8JGpUpxdlCPv1ZdoQte7u99kr6vToflGLlWzPG0sJRTnWxNWFCjFXd5VHGN0kvsq8ns1yvRbH4ift5/HSfx3491gx3TNY2csttbIWYqEiLABVzg9OBz97pnlvxc+IniRgszMcu7OEUcgLnqRgNz3PLDgNlQcfSXxd8YS6rqWoXMsu8yyyyZLkEZZiSxBySc85JIOCccgfA/jrWXuLySNH4VyCq9OpyAvoegySSTkk4NeNxLmSr15Rg1yQXLGN3ZRilZrskkl6dmf6CeDPBdPKsuwOHjT1p06bqSsk3NqMpyk+t/tPVvX0PO9WuGuJ5HLZyxYhscAsSeMAEKOmSOSMAjkYjI0rBFzglsbRzk44BXj27Y+hUCSeRixIAyRyD3Y87QDk56ZP935lJNWdOhLSmU4ULxjAGduMfgSARgkZHrtA+VowlVqRi921e2umi111vfVvrdu+jf8AavDmXXVKCj0jvpolD5rTZXSvZq+pr2tuIkiiAHGC+MgHjpgAHJ4I4yAPfI6awgyy4GTkYUexA7843dPY5Jzmsm1jMrYOQQxIxyM8AD+HjPGOoHGdwxXpPhDRJtY1OztYI3eWedI1WMElyzgKoyCSSTgAAEN8u70+74fy+rjcZhcNRi5TrVKVNJLV80op2S11eu7Xroz9tyTBSqToUoRd5SpwSWu7ir9Gm3vbS7sfqZ/wTV+CD+MfiFH4v1GzMuk+GVW6WR4yUa/kDeQoJ+UmJQZT97BAIx3/AKE/GHiLTfAHgrXvE+pSpb2WiaXdXczs3lqFhgdgoIPUsoVQMHc+3kYx81fsVfCC3+FXwi0C1ntRDqur20eqakxQJKZrlQ6I+fmxDCUGMHDLzjII+cP+Cofxqbw14H0j4S6Dc/8AE48ZXEbX0UD4m/s2KRfkZUOSs8rbVUAFlJyvzEV/TGOnQyfCYbLoWWHyjCpVuV6VcUuV1dnq5VH7NJP4Ula2q/rPK40eDuEquNrcsZ0sNKtJSsnKpOKVOF3tdqN7O6s+5+YXh3xHe/FX4s+PPjJq6ySl764t9BEu4oNR1OR7bTI03ZO2xst1zIVBMACOQA2G+SfiBBcfFb41J4d0gyXlvBdweH7LyxvDpayIt3dFUC8CZZCdgzI5JO4rivqXWpYPhP8ACS6m+VL2w02UIyNg3fizWISu5cDJfTLG5toEdSHieVlwTG7p4F8F7qH4bfD3xp8Z9YEU+u3UD+G/BUV0d0txr+sCd59QhHzF102FvtUjqAUcKd2HCn8G4mxcsVio0Kjd6kpV8TrpFtxlZPvqo2T2duln/nlxtn2Jx+ZZpnSc6+PzHEPAZXSbu6lWtV9nCcbq9p1ZyqSd9KSbk3Z286/aC1/S9LvbnRNKkj/sTwNZpoNjtOY7zXDGYbi4jCbQ/lyiRtygECKNm5Y4/ObxHqDeTJuYmS4dnZzgvtIDO7HqN5BPIIK/3QSK9v8AiN4hl1O5FiZjLFaGSe9lJybjUp2L3MrsNpLRgbASOoYg9q+eZom1vWIbJQDFNIxmI5WKxt90k7/xbQyKURgxG8qMkNX59xFVXNSwuHWvu87UtZ1puN4rRJRguWmlde6m+59Fl+UwyrL8vymn79WlTUsXWd1Ktjq7jPEVJSetlKXJe7j7snez0m0+AWOji5mAFxqhFwVIxts0XZaRtyoCvGGmI5UiYHrjPKXczM5YMCSR8uCwZWK5BwwAyDzubIbnIAIPW+JL1fNdUwkajy0RekcarhUVVAIVEQADGVGNuFA28DJIrM27dkNtHXaxAA+8SQOck5TleSVKmvi8xnySjRhLSnFRuus1yNu/W7u7La7aTOjEtc7jBe7T91W0bty63d9XvZO7fd6Eg3f3jjgMN2GJwoKjYOBjHP8AskcLzTi+wAfeBO4hcZ3NsJzkAnCjL7uO5BHSPOwgEqUwpLF9xYggFFVdoBAVvnDdhgHJpGbj5eOnzbc/xArkA7R6bl3DIPG7IryHJvuvh22TsrLbRvy21Vzn63vfa1t3qndrbrZfLTe1mG//ALPuYbhAXWORTJsyPkdR5qnbt2q0RYKnmYyVxuTcK2jO2kazb6haocJLHeW7ZyDHIXcIyrhSrq23YWKggrjGVPPqFbuRhgCfvBgGUAkHPDbvvBeRkZXkHZ+W90xSGDzWREZck5KbWaPJySAykJuAUlgqkFcbezCVXGXKnaUJRqQ1avKLjpfp0a221VrnDiYqlWoYq/LdqlNrtKzpyd29p2itvi3sfdXwq8SWuoi78KzSf8SzxTY/a9NLkFYr1Y2byxnaC5fMbICvziMMDwRw9pby+GPHE2n3KlYbqZ7SZW4BSXKqQCuxguVZezDknoa8c+HPiGcWv2eF9moaDcrqOnbSwcwNKPtMYAO4mJl37cDJYAAYIP0x8QrWPX9G0bx9pqozXEMX25Y+fJu4sLKpC5AJZWPHQgc8ha+6xVRYzBYTMIWlKlGHPFatU3K1SDa3UZ8yd9eVxtfS3Hj6LwuLw+ZUY3p1LKrFbQkpJy7aS966e99dTNgjk0XWpYCWQLKQvOQyk5Vgf93ac7sbScjnj6K8M6gJY0Uv8rIFP905Zt2SMYUcDkkr7sCD4PqTnU9H0nxFEQzvbpb3m0E7bm3wgLDJIJVQcnO3GQCea7zwXqRfy1Y8gg5OCGznbuCnnnOVCkH7oxnFcVNLD4rlTvTqKM6e9uWfJJWVrtpPl11vvukfj3iZkyU/rdGLdNpVFOO3s6ijJettbrbdJt6B460x4LiRiu1XG5GwMEnJxnnKnoOuTxy3NeCatbsu/cRnOeDkkAdWOcMc8/wtjrnPzfX/AIts1vtOS72k7Y8deuASOck4yC2SRyeQW4r5Z1+La8gHIyy45IUAjtjnPHXu3YYNRmFNRm5K+qTjezuny62Vk5Le79FqfKcJ42VWUKdtYNQdu6sr9tUtl1Wru2eRXakMxx1/hxkAcbgBnBB6cnBLDBHfX0S0eWVWjjknbckcUUStK808jBIYo0UFnkkkIREQFiSAoycGtfBY2IYAcqMgBiS2FUBSDlunC5xwOSK/RD9gLwJoieOJ/iv4k0rTvEV14CWBvhX4L1iGebRfEnxTuk8zTvFXi6JIJFl+HXwrhI8W+KoYmE+s6yPCHhC1jaTxO0kXVw7ln9oY2Km3ChQtOtPbkgnFtW6ykk4QW8pNXP6l4Ow1BwWJzDEU8FgMNSeIxuKq3UKGGoxU6knfVyUE1CEdZz5Yr3pI+9fhP4A0z9nX4Ear8NdenttC8Q+LfDtl8Qf2oPEU032Obw54UmsBrPhH4LR6gpEljd6vojt4g8feSxuNL8Hz3NjAk9/4rghi/DH9p79oK/8A2gviJLqyeZY+DPD8cml+C9J2JaxWOkwGKGTU5dPjxb2t7qYt4DHZwoI9N0+203R7cmDSomP1r+3r+0NPrV9ffBDwrr+o6xa2etXmqfFbxRcTwyar4w8b3l7/AGjqFhqVxaEwXV6NVjF/4oaKWa2j1S30nw1aMumeDNPR/wAyLfTZrm5Szt4WnKyAz+SC/mzl1jW2iC5Z8SEW6INzPKHWMELIY/d4u4gnmVejluCjKGBwcaeFo0IOycaTiqdFW+Jt3qVZWbq1pSlK9osjHZxV4rziOeVKVShl2Goxy3hbK5t/7DlUJJRxFSFrfXsxaVfETtzNy5brWK67wb4ev/E2q2OmaZblri7kWOIEER21opBe4lbkIuNzSyNgKmeSZAp/pe/YF+CXw0/Zw+C/ir9ub4/afG3wn+Dabvhz4av41huvi18WshNHsoYJ1P2uGDV2tVG2OaGORFM0U8Wk30cXxV/wTf8A2GvEPxy+JXh7wQsElo2owx678RvEixhoPBHgaxmhe/mWYnyU1G9QHTNMEskcT30y+UWUyXEX35+0l8Xvhx+0L8Xj4d0SSz0H/gn/AP8ABPq3uLLSbWPJ8O/FH4p6HavA9+YiPK122068V7e3Yrcf2gsiux+0eLjj1coy6eFpU8MvdxmLiniZuzjh8Okp1I8104wjBOpVbttypq6Pg+Pc/wARiMXS8NMhryhmGYYaGO43zLDzSnk3D14NZXTqR1p5lnMv3CgrTp4eU5tctj5g+M3xs+IXw58IeO/jv8SLmfUf2wf2y7udrHT7RXk1f4bfDe/NtBFpehwbZJ9MnfTrnSvDOhWiiKexla0tkVrqwvtv19/wSk/Zi8B/CTw341/bj/aJe2tvhL+zW+p6/ZXVxGJrLxv8btKtpba/1LSlnBGraT8KluIPBngiFS66t49ubi/t2kuEkNfm7+zp4R+KP/BRP9sGy1/TUudP1bxjrVzoXw/8+NrzTvhx4L8PgnxP8QrwPsj8n4e6FeXFxbzfe174p69ZxwIZIGjr9Df+Covx38G63qXgD/gnH+ztMdH/AGdP2Z7HTbf4lXOiy/aW8Q+KvD7RqujXEtuWGs6jpuqXTG73ea+peO9WuppVkn06ILrUq0qrUKKksNZ08M2vfeHbUJVopautjKiai0uZUknFxaVvxfityzrM8HwJks4YPCQpQnnFahJQp5fk+EUIOmnG8YRp0F9XpQlJRlVlLm1amvk3W/iD46/bf/aH8e/tQ/FnV18KaTc2etX2iX2oeZd6J8G/g/4Pgf8AtnXYUfEdwfC2lTR6LosK/wCk+LviTr6W9ik15Mi15bpms6d8YPGesfGrX9FufDnwf+HmhWHhP4XeBZJS15pvg6KaceEvCEU4H+k+MfHWpvceJPGetgNLPq+ra9rF0Gtmhhi7X4uabq9hBov7InhezjtvEV7L4W1z9oW30yRhHpWpaWi3/wAN/wBn9LmMlI7b4eWNzJ4n+JD7lF38Q9Snj1JHvPCMRPrfwC+CZ+P/AMU/Cfwh8MXy6Z8JfhvFqXibxv42SMRWFtp+mJFL41+IUzYCGGGFD4d8DQTHDXs8MsBJu5Fq1CMNYQUrSjTit1VxMbcsErt+ywsWpTiuWHO1FrWJ52Z5tleEprEKX1Th3h7AOngaSfLGhltGCjLEu1nPF5rVgo0ZSbqOinUg7zqxf6Rf8E5vgv4gt47j9ozXtJj1D4qfErWb3wn8EdJntgLSHWBbNY+J/HS2zgCHwv8ADzTGk0bRm2i3+2Rah5UvmXUTR/0mfDfwNpfwu8F6V4WsHkupbeOW71fVZyHvda1y9kNzq2r30uC0t1fXjSSuzFyFZY0GyJQvz9+yv8LbDTNLsPiLNoQ8O2B8N6f4S+E/hN4tn/CE/C/TFjTSYmhddy654m2Lr+vXLD7RNc3aQTbvI5+pNTvAoYB8Y5AUdcAc8HOc/KM4z3BySfHzXEurNZfTk5qMufFVFJy9riG9pNbxpqUlu17R1Gm1yM/i/ivinE57m+P4gxbcXipShg6LkkqGFpe7RpxT25YKPw6czlJKzssvUr8Skj5gp5yDg4AZcEcY429eQPcV+PX/AAVD/amg+GXw+l+GPh7UBF4m8XW0h1Z4JT5thoa8mJih3I16RsxkFog5wTJmv0b+MPxR0L4UeAfEnjvxDcLBZaPYTzxxu4ja6vCri2tYdxy0kkjKox8wzkgLyP4pP2uPj9rnxY8eeJfFutXjTXGqXc8scXmny7a0Bb7PbIOQqRxiJBjIAxjJLV3YZQy3Bzxc1abi6eFjJb1HbmqPZtUk/d0+NrazS8jw54Wr8e8V0FWpynlmAq0sRjW7uFSalF0MJfVXnJOpUTvanFJ39pc+Nfip40ku5rkmQtJL5ikFi3U8ruGc8j5iTn14r5RvrlpZXMhJ3OTtyCST6bcnZkKM8kH2wB1vivWHvrmR9+cFsY6qQT0OBghsDIyAeAQeBwcRae5XPPzHJPQAYAOflAx+ZGeATXyMqs8RVc225Tnbvuo6+t+uj30tqf6q8DcPwwWGw1CFNKbjTVlayUVGy0tZX0/BnUaPakIJSAHkyoyuMbgD0A9iTyQ2V4717P4Q0iXUL+ytY1aSWeWKNQq8sznABGASzEYx83J6gnFeYaYgzGCMYA28nJOBtP8A8TgKcEjJNfev7HPw9/4T34teGdPljElta3K6jcKygr5FnmQgk8gMyopGBkkcbsV+t+HmSRzLNsDh7LlnWh7RuyShGUZzk+1oJ3d1tbZ6f1TwhlHtsVgcKo61KlKPq5OKdktEm2730uvu/e39ljwDF4E+FvhXRDAsdwbCG9vCo2s1zdKsj7u7Y3BGJBbHQMVFfbOlxhIN5BHygHODwVA6ZGCBgnkEcAmvHfDkEViIo0RUSCNFQKAEVUUKFGScEhDjoc44zivWdK1CGQbGPyc56d/lAy3BGM4DYwOT81f0VxK+es1Ri1QoqMacU04xjBRUY9LJRt2trbz/ALayrDUsJhaVJaKnThBLTTljBLRdbvVd7bXbX4w/8FadM8S3WqfDC/tLO4k0K1s9aie5XmCLUZHjdkkkI8tXeKNRHvYnIwvTB8y8TfBnwR8Tf2bPhL438IeJ/Dmu/F3xh8QNQ8IW3gMawreLvB998OvhdeafYajqeiyKkz+HdVt9Ih1G7eBHkt49QtHS4ui89ta/tT8c9L+FGqfDXxXN8YUs38Eadptxe6nPcvFHLAkaybGsJmUyLeysRFCsJ8yR3VArbyD+Vn/BLD4HfD/4yftSeIfifDpl7N4B8CXl3J4NsNcdb6+t7m8V7G0vLmfy1SW6t9LOI4blJrePzY2ETMiGvwji6uuH80hnlLFuKxkIwxOEpxUa8qeGpxptQutaT5YvXlftEo3lBtH8b+PnCawnF+UcV089nQcK7xNXA4flVepRVCGGrYeopOyoVUk4y0fNF2T3PxJtvhl8Y/Bmm678T9GtfEGneGoNe1LwzL400TTrPQ7aGSeSTydKMWpW8V9bGSJQifu1hjYSxwzmRZzHzTzfGTxhcQafZ+Kfib4iuJsLFZQeKfEN7PKTgJHHYaXJcIfl4ChOQMJuUA1/oT3P7Dvwi1a2MdhaeH5rN0ljh03xJ4fs9fjt4Z7ma7kto5ryR5fsxurma4EWFjSW4mKRo0km7zO4/wCCYXw6a4F5pWmeB9FmG4x3GhWOoaFJFnIyq6VPaxhwDtyy7gB97Kgj5KGb+H2IUJf605nl9KTVStg6uErSqKpKSlVUHFxpJu7SdpRdt90fGSlwRXhRr0eIMbSc1H2+Gq4KUsRq4uap1Y2oyVr8rk3fe+tl/EZ4Q/4J9/tX/Ez7LcaX8CPjTrcd6AwvZdAvmhZDj94bnxBHaIVyQdzuoIBHTBH0dpP/AARm/a+ZEmb4I+JrcsVZl1U+CYvLU/MTst/GFrOzD5soxX7vRiVFf2E6R+wjq/h2RF0/4t63o0EagJBp+p6rLGiA8Kq3E7N0+UbpXy3c8E+l2n7N93aRhdR+Nnj24VQMrbaxJbqwwSVBMkgIx32gHphsZrKrnHAVCtJ4LHVcxo2jy/XsPi41Iuyd/wDZ6tKLbevvLS9uiPawOP8AC2m0sZiuKsQ1a0qP1KnTfwq6jJ8y1u7uT7PVWP4wLz/gk3+1popYN8EtSlRcq5ttM0PUX2qQM4j8bv8AMTnChTgg/wB5c8vd/wDBOD9pywfFx8E/iKm0Dctj4C00YPPCyy6terj5SQ21wT1B4Nf25j4IeDLP5r/x/wDEXUWxkl/Fk8SkEZxiKFH9eC/Oc5xWrB4H+F9goVr/AMXXbqeBceLNbYnbwQdlzEp5HPHOcgdGprizgmkub+ya2I1S/dRxVNJe7e3PjHbqryjf8jqrZh4OL3qWG4uqbSalWwCfN7rabae927/Je9ofw4R/8E8/2lCQI/gx8ZJW6FE0fT9LXBGD+8j0GdQBjkGQYBAwWC46Kx/4Jp/tQX5UJ8DPHi88ya34qh0+PnP3lSy0/A6EhZcDPGQK/txktfhpZqwGl387YIU3Wt6xKp6DODebiSfXKkAj687ean4CtlZ4/DWjkpkhrmOW8Jxu4LXTTndj1ySBxnIpPjXhGTfs+G8RUV1aNWacXdxVrutKW9ru2i28vHqcQeGlCTdDhviHEJ+7F1sxw9JbwtdU6M9L6OyVrXP47NJ/4JKftIXpWS88E+FtFDN01nxct265OQDGNVuZDgDBJjAYN/eAY+x+Gv8Agi18ddXZHfUvCWnAD72laLq+sSRnncFuI9PihYrzy92UToSeQf6d9Z+Nvw/8FwS3d43hXQreBS73Eq6bYrGq5yd8ixsNhHBycZJOcDd8RfF7/gsJ+zb8LVnsl8Yt4x12LcltoHgmNdauZ5+Fjh8+IJYws7/KDJcna3yohJAqf9aMFVkv7N4Nw9RzaUJV69aUb6fZpcib5rJXlrt11xp8R5HiJKGV8E1Ksm1y/W8xxOIi9o6xoU6SeulnJJ3t1Pzw8Nf8EI/G1/HFF4n+IN7bRMwMsdrplhYgqQMqsV5q90yn5Tt328ZQ5bGAVr0e9/4Iu/sl/CTSZ/GHx8+JFjp2g6VEbnUb7xL4w0zSNOWNBvkM96YNGtbYAD/Vqb2WQnbAVdg1dlaftd/8FDf2qnB+D/w/0P8AZk+GmoEeX8SfilbXGqeLbnT5gf8AStC8LyLG0tw8Z3wO2nxWRJG3V0BpPEnwT+BXwW0W5+Ov7VPxE8S/HnxT4fzenxp8adSOt6Xb6qMvBaeBPhq0reFbC4lnAXToo9O1LU43Ak/tARozJ9PleX8T5k1Vq5ZlGTYdRvzPAR9qoqzk067qVE0rtTaUWtU7rT9AybhXibNofXXkuTcNZfCn7SeMxGGvKMFZuUPrM6srpap80Y6Xumk15PoXh79k3w3p19e/sffso/D7xP4a0eCd9W/ao/aE02bwT+z7oUdoH8/WNLv/ABFYXfxH+La2hRmjtfA2laZpV3N5dv8A8JVbLKLgfInj79oXSfiRe22seNfH2s/EP4OeENQ1/T28Rx6Bpfwq8EeLdd0vTzNqHgv4AfB7RZLvQfAPhfSNPSy/4Tn4veML7xz8TItPvLbTrDxJpGp6rDYL5b8TPjF8Sv29te8T+K/Gusat8IP2Ivg9jVPErW8uy41uK1dU0vR4lGyDW/GmuyiKy0TRbdDpmjPcLKlq06ln/L39o/406n40uLDwd4R0F9CtdZtdP8LeCvh/oivPH4R8BrehfDng7ToIozJcav4kv5E1vxHehRea5rN297dvLLOqryZzmlDBQlTwtWpjnSapyxc7JVajtF0cJThZxhOfLTlO657NRXKpM/MuJ+I8Njc2xXBvCeLr5jXw3LHiPiWc1DDZdRkoyeFwFGHLThi68Ly95zdGk1OTi6lFT950zx146/4KG/tZeFPDyW7W3hZb6x8HeCvDXh60ay0Dwx4fv9X/ALO0TRvDmmIqW2nf2jNNPqN3cuqPDp8F1e3cnk6VMa/ZD/grL+1RFZad8PP+CaH7MbLLDpWn+F/C/wAQR4ek2wPJYWtvF4e8CiWDBe3s1/4nniaRmGbh4obgK9u6n8vv2bfFeifsD/CTxN8bm/s7Vvi8YvEHw8+EMQdJ7PUvi/f2DaZ8SfHUEqyFL7wn8FtCvG+H+iXUSzWut+LtW8bTW8vlLBLH7L+xR4Gu/hf4Y1n9tH406ZceN/ih4/1S40j4NeE9cuRDrHjrxt4pkvbmK5uLq7ObO31Bxfa74i112itvDvgvTdV1u5mitkjEnl8O5RVxdedXGzblKDxmZ4i1qWEwMEoxhFttKrUs6OHgk23+8StZv8XwPhpQ8VvFzK85zduHh54U0ZV6U8RJvD47PpKniMdjas5tqrDAU6dGlScrynjpVI3vSqQl6L8Sx4K/Yo/Zwk+BelalJY+Jdb8K2njn9pHxvpUqWet6Z4W18S2+hfD/AEC8LBrfxp8XrmG58PaAkJafw/4JsPEPiswC2QXcv8y/xd+Ieq/FLxlrHizVEtbMXMkFpo+lWMRh0vw/oemwRWWheH9Jt3H+i6bpGmxW9lbRBfmig8xi8xdm+pP2yf2iNU+LHjPVtGtvEp8VabbeJNS8QeKPGEMUlvD8SfiHd+VBrfjKG3dllt/DOnW9tB4V+G2hEJBoHgnR9Oj8iDUr/VXn+FpW3p5jqxQXJ4BOfkQMxznfydrrwFViF4KnH5/x7xLLOsb9UoJ0stwCVDC4eD5aVOlTlFQSSdm3dyne6lJu7aSt+75nmCz3NFmihOjl2EovA5BgWuWOEy6Lj+/cPs4nGtRrVpaNRUKXu8rvFIkf2KYgESGC2OS2W2i6QMQFwyqAybwe+AWGcHnJJHVggAHzYPysSCX9OQMqowGwVPYRgg9Lu/c3nQlbEHG7BUrfWqkcjpnJz/vbjgVzLAmRwAWJyWHzEEhgpUA/IFxhgAMAAlOSBX5nVcXyaO7jZ2el0781rpt366u99dzilOPPVi94uEVJa2fJDz3bSTerV3q7WK0gAdQuMY2uSW5O5Nv3eA+3OTnjoMqSFrbslvlwA2wqfLLZBjz35UN7jkAfKcZsOVLDb/s4PUclNvGFO0nqQG6N05zBIu4fMcsMBRkBSwAUdMs3y5UMOQAG2k1yTu3or2a00S0ce17fzbPZ62teHbdaJON720lZLmXa297N693Yj3bw2zK7Dk/NuZnQJnG4AspBKrjJZgAwBGSB9pA+VWZQMYIAzhSMHJIGAQ33l4JHBpruoUlwwIbyxlWIAymXZWLZAwSzlkfGEIJwKikfCsE+YAAEZBUhNhYdQuBnIKthTnCkcDBTaVmtlzaXaakotppdWle3V6WtYUZcsb30Wjav15Wlo09Nd99lsiRlJQKpCSMoAZgoJUgYJByNzNjYyjB2jGCoYaU//IEtD5iNGNRuysRLlvmtoTvBYjCsyNsZRk4BYEuSMUj5E2s/ARyATuIIwwKpkAcKqMCQGHAUZWnC7EpS0eW4ZY2kmWONsRQmVUV2MkibVLYK7SSNwRCASBTU/jutZwUbaWavB7XSupWu7Xej6Nm9OSimpLSUVazjo049LpJXvolFaXa7OkKrvZgduWOWA4UFSTkgqp4B2/MMnIJDbQwOcIwClORIzbSdp2YAIYHrtBZuCSFJ8skqSQgqB5s2CwcBZEJQZO8NmMkoDgkNzxjO3ioWjVmQLLdK8QBX95bAMysfnciEncQB1PzKGBOeazcmk7x2S1ut1a3kr6JJW6pdRKom18rO6snpbW6to9G9Ntr3JWlZBzgqzMhIyBGTsOSSwUjYpDKMggbhwKVZcgsRhwwRcHaGxjBxluwJzwCSVKhgKpFXLf624UjhSHgJDrj5nUQ7SScMdwGM455BtvbBYzI9xcZCLwklucuxDYGYMYOdwK/KvzZATJqfaSV3ytWT3kmmk02ttX2vdrp5HtYp7NLbolvHTfS/3JX0tqThFYNnIJwwHIAYkZHAUKGIJGCcYBXDDhxOc5IGMgHPJICDHdiQFwoIX0bGKrPbhVjMd1eMflaSMSWwBQIS5QrGRliAEwPkwzYaNgaFjchwLi4RCzAK8kG5ckbMlk+76DJ2kM2dwwWqjt8DWunvK2ije1tdVqtY2eunTRtS6NptL4opq9nZa9N7r7NyzJgJyQHGG+/gsARlSWxy2whjgjlh9/5jRlJMvmLa4hKlBMHUSxtIxLkqHUHy/nQIwMh3K3mFWZElMDHarT3WR8wy9uBjGQVHk8kls4zgjA4JYGP7Nht/2qcL3YvbYYknk4hXgjkYAx0xkCofNK3utWenw315bKzenS9ra2dlrZNSbS05U1azV7prWzd99baO6vdIckSvuTgAIQxDtkHGSMYILYzkEkLkuoyuRJHKkEiQJF5jgoC+9ZQoyqgEswLM7fKQhCDOWAc4FXyrnMkbPMsSqQjiWFWnyAoZSkZVXyrsxLKcgLksFFSQxHdGWnuwqupdWNu4B3LvXDJ8yg7uWyoIUtnJAxcpcjtGzel3bT5drLR72fVEyUuXmTV9NbrmW2i0u10TTv5q6v1G3IUbiNoVsryM5Xj6EnJ6A42jBKsEIMgO5sEjKsCVB+6ByxOASvDDrwrENk0ccgg4GNuc/e+XGAWywOQOAOd2FDc0ibjjIcFflUEc9RnOTkAMcAAccjhjULo+j2dr30W9rWvpr5H5U3omm1y2V2+jst99Wn+HTQz3gYmUqZFWSQCZhI4DlCwjVR95AW8tcoMjC7eCUq9bQx28UcaDaUGACSxJwgOckByTyCCBgkNh1xThuOSy4GAwYgE5JXDZPUEEhcr82cMwIG5wGWyc7gFORuICfJzk7idwOQ3DMc5xgmkoKLve7s++mqT625dns9fM1lVnKPJJ2i7N2XWys3tzdUtNFtdJkgJbcFI3Ac/KWVW42k4UMcMo+6Q3JGccCN1keDAKxyGLbn5SEYgA8bcE4XOM8ZwTkHD8k7h8oyo5wxIzwXbcGzknj/a6AipFXAQDJ+UZ4PyghTnGcAk4wBhScgEhudG3eyTXMmkl5W389dL73trdGUWoxTW901snpa19NVqtLdNWhrYwAoAwR8i4B4ZV24UHOMZYE8fKc7Q2K8kfG+Pqow+CoyCVYltgbBUH7o5x8oJXAE7lUDSMfkUb2PzEHcV5CKp2gE4GMkEZ+ZW2mJXZxnyyoKljvUBxuC9FVsrkhiMElgNobac1MlzJptu6slu9eV+ad2tn5X2NqbtqlaKa5m9nor+frZa2v2ZWiUjG9llXcVDhAGyyI2xwcEqoLAcAnoDwakbYMliq+ZlmdTw5A+bftIVmORwgADAAlDkmkrrGRayuXcrIVJBUyJnAkLszAPH82VGCMZA3EZsylY4CWZY4kKuzOxVBGgP7wswZTnbn0bjKgN82EX1SVktbtPWyburdLO1nfq/Lpmm5attzdoKN0nGXLaUbd3tbV2s+hFlxvyiqVO1F2jaYsqu+STLBVxIcswBb5QSMEtkoZ757lIJU/swSsHmBVZrxxsdooG2I6RqBhgFxtyybi7AIPO1WVNolh07llyCkl9KuxiWKoStsHKvtfAYKVQl/lXSmd7GBTagK/MEKIjbFeWNSCoZJFSJAFEvCuxIZnyGes1+8TbTUI2d09aidnZd46721vbZnSkqcox92VeXKknrGlZrWTe0rK7b92Cb6vS5brGF2wxqIxtCJEDgMTgbii4JAPLNwW6kdpLiXUI1a1ttOmcnLC5a5t45JUxuCxgbmjieRC7nKuynCklsVm29vKAryXJkumVN8m9zGfmHyxJHsURH5FJCsCqgKFjJAuiSSVVaFxuP7v5XYq7Jy0ZjXLKxYhVDEZG4rlcVvGUuXlacE7cqi1ezte6fNbfe2l7dNeVxhzKS5K1n7zqOajF3jqnFxb7a6NPaxXS61kozLobFIoipIvFZQoCE/dUjcDJ8zAEdnwRmmwvrRVnGjb1Ls/m/aFQCNdoCktGFZU6/KCpPbbkjoWk1BIUi059IjjWEGU6glzLcySnYJlykkiCBWhbYu52Ckk5LhAf8AFQlnYXfh7DQ4fNnclSBlidrsxblWG8AqzDJYqM1apybacsQ0mtVGla3u3teSbX811u73JdaDSfs8HC7+GU8TzJaXvy3tvdWbtp3MBIdZRsnQVZpQ0hZb5FV12bSPL2qjKcMQiALIFwmACaabTVWfzJNCCTQwPEP+JjHHH5TKUJZEWPezuw2vwpaLG0hGxvLa+I59yNe+Hgy5AJs5lbCAFgNxVlUbvlVuSWLFRvJNdBrdvM4MujFlLSvItlLIruBlgh8xVZTscYGUHzIuGZVByLR/vlBWabhSvf3bdXZtWd+yVnfa41k20pYJSVorlli/hairXuo6p62TtZXtqymJNXi8qFNIUReUgDPfxNPvUfvG3EcgBcnKklF/dn71ON3qSqpbRWKglWZLyAqCCARwvQkMdp3Y2h8MRhrgm1qL5DLphWQKig6bNtPYqR52BgBsK33lYkkBiTKZNRfAJ07JQMcWUuW2Z8txunbgEMw4zk/KAdzGkpJK7rKyVrxg9fd0urXXRJ993uc83DSUqeEab1cZYhc213d2TezdtnujPWfVvkU6PnLrEWF5CSeQVbOzA+6zkr83yknB+U2MajIxV9MDKWZwVvrfDKuVwMLtVSFY8Lg7FbbleZ5F1BxGjmyJUiRQsFyCGV23ZAkDMWbAaNyy9QwLFiRYdU2v+9smMm5nDWt07bgoXc2ZgwHJGecE4wRirjCbbbdRq6TVo7XjvfXSPTV9Ntpc6bs+XDRaknvWaurO9uZt2s0nawyF9SiiYPpSS7gAJTqEJcoVVFVmaM5CmN23cMCASFBIMpnuIAHurNoYlkYSTJNDcbUG1g0igKyxgKQ7rlVQDKhQTUrxaptEu2ylMamQwpDcI86qBuRZJHKs2CzIWzuctkdDViGdLhPNVSNqGKVHAWSGVfvpMgDEYYyKSTh1VSDjo4xd0lKSas1GUYWez3SSd9L6t26/zZXWs/Z0pK7UpU3O8b21SnO60ejlFxv9prQsJ5cibmYNEwLoUOVZRuwysidAcFV3Bc8nkAjTghUqmGPKj5iSWBAXl924ghQwYZyPmYEHhcFIBYzeYhdrUgvNFgsLUu25p4TIyqITkGSJUxGW3qoG8HfhkDL5isChIYBCxTy8oQcoD2Py4OUJAOR06qWvNzJXVr9/s63dnZayXbVR134cQ2o+63OM9bv7NnHSS3Tt0vqtU9jSgUNEFlVCHypBKsjqQqqJNxLEuFJIIGD14JqSCFrGSNAxa1m+SIk7zaSv92FyxLeUwz5TnDL907hjMlqAyKVwVIBU8ZbJDAsAAFI3E4zwGJHUYvFcJHjIDXEIJ4xjcD0bAIOAAR0zhiuQD3wWkb2ule6SvbTe+992tvS1zyK1Vrmi7OLl8O0btJp9Neqdra21u0tGG1jaZbkBo3GY5NrMqTgFjGZhlAXQ7NsqqCeEO7pXVaXFHHpZcLkNqIwNokJjSHIyE6EAk7lLAKPlZRlVyLNBvI2kMxbndlVXcBncecg5VSAcgcY2nPRaQJbeBZZQJ4JHkEca/ObaUKkZdlZkRwQkm8iPq45wBXoYaCk07OKd1d7J3gnJpdnpour0PkcfinaSb92LXKk3eWu0WmttUknfRO17HQ2GH+5g7WUNuIVtx8vI+bLYLABsjCjAbaMMe20u3jSdctueUgAGRcFh5WAg3AKo+8SwXIyAcYY5Gl2qStujUbdu4FPus5wwAVAAQBgsGJAK4BwVA9B0bR0aZX8oFWZHO5OpAyAu/qBkEqDzjGR8oP0WEw6ajpe7V/SySd76K2mlr76an5/nGNjCE3ZxjZ6S3d2rbWau3r01V+iXb+GrLDwJ5sTM3BBVSy8pggqQoTgqiYBLcHrkfVnw70WW5uLaOFPNaVoY4YYojJNNNIyLGkcWBvd5DHGI8F2ZtildwJ8a8KaKZpoyIwSDuJwuTyFIOcsSSM52sW2gZGAa/aj/AIJi/s8r8UvjhpviLVNN+0+EvhWln4o1QPC0lve+I5JjH4O0dw2VmZ9Rik1maFgQbbRpo5FxMAf0TIsJFKVeppCEPaSctEowintdeS3vd77H8weJvE8MvwWJq35pqMoUoKXv1Kk5KNGmkrNuc5Rikk731W9/6aP+CWX7LcPwn+G/hHRtSsohq2nW6eLPGsoUH7T408QxRytaM/PmpoVpDa6VCCflGnxyjBmOf0U/ae8enwz4MbQbC5jt9T8QE6dA5kCfZbcoft125OCkVtaiV2k4VCUYEcBu7+EHhKPwF4BsxdIIr+4ifUNSkY4ZriVQ4VjznyY9kROBkRg7RuJr8K/+Cp/7UqeEPAPjS60rUPL13xZJefDjwOkcoWWC1kiVvGWvQ4LFUt7Nzp0U0fKzXNuflOc/nGW058c8f1MbJe0yvKJxVO/vUmqM7UkrqzVSqnOzWtKLW6PsOJquI8Efo55bwrhWqXiL4u1pTxsl7mLorNacJY2c18dOOXZdKnhb3tSxFRztZyv/ADw/t3/HOL4ufGHxVqOlXjv4R8OFfCPg+Mt+7bQ9Hd45L+NDt2HWb43eqySdT9sjQnKqB+lP/BPL4f6J+yp+zF47/ao+IdlHDqI0dPF0dpeoY57vU720ksvh14ZiEhOZFs9UOszxxMGhl8VWbSKJNKZl/Ib9nX4UT/tC/Hjwl4Je2nvdAsbpPEHixLcOTL4f0q6t9ulKY2BW48R6lLY6HbnALS6ksuHEZx+of/BWr4vQeBfDHw8/ZQ8MXsCHRLW28Z/ET7EUjhuvEmrRPLp1jII1RRBpttNPd28JC+Vb3enRAAWiqv7ZmNWKh7O9vbxdNbtwwlFQVeW6t7ZShh4tv/l7KSd4u3834bJearw/wPlqvTw8cNisyqUrK0veeGjPS3N7SnXx8otWlKhSjKyqq/4sfEvx5r/xQ+IHinxx4kvJdQ1vxTruoazqN3KxYy3d/dPM0UeSCIot4hhj6RwoiIMKK+1P2c/hzePDo2mWtpJJq2u3lsWiCEs091IiWkIAOWKh/MZSMrhgSRk18Y/DTwy3iTxHZxsrG1tnS6uWOSnyHIXjcvzMOMhcktkYJr+ib/gnb8GR4k8a/wDCX6hZ79K8IRxywGRGKyavPGVgRePmNpCrvsOWVyu45bjy8EoqVfH1/wCDhoSqPs5K3LBdOsYpX629f3vifMKXCPCU6eCShiatKllmW0Vo3UnGNKEoq+sYK852d1TjJtW3/YL4C/DWz+Fvwy8M+FbaFUmtbGGTUXUDM9/cKJbyUknJJlZhkjIRU9AB7BI5AJ3ABTntzliFOfQ9BzzjrninhRHEuPlQDbgY5GAOccAZGBnlh0HXFKWQAEMRuILDn3GepJwOhHJ7k5INfEV688biquJqO8qlRza3XvPz2SSS8vdR+KRhHA4CnQbvNU1OpJtt1KsuWU5ybfxOerd27t38s+6kPzcjdx0Oe2QTnHA6c8kZxk4xzN7LtRlY5IOdwJBJJBxjJIIY89cAdckZ17uTAP3c4JH1PIB5OeOSeScEnnpyV3PulO7Py9iABnHTnOTx25OT83Iz6mDop+9y7WdtFro+2u2nZWs7o/N8/wAbpOKkm23bXW7aT1WrTTd10302Oc13U7fSrC81K6kEcNrFJKzNgACNXIJJGMEYPHOAAccGv5fP29vjtL428a6xFBdl7OzmmtrZVf5QkWVyFGByc44I2j1JFftZ+3B8ZoPhx8Ob7Tre6WLUdSgliQBwGRWVg5OCCAM8dMnAIIbj+Sv4weNJdW1G9nlk3vLLKxdmGSzMSxYj5mOOozk5+U56fU1qscuyt1Gl7bFJNWspRpR5eXa2snq9tr7Hv+DfC0894gnm1am54fBTVLDppuMqzlFzmtNeWKUW3azvq9j5t8f+ISPtUpc5YuCFJPy5bHOQMHAHbaARkgkV8oateNcXMkmerMRxnu3cMwxk4Ge47YIr0zx5rZlmeAOxJJ+6Sdw7fM3PJJ6gZznBbgeM3EpeRlXcNoJxn15O04+Uc9+D0IOMV+XYqtKrVk3rFu+94tt3s7/01v5/6f8AAuSrD4Wk3TSclHlvG2j5bPVrqu2rb73VdyWkGckk8YOBkknPy5B3DHylT64wRXQ2MXlwovALYYjoATgYOQoyWK46ds5ODWJZxNNIHJJXIJBJBAyMAZGCc4GM8Zzmuotly44OA2AM4OCcE4z/ALWQvzYGGJGCa9LLqDnJTaTvZR0Sb1im9dPla+mr3t/RPD2XuEIykrN2ir7K7jdq/wBy7XW6NvT4BuQYO49CQGIXjqOQD3x/FnaOcY/Sr9gf4Kv8SPiro011bGbStHmTVr9mTchjtjuhibOARLMFUA8MASRnLV+emi2DXNxbxKCzSSIBxyADnvkkY4BJBPJUHpX9P3/BNv4Mp4L+F6eLL+1EWo+J2SWMtGRILGIOsYUkKB5jbnyuQcjgcY/e/DXK40auIzqvBOnl1K9BySs8TUSjQS6Nxd6llf4Xoz+gfDnI/r+aUZzV6NG1Wba00cZLSy3k1F33T9UfoorWHhvQZ7y5aO3stLsXllcjYkcNtCW5ycBVVTnkABeM7hX80/xJ+IEnx8/aZ8T+NL1ze+HfCVxKmmW5zJFKljOttptpGvzjdfXzRLtXLNmRh/dP7D/8FEvjIvwq+CN9pGmXQg17xju0u0VXxNHauCLqUBcEARkrkbQcnGeo/CH4dRjwf4Yvtd1LeJILf/hK9UZslprq5W4t/CumHccvJt+2avJGTlZn06YEk5r0eK8z5MPGk5S9pUvjK0nZvljK1CE9n79S83a2yd7Ht+OfEjw2WYXh7B1FGtiUp1kvsXajHmW6VKmpVHey5nG/RmH8f71/Fnijw78NdOmZ0tHN74guF5iF9dO897PIykbxBAtzIrsFYQmJGydu35l/aO8ZR6I+keANKMS6b4It54GghcyLP4h1AR+bLJsKh5rW3+z2zsu0q1vKAduMfV95oF/4A+ER+Nvi+yJ1Tx/4hlm0r7dFteTStLilvZEsy5YypeXS2tmwVR5cMQZnUfLJ+U3ifXLjxRreo65eSM6NczXdxMWLC41GeVpiwJyGCK+xcgDCL03Fj+M5nWn7RuTaxFe1Ru+sKceWSum2072nJvRNKK6n8V5Ly59xKsZScJ5VkdSph8G1dqeNp2hWxDd7SWH9+mraObk1eyZ5/rt68UBR3Y3ExzK7cli4BkYngnGArHsBwdxNZfh+NbbTr/XJlZZtQeSzsegZbG2bM0i5JAFxcBYywGG+ynBB+9katLc6lfx2luS817PHZ26A8CSZ8OwPHyIjZYg7gAXbjatbviK6t7GCHTbYgwWVslnCM7WKRJtaVgACTK6NI27B3sxcNxXw9Sv7SviMRJ3jRUoU9X71Rq1/PlipO/Tmg+iP0fnT9viLO38Kldq7k1FSnu3flvfr7yd07W4HWLks8nudu0sScE5bB46YIU8nG1csSaxIjGgG50XcCArMIyyEKC3OCBnJ6kh8LwAxMlzL5s7HIIB6bjxyC2QM/LzwCwBwckgADP2sZGR412FWCNlGYjAXYyMWw/yswYMDjpnC4+SxFRzqOTvfmtrqm3y39bbXfS3ouDvdvVpu7u09La6qy6+VulmXllR0DxuH3S+WW8xQnIXPfKkcBWIGc5woK0bXYDbjKsoyBjfHlW3FxxtYnovyMobc25s1lOkBYq9sMAiIMF2rglcOpYqoyVyzBPlUMVHmHJui0t51WJwSqxsgVHlQHjOThjuKHDKwX52ySMmuWV9Xpeydtd7x33Tsmu+vRag4pbPaz2Ste2t7p69Xfy3LQYghirbPuAAEZ5UIwJUEDONoJBUgZAyMXNNu2S+WzZgsd9A8ZLAjbKnEY+6MElWTcSdxbKsCeMGOyit3YxXN3vC4WNp3mAdQmC8cgyDgKpLErjJIIIIbHaMJUvTPM13G8REyZVSYQ2YhFE4QbsjcyjbgAtgDJUKkozhKMXo72TXw3V7W1d1u+7ukZVqSq0ZwvdzgknbVStGUZeVmk73800nr3ej3kmha3aagqskay+VdAnO63mDLJkYAYhHJBJOWVG2gjn7i+GF9b6pp2veCrtvMt7+B73S3LAqHC7iEyAOQQwAwvyMzbskH4audtxDHd4KLOilgRyN+47ip6FWDcbj8u1R0Kr7L8NPFdxZTaXeB8Xeh3SwzZYZktCx8sNgjcDHviLADgZUktgfe8PYqnyVcHVb5Kqc6e9uVxjGcbPe6al5NXtd3OfCS+uYKeGqq81zQa1Vn8MuifZp6aq6T0T9x8K7gniPwZcYWaPzLqyWXgiWAkEIGI+8mDgZBAOFrQ8JXJt7ryZMgxyEYO0fMCT0A6ZAJBHJyRg4zR8eg6D4x0jxdp+DY6nHbXZMbDY0dwgWRSORt+8rZPUg49dTUYksNXivIgPst/FHdwsmCuyUBmCuADlSxHG0KdoOCfmmpFwcoNpTwVZ09V706M3F05LTaLb6WT06pHyGe4P8AtHIq1Kcearg3Oi76yUF8PM3ryxkmmlqe1XmqebpMsEmB+7J3EAbcL+BI4yCAOSckNuavmXxLdRwyTu5AG5xjI5OSei56MAD2HBORgj06717yNPkd5BjYRnPzfMhDd92MAZyBtAO7hgR8t+Kden1TVPsdmGcySFFjTJL5YjOFwV5K9PmxlVydlZYzEJqlGPvSulGz97VqyWt7u9krfckmflXBPD1bEZhWk4uNKE9XsnaS08nfr0vfuzZ8NaFeeM/EdnpVjFPO89zHGRbqHmIdyoWGNiEMsmGEIldIYyr3FxJFbQ3EyfpV8R/iBZfsi/BvSfCvhma3h+OfxM8OK+lSW02Jvhx4BLyA+NpnkiSWyvtXnimPgVJlgvNQ1aC4+KN/bQXGjfDqOy8o+Cei+FvgH8PNb+OfxKsor8aWbew0DwxcSPb3PjTxlqNo15oXgS3KYnjs57ZE17x7dwBJdE8GQxWwuYdS8SaVbX3wf428a+KPiZ4v8UeP/Huqy6v4l8UakdY8S6mVWFAW2pp2kadaxjyLCxs7aO10/StLtUSz0rS7O2t7aKOCzSOL2J4r+y8BTwuHaWJxKjUxE4S1pqySi2ndNRbai76u+nus/YcZjP7QlDI8PJLKcvnCpmtSNuXH42NpUcuTT5ZUMKrVMVbSdVwpNNKoo840bu8Ity7Xd2HXTmkLb4YnZ/tmr3DSFyPO2TCyZy0nyT3S/LawGb6//Zg+B+q+MvEmivp+iX2r3V7f2Fj4X062tmmu9W1O9uE02xmhgAYyXV3cu8ehW4DHz/tOqNmCASz+SfCz4b6h451aMTwMiXLwG9MRWFYLRxG1rpVoT8i3GorGkKLJhbaziM8o8hbk1/Xd+wt8Dvht+xD+zN4t/wCCiH7Rdja2Gm+DfDl1J8GPC12qQ3OratdwLpVlrmnWc4DrqPiG/WDw74FSRXltNKjufE91GI4oLk9uTYalhKSzPFxbmnGOCo6N1K02kqjT2UbOTdtk5NM4OJ+NsJwXkk815I4rOcTJ4HhvLIrmni8ylGMaMnGLb9lRk4OTS30XvySPMP2hrnUf2DP2e/Cf7DfwOuLS6/bR/a7t7eT4seLdOm3P8OfAM9pNa3UUd/ArNY2Omaal/pWl3LMqx2lr4j8Q24IbTHP4eftN+KtGhtfB37GPwX1EW3gHwAJZPH3iSHlda8S2kQv/ABV4i1mSMsZoPD4+13UyNJJF/bc1lYwrIdMs8fRXxa+OXjDwr4Z+IP7Yfxau9/7Tv7Vb3n/Cv9Nud7y/DT4XXAjW2u7G3lxJp8EmiCwh0iExxSQaVD4ehT97eailep/8Ejv2MtI8ZeKPE/7SXx/W3034LfBGytfiR8T9T8SR7NNu9V0y0/4TDwf8Pr+SY/vrXTbWK3+J/wAT7dSxvFPg/wAM3ULS67eRN79d1oxeHk5rF4+Ea2NnvLDZfNxdLDvVcuIxrSlUWnLQUIPWLZ+XV6//ABDvhTG5tnOIeP4w4gqSzLOMQvfxGMzfE60sHSvduhhHOFDD00uVbtQ52z688EtY/wDBJv8AYLi+IKaONK/bE/a10ez8I/CLwzewCTXvhZ8MIYEutLuL+3cvLb6vYWupx+NvFMewHUPiJrmhaTcBzosiR/nF8LJLf9nD4d6p8ffFKQa/8RbnxDNpPwl0nWxHfnxj8f5YDe3finVlnEi6h4V+AFjqUHinXZbkTWWtfEbUtC0+fzrZ7wL23xT+Nfi3/goP+1d4q+Puu36+GPA2kW2saP8AC5tfDHRvhd8KPB0M9/r3j3XIW3xpJo2kLeeKtdWJGn1bxjqtnoenJLLbWVtXi8XifSfjF4w1D4s6jpVzpvwM+D2mWHgn4NeCNSd1uL/TvPur3QNEvNob7T4k8eaybn4h/E3UIm85LK6vIWmS3/suMlKMpcsk4w5m40XryRhCKjWrrRR9nh4RtC7vKeyu5X+Mo4TE5NlcsJjpSqcQ566Wa8T1It+3pU6vI8t4fpTb5lKtdQqxUvdpxrylNN029zwh4e1Xwl4baC5udR1X4n/FJLnU9e1e7ea78RWuk6/cyXN7qF3LJvvJvEXxJuro3QkY/aY9EmSNc3Oqq4/pu/4J/wD7H0XhLw7aeA9X09IrqQ+H/F/7QF6iFUk1WGFNR8C/BK3lU4a08NW80WveObaJjHL4guk0+cubMEfl/wD8E7/gZ4h8c+Nj+0F4r0xfEPiC48UDRPhTpGo26tZeKPipJEJZvENxbj92fCfwosXi1e8VFSzhv00XR4CgWdD/AFmfDPwBp3wt8Eab4XspZLy7QS3+uavcHN7rviDUZDc6xrN7JjMl1f3sskpYs3lhkjU+XEuJx+Mjl+GVal/GrxdHL4Ss50aV17XFSg9pyk7qTTftGrSapcr/AAXxP4j+tVHw1hq0XhsLKOKzuvSaUcTjPdcMEpKzdDBpRgo6JSTvFTjJvqbqWK0hW3iEcSQIqIkYVERFUCNEUAKoUYXAwuQcbTgVxd9c/eld8AA5LcAArksWPG0IcAgc9DwTWtql2SWQY243E8gA4I9s4GcDgcYHIBX8+P25P2k9P+CPwx1Cysr2OHxZ4ktJ7DTYlkUTWds6lbnUSu5iu2MlISQQZCCpypB8/KMHOvUhf3eZOdaq7OMKaUXKcm/JaJWfSLu0fzJm+MxGYY2jl+BpSqVsTWhhcNQjd+0qTcYxiktOVfFJpWjFNvZn5N/8FT/2sl8U67J8L/DGo58NeFnl/tOa3k/danrK/JJuKkrJBaMDHGNxG4vJgjFfzT/EjxVLc3M5WQsZGcbs5yPnwuc4wD1XHOOCzBq+gvjd8TJtd1XVLl7ppGeWWR5GYuZndmdmYlj8zsWOCDkADg8j4Q8Qau95cSOXLAsck+7HnJGC27HAB6c4wMedn2ZrE4lUMPphqMVTpq6tyxaTk9tZO7l3bfe5/oH4HeHceGsmwlOpS5sVWUK+LrONpVMTVjGUpNtXSi7Qir+7BKLehg39yZnO7OTwCR1wTg55GSRk4GOMEA4qXTY/49pBPTIzkDGSScZGRx1BIGOWrE8wySjczEZ3ZJGexABxuzySTxnjgHr0FowBXsADwPcZx05wSABycdDnrw4KPNVimtLppeluz17b9Hppr/bHC+XqDhPluopJJ33sves7brXe7ut0dnp0hR4yQDjBwOCc7ckZzuxxyTtA3Zxzn7u/ZE+LFp8LPH1prt66rCY3tZg5A3wTgrKqsWCq5AUqSQpz04DD4ItJ1TBIyRnk8jBwAeW69eOMKCCD1PQQ6+thiQTAbTkqGAY5+b7pIBABwSSQG+UkYzX63whn/wDq7jqGOhGElRvzwm7c0Wkpx0fWMmtVe2raufsuTY55ZXoYmnKMZUZxmnJpWty2e/o7e9fVOx/Vl4N/aZ+GniPTzeJ4htNPWKNXuBfv9nMeQCys5Ur/ABDDqx425VQQxb4u/bT+DPgTS5L+fxJDrVyEcw6dop+1TMUyNss+EghDsDh3kwB8oVmwD/K5N8VtW8oWkd5MlmhGIklZBIwzgtty2eRuBYDGOgrndX+I+q6kn2ea7cxJlVhVtqYXIAK8ZIyMZz15IHX7/OPGDJlQqPC5V7XEOHuqpWvR9o7c3uqEZqmlaz51J3d3bR/f4jxixWGoShRo0ZVVGyqPmacly2drpKKte+t3bTq/0e/a/wD25vFH7Q1xB4Z05X0HwLp1wZF0a0uHP9oypJ8s2pSgqlyYk4RApjjkZmUEnLfb/wDwTT/bZ+CH7Onhq60PxGbzTdT1G7+1X1wYzLHO7MxLxuCSEC7flBB9N3O3+d1NZLESBsEkkjOdpPHGARkn8sdMFQdq28QTQBWikIGcDnkHI3YGe3QZxgbjjkiv54zjPq+dY+tjcyftXXSg6cW40qVK8bU6Si/chHsk9bybbuz8E4ozzF8TYnEYvNaksTPEOKbUnHljFx5YQV7Rgla0Uktm9Wz+93wr/wAFOv2YNZjiI8eQ2DlckTu0WCw98fN2bDA9Mg4Y16cv/BQv9mlbfzR8VNNKhd2wXWSQF3cruPGCOwz784/z97bx3qMKnbM4AXB5YDDAkYBGQTgYOdxPHODnUT4kawq7BdPyOAWY5zn7uTjA56AZxtwc8/OywWUTlfkrQ1TSUlKKat1dP7ru1r2sfDvLsLGV4zrRXMtOdWXwaaqzd3Z3aVuquf3Y+I/+CoP7Mmmqyjx4t2yE/wCp3yEsMdNoOc8ggY+6c55x43q3/BXP9myzLCLWr+5ABYmO2kYdTlQT+pJ6cY4r+KW58faxMzkXMgzuyA5PB3YweOCfqPXnrkyeK9UmBDXswVieDI2OcgcjjJ9AOMgHk4rWnh8upaRpVGtFrUa6Ra+GKVumvfdaN7RyzDya96q0krpy06bvRtPfdNaaX2/sI8Vf8FmvgbbRTLpllr18xD7cQRqrYBx8x5xkDJAJx2xivmjxF/wWv8PQyTHR/B88uCdrXN4kK7TnG7aCWBxtYjdkZDKR0/l9m1e+lI3XUpBLDO9zxzznJxknkAcAjABBzTkvbiUldzyuT0BLnJBH3fmB6gHgjJxya9GlDCacmDUm7LllOUrtuK/mu23b5dHoj2sNleDjZRoyqNqLXNJ3eybspeWmmna97f0JeKf+C1Pj29WZfD/hvRLIvu2yTNNOy5yMkDaueAeMkEDHJOfkzx9/wVF/aZ8Z+ba6f4wGiRzAxrHo9lFHL82QFjZ0eTd82AQ+4nHDda/MHR9EudRmjWeU26ErwBlyvXIHRe4OeASSccA/rt+xZ+xxF40ntPGvinT7iz8M28iSW8tyhF/rTqTlLTcM21v8uGuIwJmXKRSA72T9G4R4AzDiOsuXC4bA4Smo1KuJrQ5nSp+7eSgryc/5Iycb6K+599w3wTjM8xVGjQwkKdOUkpVKkL8sG4u6vd302fS97Hmvwv8AgB+1V+17qI1Lxj4y8S6P4PMiPqOueJNQ1CeR4nJZ0sNIW4gEszqvypIIII9ylncnaf2L/Z7/AGIfgV8BBa6novhSHxT4zhAebxt4vgg1bVIrggb5NLtp4jYaOVJPlmxt0uVAxJcyNlj9R+GtA07QtMstJ0ixt9M0yxjSK2tLSFIoo1UEE7VADuwwWZgzM3zEl8E2fGPjPw58O/C+reLPE+oQaZoWh2Ut3e3MpRF2RpnyYskF5ZWAjiVMszuFU5Jz+8ZXwrkWRuFDL8FHFYtK0sfioqpWnLRzlGNnToQ1btCMWoaTlJp3/q3hfw9yDhrDRxOJw9CtiKVN1KuLxMYuNFQSlOUIyXJCMUnrbRLV30Mb4wfHTwV8B/Amo+PPH+pi3srSJ00/T1ZTqGt6iIyYNM02BjmSSRgFkkVSkUeTI2Bz/Po2t/G3/gp3+0Hpnh6a4uNI8A6fevcLZQySDw94N8NQMDd384J8ifUDAu2bULjL3NwwijIhiAXxn9o349+PP2xPjLBp+lR3z6IdR/sfwR4ZtzIyWdnNMsUcphQEPqOoDbNdSkOUViuQixofvn4u6npH7A/7M2m/AXwDdWiftFfHTRvtHj3xDbOPtXg/wZNC5v1+1KS9mZojNZWuWVhEL+7HzGB6/NOLeI44/F1clyuT+q0qns8ZiqT1xVWLjF0qU4/DQg042Wk2nJvlSS/kr6QnjbjJ4jDcCcENVc2z3ESwOWUaOqhCLUcTm+NjH3lg8HTvUhTlpUkoxu76fI/7cHx6+H1np+l/AL4PRQWX7O/wGuXs0WzKx/8AC2/ilhre51q/kQeZqFvDdJOLORzKFshcXiBDqFsqfEHwf8AX8jD4meJNZGheKfFdnr2u6R4iuIzIPhv4C0xJbbxh8X549oWO9SFpfBfwstMrJf8Aiq/k1HT2Euk2bT8P4esLH4neMZpNSN9H8IPhfbpqGvXVpG73mrS3NxHb2ml2IyBN4l8c6t5el6ZGPMeC0e4upI0trSQn2zxh/wAJl8WfF+kfAj4fadHc+NvH2t6LH40tdH8yTTNMfSIVi8KfD6xMY2Q+E/hZpLE6gqDyL/xGuo3sxmeGFx+fRwqxmIoRowdSEa0KOFpw1lisQ5ezcoXfux54ujQnZNRVeunzxs/hMp4WnkOT4DhbJlUxGbZvUbx2YSSq4jGYvESi8dmNepJtzlOpKSipXV3GikqbvD0/9nz4ZwftjfGy01zWrRfB/wCzN8BdBtLWGx1GcWumeGvAXhiK5vLLR7/UJgsLanrDQXXiTxtqzYknvLzULm4Yv5CnI/4KG/thvq1zDp/ghpdDt9e8Jz+FvhdoSRGwl+H3wN1NbeHUPFlzp6Ij6d46+Pa2UUyROiXnh74Sw6boxLyeKL6WP6u/aM1X4ffsg/Ai6/Zl0Ge2vtB8AW+i65+0NqUM8dvc/Ef4m65FBrXgj4GRzwN57pflYPGvxQaOVn07wZYab4aklt7jW5on/m88eeMtf+IPizX/ABr4nvn1HXfEGpT6lqN04Khp5mUrDBEoEVtaW8QS2s7WEJBbW0UVvBHHFDHGq4+zyPD+W0+GcvqxeNxLWJzvGYd6V8VyxjHD0XG3LhcEr0KMVaLqJzUYuEWfb5pSweTYPD8BZN7uEy+UMTxXi6cuZZhm0lCpSytzWtSlhZSdfGtzl7bESjz398525v7u4DSNJa7gu3BschwoU7WxJzwGOdoDlmLjaW3Il7ERtu0WdTFNlYY0gP2h4yqSqJC4EIAyAQSm9mDHocyUsoUjJyoHBYjkjIKqMcbTnJG3jHGRVbeYy2ThiS6HqCDzwoJOMbiBj5iP4VAI/A3iKnM2pOTbV+e007Jb8193rtd3TZ5fM4e7BuCslazaVkrpRV0knpHRWtunqWFmmjN0ZPKeOe3e3G1nXys3CzLkByrECMKck7iASxGDWXNsAxgYKsR9wMHZ1YKTuJDMGAYDavAZAM5MxmA25dscKygNuLFVwVzgByu4knlOmTxtpFgQxXcBncMEZP3dqkKCoUjJALEA7uVAwOSTvK3Mm0rLVbXi1pa7Sd0r36mSl715Wcp2bb6t8q9XolHRq77bOJidwHlOrRgrjhl4KZwW5O7IAUgMdvzDjcYAx3OSrEAEAc5VtsZbcmcHHTAJz1BxkCWWVlR5FR5QqqZET5XUswG5TISoAGA275juUZwaqySTIoZY4VdmTdHndHEu0MzllQZI2kkhvlyAAckVzyajJ/ForJ7rXl6tvrona290y1q1tpdyS125df8Ag62s1Z2u1ZG3P8uSSwZlBQspCggKC5LAlt+QWznPIzVdlJbYAIwVBJYk53YLKNynJYE5PHXhgVC1Pgh2QhgrA8AAMWQkHYUZtn3QWBJyGwGzkFgi2gKCWCZ2nDj5CF3ADJZSSeSQBliCQ2DWbi7LeyST6XVktuqbuvK2jd7jV7LaySe6u7Jd7NXjddHa3kQeYfKfdtaUZVQANzGNQdmZcBlG1gTtBI+V1zwY0eZoIkhKQyLGXM4jjErHCqFYASEKpUbZOFKDDCQYJuKFIIUkoQCSFXIdVAA59AcYPLEEAnpTRglup3BipDFQSSMDgjOWJChV2kEDJYhTLg9bOWi6J9LXSbb5dU1ffTTa5SvpZtWvffbS66rzb0tpbSyKHkXoaRjqE7IYTlRDbp2GOGRlQLgbiFCnrnDbTG0d2QrC8uF+4h/d2/zZOScGMYU443AOuRuXa22tB9zMCX8tlYKQMkn7uW3EoxUsCCowT2A6U08At94g8DawfYAGJJdhk5xuc4IH3xuJzzexV+VKenV1JN293tzNdFty272Is73V3ZxV03pdq11a/K+js0/Vmd9nvBn/AImM3OZCPLi3EDdkLtXAwdpVhgM3ACg5phtNRKBxqkzZYABkUjYybmAJDFpNmTgglgoQHoa0vmQ5bAYuoXO8BhhRwQWClQMtzgkluhYVDIY4t7O0uZJdrJhmIYlVHlhXwoIb5sjgheykHOVCnZS5p3sm26k46Wilf3kvRf8AbyTtq5QSUW07vRvmtZ+7rdrTqld+ncgS1viFC6nKpYEEGGPnkBioIydxwBtAJIIyCMU37LftIIjqrDYCwAhQFRxs3HKhRgkkFggwgGSeNAkMSGU54cMPmL7cHD4OSDkkup5AI5xgPVfkLA7SwGQxyyqQBg45I+YEuTwcbRgYqvYU3JWdSyWrdSok2krJJu1+bW7SejTulraguZJXasrtOSVmlZJb3k9Wr+6tNNjOFlfliv8AacvmbclTEMgEccMe/wAoXkFmPGDSGyvmIB1SXPLFfJUcAYBG4huT/ewo28nPNamSgYLudipYEsSd20HMhbKBTs+6DhsgqcnlkHmFELnMg5fgAjOAAQGIUqEIJAKBVA5OKbw9JW/iu63VSpZK6036dL7dS1TgtfevbpN6NW3126rT9DNazu1VXOqTfMdn+rBBLbccqSdpDH5gSVByAc1JFYXXmJ5mqzRrvDZaJNpAZcEM7jcrAEhc7WAy3Qhr0cWGMhZnLNgr83EW4Y2sWVRgL8zFQOFzgc1a2iRQxIXbgq53DpsYq2GY7ics3HLYJOF5h4ak+bSpdR0XPPVabe9baNl0u+pKpqz0aaSXvSs1dx10bS8kt0+mjUQ1ubgjRdQK4IA+TsQDj5NuAScDPoOuacNYn5zo18ApBYfIS3TOTtz2YDGO2TkZF2MzNlxIHBKKVaCPHOwDPdcAEEsQwzuI2k1OWlHzG5UnysmEQQnEnyZxg4CMA2HJwSSANuBXNGNV2XtZ6u13Clbpba7fW+7XqfnknhouywtPW137WvZ6RurdN7JbWvq0jJ/tqZny2jagNh3KMKpJ+TqVTJGAx6gHJJGRkPGty4ONHvuM5YBOCQudxAJzwQSSRgcnJNaiNMAGMysCQo/0ZGGcLuIAPykDqDydwK9srumIIMgAB4/0dOnX0ACsCQu3arZyRvFVGFVO3tZu7i9IQaTXLrZN3ulqu19tWS54drXCw0sre1ruy0T7X1u+u+j1M0a26gD+yNQwQe0YPbcc8HAUMWB6KOy8FP7Yk76RqGRxkeWpyoGW5UfKQCDgEMMbVByp1g8hP3sADDYij5HAOVwepYhepHcE7aaHlC5MgIwXVWjjIBwACM8ByMAAAD5iVAAILUal0lWkttXGHS2r7XavtffpcXtMM2n9Vp36J1K1nrFaPotdbbrcyItYuCgY6PeE5IZdyAZAXBT5Q3CgjaFKjAOMgkSjVLvbn+x71lXglpYdyqeM5YdFCsS3CrypGQM3UuZcukgIZZFjDMINmMLyB1ydjZYenDKzA057xYim5VBYrGQsEa7mOOGOCuxssSRgpgbg3JMJTSTdaWlrtRguq6NPfuk9/Jo1jKkmksHBttbVatujet9Vvult6mN513uaRNLlVid53yWu6PJU4R9u4KyICEIIzwSUJDvSCfUG36gohtVyVsGcB5GVVIlu2RUDqGOVj2glhyBzu1FkLPu/0baCdqm3iBBOCuBuC4+ZlD52szYACnlgu2KRyi2QEkO0IVlcKuA28xPhX+XqyqEjdWKlmJqfZxT9+cpRbvyyUbSd4reO67LZu6s9baus7Xp0oRklGCnzScoXtZLmbs91zWT10d95NhVDsVNuGdESIDEYBKEOH2IEcAhc7V4P3uBixR6rYTmW2tpLyTDEm68m5guHeQGPCSTKiMUQAEAu8adlDFekgvrWHzGls4pQVY+YstwAG+RXiVQOMsv3ckZbe2FypWPUNNkM8cukQI6T7EjN5PhhhRGUYkje2QpUFsoS4AXhtnCM3GXtVBqzXLe6vyp68rWy8tktVdmFKdWm5r2KqxlyqfO4PmWjuvfi2k77fo7YQ1bxS8LRf2VZKrrgOun6eZNoVWCg7ycZTI2kliWBAYkUq6j4lV1aPSrVACWaMaZp3DMQ7EYYdOw4EfzYIBat8XWnFQG0gHaQHZLmdAuCwEh3RsMeWrknkuzMVUHguWfTFZ92mOG3E7xqDquwhVXLtCWI2ZJZWbO0kgbApFS2/wBpnzLl1Teik46J8ltN9NHez00LVaOv/CfQSdm0oxcX8N2/3z112tdP5mLHqnigcro1o0iqyLu06w8vYAcvy5EjZZiOvmAkdA2HtqHikKg/suARxzLN5Zs9ObKsSSCVYHYC0hCY2jG18YBG4l5pxU50ptsjOVY30oy54QEiL/nmpfzAwwWyeRzOt7pgdt+i+ZIqmPcmoXBVyAqjeTCwkkJLSKeEIOCg+arUL2i8XWT93W7VneN22qbul1Xo3ojKVaKs45dQbS192KvblSV3Wtve1lfpq3pg/wBqeKgZQNGsXLgAh9P04ckqqncswJY8KVwSdzbmkGTUiX/iqRzGdGsY2JD/AC6Zp2d+cqo3XA7qTgEZ+YlNzGt+a80yR42TRGBhbzCyapOJYlYq7R8RFV3Fdrbl+XzXKBRg0s+paaiFxpxiX5YhGNQkyAxjwzQrbglk3AluhJJzkCn7NRTviqlot21b0uvsuG972s3orIzde9lDLqDbWzjF2SUevt+q1Tta1/lz89/4puIxbHT4oXnxtkt7O0jkDbkx+8jZnjUYPm4G5U3MWXDNVwm/t5jAl+5aKJC7SxiUrN8vnKu6BBg7Qq8BWQbiPMJJsXflyFJ7VDayxKzQgz7wWO11imI8tipXcw2l8KWUfLtD59tcNPLPDPAbee1mkaeNX8yNUZlCuHUFjG4BJJfJwCPk20WipWlUqTlLaTbtZW2slZ9bb79Lk6ypqUKNCEYfHFQXMm5RSfvSleKel02rvVK6amWS8jJD6k4iOzaot1Rzt2bQrhGWJcq42oFUHG0oCxqWN5Ekfy5JSZGaU580hgrYaEKzjcCUDMcZAyCFBKpIVV9xeMsCrAowLoBgDcu4gjOSVY/cUtngklFtnLlHVUVTtLRBSTkIA2wsQqkZGQVLZYZDZB0hzRkkuZ3tZ6uWvK76tvst7va5lzKe6jpaPKoRgmvdXSKu0lZN/JpK6vQ3TSsipG4j2YLFgobOwMYo3LAFQ5w6sdq4ZioADTXEMYlSSI7POnRJJFXhwVMpWQLIPMOXKOSAwA3KCMCorSExKrPIWmJCjIdVKZjwi5ZFZTgbjsXKA7gGGBp3a7YLN9pjMktq+GK8jDRr2znMRfJHJIGSVFbx53Tctbxa3ekV7rstemys3Z6X3OScowqR5H8V1pdptJXu3q12bS6LvZlnPEoa3eGaG8dZBDBIqtHKscaq83mhWEikb2MfL4Qr8xIpIbb+zZFfc8tq8okliGc2sjO+6SNGY5tSExt2EqRkAjIrSkt1mUBi+dwMbxtiRHVziQBcFXGTkZ2lTzlCVNizindHguNu+J1Z5lbH2pZFYRMFUyMPMIKvHwGY7YwGO591TbcYtXkl7jiklGNouzSatLdWas7d9TjqVoqMmnywdnUg7u791KUXrtdNLR37xZrQGKSLejq6Hayuhyu07CpBUYIKkYHVSp2+o0XTMdqSqnNxAN4XoCw/3ucY3qUy2QcbgpqtaWkcKfIoEcjhkhAdljZmGTHuIG07F+UgAEnaCcCtaSJdkCqnym5tgwyCCcjkAMoKsTwRjHyrnOMejCDcUnHVqKl6u17LS2ierTSV0/LwK1WPPZSla7W6Ttvrqlf118977lih83jBI+beqgg5ZRt5BOOu4heVBU4YAjqdBjZ7RcE4SedRjPQ+hK8oc8j1Kj5RlayLGFSynYoyRnO7khhgfKAVOcnOcYznBJA6SxsFhljEck0cBYGSOOVo0SRtjZA3YG/Hcc5yR93HtYWlZqybSdtujas907XV9NLW2PiMzxEbyi20rRcbJvZ2t5Pvbqn217jR9PkicNGp8ksN8OGO45GShcqq4GAw+7k4UEcV7L4e0zzjGdjNuwFwRhchcg7SV3BTgg9cfMQoBPneh6VbyhWU3DKyhfmmk3hmAJyQOoO3HUDoCc5Hu/hLw8heFY2uEUlCcyuP4gckcqeUAPAI6pxwv2GWYT2jgrXu49Onu7tNbdObyfW5+RcUZlClRqNy+y1dXV/dTTerTafdbr1T9p8E6BuaDKb2YqkaqpZ5XZgFRVALNIX2hQCC2QBztJ/t8/4JWfsmR/Cz4c+DtJ1fTgviC8WDx58RJWQ+YfEWpwxnTNElcnmLQLGO2sFiLMBcWuoSgD7U2f5qv+Cav7OjfGH49+GZtTtWuPCHw8WHxv4mM6+da3Uun3EY8M6RcFwUb+1Nd+zTS25UvJp1jqA5KuK/vQ+Cvg5PBfgqC4uYjFqOoodQvy4/eKWXdDE5Ybsww7FcE/NL5rdWrt47zj/V/h76lh5KGOzNKjDlk+aMZJKUk1baPM7rabhtufjPhtwnPxS8W8BQxcXU4Y4OlHiLPeeLlQr1sPOM8uwVSTvCXPX5alSnJPnowqO142Oa/aS+IJ8EeA5rLTpNmta0Y9H0iNWCstzdHyRN1UBLeMtMxGRiPoQRX8Lf/BQn4+R/FT4zavYaTqBufCHw8hk8FeHWSTdDeyWUpPiLW4sEK0mq6qJ2+05O+2gtCG3BQv8ARL/wVO/ai/4QXwX4u1vSr8R6qBP4D8BokmH/AOEl1iGRNa1aADBH9haR5sscmGEd49tkr5mG/kj+FngHU/jl8Y/CPw5tBcS2ur6mbnX7qAb5Lbw3pSNqXiC8z8+6Z7WGeG2LL+/vpba3QmSVFb2PD/IP7D4cw3tIKOPzS2Jrt2Uoxny+zptvZRhbe3LOVTyt8l4l8bR8S/Friji2Va/CXAlLEcPZA017Cf1K8s0x9H7LdatGVGEoP36UaajeUbr9wv8Agln8L9C+CXwM8eftT/Ee2jtIU06XxlK92qpL/YmmW91B4L0aBpgD51/O91r6wKdskuoeEphkqpH4gfHn4n678cfi14z+Imv3Ly6l4q16+1JizEpbW8k+60s4Q21ltbO2ENpboVIEUKIAqqCf27/4Kd/Eq0+CXwK+Gv7KfhU2+m6lrdrY+LfH1nYERR2WnWyRx6FoDKhYrawPDDBDGxANlomnnGG+X8KfAPhyTxP4lsLIRMySTLLcMoIEcAOWdgMgK2F24IAwuc5LV6eLqrE1JSg241XGnQ3vHC0pNU3Z21r1JVcQ9XeM4L7Kv6XhTklfE1cZxLj6Uo4jH1qsKaqWvBS9mqkU7tpUKUMPhFro8NUkre0lf6s/Z88BSQWNnMbdpL7VpImCBN8piLKltFjG7dKzKCP4+ccg1/Wf+y58K4fhT8KPD2jTQBNXv7ZdV1mTYAzX16qyyRyMQSVt0ZLdATwsQHevx2/YS+CaeMfiPo9xdWRfQ/C6xaveFkXyt9sQmnW5GDw9xiXaeCsJbGMg/wBDEMSxxRxoMKiqq4HGABgDOeBxt+meo54eIK6weCw+WwlapiEsTiWt1HalB9Vd3k072fI9rHFxpmTzzil4WlK+X5BBUo2fuVMwqwh7SdtU3RpPlT71JrRq4yRiMg8YJwCMZAOenYnj2IPDEHNY9zICegIUZ3Z4x378DjJJzgZ/G7dOQxBYng4I7dOnsDzyCDxwBkHDuHIyFbJ6k5ABIH3c54A6/TnHavmMPS5mm7/DG9r72jdvz9Otk32/Ps4xapqaT2vv2SS7bf1rqzKvptqsS3OT3ByeCcjoeDkeo+7weOL1nUoNMsbrU7mQRQ2sUszMzAKAqlt244X5QBwfujPBHFdDeTBmYFieckH179+Omc46njgAV8KftpfGO2+Hfw6v7K3uUj1DUopYEHmbWVNh3sSME454JGX+hFfWZVhPbVadNpqOlSpK3w04tN697aa3u9j8izCVfMMXTwuGTqVa9aFClBdZzkk29L2jdttWWnZ3PxQ/4KB/HeXxn4w1O0t7smx055YYkEhCfIWG4gMB82ODggj5QASFH4b+PvEZBuJXlGMyZUZ6ZYc7TxgjB3E4PPGTu+mfjP42m1rVdQuJJS7zSyuWZiTl95JbJzuPQHjgEgZxn8/vH2tCSV442IBLhlyMDkj72Ack44Ix0AHy5Pk8T5h7as6dJtQpuMIRT0SSikm97WXm7d9D++fBbginlOV4HDeyvLkhOrJr3pVJuLnN3tdyd+933VjzTW9QNzcyyEgjJHIBIwSeMbjnAI569c5wa5ouSAOQQAScEnjBPfPQnqcDOeuCJ55svztIBxnk7iSBnpjIIPA6Z5weKjtwZZVUDnIY/wCzyCw6EE8A9umcZOK+PpQ9rUSSbcra79ve9Er2tbZ2u27/ANucN5WowpQUWkuSMVve6ile6vpfS17JdNzXsVEUW98BnwfqSpBBBAI+YDGBz8vPWugshvIIG3BGMjOMYO1ucNu79zz161mRxjICjjAGPQEEHAA5OSO+cYzwOen0y1M0kUIBzI6jgZBB+UAj+EFuMdewyDivssrwzqVKFKCu3KMYx3bbcV3erd7evTVH7VlWDt7KnCK5VyJ9byfKm7dL3te/TokfVH7MHwwvvid8SfDXh62t3db3ULcTkKWWG2R1eeU8fKqxxsQck5z8q5Of69PA2gWHhHw1pWjWUcdtY6Pp8FvGqDavlW0QDNjAAzg7j0BLk7sZP41/8EuPgslpZ6l8StUtT5pB03SGlQAkHJu50JA5yfKVgOMHt0/S79qD4s2vwb+DXifxG8qRX0tlNZablyGku7mN0iCKTnC53sQDtABB6Cv6fw+XwyXI8BlsvcqToxzDHS25XOEZU4TfanRV7W3nJH9X8A5ZRyTIqmZYpRg6lOdacpbRo0o3ab7N3ttd2vZ2v+LP7c3xYT4x/tBy+H47vzPCvg15LZxE+6JYbJPN1GUKMqXcxtEuQA5Kpkb8Vw2mfDzVfiDrHhPwBY20i/21dx+KfFyoikWNnti+wWM4BVlj0vSYYY0RhuQwOU3KWB8U+F2n3HjHxLe63rLmT+1tQuNW1e5mO4x6DpUo1TVZpGbgJdT/AGW0UnMboJ0OOCft74W/E+z+Gnw4+J/xIutJjuPFfxAtb7RPB11diJTpFjcNHBJqFskgkYC3sm8p5Il3Qu0OGUZYfkfEeLTpYjG1ozdLESSpQTim6cXFUVFt2+FRl5e913/j/wAX87zHMMNxBnWHi5Y3MKryvJoybahPEzhSdVJJtQoU3zSlqoqD9D89P+CjP7RKfEjXfCvws8C6XDpnhXwHptt4I8KafZKFlvQJRb3mpSpCAjXWoTxiHzMMXQs4YBto/L/xpKnh6JdAgZGmsl+z3U0e5xJdqJBdSHodokYxgMMiNVAJUEr9aobXWPE3xF+M+r4m0bwVDc2GhNJzHf8AijUIp4LFogfld7WNp71woJSZ7dyxZs1+fvirWJry8ubqZzJLPJLLJyWZ5pXO5VXA3EsSgI5IBiUYBr8hzXFuiquJqSvWxblTpRvf2VGDjFyvdtOpO6S10imrJq3xnDWUUMiybDYLD0+TlpqHNZc1TZ1asrJN1K1XmqSm9ZNSbvdmp4YiEl1qGtSqGj06JrWybGd9/dKyFySfmaC23szfKyNPGwwuSea8QX7SSudwyeuc/dYjd8oPYD2bLAqCDmu1nQaH4fsdMPyzpC11fnkf6ddjzJB2LG3RUtlJLDbCDnBXHlV7MZpXx3JBPUjJB45ABBIwQGA+6PlLAfMY2r7HDUqCSUn79X+bmlZvbsrRs+iurX096vK3s6Mb2pxbl5zbXM3pa6VkrdltdlRSC27awHcE8cYHBAJx6knAGAcjiq8mQ/3mIlYfJsONoKE4Gdqgco77Q2c8hQalAPBUcBUwcEAjK8fLngY5RsZ535HBawKkkMARgSAAgFTs6oqAlSVyG3AkgjO3NeBNX3SurJ72WiT0vuvvv1ukYxlbVve29+ttHaza6Py9LlcStu2RwsAjNncEw2CuUjBBGWwduCSQCwAIIWwpDB5opCkhIUkjeJP4gpR9qDado3L18rCsuTiBt+FI3fvMsPvBkJIYAEbgAxKIoGRu3OuRg06F1+bDKOSCCzEoCELbMrynJBPQ/NkArWLbva9073v3drfnpbbSze7Gluo69Fe93dd93tbta1ralkxqCrxkMSoSVFyQybzxy6hZM7VLAE8D7oORErnzzIkbbNhLSlhtc+YAqxhtgWQBMBtrhpGKjGRuA0hhkLQncrnapcK0zqF7uAVLIrM3Yg5G3O4CPKVDNFHGwRWP7zzPm+UBAfLZiwAwytnBIOckOS6urp9/TRLTon+LW+upG29raffpb7NrLq+3mkjf0e6+1288Dp5eFaS3LbQWZFQOOGKsQW+baiglsBSNrnofC+oHT9UTzGKW13i2utxYABiRESSMAo20sSSWGQgYltvHWc8sVxDIUQHcrSIWBLqw2FcsqE4T587yFXBO48v0E0Ihu24ARgJo2U4AZgHG05I+9u2BckDBGACF9bLK0qdWlNt3pTitLL3fdaT8nrF36O2978UH9Xxl4XSqx50vsucWrq1tbq+lrt3Vup9120Y8YfCi4gd2k1LwnMYgMK7vY3DM8LquN7CKZSgPO1CF4JrkU8RwXXhDRhO2L3TbiaybO9mManchJJHygegbODzyKi/Z38ZadD4v8P22trHJoWtX9joHiSOSTbElleSvCL2QBvlFuXS5LM4ZVRyv3jhPjZ8PtR+E/wASvHPgW73MdA12eKGQHcHgkxNaToygI6z2s0EySRrsZX+XgE19bnNKUqMMywsW6NaNPD1dFpOyqUm1r8UYSWlmrNtWseDj8XRoZvi8ql7ss1y+WPwyaajOFKpSp4pJvRzo1J0pT7KtFaHO6/4jZrRbeLJkcbAEJJORgcDqcsByNxyBgjAHvn7OvwBvPEM1l4x1k6ZYx3i6zqekzeJfPTQdJ8P+Fbf+0PGnxR8YmOL7RbfDP4d6fi91e5ti954q8SyaN4E8PxXOs6wBaecfBX4XHxjq+n6z4gtNY1HRv7b0vRdL8O+Hoftfirx94o1W5S30bwF4NsdpkvvEGu3TpC8scdxb6Dpa3WtXyOlvBa3P0x+2N8TIvh14f1T9mbwxfaLJ4t1GXSH/AGktX8ITiXwzp174ZlF34N/Zk+HtzFPcBvh18IbqWTUvG2owTzJ8RPi7NqOvatNqn/CNaBeVhgMIo4Z47FJ3jFLD0n7ru7JOSumnKz5dNEnN3Voz/OsfmdXD4ujwzw7JRxuLlKeYZhCzWForkVWUXqr0lKHtG95zp0IOM6sq1H48+P3xg/4W/wCOLWz8KrqkHw18Dw3WgfDfT9Xwmp3lrNcrd61498VQxO1sfGXj7UEbxJ4hVGmi0e0bR/CmnSjw94e0OGPh/CPhq58S6xZaXZDdbxSNM88iFow0eJLrVbvHBtLZBuiBVmGURQ8krI2Rp+kTKoh8sG6ugnnFFLPFE7Dy7WMKPlluDkSpzKQCuCSc/sH/AME8f2HPGn7QvxF0nwL4e04KLprbVPG/iCeAzaT4b0SynjkUX0hATybFwGeyMn/E38RGy0lI2t9O1IrpgMFVxuJlVrtqCfPWk38EbKy1ekUkko7KK6JWPZzHN8n4TyWpWxFaOFy7LKFSpWrzl783FKVSpKT96pWr1HKTk1zVak27Ocj7v/4JM/8ABP4fHbxfbeKPFemz2Hwa8BXVvqPie9uIzHN4jvHSKS08L2sp2btR1kRJda7KrE6To0q6dEyPdHzfXf28/wBpHw3+2v8AtDX/AMPLXUbSw/Ya/YiZtS8aS2LxW3hfx/460O3ks7XRrSK2KwXejad9il0PTbe3Vojo8GsTW3ly67YhfuX/AIKS/HnQ/wBhf9mvwD+w7+yrbeR8cPjfajwl4Zg0+SMa9pHh7V5v7P8AFPxC1eeNRImveI55Z9O06/mK/ZfM1HUY2itNCAT+Z/4/6hB4V0bwH+wf8FtQt9QutPv/AO1fjF4qSUQ2mu+PHthquu3Ws33AXw94OtIJ9T1e4uG+z2dlp2nWtwd2nzmvt8O6cm8TUp82FwcadHDUtI+2xNTl+r0Iq7TlWa9pXf2aEUrWnc/I+Cq9fjfOsT4qcR81HIMmp18PwfllduNGKpXjXzOUHo5wcbKq24yqOe/sabIfBPhz4l/8FC/2sLPU9O0NdXtNS8Taf4T+HfhK7R49GN6Eu73QtJ1LyAEtvDHhfSLG++IPxRvIVC2XhbRdQtFZbu80yK4/Uj/gpn8WvCfwh+H3gv8A4Jbfs8eIJJPDPg+0i8WftUfEW3RItQ8W+Kb+4g8Ua1DrYs96z6lrWszL4p8Q6YZZIbB38K+D7dRaaNJar6l+z9b+Dv8Agl9+wvqH7WOsabAfjR8aPDVx4C/ZV8Na5A0OsReE9fNvqN38SNZ0+RRdWmofEm4trf4ia8rRvLp3gDS/h94UeRZtSv4pfyw+GejN4N8P+Ov2mvjGG8Xa3H4hhvYtM8RI1zefFP42+IXn1rwp4NvVkZpLrTtCuPN+IvxSKrJBb6RZWHhq4ZJdWs0udJRdetOcqzVavKU6+JvdN8rWIqJJNqnRt9Xw0ddpTSVziw+Yz4u4gxvGGZwlV4f4bxCo5Rgp7Znn3NBYeEVJ2nDDyftqk72VR6ylClpmeMtN1jRtD8N/sueBtNaz8XfEPTvC2rfF+G3eNJfD/hF5U1z4b/BuW7Vna1kv7Zo/iX8U5pZV+0Sz6HZ3cMZ0PU47j1/4SfB2f45/Efwb8G/AN5HY/DPwLbanqev+OJ4Cul6fpFq8Vx8QPi9qcYAXyZxHFovgyxnYTXUUOhaRAzz3zxV5T4N0LxbHpr3M41XxZ8dP2i9RvZbi8ii+1eJW0LxHqc0WuarCkalzqvxM1W4l0PQ0j8trXw/b6iYVWC8WWv6W/wDgmv8AsfaRp+kTaVLHbaj4a0XVtNvPin4ptGE2n/EHx5oOx9I8AeHr1TsvPh58M5iUv5bdpLTxJ4v+26o0lxbwaa0G6jShTrV8RJ0cLQpw9qnrKFGMlLD4OFmlOrV0q1WvinKLco2kfFcccV1cpwlfFU6kcRnWPqVo4aorNvF1oeyxWYyi3pSwsP8AZMEprSnTcfeTVRfoJ+xr8BNJ8E+HtF8atoL6BpWn+HIPCvwl8K3kY+0+FfAkbGZtT1EFVL+K/Gt20viHxJfMolkubsw5ESLGn2Vqd7kMAyj+6eSeOgwQc+45X17Y0b+eK2hEMISNI0VEVAFRFULhUA4CqBhVGM9TkV5f4m8Safomm32r6tewafpljBLc3d5cyLFBBBEheSV5GICgAEkFu5UdFz80pV83xrxEoe7JxpYelFe7TpRsoU4xs02k7vTVuUnrI/kXiPNFhIVaTqOdWblKvVlJynUqyac5Sd3KXNNu7k3KT3bbV+E+LXxL0D4ZeEdb8Y+ILuO003R7Sa4fe+17iZQwit4dx+eSR9gUAdMnHBY/xy/tq/tUa18X/Geu6/f30ghllmg0+1WTMVjYozfZ7WJWI2EJtaTjjJYsScn7L/4KM/tzj4oa1ceDPBmoSQ+CtDllRJFkKrqtypCtdyAEKY8AmBXztBDkbmVG/ng+Jfjh9UvZUjk3KHO4BixZgSSSRklTjJLAcsdxBwx9fNMZSyrAywNCSeJq2+tVE9n7rVCEtHaP23HeatdqJ+s+A/hXicyzChxTnWGnFzSnl+HrQs6NGXLfEVIPWFaqmuVPWnTsmlKUkcV428TteTSAS53sx6k43EhSW6N0HTk4PqCPIbq4Z84O4MM7j1IJA67uTxk4z+XW1qd6ZZSz/N3B5OQQc8HJ+hOMjhiO3PTXCgcDk5PU89OcYOOOWOVOCM4B5+A53KXM/ibavu9LLRrSzeutneytbVf6McP5ZChTp0o09uWzsrXtFNvT3eidtPXctxsMscdcZAGeu36EHvndg4JzxWpb3SwoQ7ZZuR03fNswOc9MndnBAHYZrl3vVAC4O75emMDpjDEjPfjnPY8Cm/bSxBDHGOArdwpJUevAPfv1wK78PWjTtJNLZ2ei+zq39q99Va/zaR+sZbXWGhCMbNpJLW1pLlvqne7vb59Njs31kJGR0cLtBB5JDYDHI7nOOn94ZwScSfUnkYkuysMgrk8A4wM5HXjAI+XGTntgS3aHAU5Kj5jnlcAcjBYk9MEH3AAwTUNwhbljk+u4egOT97ueRk9s4wa6J5hOacebRbJbN+7ZPXrvslZu+isexPH1Ki5XeKS+FPRX5VZ2fzW3XTc3jdkAkMTyOMkYOFySASR2znIHptzSmYcZkx64POSwyNo7bSRgHn6MDWALjnrx0bIJ3DvjnIGSc5AyF2nJYAxi5YHKncOnXPUjDD07kDJz2wODySrc9tXbd+8nZuzvuuv5q+trc0uWolGTbT/Gy/B21ei6edulW4eNwFJdFH3hnnbzk9Dwd2MEAZODg82Rqci4AII6YXHIIyV4JOedwyRknPK9eYW9ZR8wBHHIx0AP4Db6jB6c4xUwvEwRhTtA7Y4wPwBzx1IBOB2zg4xlyu19k7pu7fL72rauuWz6fOxzSwyaav5a268unXW2mr1utbaLp11dtpAPJAJxgnp3GSc456qeMjuRN/bbYG04xwDge2MkrweVyR1zzxXJG4GARtB+XOSMtnGOeBkA56HpjOTyxrwAAKMngKBx6ZbJOSQc5z179cl+yty6JLSXR2T5btq902raa2fkYLL4ytd9trK92rXaevk9N+uiO0XVHZULAk5BHQk84XOcEepG3gAA4NaEF1K/IAOflA4BXoT2IyBkZAwD13HBrhIrhmIUhf4evOexHPO05xnnJHygkAjtNHillZGPIJ4GDgn5AOB+HGRx1OTXpYLBqvUhDWzau1q7qyuuiV9fN666np4LK41WuaTV9XZPRqy3aa6Lb53udDaWs0rAyHbEDjC5LEcHkEYGMNgnjgnuBXa6ZpSuwht4wGcj5tu9h0UZK5YfdGR3zxyKzbG1LskYJIXG7AIwvJPTgHHPoMHHQ7fuP9k/9n7U/jF410+yW1kXRbaRJ9TuyhKRQISWQttx5jknYCSwByeNwH61wjwr9fxuHw9CjeU3F1K0037KmrOU7tJJRSeqtr9y+/yPh+niMRRo0ablKTipSkr2Wl7X2t5aO++1/b/2Mv2RpfiRqkHizxdazR+FdPmikjheNlGqTo2Vi3E5MIIBk2AkgBMBjkf0B+F/DtjolhZ6bp9nFZ2Vpbx29vawRLFHDDGqKiIigAcDgAjb39azfAPgHSPBWg6b4e0ayhtrHT7aOKNURFDFVBZ324+ZySWBBbuCMc+k+UsUbYUfKOccls5wFIYLzgA5BxxjA4r+joQwWVYKlleWwUYxSVasklUxFVL45dWrv3VtFK6tu/6r4S4dwmU4SnP2ajUajJtRvNtqKu76vXzio9FbfOvtRttKtpJppooLe3R5JppGVI4o0QtIXcnCqBzI2eML35X+cr/goP8AtkX3xb8Qy/DXwTqEo8D6DePDPJbyOq69qkTFGlkCth7S3YFIFJK8bsEsoH2R/wAFGf2sV8GaJdfCTwdqIXxBq8W3xFfWkoD6ZYSL/wAeQkXlJ7lXw4yrBSAclyB+Yn7GH7Nup/tBfEqHU9XgaDwV4dlGq+JdTuCEtora3YzvC80pEatLsYzsxwke52bAyfzfj7ih5TQXDuVy/wCFvMaajja1PWWBw1VK1FSSfLWrQadR3TpwlyvWTt+F/SF8Ycu4QyDMqEcUqGHwVCUswqUp/vK1V2jTwVCzvUlOfLDli7ylJRtufYf7GPw08J/s3/CjxB+2F8ZreOM6RaOPAuj3iolzqus3Qkj06CyilBZrm9nIVJFDmGBJrpiEjBH5a/HT4r/ET43/ABB1TUbprrXfin8XtaitlsbUu7aZpmozpbaN4a05eRbRvAYIedqWunwmWc4JJ+nv28f2pNJ+JviSPw54SkW1+CPwbeTQ/COm2h8u08V+JrdVs59aMKqBPEGiaDT8hhHp0ZmA8y7kWvizwu994C8MXfj7X7iSy+InxP069GhzFWW88D/Da58211rxXGpYSWus+N4En8PeFdpSeHQTqeoW5je/tJl/GGnSX1SMnGMKbqYuvCSUqeGdlUqc01b2uJqfuMPzSt705u8btfyF4R8J5hisRj/Evi+NSOf5/SVbD0a0Xz5Dw+3GWGy+jGX8PE4n3ZVrWftJJSsqcpHY+Ide0f4T+GdO8G+E7u21GHwrqM72+r2ojlh8c/FdoWtdc8aZIb7V4a8BxvJo3giNw8Uk0Z1RA8mp3QX9Qf2TPhtN+xv8Cn/aC8SabpV/+0j8a7W/0L4KaF4oIW18MWJsbjWNd8e+KnuPmtfDXgvQVm8ceNr+Vh5lrb2Gh7xcatsb4x/YR+AGj/G7x3qnxq+KrW3h/wCAHwNsH17XLvVMw6LHa6FBJfwaVM7ARzQWkMQ1LWEQSS3txJbWKRSXF9bxPk/8FD/2vNY8YavrVtDHcaHrfjnw/Z6LpXhWSQRXHwp+BMd3Bq3hvwVcwIWis/GHxMvILLx78SNqpNbQDw74TJWCxvoB7DxeH4eyZ8QV4Kji8bTqYfIMNFJexwrhGlPHqMneLkoqjhpSTlyc1WUXKUpL95liHw1lb4gVOK4i4hlVwPC+Hkub6phYRUK2bTi7NUsJC/sm1apWkt7o+A/2oPjS/wAR/FMulaTrOpap4T0G/wBXubbVdVb/AInHjTxNrt4dS8XfE/xPHgh/FHjrWC+pSQM8smj6Kmi+HYZxb6PAo+QLmRtrAKgbJ2u6jaOVOSWZS5O3A6b2I3YcE1p3Fw8nmefIZXeRmd9xdjuJAPy4DYC8oFJBG4YXIrKnC9Dwqpw2eTkgY3HPLEnLKNrg7Qc8H+eM1x1XG4irWqzlKpWqSk+Zyk0207Xk21a6ta91ZrU+QoYdYOgqSlOpUnKpUr1pyvVr16t6lWtVlJtyqVKknOUrX1bVtjPEx3L50kgJC/KYiqONwB4WQksWHyNx8uAxyGVmGWNQ53hRuKMGxk5IwQVO3cegzgjvwtSzs+1dkRkcNuIL7ExjjLMDkMRtCgYI5JByRUB3w7pIVjkYAlQybUIC7dxCF9xGBk5I5XJPzV4bspNJXa111X2bWk3brsnvfZ6l8z0Te8UruSeqS0321as+jaXcc+QoBdcshyxUEI3y5Y4UgnOcKp3BiQu1RzTY7wodtyKBt2iNDuVlBJXhgu8EbeF+Ut/Eal34CvsOeMgh2IXK/PvJXA3Z6nOCVbf0NYOgI4AYMATtCplhHtYH5gVb5QVUn5Qvy4BBiTvLpZ2T6t3S0+Jfda916Cb5rNpRTS0X/bq1WqaelrXtZardqxOX2AhZMMeuA5O4iMBnwxXAy7EruOMg8MCqpZW+bfnCkDeCdp2ncSFCsRuydpYllO3FPBYeYACxbnJAYYO04xlUJUH93t7HOeDmLcSSVyCCBkMSCCFBJOM7eoZivGDgDANTyp2k1onH3Xum7J2ur817vo077dWkla6vZr+az+HZc2yavvfdN2WjFIDJuYl2Qhvn3FlBRgUVSAeu0AA4wAACeK0hJJJRkIlCsx2ncp2DgDawjJChtucFgBu5apVEb8KOVkDNznLDapIKoCq84VyQFyeOBuFiRU8sH5QW+Y5bOcfuxlsnY5A+UfMVPHmECsXrb3kk03a+n2bWt2s+q0bb3bGmk09r72d29Eu1lr/LK72b6kQ2N8p6Fhty44O5SCc7mCcALkDBw21XwKmLJsPVsKASQxb5QCWDEKQv3juPAOWII5LSFJXcN2FCY3EEKdu3JAGMZ3DLYVVVpAQozECsPlhpOXBiUu3LKQoA3MSFXAOGIIIG0/MQWyc5JpS+VnvK6V9W5J3fMndPZ2d0hXaaVkrvVtbK8equ1Z2877PRCsflztznaBtJycY2k/eLYHBB2jAyWYBjTgW6gBiVKsONgbIyOhyduCH6judvWIbCCwzjaynbuIUgBicKFLFSdoAO7IyeWChsTlidw25Hyj5MphEKszDdu3sePl5PU7SwKi0mrJtNJq6Wuzvaysr3bvo29PK1bRPRe7fbS7TiuXlt0Wmi95u2/KyI9TGcMSVLE7AZAVKx4GU2qykHORtww61C0M7tbu3lxup+cAkxqmRh8gkSZEe5iwG0PhflJYWd2QPLUYYKTwSOwJXGBg4yWCDGcYI6KpO8LychgFxnjjBKqNq5zlcncmSOmQszhe0Xfps7LVx03undXTSd9XbQOVNq2qlFWWnXkskrvWVry0vZ91YVhFH8x+VRJkNuVsPkEMFPy4OCcHYMAY6EUrOWVpEBwgIjJCiNgNrBm2hwVyAAR98Hhd5G2RwVQFiXQKDt4AOMZXaUYM2G43A4A3YAFU2gjdRv8znbhCVU7Ttcqyj7+SQWLFWUYwWAJWZ3tyRsmrN3eqva6dtNu1k7XSLSl8MXa2zWltFfVtK/LdbLaN0lYntRLJaJ9oG6Ry8xBG1kjJPlIMhcYRVBUhgDjGNxJJEJwdxVSrDq+1SzLgkqRtCkgbAMheRkn5n/ADAxsdxBwCMMVONuCGXcBsUAf7IwfmXJLWRHZElRiqHJVSBvbKjEhAyeMsO5AVtuXALs1BLW9km297uO8raXu7q+/vLoilHfW9nHW+is426X01aV76312HQykIC6HzNpxkKC6ptwVDMWGcgksvJzjDAmp05dRyGyBhcbVBKD7oKgoQMDnJwRgAHNZp4wzIrqGSIsXYM6KpLbdqY3HbuXJVgqbiSwAIpiTzCVFnjEQWRQHjdCh2sm4bmxtd2DtkF18sAnqWOUpqMWm2l1kk7taXTer6u6bS6WFzRilF6d3q16u9nG+tr2d79FpswsdhAHHG8Ac5yvXZ8owF4BOQRlSQKlU4bavvnnlRgMSygEKMDhdzADG0hcgV4w/wB3gA8kggZIC/KecAk5woBweN3HNlVEamRQcKVDAMfmGV5JBBJXH3goKEdCGLjGLXIltbppZJWvZLTbdpvXysfmclFyaune1krNdN938raXXoKnzEjByvZiASDtPy8nqRxgDhiOPlJfn5d7DaFCgsW2DDMg5ZicFuNuRubgD5hmoiSpXYBnGWBIGQSuQduCFGR3zwSMhhiYKWXLRK2V2hXAbqV+dR8pzu+51K8BcjgXGVuztZXd3ulZpK6Wrbv20v1M5K6jJqyb+Hftpa12+jd7b6WQqr+9ZiMBduCxU7mP3iQygggptwQSXBGCabITEm49+gBI2g7BjkKpXBO4A4yD/CRmZQTxuAZssWbcSpBODyCwHJLYJ+U8Lkg1E5JQEtuGF385JYAMSfvMucBVy2V4BBGMLo99r7WvrFr7nZX6W1tezcXe21k4x06u0d/J9fd07kDy4CqDg4yBxnYCpL72BjxgHaQwBxgdNpiXGQqMSNvIGMj5g21gqkh23LhiR1GM5NJCzFFeSMwyH5ChKu6oSFTeFCuwfaGZQTuYkEBTkMWSFJBH5irLISUhMjZbOxs7iOOTyjfMMZAzWDbbTb0eivZJO6VnfZ9XsktX3OqMHFOKjd21cdXZON29X2Tb1+HUf5252WMPviwC5UrGDmIkAMAzSKWBK4GTjOOpUJGqqVxGcdSSoJwuWTgAl8qMcngjDBQBERKxTyyD5kqI0gB2KoI/eKryAs58sq3AOGXaSxxUrQgmRmBZi6sFbzQqeUCF2YbgEqSwJOflDFSAaIpu6sm0ltZJJ2fnfdJ326q61t2Sjd2i1stW2nGN2+y8kl2T3Gq4Eqgq3O542JRh8zhcqGIK+qkgliWU4ULVZopJb1pJ2C28QUWyyOV35MQ3kFVycplckMWA2kJnNyTEgXf8yqxl2Fsj7+CxD4YI+RwpxnAJBcZaNshCum6PIfDF8bQdwkVSDtyeAhyAW64HLlTk782yaau3aSfK9bK9lq27bq1421cZqC92Oskotq265XdXulfRNvVapb2HBwElCuxCARZLOHZXCxI3I/eHklSuANo3lSQKhLFMMWbZGu2QszlTlwCzBd65m3DIyvz4JHGDPEz/ADySQomUKxssiyzbEdF/eFuAPk3Hgsd4DEkUsyKxikkjSdQiqI0wx3Ow/euMJnAXLFyVUjKqPm20otq6bS1Svp2tdNre6fn0bbIuoyWi11b0d2rXt007LpfXa1i2iZY0QguUxliWLMDz944wMsFBCYZR8wyAFe+yF0kcIInbJGefOdkySWYkI4ABYIQGVSpUYIlXbkKxLAb8KCD1YjjGAgUEfKSQCflJ+XMy4YMDj7vI2gqMICCyjPK7jkk5xtI4Axpy6JLdNJN+Vvnrpd3uc/Pdybu+Z6pWtra1lbduzXTTorAi/f2pglwWION0hQLktlcMDwMABuQQBjLjFHIQ7IPMUMN2X8zaxdXCsu0+XiT7rAqBkNnoHIuDtL5ZiJMNgZUso5J4DY3bexxjKk4NgDaM5YgccBsso28keq4C5ONowCpPTSMb6O2uvVK+jvvZb32bV7vzxc2mmtdk7trT3WtdXstrrfVEAjCxiNWOUTYNxZm6HIYFnwSWUg/ec4AIx8sU0cgRWWRWuIcou/cGu4CWZ4Zt8o+cHPkkjARyvPBW6uFz0xkNlsDb0HIUElQDgAZByCDjpIEBySAcpy+VJbgAZYpkPycFick9SMZvkTt3stnr0tZfpbrrZmaqODd9U5a3s73s7a766Wt130RSgk83euMSIpDLtVWiKqvyFRktyDgqfmK4PChmsBV3BSz5yZVIYBcY+5l9pG4/KVQFQqlVZSQS2aKVwZ4mQXADABwxilABfy5slVDI20eYyhQdhPSqunXbyBY73bFe/vIiQqhJSpSMBJCD5c3AV4WVANu8BuJC0+WUYu7b+JuyVrpWfVat+ei6j9m5RdSLVlJRceb3ul5JW1irat9LK+muymWbO5FPygknasmDGMKWLtgDHzOuSwEZA+VhpaiC1vZc7MS2akAAHcQzEgsOANwIA2jAbcCQA1MLlRuOWB4xlAcbVALBAWKnJV88kbiWJAq7qOWFmMjIuLUfKT1ECZOfm3AKR8wJznJHGa6I+7F76OEV06q9uultH+DTu+CpK9SlaVt7tuzTcY2s3bv929jVjjXcSFJJB5JDKMEYHOAONv8Ae3MCfunB1LSFAsz8ZQWxBGNwzJJkHYhbB7gEqvRSSpIoQlSpB+9kZOMMCG5XcwxksSOAQcdRgGtiyMbJOpJHy2u0ZbB2yOMAn5iB6gZUAtgECvQpRbknbTXa+j6ebutumrPCrzk4tJ2s4p33T5lZprVaaXbVr/DdFuEqqqZEwpZUJI5yzJtAd8YJwedu0kEkZFaBUFYAwORd2gBCFiQWBzlcDptO4DnBfJC8xQRlmAZsZIbPqqnONpUgFixGR/s/3RWzHaCMwSKnmqksM0inD/IBncGYggx5B2gAruwQcgH0qVOUktNHy2vuleKbvdre7b9VZ628PEVownum7tt/ZeiSS2tddNvwOhsIWUgsWdixKtzwMDI+XgqQoBBALbuTy1d/o9qruqMpaNgN+TuADBcg4I9eucLnjpXNaWiSgMAWDO6HeoDINwJWRRnaTklWJO4Y2sR930vQ7Ft6howAPmUY25OF46E+mewOMHdgn38HSvKKs7XT0s9Hbronfy0bu3daL86zvEtc8ldfFduzts4t62ve62tbpZnd6BYSIYgYw8IYBFiC+cqjZgPDkggL82VwQg+ZwSSPpnwNpXntbsqhQ2xnDEYCjljwpI+51baRgDIBrybwpppaaOQRSFwpVyWfAUqmcDcMZxnAG4Fhg4BC/qb+wV+z2/x1+OXhHw1f2jy+EtDlTxf46mVCIV8MaJPDM2nO6hQr+INRa00SIMcuL2WdQfKfH6JkeFs1VlZU6SdSb0uoxV7+80tk7Prrpc/mzxJ4jpZbgcZWqT1hCTSi9ZNpRio9eZzfLFNu90r6n9NH/BID9lIeBfhV4a1DXLAw+IfH8tn8Q/FnmRbZrTSHt2TwZoU25S6GLTZBqM8Dt8txqt9EV+UV+2Hxz8bp4F8CXZsmUapfommaRCMB5Lu5HkxBVAORGMzNgfcQ8Gs39n3wjH4X8FJqlxDFb3WsKt5JGI0iFvZomyytkRQNkUVuFKoAFjLMqgBQB+Yn/BS39p+H4beBfGviWxvYxfaBbv4V8Ex7wTceO9ehkRbuJSCXXw/p4l1F3AxFJDscgSAt+XyVbjrj9QV55dldZJxvem40pxTTaaTU6iUG1a9OKdtNPsvrMvA/6N9XGxtS8Q/FipGOFb9zF0XmtJQw/Lpzwhl2WyqYhXVqeJquLaur/wA2P/BTL47J8Q/i/e+EtJ1EXXhb4X/bPDtrLHKHh1LxXczLL4u1jcPlkY3yf2dBPvZfsumxlCfMYn6Y/wCCSXwJ0nwz4b8W/tPfEK3Sz0i20u616O9vUwun+BfCk1zcxvH5pKbvEviTSjcRxjEj2PhUCMsmpIX/ACN8MeC9b+OXxb8J/DrT552vPFOubNY1MkytZaVC0moeJtcum3ciy06G9umd+JpYfKB3yqD+7P8AwUE8b6R+y7+yR4I/Z68IKmi+IPijZ2d5rOmwOY7jR/h/4fitLTRtHuMBZlMiWum6dMZGHnz2OruzM9xKT+846pGjShRhLklUX1alezlGnCCeKrRba96FDmjB2sqtWkj+WKOTToYDIOCMuXPWxUqGKzWpFN80HVjKHtrK7WKxjlWrRl70sLh8Rur2/FP9qj436v8AH342+NviLqkrs2uatM9jZvKXj03Rbci30jTYt2QFs7CKCInH+sDsQS5J9U/Zx8DtHbf2vcw5udUkSK1ygLJbAnL4IAAkGcMrYYBMEcCvj7who1z4m8RWdoqF2urgNKBk7YwVaWQ4yvG04bORhgrEAFf3S/Y6+DbeN/G/hnQY7dzpdj5N9qWFPlpptiUcqSAAv2qTZGORuzkV5eX0Y1K9SvUkoUMPBzlezjCnTjG0b22UEkkuqtvc/pLMa+H4I4Sq1acVzYTCQw2FV17TEYupFQgrPepOrJNyu/em2z9j/wBjH4Up8Pfhbp+o3VssWseJ9mq3RZMSRWjIFsYDvAKrHb/vChGA8pAUE5X7DkYqhB5wpwDnnOQAMAcZzk9QRn0zX0+0g0+xtbSCJI4bWCOCOJBhVjjjCAYABwMDAAzxg8ZJbPLlSOMkZyuTkZxgZ4JxwDjB5HXBr4jMMXPMcwxGIlqpzfJF3ajBNKEV2SglF23s33R+CUIzwmCdStJSxOInOviJtu861b36km1f7UrRutIpdUkZtzINzYOVGRk8E56jtyTgAHAzx1xXOXs/lq3I5yAOSCckHGCevXHOMtjJG2ti7lAyDjHp/u9xjHr0z0x6ZPK3s299vGGxkYyBgfe74zuJwDnsegz3YKmpNX1tZu/lZ9r69dr26XPzziDG2UmnZrmcbt6NK2vXt0S/TntUv00+0ub64YIkMMkrsThVKqT15PAU55yBjGARX803/BQX47HxX4s1OytbvdZae0trAFfKNtLBsAHaCSqruA4AIXJPP7L/ALZXxktvhp8PdSigu0j1G/t5YY1LgFU2MpbByVwCPmUZP0O0fyPfGvx7ca3ql/PLcM7zTTSOXYkkuzOckkg46jlRnOMMSB9XKccuy2pVk+WriU0r6ONJcun93metutr7NHqeEHC9TiDiJZnVp82FwMlCi5JyU68uVylZr7EWo3XVtXsrr5o8f+IvMNzIz9Wf5CeTnd0xxkgeg5yD2r5C8QX7Xl1JIGyAWII+UDBIA64J5HIJzwfvHj1H4ga2WV4ldtzkoMAkYPy9T26luQSTu4I58HuZWLDGTkDjjqSOM/Nk9iSew+X+KvzLHV3WrSfMpa6d9bP522fW9vn/AKe8C5HGhhqFoe9LlS2Vl7qvfp0fo+j2jL7hu5PHtjII4BBxyfQlf72e+xpkAWIyY2k7iN3bOAc8gY6ZxkcZHORWLAPNkVMckj5s8dh1YAkkAsOCcckenVQqAFiRQQvJxg8jORyT1bOT0znJyuK3y6i3NVHqk0l8+W+l76W6brTY/o3h7L+WMZuOkErXVrzstdVutdPPRao07RNx3YJwMDjGTzk5Iwc45IU4wcjJIr3H4SeCr/xj4u0XRLGFprjUb6C1hRVLHfNKi5GBkgBt3UgZxgck+RadA0jRqE5BCjnk5BIABznJyMY3EY5ziv2j/wCCZHwQHiXxpN491Gy36f4ahBtDImUk1GYP5ZUnjdEpLnAzll5FftHh1kccxzajWrRSwuCj9axMmlpTopSUbt25qjUYRve8paXVj9m4OyaWZ5phcPFcylUg5OzsoxcXJvTWKin6ba3P2s+A/wAOrL4afDzw54YtYkRdO0+FLhtoVpbt0DzSEjByWLEkk9cg1+Q//BTH4zS+MPGmkfCXQroyWujzIb2KJiyyX1wUUK4HH7lcgk/Mp3AjHNfs58VvGunfCz4beJvFuoyRQRaRpV1LGHIG+42MsKICQd7SMFC8sxJI4BJ/l88LNrPxm+MWq+I76WWWe/1eefz3JcxvdvIzygnIVbKxWR1wMK6xA5LnP6nn2Kq5jWpYKi/9pzjFKjFQVnSwUHB1pKySiuVci15eW6atdP8AcuPcd9TyvA8PYD/esylToclNJOOGhKEZNpa2m7cz/lUrdb+xaD4ZfQfBmmaXYqF1v4jX9r4W0wrgyQeGLGXzdXvwqndHFfzNI8rDcHgBYFiAy+JftSfE37B9r8LeFbox6Lo1jb+DdFtE8ovc3MYi/tG8RUUb5JrtWQMjeZIII0diIm3e/wCr+K7Wz1Xxv46tiTo/w60NPBvgtEZhFLrFwkdlJJb52jzHlkYEph8SQFwQefzcvNVi174qaSmoS+dpXg/z/EWtyPITHLJpRbUbsTscrtub8Q2j7wVId9xBYNX4vx/iqM8ZHA4OVqNCUcJBp3jy0vclVaVvik5tN2TiktLJn8k8aqhi8zpZbhWp4bLakMFTkrNTxEH/ALTiHZO85SlVfNo+VpbJN8x+0Bf23gLwR4O+ElhMgu7C1bxF4uaJgGufEOoLkQ3GCd32IERor58tIoieQxb4h8P2Cav4iWSdfMsNKVtRujjdGxhcLZ27EZ/11zskKkYeNJmDLww7n4p+NLrxb4m1zxFeys76jezzbmLErEzl1QZOAAu1CSAoGEPBIrI0eI6T4aWd123etkX9wG+VktwhWwgI2gnCM1wFDAl7luSBivyLMK0cXjbJN0MPFKCe3JTtyL/t6Wu+1733PFpSSqVaru6dJxhRg7JcsEoQWlk3Jxcm93Z3dtTnvFGoySzS/NjeSzfNncW+YckjIGCm7IPUAKhIHA8yNgEKcZywXG44KghgULkjJALKeCMZBOtq1w01wWxnbIMHOfbBZgM5IJUAdep3HFZKgxozYJY/PtLNsOFUtswQqAKpy2OR0IHA+ZxVWVWrKTasnqnbW3K3a6lbXRLaySd+vO3ze9dSlJprT06eXVJ23voVnVmHMhjZHxvUKHdl2sBlwpB+TaqnO7kSYwpqtLlRE2JHXcEbHyEkiPc5LPwV2/vNyjJdSuzZg2lLOSxUMxTeMFRtfhmRmJcBGCbQWHzsQVODxWQogNxKGidwsUkeWYLgxKqZjClmLIWLPgqoUkkZVfPnfmtG+j9NrN6P5Wbe+60KUrJXu2nqklvpfrbZ77LyuVGjGJg0u8yvhI12hYo12kSr5coAUnCueJCB8oRmVqmWOVvLAcNtj6JKXY7CoQySKrAh1K7lBTJK9OrWoISokQqwb513IY/3hKoNylQAVAXbgcOApBLA06KNF3NEmMuQ6guVZW2EvlgN2CcBsHygdpUgZrK15Xfa6d7Poutnq23fpfVaIlz0lZJvR30291eVut/m2rvVYEYJuIIkZkLRlg20bVO0khiQcEliMj5VPyhSsUluIHkunuJmYfutp3CERuY1CLEjKdxRSolOeSC+ELA3yCMbH2qikHCnBwylUdE6hvu8liGO1DyQEVZGkYSY2FSUEagEqcIokEnIf5SY1ByvAB5G4Ud97p6PW11ZpaJLTXrbzRCk11SVr31fS3TbXfazvr0HxKVCrvOF2AsASxYABwR85PDYKbsqzAA7QCOoD/abCKXfma1YxSg8kIoYwktyx3pgAkDOCQMc1y1r5puC7uzqGKmPYpXJ2BchSQ0ih/mZyrbwNiuoZq6vTCBM0O0CK4QruOCquqFomOMI2QGRmUHc2MhWLV24eXvQSVua0W9V1jrG972emmqs909ODF2jCM1vQnGoviS5WlzrSzu4t6JbpaHZfDi5jg8QQRXjstpdPtJyG2zDeIHAYcMshAC7T1APJAP6g6rbeDv2jPiNea/4rn1Zb3SvAekWV5DpHkTaj4o1nw/aWvh6zhhl1IJLc6jqclraMLezR5PsO232RzPGK/KzTIJo7y2MKhZUnUJuJAUh0KhnGOVdgzEgEBclhjJ/SPW/jn4O+H/g7wppPg7TrNPENro2iahqXiS+0vfquj+JLePU7y6isGdmOpXst3d2l9M7Ilrpkdjp1vi5uHkkb9QyGthZZPjY5g4qjh6uHqQUlFuUlGfLCKvHSLbWmjUm0cOeYHC5rkeJxUascPmuEw9ShltaM+TEc2OlRValTmoycYv2UJ1Pc0VNS1sme8/Ej4keHv2PNHurrwY+nXHx7v8Aw3qHhPwRLpUsj6N+zp4a8Taai+IrvweL9I7y6+NHjKGWZfEnje7tkPg3SilhpFzc3s9qLb8kbCwuppDd3ReS7uH88b2Z33sxka5mdy0kisxkctKWeWVt0hMjDHQ3t5qfirVJfEWty3k4kkmnsLS9nlup5PMkM01/qErlpJHuJQHuJiubmcpFCiwRwRj6p+CfwJTxhLpuueLZL200zU7i3Xw/oFhGY9c8YQrMTfXUM8qNaaF4a06KKRrvWb3KHy5IbKGdo7i4tuOHtM2xNOnRg40ofw4X0gpcqlOpd25pWtrd8qUYpKKPy/AZVguFsLVqSryxOOxavisZW5fbVnTjKfsqTikqdCnerKMItR53UrVZSq1KlSXT/smfsyeOvjZ478K+HPC2gXesa54n1OOy0K1SJle5vmYST6nJJMjpFpWmw+dcTX0jRw2zW7ys4MRFf3N/Cj4X/A//AIJb/skeKfFniW9soLfwd4ZbxT8TfFwhVNQ8XeIoLfy7HRNK3gSyQSX08WieGdMDbp7i5SecG6vLh64z/gl7+xdpXwH+Ftt8VfEuiWNl8Q/H+k2v9kW0dkYP+EP8C7Q+laVpltOpmsbrXkVNU1DzcXQtWsbe+xMl8rfk7/wVU/aDk/bA/aHj/ZZ8K66tl+zX+zVPN4z/AGhvFMF0yaRrnjTS0lK+Hpb3csUlt4bjW609CpkMWpz63qGyebQ7TPvU8N7SqsrwCVTlqxjWmtI1611zOU7pKjT96U3eyhGc27JH825vmuZeLXGeE4SwM6lDh3CVnXzGtDWM8PQlH22InJ3jJ2XscNT+B1pqT91px/Mr4iftFeLNW1T4nf8ABQn4xrG3xm+M11qvhn9nfwleyNNb+CfC4ga0h1Oztn3GDT9C0GWG2s7jZGLiE3F4zFvEqynvf+CTP7Edt8afGviL4ufG5zb/AAu8PaNB8S/jl4h8QXLWcA+HbzXXiHQfh7qF9MA9vffGm906fxb48kQrPZ/BnQp7JpYk+IOnO/w5oqeKf25/2nNIsPCvhW81vwJoWqaF4C+Gvw8s91nb6y11cPb+DvBluEKQ6YfFFxYTa74t1M7Y/DXw/wBJ17WriUWugxIf2f8A+CjHxUsf2Y/gl4F/4JkfAzxBY6t8SviDs8bftR/EPToIrFdVv9bS11LWJbuKEKun6Nq6aZGLPSJAqeH/AIT+GfCvhlN9pfbZOipOhVko4aV8JgFOjhqlnF4iq2oYvMOW6XPWl/s2EV7xpqNouMJJfp3HGMr1auUeGfCjWEjWoUqFaVDlUcuyzDwp+1r1Gr8io0060m1FzrOEYycpST+Qv2iv2gfFn/BSX9ry58TaNss/hT4Eu5vCfwe0jVmWx8PaFoelWUmpXXivV4ii2OnWOn6Npt18R/GE8v7rTdKstA8PyGSO0igl8q1TWvCvxk8ZLLp7ala/sz/APS7u18NmSLyNU8U21/fxtq/iq7ik4Hj343+LIlOmRSmebRPDx03S2ZrLQWkFLxzp118HPhtof7Pvgaxum+KPxk0vRZPGptgZNd8NfDDWbiLWPD/gh5I1MsHiz4yXItfHHjxmC3Np4Sg8M+HyYrW+1Kzk+nP2b/hHpNw1lYX2k/8ACU/D74W+JbO1Gl2CO0Hx5/aF1IeTpvhHTmjLzXfhDwem6DUmtzJDZ6HDqflkX3ibTzH2YWhJt0fZNOHK8S3ZwVT4qOHikv4eHg1UrxTavGMG1Jxv5Gf4/LsmynBZflbnTyzLaM8Nl8LpVa/uqGKzWbbSlicbWlOlhqrjdxnVr2dOU3H6i/Y7/Zx8c/Ejx/o+pG0GmfGL4w2K6rHPb27xW3wM+C0tsmnrrsERCf2brWv+H428P+AYGMVzpnhn7RrVvFFfeI7S4h/rA+Hnw/8AC/wf8A+HPh/4QsorHQfDOl2+m2MSKA8ohRRNeTsoJkurqXfPPK2d8ru3fA8O/Y//AGdpfgp4FvPEPjRodW+MPxImXxF8QtbMcYeK8uI4zbeHrEp8lrpmjQLDaW9rb7bW3WBbe2UWtvAqd98c/jR4A+B/g/UfG/xH8R2fh7RLGJxG08qm91G4VGdbHSbTeJr68lIASKFSAPmcxoGdfDzLGTzTFQy7CSdTDUKsrtJf7TiG06teUk/ejfms3oo8zvy2Uf5e4tzevialTFvmlNqFDC0KV5uKXLCjSowSlJqKahRglzSbcuX2lWo5bfjHxdpHhzSdR1rXdStdK0jS7aa8v9QvZlgt7a2hXMjyTuwAGD0VgXchVDMVr+XD/gob/wAFKJPiDd6h4B+HupTad4AspZYZJopGguvEk8RaM3l5jDRaerKTbWrEMy4eVdxCr88f8FAv+Cp3iT44X974X8KXFx4b+H1nNItlocE58/UzGxEd9rssTKtxcMvzQ2KM1tahjnfIzSN+F3iXxtq/iK5mmnnmdZmZiWLEnJ7ZwMDOAASVJIXgE1rLH4bJ6ToYTlr49xUKlaOsMPe0XGlJfFPfmmtFblg2ryf0nhl4G5nxBjsPxFxZQnSw7nGtgssqRvLSUZQrYpO8XO9nCjqoPWfv2UO48f8AxOutbuZ0hmkkDvIzykjLFyRhTwSPQBQGLZxk18/X11PcO7sW+ZyfmbnkgsWxjJIOSSSxyCeME3JH7sx4PU/xd8hgWBPPy8gbuDnINZsrKf49xYZwwbGDjAzu4wOjcn3zjHydapUxE3OpJzk3d9bXtrumnzPr5vQ/vnhrhSjl1ClQoUY0oRilfROXw393Zabdn22OfmSQhiDlWwR0OegIYDI4IH8Wf7pK5FZUkbAHJYAL83GT1U9uBxnJzj0OAQehmAAIAJwMDjONuCAufUkADAGD1yd1ZcokJBKZPOA3ORuz1LDI4UcgA45IOK5lBJdErxur7pWd32uvd1e9m7bv9GwmEhhlDVN23T1taKl3fzTVtrHOSKwLYJyDznBx8oGc+hAzkH8gRiswkP3WA6K2c4/h98DG0AHp15PUbMm7cTtXIxkAH+8pIwCDj3J4PTPIqsygMcrgkA4IAyrEDkYxt6YA43AYxwScyjorXsuW60aukndXTu3yu97WTWlr+vQjG6bk9EraduV6vVq7S337q1jLzNgHGfQr/DkfxbcDuM8cAck967s6g7geT0xt4yMBSMnIz3P8IPHAOwwBIOORjBPykggcZyCRn14PyjqcGCSzVgdrDceQBnAJ+ZgQM8YwScAjdjo3Oamm17zTaX8vSyd3s27cqb79ztpv+9qknuk1blutd+q73em1zHaQ8ANt4PJI5CkcZGDzn2ByMdBSeaVbcd3GBnc2NpH58kcHqM85BOLDWbbzk4C8EDnGMdjzkgbj1PTjg1F9mwcNztBXJyAeF5479fYdjms05O6vJX003a0UdVono9F0vu9XSqP+9dbu3urSKeq3/wC3ddm73HiYlQPmGRyQeCOATjttzjhsEdOFNSecwABJA6AZGcfLhQcnp3xnHUDPNVCrIPm+6rdGyeuMHaAfXr1Bxk+jRLyMc9M/KRgDHHHbPA5PU9RxTVVp62e2l+nu2u799XdNavdaFRxDuk2kr7u2ism3db6PbfszQ845G4Ec45x1XA4I6c5HQ8HHHNP3lgBgAnnJ5Knj29TgcjvjvVWOQv1A5wWIGGJPcYBzjBP3gD1FaMSlyAVAIA+6vHJA5z1PJJx1AHtXVRlOdruzv3XlfW7a/XbRnTTcpNfDqovbd+61s3Z2t1u13NSzTzNgAdizYyq5wTsIGCG647EZOTgYwfTtHtmWKNejYQjdk4HBGD1wfUYzyOa5jRbDcofYCMY6ZII2kduQNoHGM8Dodp9X0PTmuJYokjLF2VNoXJJYkEAbstk/L1IyQPUD7nh7AVK9WlypOUnGMUldtyaUXone7SW+vTTQ+sy3DuSgmrzmoK1n1UU1ve6TS+d+56t8L/A2p+Mtc0zRtPtpLi6vZ44VVFLly7ld3QABslmONg5AwSDX9P8A+y18CdL+D3gjTtPgtYxrF3DFcapcmNQ5mK5aMtjOyMsyKBjBJ47V+f3/AAT/AP2elsYovHmv2QMrgHTFmj3eXywLgHkHAYjBAB5HpX7UaakdvEuFIfIATadu0A/e45IY5z8uBk8E1/WOR5PDhrJaUHGP9o4+lCVZ8vvUqMlGUKTd9G7RlNX0VlfdH9GcBcM+ypwxlaCu7NKW60i3bTS3bR6mtawiGI9xnBfvnjJ68DgknIOMdcnb8uftZ/tE6N8Avh7e3qzQy+KtWgntfD+nGRfM85lZReTJztggOG3NgMSoJBJNe5fEDx7oXw68Kax4s1+7jttO0m0knkLsFaV1VtsEIJ5kkJCgAnAIHUHP8sH7Ufx91745/EPU9Zup5WtnuHttLsVkYx2WnhysFtEmcLLMoDysOSTycALXmZ5nmH4ayqtnGKaniJc1LLMPLevimly1Gm7uhQupT3UnaGzdvW8Q+MqHCuU1aNGrGOOrUWoaq9GLVnUdtra8rbvdX6WPLF0/xv8AtB/FaDT7QXuu+IPFetgyTHfJJLNdTEtK7gttjiBIQYG1F3AbADX6b/tPeNtD/ZG+B2k/sm/C2+trf4i+MdDTUviz4ptWWO40Dw/cQhr21kuYzuiutUj3wIhZXisAxVQbhGGn+zN4N8M/sd/ALXf2qPidYwy+M9ds30z4XeG7xdl3faldpIlq0UDEy7Zm/f3U4B8qxhdiwaVM/jl8YPEfxB+LvjufQopLjxH8Ufivr6Ta/MJB5i3OpSh7XSTKW22lhp9s3n6g5ZLewsYVDMqLlf52VbEVZ4zN8c6uJx2Pq3k5Pmq1alecfZUKb1anVm+S6u4wU5K1kj/MeUcV40eITr4n2mI4J4QzFT5HeVPP+JIyhKnGXSrhsFUs7O8J1bcyaTRw/hOw0fxxrWp+LfEcMw+DXwrS1lvLYO0MvirWb1pRofhe2Yspk1LxXfQyS3si5fT/AA7Bqd7JszEWs+G/D/xE/ah+M2l+CNBh+2+IfGmsxG+lgjZNL0TTLCJIhsSJTHZ6B4U0qBLWzgQLHst47a2UP5Sy1/iVrGlaTa6R8I/Ad2uoeEvBF1dxLq1qij/hNvHF2Eg8T+NpUQK1xbC7WPRPCcD58vS7K1dRuub1T+s37P8A4B/4YS+Av/CyNYTSNO/aU+OWiahH4L/t9Va1+FvgnSrUahr/AMRPEcUivLHongXS54Ndvrdk8zxF4sufDnheJbiWV0Pdl+Wxx1WrHHVeTK8s5cfxJjKTVsRiIK1LLcM1ZSWqwlCKeq9tWStOx/VWAwGDqVZxxtSOGyDI6Sxuf4uGkas6SXs8FQa+KcrLC4enG/NKVSolaSSyv2pvih8P/wBmL4T2/wCz/wCCTaXngP4MXmnHxnbzKhX4u/tAmKHW9D8F6gEKjUvDnw6mli8efEuJTNaT66fDPg65Crb3Cj+dDxd4v1zxp4i1fxT4h1K51XW9c1C51bU9QuZmlluru8laa4mkPJALykxhAFVMxoiIqqPTf2gfjHJ8UPFSRaZLqi+CPDEdxpfhK01KWW41O8iuLya+1jxh4jnff9t8VeM9YnvPEviS9lZpDe332ZGSzs7aKP5xnvQ7RLDukZmCyNHhhEpETb3aQIqOQyAxllOHJQvtYD8m434tqcRZnUqRtSweHaw2Cw1N2p4fDUkoUKMIxfKoQgkkkmtZT0lJnyuZZpVz3NsTnmLpxw0alOOEynL4WVPKsooNRwmEpRTSVRwXtcTJK860ndtQgy8b6CRtqTwuzfKsfmKWc5Q4UEE5BdR0+6S2flJqoTPKjrIY4DztFuUc7htCvuJGEOG2qvUjJYZzTVcyENGiqScxZC4WPPzOdiAhMupYbso5BPMeaWaXDIrDDuNoZwQoOAdzDaUCjLYIPJOR1IPwkpX1crddHbmu1a2l3Zu+922+5wyadkm/d+FPTX3b2dnfq79dN3oqcqeZNs+0XP7qMPIivFGoTcgyzqAwYDJKEBAzYbhSTUmEyWceyWXzFdD9oYK7tGZAXAywcsqJlgWLuGB68nQkbByCQ4B6rnKhlbzG243bS+enAwvPDGBgVXltzfNIUO5VRthC7RlguA2EZcAd8HFcsqbbb52m1um7K/J8OttFrfS23clRei3tq9bJN8t7d/8AJ6apkfmDbgqC5Co6qyIS5CjAYFi/qQpydhIyThYMMq7QQdgBIYuSTngAkH5XIXHGSFxw22mTylVDuWwjqAsUBkkZiU+cFvuyAbgVODjdncerHZgilDtyqMQWdmZGCZVlGCu4AHcG2qEADAk1Lkotq92ku17Plba1b01vbls9Xe7L8lvFRsrq6Xu3W979WtFq12JNylmjztYpvOXA3DCDPzYYsuG5QcBTyCCBGRNIBtKsqrxgMfMI2FUEmBgHBGWxngHJAITfuJxHtCxuEYjBCMSRwCHXOcAEngnONwNND7X6bYzgsnJbJKhuA25OGULwSQQuccGXLdXVm1211iuj662u1buD00a1VtHpo7NJPTS1rbbLVMSFpCf3oG3JMa5w3OB87M+5g+1ivC4YbWAI204jaChKuFbKsNihYyCgBJLEMrYIOBz8pOcsCNzja8YD5XbwoKrujAIBJ3EDGChXcQcgYyFYkZJJG1MZK4GOOc7W3MSQCePm6gcVmlZaPW1rNXeslu9tdG9b7/DYe99t1b1urR2fdyu2tvmJghVVVbap28ksVQ4ZsgkAkAAhxjO5fl27jUTJGVXcqlSCw3YZixGARgArhQRjIBypC8KSDET8tJJFJulCsrOFkGTtQnBETD+EgnccoONtDjcCRyCu8ZAcldykx7lAK4A75IDnu1Zu7ez0stLNu3J3ey0d3brpo04u1pbT3U2nqrct3d3SV31S1vprZ1tnloY4wwAOFJO7cC2CdzHkspUbjhSo45BqP5PNUK/zEHHzPjOVO3OFUFc8/wAO35RgqdskrIXVSAyKRzgAL90qpDZbb8rlsE4IB45LSKB8xMYDZJLfNn+A8tngNjI2ja3ykgseJ5VzJK9l81slpHVLVO70tZdHrpbmSXXtforJ3XXdXk469LNNtrHcAoxncGGQu5vu5AJOR8xBPAJHqVxTY+ZY3zwoKEBWVfmKEA8AsB90uSWXjgjJRhkbq0IDb1x88ZbbkYY8HaCykE85OBgdaFdclt5Db8MAB5ZxsOzaCjEHqMg4AIU7clW3ZpWXS2jTSTXflVlfby8kyk7Nb3umlotLQtZ3XyvfVLdO5NsduUchg4BBUtGVO0MmCw3k4BXjkYVTlaVpBC0e5hmQ+Sq5CKXO04HykbcAlWbpggEElCyeREQs4Ybo1UBQWIyVKYIypJJJTk5AJUk5NNhIYBJFQOgDAkqVKbFKsjJyeW+fGQ3AYlQSY01Sacmo691p0V3q7vXRbKzRTbWmzbXVrRtW0d+ibu7vVK+ivMkiRBHaVUEroiM2QCWKkKOFTaMOVYkAFSOADiC9mkjYSx48pFCyRhsbuAwZWG1sDaFLhiysQSoXIqxOYmicSBCpKeWMkNG4bcgBQEqNxJK5I2jOWANV5A/mlNj4lBLEnPzEYYYYkncpJQgbuAwDEEVE3KfNFSWsY2kr81rRv3stFo9bb21u3e6jeztHVX6u1t+rVtWnZvazJ7aJpY7eUS4KsJEAUGPy8B9rBMK7owYldzR5yB1LBl4jmRZ4xJIc+UQu8dGDBgGYhSSoUoyZwSoXaOKbtcQtarCsksDSFZUYNtZ2kBVS5ZMfKhcFUAyGyo+YCyzkXQUuNjMDho2BzvQOAEwCwZSQcnMWWyC2BhUknCUXFqSSTut5NJ3XTXrs7auwm9JJauyvta7Ss+a9ltZpbbWto9lWOFfIIBC8dWAIKltvdckqckFmJGeAJy7ABtud2CCQMjlRg4OVOcHPLZKn5lJWqqsSNpBBQhdzAAZ/d/Mqtgom7du+UgDgdWw4op2hgScA4+6CCyHgZRyQOUXOMYByQc5ptR0vfVdEr+7q73fe1tdb7H5zy3kuZrS3RNP4ZK/o9lfz1W826Jw27aQjEKwLAA5QghgAG/hwAeRyGNWgyhC78RxpuLH5jtUqMliWJIAwQQMjAOMMRnQblQrLh2WQpEN24tHuXYWLMW3DOMlVwSFIGRmdXY5XKsjLksFBOzagCM+UDHJ3F1J28R8HABGXVpJyS00bUtHZ9td9ExSjqknpB3vzNXWj92+l9P0askXM9MrgttOT0Iypy4AYFWbO5gQCSVwDkmKdT5YwHJKkon8JxgkbQw+U4PBLBcKDuLfNCDIyFljaGVGKJvCTBVULudhwzIdpVVO3aTu5JBqVTJsxJtZguWkCeXl12j5FCuVU4ICkkLngHGRfNz6NPlaWttrqKtsmnqrXa11a2tjCDi1K6TT1WnWzu7aW6b6t2tayVNAxyJVLR7SIwFJK5wFZyzsjFQrkAHIJBEgyyCeP92pRss33EYqAWBEa7mfk5JVVwCDu29AcilGJoomN1MjlJXYqIiiRRbhtVdgUsCquTw23aGXnaajdkkmtZ1uyuwsTAjK4nDqrLvJWMFiGAYttGFwBuJNZX5baO7UYtSdtHZN2vo431727WOxwcnJXiorXmipOPMldJJK9m7J2tq+yTVm5uEgjyww4Cxsu1mdtzIGkiDELmMOW3uVb5t2CPmZSJH27Q7xMizOwYCUsArFA+4j51BZ48KELgAkKAYUSVp1mkkVoF3MiKi4EjNlC7hGXfGu1gN52N/qsKWUWy6xM2MyBlZpEAXLFVPzxhiEGdv3AgGGORwRSjd80tYR0Sd0m+VRbk1d6O/npbsXpDljFKcvib16tWS0VrNb/AH9hsjskfmMdzeSxiBKHLKp2qXcneCY2ZwGIYkDHI2U7K4+0W8E0m2FtpB2qMeYhGG+UlzFkEEYGZNzbSAWLzdQIiSvLLiaURxsqb2DPtzhAAiBAzqWVjnG7nbipt/lssRKAFRCM7FAlJH7rcP3Y4DMeHJJyCu4qBNOUWppJKN4p2+Jx5Z+et0rq2trtXsSTUGnTfNJ3jJ9eVLmV/u2S0StbZyK2xZWYsNj+Wd7EqVVcsVHzMrMqkfvFIQHDcYwyzknlJzDNBiQPvMjKCmI/3YV1Vd4VwxxmN2bKhWJ2kUiybnt5Bgq0G8op52hi3lmPczZIEkmAQpJG4kEXbcKFwokUnDK0/wAzbgi5CDduVW4KDA4LEHcQw0jrKOui89Hsr3Vle60e1lyt9TFtRhL3fedkr6uO13bba/S3a9tJ4cEMVK8EBstkA/KfvsCrAE4BAJ6gnNPQeU7SGXEcgUCFtgCMrKFMTBtoMigEoykfKw3ZPzJGWVFBC7iN3QDBIQluSQ3qzDIboRgDITjyg6O535OSyonKgSEDYpB6AFyMkMBuAzvpZO+1rJ82trdGk0no9rWerttyL4ppSunGz1u2kou6bVn0cdbdLrZ2wT6EsHwcc8bwdxCYypY/eJ6sQygHIkGM/K2GbjDbc4GzuDtIJGNnQ4zkFcCtvXem9jlwR824E4x8xO0gEk7UIIJJUEAgCpgchcHg4AAHJGE4x1yAeWXAORuyOa0jt+floml9zv5X000WLdnq2k7+TaXX5JPunfqt50ZVAIUliQp5GDwpxklOOTtzliMkjYvMqhW6hgSpcbjg9EOFxkZJG0YBUjAwrFgYUMTFhvznlWKng/KM5bI24BJU53H5kbsJgwUAMWOODgZYglDuJPBzwR904GACACNIq+/ktdL7Ws306PW9rrUyk12eujfXp3e10+t9PNpvULvLhCXYqoySdu3ywFUttKvkMSQD94qMdWGt9zhlVfn2CYMpKvtYuhGWBRkcKQw+YNsAztwJQBz84JJTBODkHbwCS5YHgjPLnI+8DmcAMuCpyxwzMQMEFCC5YcqTkgrg9iCBmrUU1yy68urVtbrd+Wq7JO1mZxqWta1rLy1Sju76pa2Sd11uFsyykrlv3SjzgzBnCrsaQ9JCVXODIoO3AJBwSbrxhFQNIlzNLi5iSNyTFBFCqRpC6lFeZHI8+BQW+UMDyAzQgl4VcfKd4yQTkcq/lhWxuk3DJBBCjcACSCEwjypg5s2lUxSruWaB3JKywnLMrqNuY1IWQksqhgwfVQcUm1faN1vb3Vd/JtLdX26HJOcZScle7abT305b63tZOzsmm1e7eltCwd5NiO6ySEqGOPvDKKcAu7qyMCsiMqnAzk5DHpYXWFzEMO0ojfGVBKRbfmcExhSQx2gZJKsrKBgLg2oaOeNLhovOkQi3vBGqw3kfJUPypju8FSABhs9QSFrqrdFcKViCOCRyihlCkjDbz8zEN1yMnAJwc16dCDfLG70SWrto1G92lq7ab72s3e78TG1YxbetnZ2T+J+673d9E9Lb3dmlqatmAyIYgTnAIPVgQmcooXBGQMk9SccDbXUWNsGIXAJB+UsdwPyqCQSvGc7cqDnGAu7isexijL4yygAFlAJUZ27OmflGQwHJByQxztHa6fArBecYwBjAO1ivysQc7m6cYBQYJBwK97DUlZaN6qya6aO7XK7LVu172VrO7b+LzHEqKnuuZXWno1fe/wB+vzV9zSrBhKkgVj0BXBBdCSRksQGkQDKtj5h7qA3ruh2qOI2UYViowAC2MxkYGPlIByVyThju4YCuV0OzzsJ3ZIBwMEnkc5Ctj5SwAyOCckYGPa/DOkh3jkjVXeQozowYguxDEjLMIwFUZXacYywIJJ+oy3CynKNoO7smru9rLVu/V3av39L/AJNxHmqpwqSc7NKSTd+2ieu/83XpfY9X8C6OzNCWVfl+ZmPccHqx9FPLOBhgpABAH9iH/BHv9lU+Gfhvo3iLWtP8rxL8XLu08V6qZIsTaf4D0sMPDGlMT80Y1MTTaxOgK7xqlmGU/ZRs/nE/Yv8AgFdfHD4zeB/h8IJRo1zfjWPFdwqkCz8KaK4vdYYsDtjlvY1TS7R2+WS+vrQHl9tf6BP7NPw/tPCnhNNXFnDZ/bLaC2063iiEUdjpGnxiGytrdNoEcIiVdiD5fJ8ledgr2eLc0jw1wzUdOXLjcdFUMPFW5vfVlNK97LWVtb8lnq7H8+8N8PVvFnxbyThmSdXIMoqrPuJJO7pPL8DOnUpYWo/h/wBqrqFKSb5kqinblizv/jJ44tfhx8PdRvotv2iO1S00+1TAe4vJwLe0gjUHLF5XRflBIXLAYFfxS/8ABT39oCbxl8TI/hvYait3pXw1S7TWJEkEkGpfEDWylx4hu3cNsY6Yq2+kRyHd5X2W6TIaRhX9Ev8AwUi/aUsvhn4S8T6+Z43TwJYb9MtS4Kan461eNrXw1ZFBzILFpDqdwgJCwR7mwFOP4lblfFHxe+I+k+F7KeXUvE3jvxOtq907szz6pq96ZtQ1K7cE/wCj2olnu7qZwqRwxzSHCpzXhnkH9kZHDH14f7dmslWu9ZqnNJUlrrrFyle/vOo1py3U+MnF0fErxbzKVCpH/VDwzoVMly/laWGqZlSUZZniYNe5bDuEcP3i6ClF6s/YD/gkL8BrPV9W8VfHvxjELbRbC3vLW0v9QXZa2fg/w+y33ibUmeUhRHrWr21nowlyVew0zxMgI8txXwR+3F+0Lf8A7Svx/wDGfjl5phoRvjofhCzkZitl4X0iRrTSkEWVCS3cSPf3ZUBTdXdx3OK/XX9qHxPpX7HH7Dfhf4L+Epv7N8V/GLTLTTWCnydRtPhzo8Q8y4uFT95Dc+IWna5vkO0m/wDEWugYkDBf59vD2jy+JtftbBFZ3vLpVLglh5e4eZIxUZ2oMknaBgEN8ykj6LH1Pb1JSWsYp4ehZ3bp05r29Xd64jEpxT3dKjTezZh4VZRUzTM8dxPiYSbq1VSwsJrWEVCMMPGGiX7jDOF3G7WIr4uLV72+jf2dPArzOdbuYCJLhvs9tIyY2WsZJmuB90fOSqggkZHJB4H9Rf7B3wpXwl8Pj4yv7TytT8V7ZLXemJItIt8pZKuSSonO64Jzhl8o8Yr8ff2Xvg0PFnizwj4PsoZFtby4gju3jQr9n0izIuL+4JXlWmRWUMeDNJETnof6ZtB0Sz0LR9P0mxiW3tNPtILWCGNQixxW8SQxooXjaFULnjONoByTWGcYhZdlFLCRtGvjpc9S1+aNGLV0kna0pL5qL0N/E3NP7Tz/AAvD9BuWDyaEcZjGm+WeNkkqVOSVotU1z1LNK0nTe6Rqlgox0Gd2fVvViSM8cY7jHtWVNIeRkgckE856ZHA7jIHtjjPJuTOFUjORnGW9RznI65bA6YAHJBznGuZMA/w5B4AHGOmOnU/U9uK+NowV1ppdaPo9LOzbaa62eqTa0aR+X5vjOSLhzWUYvq9tE3Z76fO+99zOvJhtY9CucEgEjsBx6dPXCn1BriNVv4rKzu76dtkUMTys7HAXYpb7x9ACQTnJB7AGujv5fMygOQOvRR064457cenzHHA+KP2xPi7b/Df4banFBPHHqOowSQQKHAdFKNvYdSABxnnPUZwoH1OV4V1alKndWbUqkpPSNNWbutfTU/J80q1MdioYWgnOrWqRoUYx1blUcUmkt7N3dlolrsfip/wUI+PUnivxXqOn2l7u0+weaCJFkJXKsyAELwcnJBAIAzkDofwj8fa+d08sj7t5k7gkHLZzjg9QSuGJySAcgH6f+N/jqfWtY1G7lnMjSSSvuLEn5ncsSDkg56gqNpbgkEivz4+IGv4WVMnczMvU9TxgDnO3jjOdxJLcEDi4nzFTqOjTdqcEoRSb0jGMUkrW003v1fdn91eCfBEMry3A0OROfJCdZ2s51JcspSem7vq7vy2PJvEepNe3shB3CNjtGd2Tu28dfcAdOSThsA8e0pYliu49OARnoc8t3POB1OOMnmeabezufvHPzDG45IOG5bkZPPXOMkgcQRhZGVQPvEdlwCxBPPfIIAA6gDaMcn4aKdScY2u3LfbX3Xbv572Wx/cPDeXclKklFWgoqMUr7KCSdu+nXo7rY1NPhA3SkdduG7hvl+rD+EZB4GMdq6a1QsSxJwAcHA54wACckjOOOhAyckA1mW8YjiWPkAEFh25znnHUk8d+5wBg7lnDuKBc4yBwCcKcctjn72OrZyeMkrX1eW4dL2cUrpKOtk1KTcbJtX3bu1d767H7PleDVKlSjbV2unvzNQ5dElqk7NbPbdHofgzRZtY1W0s4IWkluJo41RB8zFiEVQuOrMQcdSSdxIOD/XN+xt8IoPhR8HPDWmywLDquo2qatqh2hHa5ulEnlvwCBCjKhUglSuO+R+BP/BPv4LP8Sfi7oUt3aGbSdDlTV9QZozsCWzboo2O0j95OEGCQGwAOgI/qE1PU7Lwn4bv9WumjtrLSrCaZ2cBESK1iZiCMKAoVe/B6k4r+mOFsteU8N0mo8uLzqcZaPlnDCUmlG60cVUq3k+jVNPZ3P6a8LskjQw9fNq0XFSXs6UpdIpRlUkrt2uuXVJq6ldNI/Jv/AIKj/GdrXT9D+Eui3QFxet/aWsoj5CwoR9nhlAYMEZzvZSB8ig45Ar4G+HWmJ8MvhLrXjaRAusa5A+maASNrtdXczwtdocllJVpJt2PkiiTJUFq5X4k+JtX/AGhv2hdX1FZJLiLVdce0shuLrb6ZbyvGjADhUWGEscYyQW4A59p+IS6fqnjHwh8PbVlj8LfD/S/7X8QOoUQIllClzcGfkod+yOFlcEFC6fOzlV4qmOhhKecZ+5JrBUZ5XlcrK0q81yzrQbbTkpOUr+fkj4viviCNKvxJxXWn/s+WUquCyy2rnX5HCnKml9tO8rRV25LS+h8xfF3VE8FeANB8Ls5A0rTn8ceJC/Pnaxq0bReH9PmJUAyRzNLemNsfurZGTlEZvzOuvFM2maL4lZJlOo+JZI7KW4LZmj0+GQ3N9Fvzn/SpWijlz8riMD5QMN9Y/tVeLZ5xBZOWS/8AFd4niW/tSxVrXTwv2bw3p7IxLR+TpoScox2rPNOVOBhfz7169QysgLCOBFVwDkFgxZ+CcAEg7j02rzlq/nPOMY51ZVJTlztSnJtK8XPZPVbR/F30vp/O7jVpQoRrt/W1RljMZLeSxmYNVJwu7vlo0XCEU3dNOT3OQkg/tjV7TTCCIXcT3xzkRWUOJJssSWG9R5W/ndNKpJyK3PEeoCUuFUQxqpRFXAASPciICMgKqjAACjG1QQ/NR+HlWCxvtalLCXU5GgtTglksYGJlZMliqzT7gGBAKwoWABJrmNYut7vuyScKvX5VxhuM7u+RkgDPPGSvxVaooUZ1FpKs1JPq4rSOnXTXa+q7acsnaKgnJX1bd73bVrOPZStvdt/I52Vt8hYg8MCSeOp+U5bPsd3bdz82MMkYh1Uxsq8HzC0e3gqirhgGUljhS2M5+YZFTKgZlwcBfmy33cBgFBDgjJO7GSMgnBJwxcyrJn7zKuSOSoLHgMM/3SegyucbmDbTXhSabb1vpq9rNR0vbVbWvs0k1rd5zqJWsrvlW9018LTeiV3Z93pruylhsEmIschTtCYAbaQDyT8oB3kFf7xXBwAxsxbhdpckrgkrymVVgGV0GARhfvE8rjmwFHJU7V3AkFvm5IOS7YIXdgAAHHAbgHLAreYxWRWt/KBMRjO/zBt+ZZmYLscKV2NGfmXlhkK2Tsmte3z0i79N91u7NNXsrQ6rate2zbb1V0vdVr97rS2u2l2gUcowIO1SWfKKyttQZcr8zjDMygYUhTk9CRsWYqq8BNjF4hGzOoQbEMhy4I6ttJBU4GVqdS+CpDbizHGSRtDYAKqAAR5hOQeQFYDINLI+GVT8u9SSwJBRcr85X5znnGVB+VS3A+YTLRrbfpr1ikktHvpp57aoy9o3ppd21vf4XHW9rb2tZtJq+5VmHypItu00cfyyRqx3qh2uXiQ4L7NvAJbDkDOTmpIY8BcjcMB4yAgkZNoxHJuLssqEHcSP4cEB2UixCjeUu7kj5srjJI2sgzhiX5TcWUEtyyqdxqe2SR0QthtxG5RGQQoCApknduAIDBhv8zB+YHLENUm22mr20ataPR6rdqyV3d9NROrpyvl01Xdp2StbruktL69bMjigWJmaKFUa4lWSZl3YMhDqWZA6/dXYRtAIwSmDwdmA/NE2NpQo4faFDFWAByWxyM5xtRiScAkMVSJOOeBgggNnAPAB2t8p3NuIB5G4EkAnQhtQ2AQWAKsVBZiVcrzkA5Utk5G0AbQwOM1tBSTjy3VmnZdNYv11tfrffVI46leLg1Jay0k5O+mmmrei1XTpp0PTPBthYX89xPeFVtY4UdpmIxFI4ATKbtxBbCMQyqiElnVR5ier3+naXqfiHUtU8Ry2t5Zw30Ftp2meHAsaahb28YgCT3R2rp1nbvEv2tHWC8uZnlaOGF0Cnyrwkup2myWxeaFmXyVKRh2mDI8YQbyVI2uBG7KXAMoBy1e5+FdDMMz6hdLG8sQ+03V68Ia2s1LjDjtLM7tsQAEs7LtLbiD9lgpuph40vZyk3UhNxlrTlJJcjlbdpNtLZbt20PjsTmDoSnSjKdapOfLhqdNtyvaMUklzWbk781ubXSSTsbWieFNGuZ49R1fToY4zIZ4fD+lqygbD/on9o39z5phsuRFFZZkv7g7t2x3nmt/6Cf8AglP+x7qXxn+MVn4p8c6XJP4Z8LQafrXjFblXktrPTYvLm8P+DYTKoiS812aC2bUbO0WCCx0a2awSIPJdoPgD9lX9n/xB8SfFXg630vRJ9X8R+KdVhtfA/h2WETTahcyzCKTxDqcbrgWNku17Z5dltJdqzljaafe7v7bvgZ8GPAv7HvwKTQrjUdPsLTw7pGoeLPiT41uytvBfanZ2D6h4g17ULqQBxpumW0DxWRlOY7e3Q482aYH7mnh6WTYNVJW/tHGw/d0lb93GcVH20tH70Ob90rpKTTtZSP5/8aOMK+RZW8hwFR1uIs2jGjipUn7T6jh6nIp4ejGHM1WnfklJPmdRPVulZeF/8FNP2xm/ZM+AJ0rwF5V18d/jDNL8Pfg5odqglu7PU7yGO01HxLDaRg/6J4Vtri3Nu20RXGtXOl2pHkeYB/Gl+0xrcnwr8D6T+yF8PLqTxD8SPG+pWOufHXxLaTNdaj4k8a+I5Ibm18IG+y0k8aXE/m6jIzgramISATXOpq/2L+1f+2XP8QviL42/be8ZQu1qFvfht+xt8PdTV2W10S1kmgPjW+06Ujy5rsSTeILyYpuN7fxwmQLZWIPh/wDwTD/ZK1b9rX41S+NviNd3r+FZn1XxT8RfFt3dtZvp3gOO6lh8c+IRq8jR/YdY8bXrN8MPB18jpLaNqfirxRblYfBF0w2p4f8As3C08KlJZhmFGdfEST/e4fL5pJvRNxq4te5TjrL2aTSTq6dXD2SUfCjgX+1c2UYcRZvQo18RHlTqUVVV8Jl8Xu5pyc6qjJ3qymr2UUfff7Evgz4ff8E3P2O/Ev7d/wAStNstS8R32kax4M/Zr0K/WOO58eeJ/EazWPiT4j2kTbbiOy8Yz6afDvhS8RVbSfg94V1zxHHJ5fj9VuPzi+GVxf2lr8T/ANuD9pGV/F/i/wAWanBr1to2sl1uvGXirxLNLf8AgfwKsOzNvYeIri1i8T+I7SBRb6H8JvDNvp8jRPr2nRt9M/tT/GpP+Cjv7WWk+EPAdlZ2/wCy38AjZeBvhX4Us4k0PwvrE1uINJtblLeJUs9H0jXF0WJomIX/AIR/4UeFw0hi2XKSeBa1YN+1B8X7Lwz4Ve91D4BfBWLU0tr2MGyg8b6zO9tL4p8cXXkoI7O78f65Z2mj+GrMs02leBbDR9MWeOLTbqWe6OEqqFCtGnGEpT9lgqT1pRnFezdWS2lTwEW1BtJTqtt812Vwzk2LwVDE5nm6lHPOJ6bxmZVqj5a2AyJctSjgIVG06NTGy5amI5XDZ6XppPR+AfgTxv8AEPWtf+InjDWJB8Tfi2ur+KtQ8ealHKI/BXhO/uj/AMJl8R5sJI9rd60pn8J+BtKRBOYNkWjK1w2mw3/9WH7Bv7FelfD+x8KfE/xd4ZbRI/DeiDTvgx8PNRhCy+B9DvBHJeeKfENuco/j/wAVyZ1XVJpQbnTWuhZ7xJBbRWXhf7GP7JPg/wCEvhG4/aF/aMvdC8L6Bpo0zxYtp4pa00HRYZdHtY10PxJ4kXUDbx2Hh7w4vlW/w48K3IRYAi+Ib+1l1a9sYLP5L/bi/wCC9ulW0es/Dj9j6BplKXOn3fxi1qzeI3ByYZbjwTol3GhigTaTBr+uLHIwYvZ6Wkix3FZZtmEaFJZbgqllaUMZjZtp1JSadSMXbmc6stanKm2lGCfLG8fyPiKrmfGWb18r4ZwtbHUsPL2NbF0V7PAUlFQhClGv/D9jRhzQ5tZyj7V04SVSop/sb+2j/wAFDfgr+x34bu08SapbeI/iNPZSS6H4A0y8ibUZWdSba71uVDIujaUGOTJcAXNyg/0SGUEyR/xY/th/t9/Fv9qfxjfeIvGGuzPaCSZNH0Cwke30PQbIk+XaabZZdAAu0S3cpe5uHBeaUu2V+MPiV8VfGfxL8R6l4m8W+ItX8U67q11LeahfX97cXtzdXEzF5Jbq8neSWdyXYlyW242qSowPMpLbXLkHy4XhjxyI0bncepkY+2epDZKk54Py0cVGhCdHA0pxUlarXkn7WqtG7WuqcZP7CburOUpWR+hcG+EmW5NUw+acQ4qnmOax5ZQp8q+qYJ+7eOHpy+KS1TrTXPL7PJFuCXU7ma9mknu5huLE4eQKuMhicEliwJ4J5HJJ5GcCe+tYso06YUYG35sdMAZySBnnjnAx2FSXGhag+8usrMR1JLlcZxnAPOcDP8JyMk4xzk+h3Kklo5OgAOGBxgquQMjHTAOAPpXkVJVIyXuP3kt0r6ta9Hrf3r6N9EtT+hssr5dhoxhShT9xJRu1ZXslZJ+7feyu7+mlibV7VWIDZJyNxyAMDAxkgHuOBnOOpzWRJqtsckFnIzjbgHjAznA5BPOeSSwPIAEo0OZj9xyucs20n5t3IyMt0JyDjlcKOM1Mvh2Rju8sr0ILA8jI6MQcEnAA64weT8oyUqrW0lezXu+SV+tr3Wlz3Y57TgrRdNaLbv7ttddfu/EyX1SNlJEZwDyMAnJOM9HP13Hoee1UZdSXHCMOQo7BSVOeG9x975cdsjBPWr4ZkYYCEccjackDORjGOeOoGByRjqreFLgA7YywwM4XI3HkkgZHO3AO72BKjFUlVcfhk9krLXV7rS7V9L9GxS4jXMm60IeXMrK++r2v3f8AmcE2poHAdCuANpbOMfQ7R7sBkEnA25NTiSCTDRyLll3N83zA5GODjnPPXOema6S68KXHJkt2AYZyI1GD06YYNnqOhzg4K8jkr/RprfkI6MAccnB5xjG3gn73C9SB1FZVOeLTcXZ90ld2Vt1b02s7Xud+E4ji0ouUJpOC0avrZN32W97u71XSyJ3hViNuPlGATkKfx+9xz0GTjaeRVZ/MQsFB6kHLEqAMDgDgjGeCDjPGTnFG2ubiKZI5VYJvwGLcjG0feJXHIwMdyABk5rcl2HaqANgLnIVscDjCsc4yuMHtwT2zjJSSvrur732Wlrtv0t6dvco5vRmr8/Kvd6p9tmlfa/TZbLQzQoJ65JHJxwBkZ4BIyMjkk9M4GTVefZECGIOeh6H+EjtnIzxkjHODtHOg6iJNz4Jb7sakZJJzzgfKCTzjpk4zjccx7a5nDMEIB7dPlYAD5cAYAH3iT1wBjcaqe2j5vhWkrbtWXRXva19F1vrff+2aEYqPPBuydk0ml7rWkr38359LGNcy5cgEAtgnnBHTqFGcAcdO2TkVHG+4r2zg4ABI9M8n6egOSeCKvNZLEDuBLHPLKe2O27HXA3Zwc8HHNQpEqlST94FcAHOCB2AJzyT1BI68c1lFSbTa3XRaa207rX3Xba21jShjHXel0tOt9Pdtdba+Teie+xetxlgCM8YbOCOqg5H44zkE4yOBiul0+3MsqKiFiWGTjJBJXOB05A78ntgZrEtocuoUthsjAHckZHAx7deRuxkjn03w9p4wrODvIBBOT3BA/vDJAyRnIAUEHBr38pwksRVhCKeju3a6tpa7+7b06WPsspwzqWlJaWuk1d7rS3Ld3Wis72atsdTo+mBViUJjG3OMkHGckEDkHHBxxjntt+1f2Yvg/c/EXx1pNiLdpLOK6jmu5FQELGjEsDkMDnGACSSTkAksT8z+H9LkuLqKJFLyMVA2qWLEkgAA5HsvUNlVI9P6Gv8Agn/8Dk0Dwn/wl2o2ax3WpANb70IIjHpuAODk7hnGCFXPAP8ASnhnw7Rnio5hi6aeDy6MK8217tSrHldKnfZqUradotn6/wAG5M8djaLlTcqcJRl7y0bXLy8yad0rK/XyR96fDrwlaeFdB07TLSFLeKzt44UjUKNxiQL2I3EDO7I4yeuc16m8iWcMlzcOsaxozuWYBFRAWLOWO0AAbuxGCCeSBJa2WBk/KE+4CAMtyehA+UZbHQKSTgnIr86f2/8A9p2D4S+DbjwZ4fvlXxX4ghkjleFwZLCyIKu+VYsjybiqDG443Ak42/r+IxlLFVcVjMZWjRwWHhPE4utLSNOhSSk1F6JynZQpwjrKTUVvc/ozE4zC8O5RPFV5KnTo021F6e0lFRaSTStKUu10r636/CH/AAUL/aybxjr0/wAOfC2oFvD+hzSRX0kMjCPUdQjO1w5UkGCEggLggnhfUeB/sN/s9f8AC4/HcnjfxlH9k+G/gbdrfiPUr5jDZzpZK119meVyEEapE73DAkRwK24EtXx34P8ADXir41fEbSvC+jxXN/q2vaokJcb3KrPLmeeZlJCgBneRjgBQ3PWv02/at+JWhfs+fCrQ/wBj74W6hBZ6pPpUWrfGTxPasEaysWijubjTJ7iPlJb84e6iZt62y2tsATcsg/mLiXPq3FueVcbJSpZZgpPD5bhnpBU4u0FZK3NJXq1ZNOz5pSskf5s+OfH+ccWZ9Q4M4eryln3E1SUKtam5NZLkcXFYrHVLaU2qb5KEXyudWWl2j57/AG3P2p7f4ueM5dd0xhb/AAw+HSP4a+FvhwZit767twIW1mS2Xanm3LwreSgArBZxWloGykufjO1e8+Ffge68T6nPLH8Vvi9pk7WszK8d/wCCvhpqDFb/AFMBT5tr4g+IcbNbaZsCT2vhVj9mAl1yJ4s3wcmi+Ndc1Hx54ttpP+FR/C828Nto5d0k8XeIrsyTaH4SgYfPLda5cwnUfEU0XzWPhy3vQ8gluLTz+v8AhR8O/iB+1/8AHmx8O6Wsmoat4s1kXWrajDbyfYNJ0+ExwXF+sMQMdvpejWax6foVnGqRhkt4LYIGs0HBQp1sVVwlLCqVSviKn1fK4q/K5ztTxeaSu3ywpWlRwsnpGMZ1k4uKb/Q+COFcNwtk2U5DkeGk69SMMLgIcv72tUqSUcXmNaS1lWnUc7VX9p1aracU39M/8E/P2d/CmozeKv2p/jhb/wBmfBb4JwPrkguLcTRa5r9k23TdKsLTCrqM1leTWVnYafCHbVPEWoWloBLIzhvmX/goV+0/4n+JHjjxLpuoS/2Z4l8VQaZH4w0WzuA9t4A8FaVML/wX8ELCWEOGbRPNj8QfEaRWVda8dXBhuICvh+1YfoD+3h+0D4I+B/gvRvgH8JfsZ+HvwPvW0DQIIDHPbfEn4+adA6a94t1Py/3WreHPgxd3VxDbljNYar8Srq4YNd23h5PL/m/1vVNQ1PUbvUr2ee+vL65nub26nkeSe5u7mRpZ7m4lkfe8kspd2kb5huL/ADgYPi8fZ/hstwFLhXKKlsPhpSqZhiaTtLH49rlr1qkr3lCD5qdGOnLTi3bVM9jiPH4dunwvl1SFTK8nr+0zbE0m7Zxn6dqqbv7+Fy6VqcLLlddc126euUzybiQqjcNwwFU7U+YHIbkEbBzgMCysGwSKDs0a744y2JAZFBKH95hyxYHLbSD8pGByqbVG2pZJZfk3xFTlF+Ta0bbjtwhAJyQrMRjDbtmRnLMw20jOcgspI3NhgDtJJ+9wcADHVR0zX4VOSk4rVO1+ikryTV91a+177W6q/wA7KalyrRJKz0t1TWluVXTWmqfe7uU/LZJGK5CvuaRnd3DuHyqxKcRqWB2MoG0DIXPzUwh0zySN/nZkAWWNQGUxxES7TsOCAE2EknAOcOnZ98ZQkKGUuBgrgEHgEjpgrkccg5Y8U0sNrEkKN3l4CgKMbQ3zEEhh0A67jkkDFZWV7NpW1Wu7urPS17aJu19XqiFdWT121utfhS002XVLp3SvSWWASSCIFs58zBcgI3lYJZmCnYSpMalirchmBc1JI2G2KuXVck7AFaNWHVi2A5bIA+ZGwAAzfLSSyMhQIrPIZAgGGRTubcxZkXaSvOCTllYhSeQYTIpeVpAFCBkjbais4wu/dh2JYMWduMcKflGMptvRWv1Vtk3F6LXvbTfS6uCcna9013tdaxafW712Tvt13RizyAqoKbGfO5S6OrjARFYEcqGwTuBJeNjtNRMjMNuAAh3Y2HlU4/vAszkls5Ctj5huLGnSPHG/mORulXyiW8zLNuUblwAQoEi5cfc+YqGX5ahZ0CKxYMMqrEbDjIU4UISrEDJwCSD90no2MmrSvJvVtpNXjqle+lr6Na31erdkVdd9dObV2T03vdpvztfr3FEyPlcnzBhRHsAYJ+7U5TaTjDDHzDGdhwOSFEYxiRSBFllVjlVKhBk42s4PIKqTt3HAPeNlkeVZEYL5cmCQu7MaktJuZSFc8oAGyByctwokmkMUTSbGcbkUAFSWBKqWJbOVUAndlNwB3c81hztKXNH3W29dbtbN3ur3s0mmrLulZ3b302Wt7aJPpe7veyW6XdCbdm9ZH2x5Bw3ChHKkEsRkAZAwMD7u/DDDQRlZFklRiqPjysuQrNGIt8piIR/3hBCq+5dudp4Ip7yhJ44gjPkFmcfMinKqQ5JwCTuIXG0H5iTkUrjd8u4J8xZeMDII2jKkYDHqv3SQCcFxS5ubVNWja9tG2+VPqlZNt6fdokF3dXa6PrzX91K6vp5W011uIzFSXwr7ypUMpJOSpCgsQFIKnCjIAy3Pziq0jxAsruocOpj58ps5VVMeOCu9xvwVAOGJyTictknzOQwHl4GAGLYViHPrk7sA7SQQG+ameUmfMc7tqSRlizYCMAXUBdoDJ91RjPHpVttr3bJ21crO2qSemyS169upS/yTunorq9rrXv56ptJkCuMEKwKqqozY2hXI6qrDDMAd2S/ykFCMfNUxAURDDElAq/NjccjJIGQpjJbn5QAAAM9YI3LGXCMrpJsVcBgEUKS4ZXfLNs+Y7F3YAALhsDyYkjB3Z3EMcEKGwmFIbjDEYXaGbnIxzjOMlbV3d0k9f5ktnrfbp07Kypctr67p22Vly6O7TbtbTta+l7JK5AO1CzhgrIjBSF3Jlip3Pg/e3YXnrtAJqWLIVAAcbVUrlSQcLwQoIBHUnO1eQpIAqsxUyGQOw2IY8gttZd5ClgWUOMHAC7dvBbOcidRgAb2RWVWGMhhzwNqqWWMABAuc544IUnOMmrvRW5UlvtbV6ryba0T3WurWjb0SS0XuuzSi9k49bWVmr+61uSSBCscTqSQ3m52jafLAaNyxwqqzjbgjGPRuCFnI3FiwACgKCowQBvGWIKgNgqHwpCkAnAqNVl3mTaokJRBkMxwGCk7ud4OwsylQSHUOMKGNgRmNXUsZQzZPmRkFY2wv8LbVjBCtkYI6jOMk6tpW0XyS5Um9VtbZdOiZSsrtrSya95rflUebbTfRX8t9UBjcKSMZUjlhgA8Fs5ICEMCCoGwYDAHKmEqR/q7kAlDvysbKuANjbjtPHCKw+6QSeSBRcJI3lxBSQWXJX5AVyvQ9T820rgHcAdoDhizY0YP1UGNQBweNrKqEF2wxQffIBLMoyCwGIerUZX5W0m09nK3NZxdlok+vvdAd24rs1d6q6vG99LddY9V2JInGyVSpfYTGMbSDjZxlsuCW2ko7bgDkEEkGnMsP2tmSPzLhiDNIxD4BMYIjjVlJCvhSygsB8oUkZW6NyMJmcNDIvzDZtUSjlZcGRchxGF3D5gASjgjbUcjb7gEuY1WQKzNtUMQ0ZG6RMMSTlkG4ZDMxzlQMq8bUHpqn11fqnfs9/le6bSkrR0et90rpqy1V21tonrJJeTtsxZZgR8oUA7P4ckITlR8wyOVG5iDk8gkl8smEde43AfKud2F6jcCEXHLDgYPINU2kitI3dVfZlXkRMs7MQpZ0DAoMKrOw5CgFlbaM1OkySiOYNuWVtvJQAEbCxPPDqVdWckA4JUMjYOCnpyXTl1TenK2rO6SXnZrfrrc/PZ05OTqKN4KyTW7so6b/AC06O17WGCBnVFkVoiCpcKdpKnBPYhSpCnezf6vavRWI0UEKbQwwVXC7mzjlRliSdxPdgoVmK9GBNVwwZzxxkiP5VIdgU+Q8g7VHQhiCxHTd8ryMhSCBwjbciRmCupyw2NhfvYB7jBVSwpxVm2tW/tPd3cbrTazUbWdlulfVzNyfLGXu6XUI72ajq3r31v06Iesy5zghSAhyx5wEyxVV3YwcBiDjA3ZPJYshdRKhVo2O0FQMsGwGkUjBRVZWGcPjsSnBFmilzJHIk3QZRw2GBXkKw3HnAYZwcZY4bJXc8YjEil8sVzEuFUNtK/KRlEC7txVUGRkDcDio6uNnfX4lZq/MrXa31Td7rT7nCSs01ZppOMn0WrdtLNd/LRIlJGOEOAAFBQsoOT1ALYDKS20kqB8xGDxSKMgR12bd5ZwgLlIyyyvtckJuVsseC2MrIXQbRZVZQDvkgC4K/uwSxBPyq/RjwpZ3UDPyrtBU1Ra3Nqt2IsyRzszQQAEfZ5H3rLh5GIdWQZK84+UAgksJqc3uu3TVt6pWTXeTTelrrTZWTa0pNax51e6tFu6mtLxvpy29NdX0ReR7chTFsIuT8gWQHdKyqTnkgu24nAJIKkAnAJRlcNhOS43hm42nOWDYQrliuAqkgLkEbc4zFWNDHbRsxb7Ss6N5hVYXJKStHIPkI4CxoqgnHOGGDoNLEqk5zlUUqASwLAKGZ3wOcENuw6BcdTwRmp3bSTSjsly7LVpJXW+l12SvoOVPkd4OTUrvVq9rrSzadraNu2zbWxTmdoBulT7VHLIkcKxoiTIzMqrCA+cgx72DKrEHOGyCQoghuRHM0pZlG4tHchXifIY4VFKCRVl2OBu+cDDldwqxujeRYgPNdIzIo/dlgpCrHKPl4K7iF8s5HyuGUqMpCISg2Rom+XzAqA7hIR8zM+N6BdwKq+dpGcAEYiNPmbjzKUVbSXf3d3o9G2nra2lrs2dRKMXyyjOKupKyTWmruvx67211fDBMgSMP5kKXDFg6YxCI18mMZZHkdNi5JYsAMMH76CLMOHjC7cnIZflCsBuyS4KkDcY1wFwcEsaZA0chfa24v8j8g7CNgwQRkFSQN/JKDliSCZTIqtEmPmk3qCSoy21WO5uoyATGOdzArjnFdEIKK01Ta66dIpXfS/RPTmdu5xznKb1iubR/DrbR62STfVXV9ewRsyBd6tGxlKhkdWEoVdgYnBWEOqOdoygB2cM+5nruUP5ZyGO6Pjny3KhQyq/I6BVA2qQR95t1KFYSEkAo4ZmO1QwII+TJYZBUMVOMjJYHrl5AOFI5yAADjcPl5JIB6Z5BCsuGIBANaxWqTadmnfrZOK32dlfzv13vhKSau1b0b3aTVk72V9X01T3VkQqV425UjIcsNzZ8sFNucEgcklgOGBzyWnRRliD0A3Yb5snGB3A3Z7kqMk4w3MQLHzAAGJkG4hSSFAU/KTgsDxjgncMgAjbUse4lcDjI24JyQCACSQc4zklAQRjGcDNpX7300vono0krffu1tvcxk3q9HstLq+q1Wj31ut+1ne0ybgxC4ckFgQD8rDbkZBUZ2jAUkgg5AwDiRSMKMAZKB+UA35Rl38kZAwTjG3Axld2IQdxOflywVSSTuGAMndjCkq2Co5OcFX4NlMFeC23K9txyduNp2jacL8p9vUGtI2uloratve2lr6q63cVsnu9UzCXRuzsl06PltfTXorbPqtblhUcnYCVOVO884+5nK7WBDDsOwzgVdjTGA3zOQMkYVidq7txBbrxjdkkYUHOcxRsFZM5bIAIHGGxHnlQFJ5JCnJyAR3xeiRWI6BCAT8xHJVeCE4yO4IYqxwpJAUdEPi06+9p1S5bvS/XbbZSOOpN6x001cUrfy7b62a93S797ok54Y13PIFO5gquWZjvK4AzkgAk7WXILZX3Ja8gDL5bxh025bdgrkcBlAwqtk4BGduzJwSMRQIxQbgCQVAPJLEhQoJckbgBgcZXGAAQK0YossikBhnvgDClchi2MsSQeAM85AOK7acddmnt3aTS32+fr3ueZVq+8tb2sk97PTVPRrTS/eyu9SNYhGkkMyGSykIUMXVWhbLlXGOEZM5wpG8ZZmJ+U9Bp8vkSR207iRXU/Z7sgBJkbACzFi+JAEBGSCT8pyCGLLaIOjZCt0QhxkkYVT97BKcnaVBPIJbOTWlDYBIypUPasN8kRyDESTl4CWGCFc4bgYPzDj5u6hTa99aLXR2utbWb1unfR6NX67HiYzERalTlqnfVLW+jTXndLpaXdHT2EGCq4JfkklAxBVlUgtu2ksuNmOcELnPX0PSbdH2/IeSP9lgcrwNoPQ/MN3AOTnFcFpWbdoY5ds0LELb3hYMQu4nybglsB1YAZPQAc45X1fRbYu0RZT9w9UDAABfvD5VLMVOOSBnqvU/Q4Om5OPupJWcrXvb3etrb6rS3ZLU/P86xXLCersk1dXV1Za8rekn5W0PQ/D+nSGSNABIcgLtGSoUBufu5bjGeWO7duIAFfS3gXRPPmgBjO3I+XbkKOCGG088KQM52BhnBrxvwvZeZJEgjkD5G/IbBxjJGTjcSpAJHAxjdyW/Rj9lH4J6t8a/il4H+HGkpKk3ibV4be+vI97JpWhWgN7ruryEbdken6Xb3M65JVphDBy0qLX6LkGD55xqT92EEpSk9owhZtt66JJvrZ3fmfzT4j8RRy7BYmq5tSjTmrX15klZJWu3pa1k22kviR/Q//AMEa/wBlaW18Jr8RNV08xax8TryOLTpZImSWw+Hug3L/ADoeWjXxFrEM1xuBCy29lpcyZUg1/Sv8RPElh8NvAd7exoiizslgs7aMBTNcOogtbeIAEhpJ2SNQo2jO4jAJHkP7KHwu0nwP4Msp9O0+PT9LtNM0/QvDlqqBRY6FottHY2cScYyyRKXbrIqJIck5Pzb+3h8etL+H3hnxLrN3PG2mfDzR59auLfeANQ8RXSG18N6UABlpJruVZnUElUCykYVjX5tm1apxxx1hssopzy3LaijUir8v7uUFO9tE5S5aN3dczcr6tntcOSqeB30feIfEPGWhx14ltUckjUS9vCnjIPD5PSpxk+Zwo4eVXMpxjrKDgn70Yn80n/BVr49XPiPxxb/C231AXMPhOefxD4udJC0N9411tI2WFyp2lNE0xorSJQT5MlxcggOmBwn/AASc/Z0T4g/EXUfjJ4ngK6Dokl/omj3V0pW1Sxt7Y3HjrXWmPyokdjcWXhe3lOEebxFqDIwbTpWT8/fH+oeLfjH8R47G18zWfGnxH8Xx2sJ3Fpb3W/EGobWZ2yAsML3StK2FSKBXkwY4SR+8Xxi1DRv2GP2BrTwd4Yu1h8Y/FTSk+HvhO6CrBqDeFbcTXXinxTsO2aGfxLPqGqauw8xyj+JtMj3gWKhf3nEzhhaMKVJKPs4Qw2HUVGKp1HBc1VJXt9XpRqV7NbxjH7R/LlDL8TlvD+TcK4bnq5vxFiY182rOUp1KsK9anUxk6s2/aSWMxdWGF55NyVKdWTuoO35Pft8/tF3H7RP7Q/i3xFZXBPhTRrj/AIRfwVaqxWCDw9orta2tzHDjZH/aUgn1SRQD892FBKooXD/Zv8Ctf3J164iJLyC3s2YBv3SkvcTo2Cc7FCKyjgswYcZHylpVlc6/rdtaW6Ga51G8WFAN2SJHAZgw4YKB9dobH3Qa/Y39nr4X3d7ceG/Cmj27Pd6hcWWkWZC7mLzOGvLth8xEcaiWaWQHCCNstggV5GXYd4rFcyio4elBWTekKdKMUk3LpGMbPVNPW6P6yy6lhOCuFKmKqtRhlWBlUlNpJ18ZOHNKVrq86lRuVk9JSVt1b9cv2BPhSmnaVqnxFv7ZUe/J0fQmdOFsrWQG+uI8jhZ7lREHXqtuTltxFfpg+MKOgOQT0HHTknI69jgD8K4z4e+E9P8AA/g/QPDGnRJFa6PplvZrtXaZGjjXzZWK7cyTzeY7njczMemK6u5YZ3HdwoIBOR3IPGMcHOfU9c4NfG51jXmGY1aidqVNqlQXRUoNRglfROaXM7dZPRM/nRVqk44vM8U5SxeYVp4qs5NuSdVJxgndvlhBRprZ2j0ehnXJ54AyflxwOvU5A9TgZAGMDJbK1gXs5UMQ2MA85wSBxxjJPGMnHy4ByGrSuZRg9ehxnggDvjvn/a6YIIzg1yt9OWJUEEY44Jx0yTk7QM4AAw3UOM8C8FRcnG+vK7vS61aa3Semm2zunofnWfY58k3dXnd93bS2qT7aa9WYWqX8drb3F1PIsUUMbySMzEAJGhbknpkq2c8EcYz1/mz/AOChPx9bxV4r1HR7O8JsdNeW1iVZCyEplXOFzjO1gCDjG45GSa/ZP9sL4w23wy+G2ryJcJDqF/by28ChgrAFCGZcYJ2g8jHPAOc4r+Q/40/ES413VtTuprhpXnnlclmYn53YkkgYycj0yONx5NfXRqLLstnXlZVsSrU/hvGkmtr62b213j8Wtjs8JeF6nEXEv9o1IOWEwFSMKbcW4yxUpJyadrPki7N9HNq2h84fEDxA0k93KZGblwFyVwQGz1B+UADgHAHXIr478Uao15evhtyoWAxnaSS2cAcYI6DtwDzXrvj7XNscwD5L7iMEhwxB4znvnH3uM8DHA+drmVnYux5YliTzkkHHBOBgDoQduemT835jj67rVpOTvZvmfT7Nrtee/RPc/wBQOBcjjhcPSahbmUEna/u2i307O/mvRlRiMheW3YyeQDzk5AGOc4HJyRnnrWlp8Ku5fPyI2F9yducYBHUEY5IO5vvMax0UM/GeTwR0HTGFB6kngevcE89bZxeXCgwcuo38kkZyehPQ7T16noMCngqXNUVS2i1u735tNNtHZPbvvof0dw/gE3T933IxU23s7OPLayvvrqlbV7arQgi3ld204IwcgDqCvUg4Jxx1XPPK4PcaBp8l3dwxhMmRlUKuSSpOCcnOe+eRkDk8cc5ZQ5C5XKk5PXJJ4wNoHQc4yQSO/UfXv7L3wovfif8AEnwz4dtoJJUv9QgFy6pkRWcbB7qViM7QsAfnn5iAQc5r9S4NySWaZrg8Kot+0qw55tXjGK5ZTk7p2UIJyk3063R+rZJgJYzF4fDwheVWpCEbLRuUo69bN3Sdte9rH7v/APBNz4Nr4F+FyeLb61EWqeK2WaJ3TbKunRKUgUZGVWVi0vBIK42jGCNz/goz8a1+Hfwnk8LabdiLWvF5awVY32yQ2YGbuQYYsqbCV3YOMk7icZ+5PCuhaf4P8LabpVnHHaWOjaZDBGigRosVpCq9AQMEIS+RjaOSa/nE/bG+Il/8ff2iZfDmjzPdaVpGojQNPSNi0IMLK17PgHCqWRmdgP8AVRPtKktX79neIjTp1Y4OL9yNHKsrpxWrlLlowmlpqoc1RvT3ndpvf+ms7qx4a4Up4DCtrF4mEMFRUdHKrWsqs4pK7spOz6Nr0a/su+F4dD0TxL8V9cjKQWNpdLp0koC7jEg8x0LH5XZ2jgiOQytvLHeTlNBjm1nSNU1e9Lfb/ibrt3HdTu217fwboP8AxNNckVm3FIrmNF09ePLd7iIJtPDd/wDFQx+HPA/gr4O+HP3V5rF1b2lwsYAeVVnZ5nYREkojtm4Y7g037tQVhYjz74r6ta+BPhL8RPF1rIkVlo9hZ/CfwWUcKk1+kSS+Kb+A8DzJL+WO3kki5B04rvwua/NuPq9PL6eXcN0rcuCoPEY6en7yrOPNVlKzs5cvNFbtKa20P5m45qU6uY5DwamnRwTqZ9nslrF0cFFV5QqO/wDy8rckFe3MlNdLH5OfHTxaPF3xD8Sa2ChtFu7iKyQEiGC0tSYrSKNQeEjQKqqoCq2AMDAr5Q1Vpr2eOxg5ub66W2QrkMnmFTIxxyFjBDSNg4CMfuKSfStdu3FvcTO58yeUhSD8xKrvcDofmYYbHQk5wa4rw/AXu73Vn2sLUNa2mcbWuZQWuHQlcfuYmWMYGR5x5BPP885lW9q5Su069Rp/zcra5mt0vcSS2Ts0lpd/mOLxEpzr4io/3mKrzqy1SSjKUVTp6fCoqyXa99rssas8NpClnbAfZ7SBbeJAcnbCoTcSGCgy4JYnJOWyCeK89uSHdmABy2O/IJUjIXI7ZGSDyTgLwer1WXzZWxgAklm4OQDgYyeRuLHcOuMEZGK5vy1yXI5JG1QcZJK8nJAGO2cgDLAjpXzeLknJQW0VolfRPlXZ2a+ytN2l2PNlXdlLS3Lo9Nm1o1Z6NpWelm9u9BIlUsOOfmIJA5IUKT2AUfKcADkFcqVzHJGxGOVAAU4HzcCMAtg7j6scZVcEA/LWkECgLyTgHJBPzYBYYBO0AE5XnIC4xk1FsU8oOuAWxgE/J84JAyw53EbgAdqrk8ebNvR9Gubt/Lq1fTez79uj5J17Se6V1re75bR1d+m9klq9NmjPaPJAH3l2ucFj8gCFuOcZ4LcgZAB2k4CqrE5ZSMlWU5UEjCckuzDcxzyMBhkkA7SL4QYBA3EMExjcuOxBOMjOV3AE84Y5OGckQDHj5QGGSgyOEG7jIwBj5ODu5X5SWqFvf0WnZqKvd20Vt/Nt9Qdflto3s73j3S3v16N3vqr3TtRiGedxYMuVQLgqzLGAqEFN6HkYPzMCAMYKtYFtuwCzqhwxVTgJkouACCwBUbXIJIAGOSxFyO1PlRg7i6eWdyl8ld5ZScnLD7uGIwy/eKkk1a8h41BEckisyrsGdzEqpLcqQMqpG4Zw3yAEEClyt+t7tNq72003V1tbrqu+DxHve60l8OzV7NWV+reza0VtbbOsljG0jOyM0jrtDlixCfLs2L8vzAj7yqzMN2BndU0NjhpvlCMZCux3VlULt8oIAp27xwORx0YEpnYt9PnuHjjijaXblEVFPHyqoJyWQD5icEnH3lycMeu07wtcS7DcusYBUpGD505JAyCRhFO1dobjkAMvQ100qEqnK1FWS8utlpvrZ6Rvdu1na1uWtjqdNWlVXNJRvC15PW6SSTd16O/SxyMFsSyHyhlQvBViW+4OGOdxJ5Un+IHcCzKG7TQtAlu5YpJ42SPcCkLHa8mFXI4XAjyPmJBAG7AJwld7o/g0SNGsFrLJMxQKWBkuHPyjheQvQFmwFHJJB5Pr/h/wnbadcRLNbf2pqskqrDp0IeeOKQ4w14YRI9xIoxm1gVlQZMzKoIb3cHldabjL2M5RvF80lyQTfJbVr3ktNN7q2p42KxWJrxlToUppySabfK7Ll96TbtCnpdyk0kn30KvhDwUZjbf6KGuLjCWdvtCQqpPzTSuV/dW6KA0s0xQGNWy3lKxP0r4A+G1r4i1BJp0uLzwb4cv4or2aGIxzeMvE0oAh0vTCUErWMJLQxTOAtrZm41F0ju7+2t10vA/gAXQ/trxheXek6RKrpDaQxbNc8RyRkf8AEs0iwBWSzsFx++vLpBCqAkJM6LGP3e/4Js/scD49eNNB8YeKvDcOk/DHQ5nfRfDkEci2V7Y25WW5tbaSQeZPbTTwpFr2tyFpb5rl7Kzd5LmaQfqOTZVg8DhpZhjuXlw0FVUeV8knFKVlzWvFKN22rzdoQSjzN/H5vmuA4QyfMOIK9aGKr4am6cK8GnhoYyqlTo4PB1HZYrHznJQiqN4UE5zqy50ox/Q3/glH+ybL8OfCv/DQvj7TI4fHHjixFn4JsGtxEvhrwYIlhe/0+3dd1mNXiVbTTEARotDgNwNj63chfLP+Ctn7TkPjO+b9jvwdriaZ4bsrOw8VftPeKba8EMOj+F1hbWvD3wwk1DOyC712ztn8VeLC77oNCtLG2dTFqVzGf1U/a/8Ajbpn7J37O/xJ+LK2Nte3ng7w3FZeD/DyIYYda8X6u8Og+CfDdtbxJlYbrXLuwjnjgQiLTo5ioVIuf4oP29db8V/C74RaZo2ranca18Qfjtr+r6x8XPHl3dx/2trPi2NbPX/iNB5cdy8y2b61q2jeHoEkhggt9L0Q2FkFgaSNOnK8PDNZZpxVjk3l+VUvaxg3f29aclDDYdSVlrKScrRtrKVo3dvxzwJ4IzPxB4k4l8S+KKLxOTcMYiOJlSqqU4V83ryjHLcFGTck40LwqTSfu8sJy3Z8TeM9X1v9sL4/6P4d8PW93p3w+8PQf2H4X0qxtJJE0LwNoyxQz3tnp0YYf2zr0scNpYWMeZrzVb7TNGiZ2Nug/a39tf4i2n/BPf8AZN8L/sW/DmO20v8AaC/aL0nT9d+Mr6JNHJfeBfAX2aXRfD/w8sLy1ZpFW0sReeFrW5341HUX+Ini6FFfxNBMcL/glb8EvBP7Ovwh8cft2fHCyFt4M+FHhqDxpZw3McUc3iDxtc2rj4W+DtGWcAXmqW/2q18WxwAfufEWufDfUpFCabM6/mPoHxAuP2qvjr8d/jd8XNX0tvi3rmm2/jPwBpet+I4dA8Orcab4p0V9Q8N6Zd3kohkTw18P7aXSfDOjn95dW1vceSst8VY8lN1cTmNOFbERWPzitCWJqykksPR92p7OHN8EqNCKjSp3spyg0lKnY/QsHlVTxY8UqGCxEo0+F+DcU6+Oc37OhmWeqnGpSwak3yVKWESU5RfuuoqcJJ857DoDRfCz4Pn4W+AdQa38c+M573wNrOqwpAqtq15otprHxnvbG9QeeI/C/hy70D4ZaebWR5431TxzFbCae7EI+8fgn+0f8Cv2NPDmi/DrwX8B/HX7SX7QWiH+05vB+k6XLF4S0HxTcTTDSf8AhJr3TtN1q78RXmn6PDZ3djNo1nJp9ub4wwXVs8fn335L+I/Afxn1TTfE/j/4YQ2ms/D74UXWv2dx4mg8S+GdJ8TW2qXfiptf1TWtP8J6zrsHiGV9ZvNdspIrvSbO6aY6dCbJ5FglRPm/xX8c/wBojxLNLJ4g8QfEHX2kIjkTW/E2p3sMixrGiedA99GkwCwxqpnRtwWPeDggY5hmdKhi69D9/Sw9FPC4NU6bkvY03pOnU5l79SV3KXI9ldOzR63EfDkeMMXmtJY2jQwzxsqNbB0q86co4WilTw+DxMaKjVdLkUalWnCtRlOU5Wmoylf9e/2ivE/7av7Z+s/2t+1Z8efg/wDs6+ALe4a70f4b+KPHdro2heHAzBopV+GvhWbxP4t1LWFjmTOq+L7KfVZCXX7TDGDEnmnhj9lL/gndpAiuvid+3rrXjG5DA3tn8J/gr471G2klUfMIda160SCUDohfSjGiBQlupYsfx01Dxr8WFLmDTb2yU/KfsK2dk7BlJAaWDe79SCdwPJGOCTxtz4q+KMshkn0ae5J/iubazupQ2ennO6OAM7cHpkk5JyPma2Y5dGrzTw2IrSV2nNTqWfu3tGCpU0tuW0O113wwHhbiaWGjgqHFeIyXAwSUcFw5lGW4GlbRNurjI47FSnJX5qrxF5STk0mz+ljwj4d/4IjeF1hi1bxV+0z4yeNQHlvfDuq6VZsduSxt9E8IaXMIztPAuSNpOGBJr2K28Yf8EFI4hFP4f+J0ZRQGmutM+I0UmVwNzO+qquTxzsUZwQrZCj+USLxb8R0BYaEg4J40+yJPUHIEzKThiFBU88HAqVPGPxKU/JocQ4JIGnWIAPO4jawIPJyRg8nPAJrthnuWuMV9UrRStdRw0ovRJLdtJX1vs7nHW8CMoxU3Kvx9x63dXUMywsIpqSfw08Ola6fTdpabH9W11a/8EHtciMtjqvxI0sYJK27+Jg8ZBX7sd5Ff/MOGILdjtXIAPKf8Kn/4IiayJZ7b4s/FLSo42Ksk9rcsy4ZASsT6LvbbvjLEgn5lypbp/NHoXxD+KWmXVvew6DYPcQspi+2aJYXUW4MrYaCR2hdSwBKsjbiACCBXrl5+0r8aNR09NL1P4ffDa+tUwBI/w08ORXJALkE3lskNwH3Ss4ImG1yXUKV+X2MLmfD9SnKVdYmnUS91LL4Votq1m5y1STe/K166264eAPDzw81DxJ4+wte1oN4qOIhJ6Wc5RlT5dbbU7p38j9/Yv2ev+CK14W+x/tAfE5zEC0qQ6BqcpgAwSXEHhq4CkFiMlVGMBSDgCjJ8C/8AgiJA5R/2nPiLFLwoWXS9RjKspG5Qr+D3k4O3cFBw2T12k/zfaz488Y6rJNcP4I0/R7qSV5ZLjw3a3ehSv5jKfLKwX00HlgrkBYVY7ixkLcVBpvxg+KvhuH7NpllqL2zHLW2r2ej+I4X2MhjIi8RaXqIUKY4wQpCEAAqRuzxVc5yujNOOFdSCd1N4SkpOzjvCVKmtNLe9a9tWfD5t4F53RnUWWeI3FGMhoqftsxlhW9V8UnRxFpKyu+RJdL2P6Uov2fv+CK92qNB+1b42sdzBFkvNJ1Dyt5wEAZ/BZUn5lPDDBzuUnIOmP2TP+CRmoIG0r9t4WDMcA6xpM6IN5wpYT6HYJ8x6lXK4yQjfdP8ANJc/Hrx5da6viO/8B+DrrVxG8M0bfDzwNDouoRNJ5jjU/DVr4Zh0fUXaQGT7S8cd+rbTFewNzXMal8SJ9Wuzdt4FsvCjFIVki8I3Os6BYOYwQ8jaRe3usaaHmYB5FgEUQKhI4VjLA8kuJMusvZ4SDba5U8PGD3S6Yaadtbrm7ayPFp+C3FilGM+NeKopxinOOYYfExhKyX/Lx4dtJ6xcYO99Yxeh/U9o/wDwTH/Y1+KtwND+C37Znw48Z+JrpJDp3hvMEWs6i6xmURWlgLuK6vLhlUCG3srWeeV2Gy3cYFfiD+2H+zbe/s8fErVvAGqTW95LasHt7y0jnigvLVyDDdWyXKpcpDIm1tk8cMkbZUxgAmvDPBHxs1TwXJ4U1bwfZnRNe0S9ttdutd1Nbe51D7bbGZILqwlsls57OLyFhE0ERkE5iE0Cx3eXr7vb9nz9p/8Aa4+J/hu61bSNMW78e/8ACJQR6pFLZWGgeHn8XCa68O2esrCGk0x73Tg95Z2Edu881lGkoBBZV6as8Nm2Dq08NgXLFRlSanSpxUIRnrNzlGNNLtrFOLUm5Nbd+R8H8ZcGY7F55mHE+MzThTLstr4rNHj4WrYSVJqUa0pU3JKm0pPm5km7RUb2Z+WCeFbi+uPKtYSyq2HkAZlXpgE4bnrgE8445OT3ln8LdZkhRhaXKoQD5zI5LduFxvJB6bgc5A6V/af+yv8A8ENfgd8Grey8QfGq9HxX8UQxxSLokcU1j4PtLoIru0iFkvtWKyArG07WsJQDNqdxFfXXxp/ZE/Zyg+HXi9tM+DngPTry18P3psLuw0G0huLXyYHeL7PJEkbo67VIcHcSCzMcE1hgOGKGKnGlLGpVakkoqnCU4xlJxXLKpzRXV3ajJO2jaWn49xh9LjC5TmCweS5Nj8fhY1FGeOlUhhozvKMHOjSqJ1Zq1neoqTXRWaZ/ALD8MktWLXEbM/ViyP8ALgZJK4OSDnqMEgnAACjI1bw7b2YK7FUjkMSGHyt+GM98YHAx3Ffe3xj0XT9E17VLa1tUiWC4ukVRGqAqrsoyuTgHaAcEg844zn4m8ZXIDuDsAO8LjoFG4t06HoeMk8HK9K8nH4GGDlUpKzlTk4uXdqyurpS36bJH7twjxVmfEccLipVKkIYinSqxpuUrxU/ZtJu/Lou9rfl4ZrEMccpCqvUAEZOMk5OSAOcDGecBiAACTz6xYkDYAIJYKy7lxlcDOOpONvYc88Gtq/YyztuJOW5IDA8DGT16cNgEDJ4zyKjggLOihPmLBQNgLMSASM8gkjOcZO0ADBIJ8qMOeWl9ei7aJbu97uy7Xfmf1Bw7RqulRUrydo3b7vlvrq9Xdauz2V7s0NIsTPOhwPKVgSvHVsEANnaDlTxjGMkc4r17SLQDadgAO0jI6k7iuMjryeeBjnrxXMaPppiijGCZHwXPXBIycDjPGcDtwxOAa9a8N6LPqV7a2NtHLLLNIkaqqglnZ8AcbiQWypxgE8D0r9K4WyepUq0KcISlVrThGKSbd58qirdb32b+09z9lyfBv91TirzlytpK95NxSVtLpL9O59Wfsr/CDUPid480bTYbZ3tluopLmQxlkSFSWYlsYA2ocYPGR1YZH9TPgjwrY+FvD2maFYQrHBYWsEIVFADlVAJGBkc5z1JIyCAwI+Dv2D/gHB8PPBFv4m1S026zrESPCZIwHjhbJOC3KFty8DoAADX6Pxz22nWs13eSiG2tommmllkCKiKhZmLnAGBuyTgqgPI61/VeHwP9jZXhMnox5sTPkq4zlWssRUStRukm3Tjo03Zyv6n9R8E5JTy7AxxWIiotwUm5LbRNt3TSW/e1lbqef/GP4neH/gz8Ptc8aa/cxxx2NrKtpbs6rLdXhRxFDFzlmZ8b2GQACAON1fyRfHr4reIfjH481nxJqlxLcXOsX8rW1srO32a2aRxb28I6r8pVAqgEYweTgfcX/BQf9qmT4s+M5/Cnh6/f/hDPC9zNa2yRSbYtTvIm2T3TBTgxqyssY5UDaEyxIPiP7H3wIh+IHiO5+I/jhUsfAHgxG1nVbu82R2s32NWuBEzuNpVFid5BkhEAX55HFflviLn84048KZdVbnKUaua1oPR1UouOGk07OnQTvJdajd9Ipn87+Pvitg8ly7HVJYi+EwUfZ0KMJNzxmMk1ClQpQWs51ajhCnFK+vM+qXu3wW0fw9+xh8BNT+PnjKxhuPib4wtjpfw90K5UfaxdXcbfZZhEwMixRq32u8lUArBGkQPmSqD+UPi/U/G/xO8bN4WtruTW/H3xD1yTUPFuqXc4CrdTs+oSxX1258u00nQrLztV1ueR0trS1hcSsscWF+h/2tv2hZviv4yv/Git9m8F+E/P8OfC/wAPuxSAi3PlPq8tuAFEjGNb6dsELsht1YmDDfNl00/wp8ByDUGli+J3xY0uO71x2yNT8IfDK+ZLqx0gBzvtvEHxMZodT1Fgsdxb+EWsLPdt16+Ufk07Rp+y1p4ajT9piKkXaSw3uxdm3pXx9ROlTvf2dHmnpHmPwDwk4OxeGhmPGvFSlPiHiFxxmNdR8zy3LP8AmDyig2nyy5WlOMfiquU5JqCZS+IHiHS5otC+G3gKSe48GeFJLmx0S4RHjuvF2t6hJHF4i8b3tug8x7vxBdKltoVq+9rDR4tOsyxFrP5n7HeBbG2/4J//ALM6q19B4c/aQ+OvhW98Qa14kWKKfUPgv8I7Jja6x4wjjfb5OtRreReFvh/ZM8Tax8QdZS7Vms/D8yv8ffsDfBHw3ZR+J/2wPjtZyQ/CL4ORR3eh6X9mE934z8amVLDw/wCHPD9nMpGo30msXOn6Vo1sEkF3r99bvKGit7jHyt+3T+0j4r+J3j/xRY65eQr4h1/VLDVPiFb6Xdtc6Vo1zpNu9r4R+FOjTK4jk8NfCvSZW02Zowqav4vufEWvz+dJc27Q+njMy/1XySedYqKpZxneHeGyfDJWll2TcipqtCO9KVeK9lRlpKNFSnFvmP3XH46tw9lSx8HGlxHxFQnhslhD48oyVKNLEZkoaOnUqxvh8E2k7uU4u12fKPxl+Jtz8R/FMl7BbNpfh7SrWDRfCnh8TSTx6L4dsiVs4GklG+61G6d5NQ1vUHAuNU1e8vdQuC0lya8SdxlgCCOecnIxtJYgqcEAkgscIwYA8cJdSOZY33kxsGLqACVOBIrKS5DF2Vk+UE4wEx1qrIsYPmgEEqUbbuIdcsylhlR8oAVHCnb97YMHP4BjMZUxEp1JtycpylJy1s5Wfu21SW3TTTyPgKFOOGowo0k1GG7lzOTk2pSnOTu3OUm5TlJtttt3d7wSsJQ8cjSQyDbsI25VtpMcihCrOxOWYYAPOd2KpI8keyOWRZCAryTrhUdj5YUMzu+x2IYMuNhwMYJdzI1xFK7wl0eQSEbEcBkcbQoG1eOHOfmK5xg4ZSZHmnSG4ijceXeRpHcgrwTGzTR7QWR4mSQK5MbKxUbB8rsp8yVneUXttrdNrl91pO100ru17NbPfa61W+i1725b3s3a22nLrpumQyMCeo25GwbDnnAx0xuBzjcMEZJUCqZAJLsPlChdoLjZ9zeeFXcCCAvO5SAWyflGcNGnDFpdUuHVWLgKH+XkhM/vSTkqchQobCHIxspzaZIGx9sutrbhtUyBwvBZ2Il5YKQxAKYwJMMDg8fta0m26FrW+3Fu75bt6eXRaab6ApNq7jZdXeO3u20WqVlbsns9Sdw/lSP5TSlQpjjVpEeRU2tGiMwIO9SzNnDRkhgGRQtQBbgMxZGTdGjL8q5V2CEwuyEl5WK7mDIFwdquqou6FtLOQGvrok8AEsygEAAjbIwXOQGJzu/gC5IpG0iM4LXNyXT+JmfO4EkAKXG5snjqvzDoOmTnWumqdlpb30tlFpqyTvZJtXtonpdhd20WllZp+cXe7ve3m9NO5KsLKVKKzFkMchYSuI1YOzuTujBKlk+YKsijGQRtZQA9VVkQxLj5FJJDAKBtUgAlQUPJ6rnjNRDT7Y7gZrgjJR+SQcgZfAk3EcHGCAMYIxiki063aMBppg+0gYZ1GD5YA8vJfLA4wx2t0UdxXNU2VOMddf3iaVrOy00t0d7u6vtq05W+GNtGrNbqzs+rfTTe/pexGUIcgEZO0/MS24lSQBjJOSNo2r8vzBgwxTlJOAUboRkAcx4Az5hBOSePlVd2SrDdwa39lWjfMHuQDuLAOBzuOMEgFs5XA6LnDFjkBg0+yxjzrwAOylS6gqTgBmBIBGMMduCvGQNorK1WyvTSTdr8y95+7Zae9rLdq66Oy2E29kt9VdLR8t72WnbS+nkWwHZWKo5wQpGDznk8YyCp7EFgcAlicCOS28wEuj5Q7mO5l5ABA+XBbLBOCSp2hQ2Tk0pdIsywCXVxFhwjKNshcAgFgxZwG5TawCAYbCkGpf7MtRwZrw4HBDlieRlsIxIYZLBVAU43FTjNLmqt2dKF4q2k1d6R6W37XlbV2sVdq6sumjk27WSdlouqu7NuzsrLWyVYHdtzyVIwOhbc3XLbRgdRuGAHJzmoJEAlDMW+dCpYlgrPhQm0no+0qNuCBgtuGMmomn2hMiyTXkTRyYK+bEW2qAolXLKH3E8ZxjkjcVGSPSLNgWknuvldgAXjJXIIDOG3MMZxww3YxwcgjqVZaqnF/DdOa6Wu9VdXu7vRrTzLu7L3eu111SV9r3269OyY7BLTKqiR5l80sY2CxKNqBXbcC5B8wLtAJfnglchXedsnyqsQZflCAt8hy7bUPzgY2rw67QCzg1EmnWm1sXN+gDmMqNoBjJ5+/tXDdWbGCQwZFIGUOm2pAU316ziXAHmKxAXGejYAx1JZfmIAjBIFRepb4F3fvK2jT0dveTWy1VmJNpJJO6avrZWVm+13211sKSxMZVVzhV3MgJIJVjgsV5wuUjYb2DA5LcgI2KgjBEgZT86kAgbfMLbSECDAPOFG351Y9GDR7Z/MZr24IUsYwBwcYAO7jBOcRhSUZhkSA4Cyx6bZsQwuLpwPkYMQGLMR8xBYYCsSA59MP0UVmvbbOmot3svaK97LbRpWWut7WTsh809PdV7payXL087Xs3um9upYQSlw24cAhxtIGCVyMLkOSAPmJJyuB8rZC72QPvQ7eQHYKPNBChOMEDDDPQAgbjtqL+x7UFd1xd7fRZVDE5+4AB0AIDcE4A5wSaaNO08yOPNunSMHdI04AJOBgKRn5dxC7srkHJxinetFfwopt31nFqV1Fro7d2t76Wtta59Pdd5be91tHTls159N/srQc4UbA25SCrMzMY2IQ5ZE2gg7lJCKr87S2eMUPD5qZk/co7CQt90+Xv2hfNBYgH5ZQSgVVXDDJY1EbHT4lVzNe9P+e3z8kDC8Hby3JbGCMZ64q/ZLGXDI9+23nc1wgWMIAdrPg7WUHJA6ZycHGBuevNCLla6ippaPl3SV38um70DmdruC0ik1zXdrQspWWum+qTT1bSuteTasayRjc6AFVClmdE2/LnLkvt4XIJILPzlajNnDcvFLcrcoVxwkkcak7lwTgr5gMfl/ORmRgR/q1ZhnG1tI0D+ZeCFiqxE3SbFL7l+fKj+EAjhjt+baxJBBpdpJsJn1B1LqVdpITGV3KMKz8MShDKAclSSxUYrCtOo4OLpxlu2nNWV7JP4Vfq77bA5vVSimntd31tFJt2u00rfPzRs7pIoQsTeYQC0buRgloyrhmyybSRtVGHzEgggkkSRPKBErKjvtUHyNgjjGUGJQxI43kuQFyXUA7VOGR7RCAwAJOQoLFtw2gKWK4I5KhCASQQ3Rc2Y3BztU8qS3D/Mxxuyw5bdwVDbCCPmKAmueKdlqkrJWV3tZWSf3dXex8LN8qlaN/eu21e7020Wi6W1e4o3jcj5faVwQMEkbeCRtj2gqWC5Oclg2dwpr3ESBPPVm3MIeMNtaXGGK7tqrgED5s/dZVDAk2wFIwdrb1wByMM3GcdFYZyAcnJ+QkHirgZwCcBwFA+UPjG0kiPaCARgnBwSMq4ArdxaWjfTdX0921+stdLWVtG0r2OeE4trm+ajo3ZLbRqOvXrrbclkVGeBlVy8cgxFFIsJRTGqM8hUKHEa88cKN24EEmrER8qMFiMk8hTgElQDs53FEDnIY7lO7OQVFNWNHLEnLnDkDLDJ+9uyN2CGJIJzgj7wbJmbJIUk8ISeoB4xgKVIBKfKBjLA5zkAU4QsnLS7slonblUVe60v/AFonrMpqSUUm1fV7tXs2ttWt/n1GtKpVvJIkIXruLoSCrncQApYg44ZccAbuQKck4Z0gBdGABAJVMsgUfMyk4Zi5jJJCsoGHDNgyvJ5a7VTCK6hmRRjBAAIUcScgjdtU5I+bIGW8O+CBuUnlhjHJYgHaNzNnJTIB65LY2qTvdbWsmuiWnMvO77J7abFQio68t4rWNpK93y7taNK+yS22etonSVyFDCJQWBYo0jYV42KoCgMaleXZmBB4YLgVKkoDeWdpkEYJT5UJHyEnzWLhwz7QDnfuGDn5TT48l2kA6RbGUNIdhADbixOScnGcErk5DADEFw8jRyNE210V/LXbk5kZSwOY5MFRh1OwgHbtyMkSly3aT2vJ6aqKV1bRbJ+V2lZlqSk1CyS91KS2u+Xd66K6bv59Fok25beaZFWWeNY3X90WeQsyv5bs5jwkRUllUKpUkPuwpFq3SRfmmO6ZogrMgIh+4nyqgC+WAVYFsAZPrgVTt0nhiETMZ7dCZpJrhC06OmxXiTL7JIkYFipwcOCFDKDU25w0YMUhGSNgBba5IKkjBTZlZCAuNoG5iuVUqFlJNxaSskrd0tXZWvrbRK6jfbZTjo4RcZrWXMmuaSXKktb8tnutXd6uystFTHIcDkq6BiHdWWQEOeFAwgZiSSCTgggMAanYE+WocxsHSVwqgkqvyjjdwCeGIOPL3AbnYmqe91SSRld3wCREcEgmNiFcLtcAEuW6sSWPG4VMTKDGEiVwOJSzbdqgxMzKu0BmGHAQMVI5BYFt3Un7ut7uy+0rLTdarTrrppp34mpcya2d0uZq20b2em3RNO/n0tKCApUIpY71DAg4G0rjO4EKAoBLjccBgc4LcOOjEsSA3XknbnhcDGQD3IPQdqMMF6HfjkkkH5QoYbQcKpJHBHzYByo6SIr8AqSMfO/JJJ2jIOMgqABk9CApY4NaRd3ZpPS6e/RWevffTXXa9zFtJPX1v8nfu7O3VK276JVRSeBjGDknqPlPqcnsxHykEgnIyLGBty+BkLt5Py52kYzkkEnoWzkjIB5McTIFVoyGVgFTaT82CoOSF+Xa2Rgg4AzjgYmx5YLTKAcE4DN8oBUYBUDJxkHswAIIAarUVK19dL36K1ndrona1t1d7GM5O6S1fRbPaLS2tdaddbXtd3bkbIJGBjAcEktwVBC8McrxzwcHLAkFqtKqhVZj/CCGD4UZ27TuwEPODtIyxZuucVDbvHIqSR/PG4yCMHf93LDaADk5XJJYYz935asCAS7VKqCrFflMgzgjDZVh5hOIyG254KYCsa0jFKNlqmk9W1f4Fol1t6q2++nPUkr2k5R7+VlFrR6K3Z376rVWkGQCclQcMBlhwVOM4GcbThuCOpGc5vQEJjgtuxgj+A/ICoCgkY7qThdxIOelBJNlw0Ug3fIs0TbOoB2yo7MSGlEiAhschh1KsW2YBg5AODjGAeo24IIG3pkYwDgEgqSAvTThdppa3tK9r9FLW6tbTTtfurcNeTgknq3GNnfTaOura02s9U9lZ2LcIJdgwIIIwQRjblQCWOck4OTgbsMowQMa9um5l6ZCg7j6HYBknGT6EcnO3G7BOaq/KFDFXYEKwUMctt5UEZ6gZO4+uMgkbdovC9SdoLZBOWAQFmILAk5zuBC/MSRjJHoUlrFLXRauK7xtdPVu721X4X8WvPli23Z2Sbd9LKPvdknp59Vtc07eEMQME8qMZIwcLgnGWUg9VOORkqQMnp7S3GANuc7VADZJLbMrgBhyPmbcfdcjgZtjCzknBAGMr8x/uckDuegJO5QRjIbnsNOtWJUsFBIUqpOQnCA9CgLEFtuBk9lzjPsYak7xte65Xr1vy2j5X0infS92lZHy2YYjli25W7Xae3Lu797b6W87l200rcW2xlo3yHgLbkwN5LqSVCsgxjHJPHTBb07wzF5MsFs+JLZjsjn4aSEB+I5iTg4CsAQdwzvA2ECsTS7NZDEAGBYEMw+8DwF25ILryoJ+Yjbgqxwa9V0DRS7iaJVw0iFkcMwZSnLoGKYbk4ccqcEYy+PpcBheecFFSvdadl7u97PzS1u3ezbPzHP80hTpVIynok1dO+unldvz1u+tj2PwXpJlkgK7UVjGQ20bWPygHIUqBhWJbADAcEkDP9WX/BGP9mS5fSr34t6jYsmr+Prp/B/g13iXfZ+ENMukl8U63ATjYuranaLYQzKV3waPMqkpdFW/nf8A2bfhLrXxW+IPgr4d6DH/AMTTxdrtno0E3lmRdPtJJDLqepShXIS10rTYru+uiq7VitpMLyC3+hD+xh8H9E+HfgnRYdIsFstC8MaJYeFfCkRUKU0vSYEtZrl+m64u54jJdSkF5blZ5tzGY7vqeIczjw3wxiMQmlisTT9hQi7KTnOMUtPdT1ack1bkjJa2dv5mw+TV/FDxS4d4KoKc8v8Arcczz+pG/LQybBVI1K7lNP3HiHFYelLX97OCejZ9W+Ktb0n4afD67uTst7PRtMPlxrtXOyLZHFHzy7vtVB1Z2HUmv4+v+Cr37RV9fX+n/Ci11APeSzt488eKsjOn9p6lGU8NaLISVB/s3TyboxNyrXNueqFq/oZ/bm+OeieCtDv4NTvFj0PwhpVx4u8VqHGZLWwydL0wLkq82qagI4Y4WyWJQgHdX8MXxo8f+J/i/wDEfWfEN4JdU8UeO/Esk0NrAXeSXUdYvEttJ0q1QfOVgSS2s7eMKWVEhRQQcV53hVkMsuymtnmLpt4zNJudKU1ebpuS5HezacuaVRv7XNTktrnq/SC4toeIPitgOE8rqQXCPhZhoYR0qLSwks7dOmqkbJ+zawFGEKCW9GpSqq6U7H25/wAEt/gLc/F/42XXxF1WB/7G8HM+g6JctuVRrWrWMs/iXVopDlFbQfCxuoLec5W31bX9DUhWdBXDf8FNf2iI/jp+0Jq2keGLhP8AhAPhfA3gLwhb2r5sZk0uVYtW1O2RSoEd9fo8cLRAeZY21nHuwm2v0yvBYf8ABP39gu+/s6W3h+JPjHTpPh74fu7dlF1deJ9ZeW5+Inim3kUhmS2vhPpdnccAWPhvQJA48xdn85tnbXmu6zDDHvuLm9uljibJaSaaV/mZl6nncwB553DJ5r7bM67qTcI6KClh6VtpTcoyxdVes4ww6a29hU/mZ834ZZQ8/wCI8fxPWi5YbCzjhctjJe7H2UHCg4xbdn7OdXFPlTjL65FO8qat9Gfs3eA31XWJdcuLZvLs9trYsy8PcyAiR+eWEIJ6YZGKg9Cw/pJ/YJ+EySXd98QLy1As9JR9G0EyqNst66D+0ryMk4IjBS1VxtwXnUMSGFflF8A/hrPp9joWgafbGbULy4s9OtVVdxn1K/kjjZyRhnCFuTyVjQ7jgLt/pu+E3gSy+HngPw54Vso0B03TYY7iQBR594yebd3D/wARe4uJJXJbJIYDJ75ZlX/sjJFTV1isw/dqXVU7R9pLyTi4x135npun9Z4sZuqmIy7hKhO0aSp5lmvI27qLj7ChO1leVRJ22caWukj0gMsaKvAIHpgE49j6kcHGenBrPuZgx2A7SOoxwOmQCemBkdMdgAQxqxLIFXJA4B4I9flYjvjnn8BWLcShQSVHOVyMHgZJzkg5ycDHB59gPz+jTTkn9q93trrG6/JPXzW1j8azXFezpciaSUVFPtGKjbzs2ujTV31M28udqsThW5wAASqru55GcAhSSB1GBk7QeN1G7FtDLcyssapGzMxK8KgLFiSBznA+Y5PbrW5ez7i2MY28c8nB5HBxznHyjBw3XoPkf9qz4s2vw0+GesXKXCRahd20ttaguFYEph3A6ggDAIznqTg4r6vLMK6tSlRSfLJ3qPXSGjlfXt56Xeh+R5tiKmKrrD0k51atSNGlBX96pUlGMUrN7Nrba/3/AIn/APBSH4+t4l8UXeg2F3v07ShNDsjcFWdCVLYBU/Mw4YkYAZhnt+A/jfWy8sszsTuLsCzcqATuBAOdw+6Cc447MBX1N8dvHk/iHW9UvZZjK1xcTyszuXBDMwDY6hjngklR1+bv+f3jjWCqT4cjeX4zyMk/KNoxnjDAgE8Z3AkVz8S46Lk6dNNQppU6autIwSitmk23q97u997n9veCfBUcpy7A4d071ZKNSvUaS561RqVRvfq2vJXtZb+Q+K9Va6u2j3kqGz1/vM3Yc44I3dDyQcVw8wYjkcE5yAM8Abvm5LdW3DnoD1Xm9cOZpXkdmbcxPORySMgcHAGcD0HvVNlZnyAoznA68Aj7wBycg5x3HAJwcfApNu7bXM7u7tfVd7tt7a2XldWf90cN5co04RjFqFNRsrJpu0e7emtlbl32sOsYGeZSeUTDHIxgDpzkkE4JBKtkDjBw1dhboZGCkgY2j8sdN2eSTx05OeD1ybK3ZIizAISMg468AemT7gblAYbRmt+xTackZHJOc5OQOTnAwMYJz6DjJB+jy2g0oK172lK632s9dNnbs99z9pyjCKhRTatOettNLpNJ6dFve9ldHV6TbtPPGmM5YBQFbk54XBOCVA+9gleSc81/Q/8A8EuvgcNO0jUviXqdmPNuQdL0h5IsP5fzG6mjbAGHIRM4AG1uQSwr8MfhD4TufFfinRdHtLdp7i/1C3tkRULFnndAgAwSe4zz1zj5Wr+xr4F+ALL4cfDjwv4XtYEiXTNKgW6KgL5t28Yedn2gHJkZi2cn3JXJ/ongLLll2U4vOJxtXxF8FhLpJrnipYipG+ulPlheOn7x9rn774Y5M6+LlmVWDlSwiXI201Kq4q3S3upNpq1tzy/9r74q2/wi+CfibWUlSHU7+0l0nR4w2JGvLxXgjaJcg4iBLAjqwzjB3H8Hv2YfBMupan4g+JGtB5WjnntLKeQBmlv75nl1O5Qt8paCFhCrk4BOSR82fq7/AIKRfE+68d/E3QfhPoMhu7fRLiNZbeF9y3GuahtWNGQcH7OmGZRyn3TtOaz/ABBpVn8HvgmbGBUiuLHTWWZwNv2jUpPPmu5GxhirToBMx5aNFgzhmr7PLoqpj/r2Ii3g8jw9Su278ksdOMZ8zW8vZQXu9pbWbPsM4xccfn1fEVpc2WcOYedSPM1ySxaipN22fI+7btFb3Pmm48T/ANq+P/H/AMQ5wZtN+HulNYaEEKvDJrt8Tb2qW4bO8o7vgjEo3o7bTKwPhX/BQHWh4Q8HfBj4MwybbzS/Dz+MfFShsNN4g8QObqV7hQdzSia4uyd3zFGAIOAR9GfDzwLcXek/BXwTdRub34l+N4fGniTzF/enRLKWW9AmJ+Zo20603nho8qSNwAJ/NX9uX4ht8Q/2mfiBqCThrLTtWOgWQBDRR2ukrHbBU52hC8UjkjbhGAOWNfzjxVmdXHVMyzKc26uMxUsNTb2UKklVkn0uqajDayVlsfyjTx8s0p8Z8WVpXnm+bwyDLp9sHhKkqmJlTd3eM6kJJvZxnFabHxP4suJFaO1SEpKkEUJQElpLmZWYuwBZTI4MZZVOwBlA3HIp4iXTrCCyQgtAjNM/I3zOSZXyQCfnYpkqSUAGd2CIwv8AaGsNcTYaK133WSfl8x2ZLVQRwMBd6g8YXChVAAW+dssrj1J+YfMTyeR3GQASASPrx+V4ureu7XcYxUI6pauzlJ97u62vp2PhcZinUxPs76RlG/klyxje3ld+e9jlrlS8pYjgNhQCCTggL8xzyM8gjnIBycE0NrMAVb5vvbtoAAGA3UAMc5HA5IZW5XJ13jDZ4OMMSTngkqcBj0UZwSo6j+8SaFtyQGAKnpnacEArgAg7+M5Ykg4wSSc58iouZuX2tvvS5o62vpvpd+S0OatVSXKntpfa+kUtU72el3tddjGZB1OSAyAjAY8sPmwck85VjgYI46k0NE7lQFUH5T820FhlAi5PO5h0IABB6ElTWylmXcLHE0p2/dVWY/8ALMEFQv8AD1UsSF5JJGcalv4bvpdheOO1jIBJnYB1DbeiKC5yQRztJbPTcBWCpyna0ZPXWSjd9Luy2urKz73ktNeCriIRWs0tmtVzPVbRvd+7036aN3OWWBn3EhckMAdgJYptIQBjzjtlQGwM/Mc1ZhtWZ1RIjI7AsVVWZ2YlANqoAvGAQS25CcdA2fQ7TwrACu/zLl8cgbYoBwBgkHewyFOCVDDkryCelttGghUIHigXaAEgTawAP3WKkO3QAgszAjJJ4J66WW1qjjaOndK66PV7K90trq9r7nP9YqVHH2NGpNPeUlyq+l2k7tWve9lfo9zzS00G8bY84S2ReFEoDylcAnEUQJViFIO4hSc/Kuc10tn4XgG3Mclw4ACtJ8qgDHCwI2WA2YCuT94lcHIHo9hon2mSKKzsbq6kcjaqROC7ZP3FRXmPOPmABbhQRhceq6P8N9cfY+pSWXh63Zchrv5rxo+pEVlGz3TADGEcRKW3bnRiTXu4LhypWac046pNKLm9eXRJKybe/dWundDeExM7e2xCoxlyv2UG1OTvHRWvUbtZNLmu7XR4zZeHJgq5jWBAMEnEUajgbdvDHI6gnGBtOTivQvDfhG+v5fL0zTL3UymNz2sOy0j46z3su23hXBILvKoCkEMOp+rvAfwbm1Xy/wDhGvh7qvjS7bGdf1tbttItXJXdLbadbTQaW6ocMq6lf3mWKI1szNtPssn7PPjJ5IIPGHiTSrCN5IkttAsJFu7lSwUJFaeH9Dj+zRyMGVUQskb/ADB38wKa+9wXBOMp0qeIeFcKWj9vjF9Xpact7TrOmm2tuRSWi0eptTynFYek8SsFDDUEuZ4/M5ulB2cW5UqHMpTTW/tJ0ZLrBt6/LXhrwPdzO1ndX9np8QYRz22isL+5Y94ZdQjYQSylg0UdtayTmRz822NGkH2d4K+GL6Fodp4f8O+Eng8UeIlQrIFOpeMtbhuHBiglZI7tfCuhqu4ulpbf2zquVWMSJIJ4/tz4Bf8ABPP4h6tbReKb3RX+HPhKGE3E3jPxzblNdmtFXzJn8P8AhllX7NmMF4bq6jj2Lh47hWAFfo/8HPgdpNhqcPgz4B+Gbu/17URs1n4ka4gm8Tairsi3OoC/uEli8P6UUZt9yB9quQFjt45JA0g+hoZbhcPCVWviKOI5Em/YU4fVqMYWbbqyts17zilC21+n5Hxtx5w/kiqLF5j/AGlUw6VSeAwa+rYGpU/5d/XcYnyypaJLD044mvNWtGm1zHwt+z/+wdNc+JNCuvitDd654q1h7VNI+HGnv9o1a8DfNCniCaJmTw/osMeGksIStybVS11OOAv9V/wD+E+mfBjwNaaWtvp8Wsz2dsuoHTYI7axsIoU222jaTHGiLDp2nqzKpUK08zSXUgLSIqct8Av2bfCfwV0xtQPl69441KMnXPE9zEXn3OoeWx00zNJNBYh/vO7tdXzKJbqRmWOKP2jXtUSzt5XJCqikbtwzgDgKCeSWHIHbByOtfL53nX9sOGU4BOng4zj7RwTX1icGuVdP3a05YvWUkm4pJJ/xtx94lZ/xJi1mGZYtUsrwFNxyfJ8PFYfAYS8be3hhoNp1XF8sataVSqo3babUYfk1/wAFINTtviZ8bP2Qv2e7m4J0HVfGfjf45+MrcM3lz6P8F/DT3ehRTwrHIJbca7qv2sROjxMbDzJQuwSL/Gb/AMFKvH174i+OdjpMuptreheHPD9qNM1bes1nqp8T3t54lvtWsZkihM1veXV/LaR3QjHmWlpwxKqB+43/AAUy/aU1O3/bu+Fc/gLXkt7zwZ4fk+HWpX0V0Y7b/it9Y8rxRpMlyjfuI5tDvTZXEqMTBKWD5aIMv4k/tl/AvxTbDTL27F3dL4NTUvhw97exO2o2Vp4Y1CWfwjpviyIb3sb6/wDCF9pt54e1wr/Y3iLTlzb3S3Mc6H28RHE4fg7McqwV5Sp5hg6mLpwjdtU4QmoScb2inKN07LmjJLex/fXgBi44fwB4YoUMO6cs/wA+zDNc8r7OpWlzLLKVZ2Vo1MMlOHNa8oRcVpr0/wC0J+0n8a/jL8Jfhj8JfBv2m8+A2k+d4z0Dw54J0K5vLNfGWqx2mn6hpvxAk0K3u7658S+EobB9L0KLXYorG18PzWkmgmaJpZY/jX/hT3xjvCZT4A8XHGTvbwb4sOwFSQ25dDJBwMDlcEBRj5c/O91pvjDTPNW2kv4YnVY2NtLMqyomdiNJbMm9U3cI4bZgFQDjbzk114lgZt97qQbaGIa5vyxPIJIeU5JAA6lenGeD8Bjc0w+MrSq4nB4uliGo39lWjToqdlzOEXSc4uUvea5r3bbbuffYPJcnyqFZZXg3hFisTWxleEKcUpYnETU6tWcovmqTlK7cnZ9E7KJ9YJ8MPjHZgN/whniQKDgE+FPF0YUAtgsy6Eo3AjODuII55PFRvA3xRlmZJfCGug8swk8PeK8k/MATjQ26jnucjgDPHx/LqPiJ23LfaoAeCBdXg44wTmYn3UHHce1Rx3viVJF26lqi9x/pl2CD6ECcMPXgD1BGa8SWOouoorDYqUVazeJTa+BLTk7tO6srW177rC0m+Z0aabs20kpStypNtPfVatOW177r7Ef4afEdxl/COrHcW6eHvFrbiSwOD/wj5wQwKtj7zA54GKqT/DH4gxLuXwfrJ2YLj/hH/FowSTyQfDigD5cAg7VzgHLA18trrXi2MALqeqAAEKftt3zyR0+0K2B16Z7YLcF7a940/g1bWFxwdl9fgZHOSUuFPBycnp0PcDZ4/CWfNhMQ5NK0vbLdqF7J03s72elklKzdjSFGjo3QqJuK2qQt9nVpxSv/AHbp766tn0Nd+CPHlmm6Xwlq6KdwDHSPEoyMc/M2hIM5PzLnPrgEZqL4b8YKdz+GtTiCj7z6b4gRSuGJ+b+ysADgENgnse9eAN4l8fQkPF4i8RxH/plq2sRKPvcZS9XBH1JGOc06Dxx8SYJtw8T+J5AMMEfxF4hQcEfxRapG/HT5WG3IweBWVPG4O65sPjoxaSb9rBrZL/n22n03fMlt31hRpNt8lWC91L3Kcr3as7Scdd27vTRpo+mdI8GeNtSlS20/R4Jb2VikdjLNIl7K3BURWV1DFdzHByPLhYNxuYYJHsWn/ssftXazardaL8B/iBq9q6iRbjTPAXiDUISjDcGWeHTGRuGGArZG4FOHQt8UxfFb4mhGin1TV723brDfeI/GF1CcA/8ALCXxEyBt3OSmQGK9hXc+FP2k/jh4PJi8KeN/F3haIsDJD4d8Z+OdFjJRlcFhp3iKE8NHGQxbcCoI2k8+1gsZkSTWIlmUXJLldKolFP3bpxnhpKT22mlptZGGJw1WVKSwuYPCzcbx9vlcMRDmdkrunmNCS2eqTdvs30X09N+yj+1tZxtcXv7OvxTSIMTk/DHxO4IVgGII0gAFSVGCeMEtk1xHij4Q/GvwVp8up+MfhN4t8NabEGZ7zX/Amu6RaRruCLvnv7K3iUF2CAsQofgsBkniZP2vP2rPtTXMf7RHxztY5CgNvafFzx+yRAvkRr52uTNgKV2q0h5G0sVBroLj9rj9qXUYrPT9X/aM+NuuaZcG1abTdU+JvifU7JjHcJIq3NjqGoXFpcIJPn8qeKSN/mUBlYCipiMpquSprG72jNulNvaztLkejV7XT08tfhMR/rtDF2UuHsRh95S5cZhqskmoxkk/rCi5XXuvms+uh5fJ4guUVdthpuw/xmzVhtJ4GQsiEkHKjec5GMZIrv8A4X3N7r/jnwvo5tNOFlqer6faXgFqiJ9jluAb2bcocIsVrBK7OFQhVJeMKQ5/fH/gl7+yp8Fv2y7L/heHxm06P/hMfgHd3Gu69e+HLfStG0Px9puonQ77w1qfxA0yHTk0a9vdLt9O8SLstLCzS903TLeDVVvWZZ6/LL4V+ANC8cfG/wCIcvhkRaX4Y1Xx3rPhbwtfSiOEafZeOtc1PS01Vkt440iTw38P7fxP4nuDbxolrBpIlVIohGh6MLks51cHVjiPa061bmlScOSSowgq05T1sm3eNoyaulZtNHzfDvHODz7i7iPhfEYCrhK/B+Eo43P8XLlnhKcakalfko1FyurGeFpqvCUoU5SVRQcVKMorC+IHwz0iD4seB9C0VQ0/jHw54W8W6lpn2ZLW38Onx/e3Wr6RY20eJp3SPwXd6NqRNxLNKHvXlZi26U/0Af8ABLnxfrHxe+Jmj+F4VvrvR9M+Neka3Bqs0pWOTwZ8I/h3e6b4Rs0jhREeKyj1TTFeVldWku40BxIUH4S+ENfi+IXxD+OnxzsbI2mm6Pp3iTUPBVuYtltptjc20PgX4bWMSv5kcb6Tps+lCJCo8v7PGEKeYM/1P/8ABEb4GT+EvD974r1a1VbvRPBWi6a7iMqq694xEev6rHk5LTWOlW+i6dKSd6+TsAWLyxX1OAdLDYXNMZTgoUXRr1FJK0ZXksLhba2TqVJVJuzfL+f5P4rca43LeCMyyx1Ywr8QUI4HF4eMVdfW069Wg7WvDCQq04RaTbjZ3ve/7xalGUTaeSB8xODliN3IIxyQSpAAz6E8/L3x7vBpfwx8eX0yoFh8Najgsdo3S27oBzwBlhgYOcgEZOK+p9TlUPnGSAcgcAkNkc4JweecEDnOM8/m7/wUQ+IFv4E/Z+8UZl8q41wppsSF8OyktNIEyCTtWMe+T1BIAx4b53XpNp2TdVt20UFzt+TSWjtrpfsf5sZ/gY4zM8Hg6KTniMVQw8Ipe9J1JQhG2r6yu3pold6I/jX/AGhNRjk8U620brhbu5YbPlUN5j8qev3iAp49ApbFfnl4wvt88oDZ+YgDJ+YbtpbcSBheeQD23ZyVr6v+LutNc32pXTymRriaVzk4+Yl2JOBu2/dGOSpweoJPxNrdy1xcyuSGBZgAemQSABuPUjH4Z6Yr5XO6vtcXWkrJOo3undXXlv09Wr9z/UbwmyV0MuwMZJt0aFCDdr3koQWi0enLstXe9+pzyqXmycZJI68HcT/CcgcdwTzyMYrqdIs/MmDgfKnAPO0sMZ7YOBzyeMAjcTgY1vCGYZHBPUBj246cAtyeO+FwAc16boVhtjiXYecO+ecEg5CjBBUcr0wM+gOVlGDeJxNJNOyalLs9YyWmt7P8NUf1/wAO4NWg39lRbst9FbWy6u3qrW0bOk0ywJ2BQCMZIwW554Y8bQMgE8gc5PIFfp1+wp+z1N8Q/GFprWoWhbStOljmkd4yUPlsTxk7csV2JhiASxABAr4f+G3g298XeI9K0Cwt5Jbm/uYrdVjQudrMASAOpGc5HXJIziv6p/2Zvgtp/wAIvh5pGmJaRx6lPaxTag+BvMjoGEZYqDwDyeNzbjjByf6l8PcjhhKcs+xNNWwyVPAwlFJVMVJR9/ezVFNydrWm462aa/ofw+4elmGNhXqQfsqMlJza0co8rUb3tfo7HvOjaVa6XZW1laRJBa2cEUMUaIEAWNdowF4AGBtBHQjbkBSPze/4KHftT2/wz8IzfDXwzqCr4k1+2ePVpYZR5mnaZIAHjDIf3ctyD5eGO7aTjHGPtz46/FrQ/gj8N9b8a61NGsltbSRaXZsyrJfajIjrBDEuQWIbBz0ChyMDLH+Rf4z/ABS8QfF3x/q+u6ncS317q2pSSuu4uCZJCIbeJASRHGAI41AztBbGCDXu8T8S0+G8nxGZ1Zc+a41VKOVU5NuUZysquNaetqW1NO96rTWkGfoHiTxdR4byaeCw1WFPFVqLUnGSXsKCSUptu1nKz3bfLd+ln4e+E9f+MXxA0rwzpMUt1Pq19GkrqrFIYHkzLPK6jKhV3O7nG4pxuzk/dP7V3xF0X4a+C9J/ZT+GN9HZ2elael/8V/ENo6qFxEk76S8sZIeRzmW6jJDB/s9ucgSiqXw5TTf2Qvgdc/E/XbWKf4r+PoW0zwNo8yA3Vu1zH8lz5TAuscAk+0TN0ytvb5zJivzb1N/FfxH8YQfD/RLxNV8V+NNWn1HxbrV7cAW0ExEupaleavfkmO10TQLUXOp63dzlIrWC3myfLJVf5zp1q1Scq+I562LxtSLnHWVapUrySpYaOr96tL3pPeFNSlpdM/zny+jivFnjv+1cRCdfhThnGujllGavSzfPIyjGWJSa5alHCSbhSdnGVVuX2C14M0/R/EF7q/xV8X2Al+F/wzmstN0Dw9KTGvjTxlch7jw94QVVPmTxT+Q3iLxhNHt+zeHrZrSSSO51SyMtz4K/CHx5+2B+0Bp/hu3mudQ1DxRrbav4t18RF47KwaZhqOpBVUxxpEjDTNDtkxbxhYYoFS22Fef+J3iDT9bu/D3wx+G6Xl14G8HNcaL4STyTFqPinU9UnRNf8bX9sg3nXPG+pxqbSEiSbS/D8GnaUHMWnxCT9VLfQNM/YE/Ztm8KXWorofx8+NXhCbxT8TvEdk8f9t/Cn4P5axu/7Pdf3ll4p8VtcHwT4GgDI41XUtZ8R4W30aJm9jCYLD4mdTE5hNPJcmmsZmlaMlCOZ5nFL2GBpN2UqMNKFNLSFCNWp7rqWP6hwdLA06dfEZjO3D3D8Y4nM6kP+ZlmHMo4fL8Pf+JKtUtQpRje0Oeppz3Xin7c/wC0V4T+Hvh7Qfhd8JpLS0+G/wAIZL7wv8IrCyZDa+MfiZp0d1o3jP42XrfM17o/gC5l1Twp8PLlhJFqHi2XXfFltNK+nxMn4HX2oTXc89xPIbiWR3luJ5W8yWaSU7nlklZtzvK7sxdtxLZzknNeg/Fr4lz/ABG8VXWuXKppenxW1tpGhaFZw3X2Hw74b0uJLXSNEsV2ZEVlaIiyysWmuZ/Ou7gvPPIz+SSTwEJ++ddqow/cXQ3KMEFm2YHIReTtxuJyx4/FOL+I8TxFnOKx1aacOdwoUotKlh6EbRp0qUPhhTpwSjCKStGN9XqfDY3M8XnWY4zOsx5Vi8bOChQirUsBgKVo4TL8PFJKFLDUXGNklz1XOUvisppJSoXauVZkVmJUImfLfLkA8AAsdpJUDgYIWqzlpQUdgpD5UfKBIVAUq7YG4MckAYQgbWKsoNNN3bhsG4ULhtv7u5B+bBBxgncOSi8YIU5YZUwG8tVG5pS7NhHZo7gEjjsIsEBg5P3S2SGAG+vj3Ujs5RWqbTa6We2qfpa7TvpqjBSTest7NeVvwSet2tGu2w0xJG7TRRgSvuQlUdy8ZzIwO5wSxb7rYBYhduMYEZczMy+W8caYfMgQEsAp2KMn5VJKsw3LnaQQDhXi6swSvnIoYkbmSX+HAZeYzgnDA4LKAuE294pLy1yuLgALhJSEuCSoGAQBH2wCdu0KoCgMSWEOcNEpQStdxTSV/d81Z827fTRPSyfPGys7tdG9/h31Te/oumlgYNuV3lG1UzjIMfYAs+QGyASrFm2k4pA6A7uGyCB3fadrDcBgZI+fdzgnOfmBqA3VgzMDeR4C7FQiZclj8u0vH2yfLGCynGcEjNZb6yUMHnLshZTiGZhtQKvyYjGQBnG5QzYBdRwTm6kOa6nHW1rtXbXKtb31v0T9bdb5o2u2rWffy3elrXv+aSLWI0U4+UuwPOdyllQKGVMDbgDhm+bkjCKQImmCttBB4wSCTjGw4xjByASWDDAGQActVb7Zaq0UfmExnlmEM0m5htZFLCNdnCyZKhlCjaCG4K/a7BWJMuAFOVME2M8DugHJG4ckjHJPIOE6kHqpJS0+0tbWk7fNtaJXbej15S6S6NtNJXXRrW+uvRd3ftctMNwIIGw8YHQ/dCnI3HsMAHBAztPNQXIYJG0TbXXMaghykgeMDymAfOWONjn5VBOSPnxX/tCxGFa5QbmIw8cw28oGAAjHIzhuRhjkDkimvqNi+EMxDI6OoWOUKfLYH5tqLlXBKjJA4y2AcVk6kZL+JT0V2ua7a5o3as1Gy0drvVa6XBSi7NtNO17X/uu99L72f3ssrKAkZkYA5UMQoO11+RlIZt2wclDgt8pfGTkEkjqjyIhZvKLKoCDzFwCoZs4yeCXwGCkEtkgCAahZY3NcAg4UgRSbVZiHB2iMhdqnII3MhOEJB5gmv7aWJ0juD8y5LFJGwq/Mw5jwHcYRQCFBG4kDBF+0XK05wk7Jp3vfTfVtO+l1qlpfsVFrlsnG6WltOiV301a5Xe+99lYlj3+dvdQoeNOu1sAuWVVKbdpC9eOT8gJGMzll7kN977u1trYB5A6D7o5PyjnlcE0DqFrtjXzW2+YpG2NxsVgyn+Ftw4KkFzg7cAk0HULSI/fY7kzjyZCo4z0CgcBST95lPGdp+VRqQjeXMrXk7t+ivZf8NptZtGikurje/rtZNrWyW/8AV055gTtAB3blfaNyrgEnkryxGflOcMuARtApiKGLZcKD8yh+IyCVKkhxuGMHaoODgjIfBqnJfWhZUM7CNW3ghJcs2B8rEKqL8qMGChsAZQjLion1Oz+WMSs7bhENsUgO0YDltwySCAQQzOF2llJAxg61NSXvx3SSbs38Nk9b27q9lfZrcU1Gy2Wmmyt7rSdt1fV3/UvI4ckgEnADEbSSMqCRnLEcksTyMKrYYqS3fEXaMkbyGB5CZUhSuwgkkDIAUgE44PrGs8bBniYlTHuYhJNjH0BGGVsEhmJzz83GMPchox5eHlIzHHhS+BsZuMqCqqoYgPgDOAC2QKTa5nZ2T32aXLZWTSfo79H5jTvG9lKOuisvtR6/E1Lf3k9bWW7JF3DaEJkC8YOflOeGPJKnCqSCucngHilhJikdnCqHy6MCuH3gYEh5+YEMTgKpwpIXqIBtDqVB46HKgKchcEqWJ+YEgZIbBYNkg08MysTksT8hLDC4wPmYD5QM7ueXVwMdMBtuTV1tru7XstW3fs7Nb+g4K7Vo6Jp3Sa1fK9r7Xi3o7WV9EneyzOcLkKrIM8nJJKALnAJJwCWDYJyVyoFVyI95wMMQ2Tu4BcL0B6nBAIHygEAHcSKWRnjjQBsu5VAWDFQfl52AcKoB74wT0AJWFlO7a0gcKob6kYDAHlcDBPAICjIy4zTbXS7d1zWWmq8ubS1r2S0sWtI8qTumleLVl8Oiu5SukrvR9Uu5FJOxUJ5MqmV/LB2gozlQFwQCSSC+FIBHcgstIYYlHkx5AT5lbzNxDDAD9eQchtmf4QARuqMADaZZGlO4gIEVMcJlgMhy68qzEnrk9szghpkZhwIwysWyAAQVYFSSAnIGAeFyRuVcZXk7uSb0tG611tdpK927rRaK17Ak3fVXdlZa2u1dq19bvRSsnukm0SRCKWF/MTIVfLIYgkAKSx4LNk5bAHzrtJPc1SlWS2MWxo0hkk4ikAkZJHeNgyDcWk2psJUc4BAG5RWsrbFxuDlyp3KgJy4G/vt24Vg+fmIOCcdIJLVJJ4JH2bItqBSoXlJVHmNISBlhtH7vJ3NsZwF2VliKc3S00klukk2tL6u72vZPt1FKPKlG20b3cVZXcbaa+W927NuTQxrXRzkf8JHMxQ5Uh3IXJxuC4GSQVUncCCDuyoRqsx2lgkY8rxY6A5bBZiVBzgEnaQxwu4DO3JC7sYpqvahWK+F5s4wSZUz2JAJUMXXaQpG1e235aleayjCK3haZgSnIdcgkrhdqgqQNrcOcruBYlhmuNRhu1S0/7CVtbS62ur6u6dtVpc+PcqjaSdd3a0lLAytok73000a6/JsrrDZruB8VTZZ9icPsBH3WdsHCggEAYGF6qxFWvJ0YMqt4tuyVQM5CMw+ZhwCFIIJClwAdu0cMWOGi4sQzt/wi0x5IcCVSu0gZIIU7duCNy/3xuywXLJJLINC0HhW5UBlDK7MwYjYNqrtYBl2sATnO7L79gWnaL6U5LrridtEmrtL5NtL8QvJ9Kq074Dsutn+O712uSomjKpJ8U6grN8ihQ5IcPtG87GPllAvIy+MKc5oaLRgVUeL9QPR2OyYhfm+7wnVfkLEHG0MoAYDLkltE3rJ4Vu3DSYUhkDk5UBCwRT0Vz8oDk7WyBuFJHNaKpDeFrosj7Q2YwW4BLOXQ5l+VipcFMsVeM4BprkuklS0t0xStdrzas9dO+++sJz1adZ2tvLL9bcv93y01euulmJEmkSo5XxXfZUHbHKZYw3yL9w+S+WO4AbgMgHdgilaDRwEJ8V3Ocq7BTISoZtzANsPzfd6D5TuLKFANSbrNGD/8Ixc7GBbhrYFXy3J+Q5AAG1HBIOSSeAI0ltlmZ28LTbCE2r5gBVm2BznaQS5VtmSfLK4JC4BbjFWuoNOz/wCYl7qO2uj307uys9QUnJ3UqtlbTmwK1XKuz+eyurLoSRw6MVRk8V3SlyQVYSAr6ElowAMbc/eAAyu/FMWLSBOwHi66QD94r7ZWXzG2nbkJgbckscFWH3McBpBJbJhh4ZlZCA20m3YglgMfcOdoPCkZViG+X5VEkVzaozl/CU7KQgiVGTK8op+by9pLFSQ+d0eDghQ2aUYq3uwVrN6YmyStdfE3r20d9Nrk3k1dOtdpK3Pl93e2qfK/OyenV6OxHGmkyblbxdcovzECRrhEG4LjBWFidxIUZVDtyWKNwHCPRVw3/CUXW5FIYq053kAN+7ZYVIXfgklScgE84YkVxBIhb/hErgkSFScxKQVweP3aO0mAxJG45IYINoItiaLJx4QuDnBAYx53A8klsg/dOE6d85wK0io8qXuatNtU690vd0u27SfbTppoZydSLir1lpqnWy+OnurXRXTu9PS2upXWLRsHHi27JLkKQs5XawyC2IwVIyNykfN2IIGZFtNK3Kp8ZT5Kh85uSvOQBhUAySeTggggDY26pVnQCQf8IpcgE/OgMWARtyCzI7noxwGVlY8EBcUkMkcakt4ZumbcBkrBjnaOFCEqwKsoIAQDhkLEk3GKVm4wkrJr3a/S1763u/x0slozNymk7TqX0il7XAtL4bu6XfdW29UNMOlnn/hLbo8kEFZxnJPIwg4+Vc5AJOATgAmZbbSSDjxbKW9C1x7YBG3gkFB/EuAR05p/mwxggeG5yC3zb/JGMY3HO0sQNrEA4CnJ5GVM0bQsSv8AwjEoIAKsWjBLbScMMAEkkFskjjhVAxWkYpbKC1Vly1Xp7tr+83/4Fukt2kYSqTa1dRbaqrgtHeLs1yK710/yGrDpC5A8TzsG2hSomwXJzu24B2gbMgkNkM2ckJVkw6asJK+JLh3C8xIXJcsVAVW2sMHJIOOQCGK8GnIIwn/Isv8AOScmSHgjb0zyVAHyrwSSOmBVrEUiKP8AhGJAVZQSs0Sg7RkjgbiCWGWLYA6qzKSdoxSW0N0tqzttvdvdLW710V2rnJOpJyUvfautPaYOz0iluls38radCvbWuk+WrLr11EWAHljzQNxVSVOEGMMRyVGfm2jaFJurb6WTtXxFeADOCWmRM/JtCny8EAn5s45XhT94yKsSgA+FpGVgPmMkYcEhSqgqBtCjAwSSvJJYjaLFsI+fM8NPkAsp3KMDCBT0wzfMOU4Yk5AIAG1OCbirR1aaVqvS2qsrrf8AK+7OOrUmry56ju/58Lu7NK+99duqt3IooNOJB/t+4LLkqS8www+YDJViCS+MLuDYJJHAGnb28JCiHXZ5HO0hBJICw+QBUOBnBK4YqrZXDKNwNMi8l2VV0F0ZnUF22/eYg4IOfl6kkfMMEb8jA2rKCMrcuLeKN1VkZY0HAVVGS3ysM8gkDkrtPC8dtOkuiT7pKpfTltrJ2t30un0a28uvWnFWbqX6KTw81a6SvywejfV79dEXLW08mWWV5ppndYVZpnZjhWZQw3MuN+zlggCgiM5U7j1lhESqDA2nJIHIDELkfLnBUEjqMkjGVJAxbZVdwWUtkwdSCo3An7zAEMTgKQMAHg7gCN22hlaWJ4S42xv8iBgCAwIVsMEAPCgkAqFC8sSa9KjGzjZaJpeerTb26vva7Pm8ZWbTUpapW5u9uVW20SsktdV0116mwhO1SGT5cMBuGQRtIGGCkkk5K5wCTgiu90u3ikEe8OThQpGAOChP3yDxyAcdsn5+Tx2mowMSyJ5ZbaBhww3KVHIfDA5GWzkhcAjJVq9P0a0YlFyCNq5bAOMbCwBAYbQN2SRggjPIbH0OCpczi2n0dtm7KO99V8Vvy0R8DnGJ5Iyd9dbNO62WzT1S1t3v6HZ6VYK+1SNo3JnAO4AEZGVBbdjcBt44/hX5x7/4P0Tz5LYLbsmSjqQMbtmFBVNrsgO0sxyVKknPOR5n4Z0357WWVWMbuE34DmJ2EewMGKgByoKoVOGIy3JFfa/wU+HWseNPFHhrwnoNm97rPiPWtN0HSrXJJlvtTuo7WINhTiJDJ51wybVSNWlYqqMB+g5FgXUrQaj29OVW132Su7Ox/PHH3EUMvwWLqSqJKEJzcpSVo8qWuu3KktrO/a1z90/+CNv7Mk+qaxqPxgvNPc3GoTP4D8Cu8RKxRuscvjDXoAVxiKE2+jQzqR+6GtQsd2RX9fk82j/DXwE7ki10zQdJYs/Pypb25Yt0Jdyyktj7znbyeB8S/sFfAHR/hf4E0DTdMt1GleC9GsvDejzCMA313HGJNb1h8j/XalqMtxdSPksJZ7lW4xXYftl/FLTPC/hq40m81BLTS9MsLrxL4sn3BVt9E0dTcBJMkAC6nREjUk7xG6AHdg/E8UV58YcX5dw3g3KWDwFSMa9mrXi4utJ26xprljfac5R6ow8Na78JPBvjfxvz2mocQcWUp4bhmlXVqqwqbw2UUKMXaSjjMW/rddU21OhShVXVn84P/BV/9o69uxB8PYL0jVvGl6fGfjKNZSZLbQ7WTyfCuhS4CkpmOS9kicLuaGGTkSAn4Z/4JrfA2/8AjP8AHuHxvc24l0j4e3lqNHklTfbnx1rcN22lXaqNyuvhTTLLVvFj71aP7VpekQTGNb6In5V/aV+LerfGD4oeLvHF0s0114m1pl0mxiLTSw2AlFpoelwxjDOyWywRLEoLSS5CgmQCv3C+FtrafsA/sKax45v4re3+Jmuafe+HPDYaRWuLn4oeLUH/AAlOpxNy0sXhOC1tNAilgd4GXwjPMMrqRJ/cK3s8DhIUMPGEaeEo08Nh4Kyh7VxjCnpe7jScXUlrdU6UtdEfzBl+Ex+B4fw2FqTq1uJONMwq1cxrOV8RUrZhP2+YV5TvJuc3UjhIS0XtqtPVK58Gf8FQfj9ZfE342r8OfCNwrfD/AOCth/wg+g28UvmWl3q1kYodf1AFQscrPeQrZCb5jLDaLtOZXLfNH7NXw+k13X38QXNs7W2nSCK0Ljcj30wADKAGXCcsQCNv7thgAmvnJpL7xHrjNIZbq+1G9MkruzSTz3d1MXaR2bJZ5HdnI5Zh83JJx+v3wI+Hw8KeHtMsooGluoYoAIUAZ7zWL4rHFbqMDzHMsiwoBypyCTtrxsvovF4qLjrRoKKTlduVre83/PNuVScrK825Xdz+wuEcowPB3DinVUIUMrwUsZjar92M8Soe0lv0c78kbe7GMYppJX/SL9ib4Tx6344XxJdWofSfA1uGiZ0/d3Gv3sZ2hT912srVpJiGG6OSeIZ3dP2FIVUwOmPl68cqeCPQcAjjaOnNeH/s/wDw1i+GXw20HRJEUarPANS1qfA3TarfAT3ZYgfMsLstvFkkLFbooyAuPb3YEcnHy9Mk85OByBnIHzNgfyr5fiLH/X8wnyyvQwy9hRS+Hlg9ZpJfam20+ul9kz+dcXmFXNcfmWeYn+LmeIqVY33pYZPlw9LXRKNPlbWj5nK3Yzrpgcrz8oyeuSDyeeCQvI4OeTzyMc7eSKASDjsMk4A4z24B4zjGCADyRjUvJQSecnkHpjHQ9ScjnrjqO/UczfzMQw6gDru6cALxjIwMnqOpGMgMeTB0nJxTV7tPVaJadb/8NfWySv8AnueY26qa2V2tHro0m9rpaXa2fz0wdRuUjiklYkABjvyeFVchjnBGQM7jyOucCv53f+Ckfx/GreILjwrp14TbaWskLFXypkxhywzjIIxjAOMn71fsx+0l8VrL4X/DnW9XuLkRXTW00NmjMFZpmRwpAJJOMjBAJ6ZBr+PX9oD4jXXinxJq+pXM7zS3FzPK0jMWO6R3bBYkcdMnnCg4O4/N9lSccvy+piZOKqV1yUbv3lHTmavayeivtuuuufhfw5U4j4ohjKtNzwWWTjPVNxniZuKik3reEbu1tG090fMfjzX3mmuGWTJbcDuyRtJb5gARnHIyBwvoevyB4v1X7RcmNWGATnjgYbjqOnzfd29wMZyD6x4z1v5ZmLbQQ4GODjDZPODheMYbAB9SQPnW+uGuJJZCclmYbiMk8ggYOTnJIJK+w5r81zKs69aWvNZtvVatNat7W09bJpbn+nPh/kUcPh6c3TcXaKi9L/Z1asnza7a20bM6RwX4xnPHJJAyCOhxzk54xk9MZNTWsQkkXGWycnvgcEcbWIDDnJBHToMkVCAWAIwMDB4zngE88noCVOdwwQcjnY06MLmQqSSNoB6AtgswOB1zxljgYGOx5cNS9pOGr3Tb2utNOumz0a0XlY/pLh/Apezi1ZNqUny2tFJb22vsr9W29N9iONcqoI6dOAP4cKNuT6c8jufU9BY24Z0VOTxhR3+m4rnHbAYsN2McVm26biG5yO3XA+UgLgnnOA3zHAB6g5rv/Cujy6jfwRIhJkkX5e7EntkE4BwOCMkfLjkV95kmXzxeLw+HpxbnVqU4xST1V4qK/ms5PW7atL1P1TL6HtKsKcVrLlS5Vo/eik7K99km+ZNWXy/U7/gmb8G/+Eu+JcXiu+szJpnhWNb0yOmY3vnDi1X5sJlcNIBjnarEg4r+hb4i+PtN+G/w/wDEfii/lSCHSdKuZ42kZRumSFkhQBiucvtCZ5PYBcV8gfsNfCWP4XfBvRpbm38jWPEUUer35ZNrhbhM20TnhwEg2Eqc7WJIwM5+cv8Agpb8YrjT9E8P/C3Sbrdda9crd6jFCxLtaQMBDFIEJwLidhjjO1TgEnFf1HiMDSyvL8Jgo29llOFj7WK2rY6ryucVa6lJ1mqUe8YR7n9VZThKfCvCEsRNL6w6Cqva88TW5YUaab1bTcLryb3Pl34FaNe/Fz4veI/inr8T3cVlqFzfwySjer6vqTS/ZlXOQTZ2+CowCjsh/iG71D9p0Sa/N4P+HFlu+1eJNY0rTD5eWOdSvo7aZ9qjJ+aTfu+beBIWwOa9Q/Zz8IR+C/AGj6bIirqU0f8Aa2ruQQxvLrLbSR8w8qNkhCsxwEwMdB4x458X6Fon7S/w21nxXew2HhzQ/FGny317ciRrWyRUkW3urkRpI6W8V64klZIn8uJJJCAdoOHEeHrZPwviqXK44vE0uavFX0rYlR5k1daU1aLv2ukj8742+t5D4c51j4U6tTMsTgsViXCnFzq1cRUoynCmox1cr8sOVXfM9kelWWmWGhfHXxJPGFSw+Efwb16WzjAO22kt9OfT0cdQgjSaUbmIKqACeRu/mJ8dT6jrfi/xJqiRS3lxe32qX83lJJcStLPJvkkZYldtse9hI5XYhVhkgZr91/ilrdr8QPjLrmkWNz8RZPD/AI/fVtC0PUvhpK+m3fjbWZLPWbHTNFfVNT05LC38IpqxtbrW7vzZY42+yxXv2SPfc2/wH8a/gvb/AAS08/ZPEs+qfEXULya/8RQeHrGOLQ/CXhX+1pRZ+G9W166h8nW9bn1G0gvJbnSWm0m90mSKa1a8ged6/lbPKdatSwuHUowmq9arWUnapObtGLjTkknpCys3stnY/lrBVKmG4L4cydUakcVSVbMMRTlCbnOtiYUeeda0fc5XGScp8vvT5W07H55QwLaK8akSNOwMrK8UnzxIIJYw8Y+7DMJIwSFLbcgFTkwtZS3LFYVZ2O3DfMcYK5+ZgFA3Z5OMnbtYkEV3v/CJahe3VxNEJrm4uZJZ5VjguJGM0khZnCRp0Zz8qIoCg7VynJ6ey+FPiieJZ/7Mv47dj/rJ7f7HEFUqACt5JGdoVl+cRM2OmcZHx/8AZWJqVJJ2hG9rybSbbW7d1rdvWx89Wy/ExqzqVHSw6m7r21SEe195belrJLbr40uiEsrTXEUYHUIpnlA46qilA3BJJcLkZJbhq0bXSdPgbPly3DFus7CNTyp4iiG/kg43EjGQSTg19U+F/gBqmtMsk8+nabZZYyXuraxpukWKbQFYiW6lWSUjeQQkYdgGCK2Ca988Kfs9/Ci0kSK71rWfHuruU2aH8O9DvtQJkcrmGXV7iGOAAlmRpLdpow6KQrrjHpYThXEYqpCnTpzrzm42UFzpvS6jGKd9Xe0Ur36nnyeElVWHhUxWZYpyUfquVYetipttq0ZPD03yK/WpNRu7X6n5+Wen3Ep2Wlk4j4OIIXSLIPAMghDA4U4AYnPfoK7vR/hd441vH9m+HNUlLFW8yGwnKgEkKzSyIgGWKj5QSM44Zlr9d/BP7OniaVoT4V+DekeEIQFaHWvHuoSahrCpwN4sIJllgcFC4SO2UpIQFKBgg9nPwJ8K6XCbj4wfGdokXH/Ei0Fk0RWA2AwBIXm1CRAAoBWzRmAIbaV3t+j4DwqzWVCNfE0KeW4VJOdfMZLCwhFct/cqWqWWykk1fbsfWZdwPxHiKUcXPIcNkWCS5p43iPG0sLaLt731dOc2rfzVIPq7aH4x6b8A/GMrL/a5s9GiwoZtWvoLdjvOQPscTy3R6gDCliQQwDdPpj4d/sk3msiGa10LxD4ucuhaS2tJfD/h9cBM7tX1LyXmjJJG6AOAfugcV+nngXw34NvL6PSv2fPgJrXj7Wt4ji16/wBHnulMx2hZpb7UI7qZlyQVKG0yvTadzL94+Av+Cev7WHxX8m9+J/jLSvhB4bm2MdD0CJJNY+zMwYxPJFIzRkDI2yXhCuSRDtFeh/YXBeSv/hQzSeZVoWvhsrp80E7J/wC9VVGi07WfInvddLVi8RwRkq5Mxz+Wc4uKXPgeGsNFU1O0PdnmFeTjFN3TlT2tZdGfkTpX7Nfhfwdao3jPxR4V8B24RC+k6Bs1HXJVwuYJdQud9y7M44kgtpEAYnaMZHrXw8+Ddh4mu1sfgd8BfE3xM1QSKg8TeIdOup9PV+Atw1xfg2i7QWPEVoxQAI6/w/0L/CD/AIJq/sx/C+a31PWNAuviX4jiZZZdU8YXU2oQmZcEyLYFza7WI4WVZQVGCWBr7403RtA8OWEdhoGjaP4e0+BAkNtp1lbWUEUajAVY4UVVZcH5eoAyMZJrkqcXYfBSVPIMlwmBhGzjXxEFjMXfT31OrH2cHs/dpNJ6KR8riOPKeF5nw/kmW5HTV3DGY1LM8zm1Z80q9d+xpzW/uq6W3Q/Az4Zf8E2fj943NpdfGTxvp/w18Pt5bSeFPBscT6kbf5CbaS7h2RQldqrkzXOw5IUN8p/VD4F/sZfAD4IxQz+F/BdnqfiCNUMvivxKn9ta7JMBgSw3l6kotWJy3+iR2+0/eJxmvXvF/wASPBnhQO+qa1atcDJEEUsc07tnJVYo97FiW7jjnOCM1rfD/WtU8aOmqSaXc6J4c+9byXymLUdVUgkNDbHBtrVwFJmnAaQjKRHIceXmGLznM6LxWPxeIdNWac5yUbqzShT5rav3VGMVHXZK1v5/4+8ZsjyiVTEcTcRSx+Kk3GnhZYh4ipKpp7lHD05ckLbJqKUFu9LrZ1r4T/8ACdWsunYt7fSph5WpXEy5iS2bejx4AxNIVfekKEfvEVmO0MB6R4D+HfhD4aad/ZfhbT4oGl2m81F40F7qDpkB55FAxEoG2GBAsUMYVUUgFj08OoBbdLeFUgtkBCwoMIuepwOXeQ4y7ksTyTkYrmvFPizSfDOk3Wqatf2un2FpBJPdXd1NHBDFFGC7O8khVUVcBWOQeoUFunznt8zxqjgeep7BtRp4end8zaj71SybqNNJpP3U/su1z+KePfEbDcT4p4vB0Pq2Dpyc6cG7zqy91KUoxfKpWXLH3W4q9rt2fW3urQWsbNJKq4Dc8ZZsehOOCQcEjgZPAOPyI/b5/bx0T4TeHNY8KeCtUtLrxnPbzWtzfRypLa+GxKpVmDDKzauN2I4V+W1PzykEqlfM/wC2Z/wUzs9Pg1Twv8MNSeG0AmtbzxIjmO5u2wyPDpCNgwQYBzeMokYFTFtXBP8AMp8cf2gNT8Y6hdz3GoPKJJJSFaV3+d3ZpJHLMS7M2S0jEM77juIUsPTjSy/h+n7WtUp4nM5RvToxacMPKS0nUlreUdLRTsvtWei9DgHw7z/jvF4bFZphquFyaNWFT2VWDVXEwjKLjzResac7JuMvelfXlV7+d/Gz4jap4m8TX2uTX9xcag9/JfvezTyPczXjytO9zLK26TzmkJcyM24OWPQnH6dfspftjfsufFt9D8M/tkWupeHfFlhpUWgWfxS8P3X9nS6pZBlUQ+KbV7W70TVfLCxzWs2vWt3ZRTeejRQ+eXP4T6z4jN1M4eQMSxbcSGDHIOC3HIzyBnkA5yTnj21iWF9yPhh0C8qFBBBBGAOpIPTg5BNfNYfP8xy+viKtHENRxilHEUpJuM1NW95N7pXSezVr3tp/phwdRqZDkiyXDL2OBnQpUamHgoqmlR5HTnCLUowqUnG8ZKPVx1TaP66NX/4JLf8ABPr9oGabxX8L/wBsS10K41MrcC2tLXwAYllkAJM1lp+v6JpzvK4JlFta6e5kZyikEhfMdX/4N8/BJlW40r9s/wAG6hZBji01rwJBcK6YVQGn0zx6wdmAwBFIxAOGfnJ/l2s/Gt/aSBory5gbIxJb3E1u3HIOYXBG0HOVxz7LW+vxO8QbCo8S+IVAONq65qiLgdsJccYwOo4PTJ4rGWazxUnKulNytK06VCmrpRXxwpwbW9r7LfqehmWX5xmD5sJnuJwHMuWap4DBTuvdS+GEI8zT5nJQV9z+i7Wf+CAOjW8W7TP2j/gfqEwXIXVtJ8YaFAXCqcO+larrDRBtpIRYWbD5YDHPiviH/ghv420oSvpvj79l3WY1yQIPjB8SdCnYqcgmG6+F2qxKz7Sdn2lwuSCrElq/DiT4ka8wb/iptfJ+982t6o2Oh4zdE7cY4AGAMnHAquPHmpzH95r2tSqc786vqLEnd6G4IbjtweeAaIVMNKzVGgru1vd01W7cWr9rbO+jskcWD4Lzp1IutxdmFdNpSjLC0o2+F6OjVp8t7OyTsnrufrDrH/BIX4oadKyp/wAKRuwpbL6b+03YWy5BUdNe+FNttJx8gkdWXJDdQa4qb/glj8TLc/PoHgeQk4LWf7UXwVnRQOym+0jT23FsEgqhA5dFcED82ovEcVwQZ9Q1eQnqXv79g3cqwaYEDgHgkENlR2rUg1jSjjzDdyAYJD314Qeo4/eAkcbTwMcFmPQ+1RwuXVoxco0ovS/76krp8ra1w0teltru2nX7XB8HRUY+2zHMKzslJqpVpJNqNtJVqnVN7pJNqx95al/wTQ8Y2UTSXNp4TtmXdwf2k/gXJh15wTB8zMcHAb5mJxgmvI9a/YI8Y6bMJUj8GXCllURSfH74WoHBIVCZLJJNu5shwUXHOWXaHr50F/4XfKy2Kytn/lrfXjA5wCCPPbaR0wcgAD2q9aXHgwsFfQ9NcsQGV3ndiQcjG6RwRkY7gcEYBOe+lleVScYTeGcW1rLGRg4r3V9nL5JvvdrS+jPWocK4anU1xON5VbSpjp8yaa/6dyW3W9lffY+mtK/YXls4YLzxB4x/Ze0WSa6FpF4e1f41eK/Hviy+md4oo49O8KfCuy1DVryZ5JYxD5dvHBIz+WZdgyPoTwh/wS1/aI8Twm80b4UfD/StImaIW2r6t4T1bSNSurZ1bEum6N4/+IKayHnJznWNL0iOKJTK52na3o3/AATQ+JvgTwR8VTpA8L+HorrxPBDp+n6wun20uq6ZMAxSCyvZUluIILiJT9oELRmd44Fk/wBUqn9+vjl8Vh8J/g58QfH4dZ9S0Hw5PH4etXbzG1HxXrLw6N4V0yNcN5kuo+ItR06zSNQWYyEBck4/XMu8PeHXlWHzOpCjWoTo1JzlRnJqDpK1RVaihSc2kub3YQsmne1j9r4J8JuFMw4ezHifN81xs8PgIYqricMsQ1DDLC0vaSnUq1E3OLppSvDlXRPe38fn7Qv7H+tfBf4ej4gajqcV75XjWfwresugvpuiz38U9/btbeGtXtp7jT9c+zXOm3v2xrYrDYRwqpnuHlCt8QQDeUWNWaR2jjUKOdzLtRFUKxyZOAqZYkcKMgV+rX/BU34gXuiy/Av9maLUZrtPhF4GstU8WBnVhc+OPEMCXOqXc6oqHz98t9fsGXIl1edicu1fnv8As+eCr34i/FTwj4asbJtRmk1CC9Niqlvt0tvNDFpemrgMTLq+szadpUeQBJLfIEIcqo/Bc/p4GWf18JlmGjh6UatOjGlGTl7+nNzNvSW/NdvW+re38j4TPqWb4fF5/GnTwOU1K+OxWXxcpPkyehVmsLicROTXv18NTWIlLSMVUaXw8x/T78Aoj+xd/wAEWvi58Rpy+l+Ov2h9WPgfwjJKwgu/svkf8Ies1uxCuRDJF431ONwoURi3kJ4XH46+GLVvhh+zr4+8Yruh1WXwnPpGiXKzNHJ/wmnxwN34D0cRoAHebSvg9pPxU1WOVDiGbWLaU7WZGP63f8Fh9UttFn/ZB/YP8J3aHTvhh4C8OX3ia3gYJFLr+o2NtoVpfXe3MazLDbazrkjSAn/iZmYgK5avzK+POny6yv7PvwS0SJkm8WPc/GDWLNIljdLLxVd2ngD4RWdxEnJWz+H/AIZh8Q2cb5QS+O725ij2XWZPpY0eXDyjTTVTkjQouXuy5sR7KEHB3tzxpKjL3drVFrdyX898C4iVPhPijjXE+7jfEvifEujKSfNT4fwFWc3CbesqEsNhZ0ITleHLi6VnaST7z9n74V6Fp/wW+Hvh3UYt+pfErxx4WmvIIyA8HhzRftnivxA11F94RQ6fYeD0jaU7IV1GVooWWY3A/tK/Yh+H58A/s++G5rm1W11HxfJceLLyIoFMUWqMo0qBhgMFg0iGyRVJ4BIHGAP5lP2fvhVcfED48fDbwlp0OzQNPttS0TRTAoMd+Nf8WN4budSQqCWit/CPgq0jgcEmO1iUK21zn+xSCwttF0ex0uzijhtNNsLazto1AWOKC2hWCJVUcAIiKCAOoC5Iya2zxQwGVYHLKbSniKsedNtuVLCxirNWbtOvUnJJ6c0PJn83+K+eVMfmMacpJ08NRq4uabVlUxFo0r33lGhTgtkk0+xzmrXR3SPkHbkZB/hVc8de/O4nOOTg8V/Ot/wWO+MPlN4e+HlrdjNtaXGr6gsbgqsl1titw65PIjVmUHHBzk8Gv6BfEWoR2drdXMzrHbwQyyyuSQvlxqzsWODhSo+bB4OM5r+Jf/goN8Z3+Jvxq8e61HcGSzGq3FjYjfvVbKwZra32fMFyyxFwMdWLZ+6QYL/YctxeKdlKVOOGp6pvmqNObXe0IuL3tzxvufh3htk0+KPETBOUXUw2WOWOrJLmXOpKlQTsrNylNzin/wA+9Ftf8rvidqqnzE3AySFlILdAxODgBsjhOvzDt0zXzZOollJIJIbjodxzxkZPGD0wckA4z19J8aam97qE2T8qbsKG43b9oIzxxhexGQQfn5HBRW+9yQOWbGF5OWK/eGM9O3y88D5VOPgaydatKWm/S7b2Vt292mno9tbs/wBbeAsl+r4LCxUffkoSkktPs6f3dLLfra2jLekWImlUkfInOGGBkngZbJIPIP4Y616zo1rjaoTc27aoAyxycKB3PPRh04DjBxXM6Np2wKdpAOGOTnoTkDB3DdnAB9SQMAV9T/s9/CnU/ip8QNC8N6dbyzRT3cLXMipuWGFX3SMw5AAAcnJ7ZJI5r9G4KyCvmWPweCowftcTVipSUVyRheLlNtJpRhC8m72VteU/p3hnKp16uGw1KLlUqzpxslfWTipbdY+d7n6e/wDBNv8AZyGoag3xN8Q2R+yWZV9OE0e3fJl9rLng8hWxzkEDgMcfucHt4I5bqd44La2heRmbCRpFCpZmLE7VRVALE7V4wc548x+GPgfSvh14Q0XwtpMEcMNhaRRytGoXzpwg3yY2rlmYkknqeBnAr4a/4KKftRL8K/A8nwx8KX6p4y8XWjrqU0EhE2kaIwKSsxVt0ct2D5ceSr+XvcDJVj/VFaOCwOGpYWnNUMrynD/vKz911OTldas7aOpXqpqEe0oxvsz+r8JSwXB+QuvWcYOlSU53snUq8qtHVaylK22t1fZu/wCa/wDwUT/alm+LPju98L+HdRb/AIQzwncT6fY+TJmLUNQjYx3N7gZ3DzFIiPQIq7cHOPnf9lP4Qafq2o6l8WPH5Sx8C+CYpNWup71dsN1LabpVQh8CYgDPlpks5SJQdwB8V8C+ENY+LXjvTfDmnxSzm7vEE0/LLEkjhp7iVgMKoAZixz909yTX0v8AtReOtJ8O6Tpn7O/gS7itPC3g+CPUfiRq9rIEju9Tt1WT+zZJ4hiRLWUq8y5Ja6ZE2t9nZa/mXirOq3EeeVMZK8sNh3GhgMM3enGEXakk725Yq9StJqzfM3rY/wA/PGXjHM+MM/hwflGIqf2hndRzzHE025f2Xk8JR9vOLXw1KsWqNBOz5pX0Wp83/tJ/H+/+I3iq/wDH15/o2m2Qk0P4deH3OItP06IMn21ozgCbav2q6lXhpsQ4Ahi3+aFrj4QeA5NFumlX4n/FHTra98YyOxTUfC3gXUmj1HRPBwkLFrXW/Gatb+IvFhB8y10EaTpMzeYdYtzmeELay1W+1D4w+L7CGbwR4Hu49J8EeFruNntfGHjMxrcaVozx8LcaTo0Qi8TeNmBZWsU03RJpYpNdgmHe/s3/AAV8Z/tgfHiy0ET3d/Dqmrz6z4x8TXRBS00yS6abXNbvbqT9zFLdbZLOzZykUSECNVhBA8fCUcTiMThaOCUquPzGpKhl+jXsqVRKGNzWrd+5GUYzo4eTSVPDRlPTmg3+jcHcNUsjy7KMgyTC8mIrwjg8BSirSpUWkq+NqyevtKt6l6k/e5VUqt3lGR9kfsE/CDwr8PvC3if9t/456U954O8A3MVl8K/Czxg3XxD+I95I+n6Fpmh29whado77yLOwYJILUx3mrTIBp0mPz2/bH/aF8U/Fjxz4nTXNZTVNb1zXF8Q/EO/sp9+n3HiC3h+y6T4V0ghiieE/h5pJTw9oVqC0Ut0l/qbNJLeh0+x/29f2qvDc8+g/Dj4PvBp/wj+EFhf+CvgvYWRMdvrWqxwtpHjP4zXUW/EpupEuvD3ge4cb49PW/wBbhcXV800v4rXdw00zyu7F3YyNK+9mYt8xLOSTufO5iM7gQMgnJ8fjriChRpUeFsmqJ5flzksTiYe68wx9lHEYubV7xlJclJNvlppcrcdDbibMMNiK9Lh/KpqpkuRVW62IhdLN86jeGJx0tWp0MPPmo4W90uWUlrZlO4cPkksY+MrubG4HLBtoIB+b5VxgE8HAIOVMyYYF2QZJ3FmORhflLcjqRuVQSQvZgN1mY7g2coCFwA5JzgYYDKkjOMKAcjBOWU1mTKqurPMuFARBjYxkLJ82QQzSSDBCup3HnGFyfyKo03zaK6Wrdla6tfVWu9vmvNeDqnpK3wt2elna19k97W7+ZGz+Ym9HMZ8wFWGWVtoB2H5/lVjwU3ZAZXJOeWRlj8u7JUBZEZi3zYYFQFcts+f5X5ZehJwWp4jVR8mACAepYA4HPKlcHIPcsSoxgVHIit94ZcK6qxDF0LZ3YA4GMkFSA3BAOME8zT1k273V0ltaydrrVaJpWfZa2adrrqlpe13e9vx3e3be6DPm/Mr7cZQ5J3MWwQMYBVQSVBCjIwpNRyGRSwUDBBZz8+FJAIGSyrhsAYJIUEEFiBiOVnI2K7I6yJuZdqjYgILKJFy+QpBIwOUYqCQSkSGNCDNJOG+dRNtdo12LuRipxgErlm3HADxdWrKb96LS0vdWel04taXV22mr2tbzi2UkrLVaWf4xvrdKzeuuuj00HFzKhIV45QAGRsEr8pHJAJw+SUYnJbGRwN1Zpok8oblXzuOWGWZgjMSSDtIOFBLHBwq5YcTyHhQSzFysbYDKArhxkYwGGw4UbTJnDrnGAxbaJI1j2/KqYVSCf9nIbruLYwVwW68MoJiXNJqyWyTbuuqvokk7q+u6dui0pN97LZdLNO1rbbKye6vp2I8I43D5kzhCCwBKkHhsYwuWUpgjjr1ArMG3uTtMKqAsYD+YWOzJkbONhJwmB97qQ2QVRJssu9BHkmNfKYFQuwxxsWOGOxcE/eHyhXyTtZs+eGSWSUvGTiOM7IXmbaFEiAmRgQrHJyAGDbTg1lJuyfKlZq/vK1/d131S3tto1bVDWnxJNOzVn0dn3Wq3Xfewiwxb2mCmVtvljDOPL29GUZUCRjyCclVyCWBAWRiRh9rZZQq/6sbdocYOM5J6lSD8xyCSMVVcXEcTLCokYykszbtqRGQuWYO+XKKp5H8LY4bGJWMxRRGQpGzcxj3b9vLKuQFP+rZUdpMFWJJzzUNKzsndtNu1t+V+S931766FR6aW829be6r3TaTV76v72hTsjKrGpCmUqxByRuKuU+ZsGTg4LLwThDyRTgEUlQuCxZ8ElSoYAMXKFiACRlWChcDAxgBvU4Hy4w3CgDhgEw5JGc5BJPU4GGIy1TlslSAy7CoyWkc7QSDkBWUjgtkqOCCCoIkk+WSVvJdlFNJJNflutLJsuKTeqV3d7q1kl6pX6Pv5CFFjH7yQMwb93sKHIG0oEzgZOeScgnOSGGAL8wJGWzFg4O8E4weQMq4DE8ENv4BJNObLbSQXYMowCwKnCkcE4CAfe5O4gY5yKj2gseuWJZhyI8kqDgk42MMMMgkYzwdtDUV6aaWa1smrt+STtons21dlaXb0vfVpNX2Sv33X52SWiARfedPmyrICy42FtwVQwzkkhipBXAGCGFUWRhdh0KooUeYiowIAkHEYZXDO3BLYyoyrDbgCwUlYbfNYYlLAKqghQFXaC3O4DAwxYbWYld2QYmRlKNGCxZkRyvAZWJcsAZAQwII3nIHy4GflGDi3ZctlFq676x3aet7pW95X3t9kteytr1STu37rWunZKyadtbLcrS7YpC0BVsE/aLcsw3FRgtGHCrHMAwVYyCrhSOvNPt545wGjY4LuZAQAyspDFZE2Eo5IKgHgqAATgtVrdFKhCDIMhJBKozbD8qZVS2fnxvDbSSdxJIqpNaKXWaFxFP5ed/lsVlLZAhuACFkVi2ASuTgfPuBqeWcWpRaaurwVr3vFprV9ruLsm+qvdlpK2t1ZXSdrax1T0tLlTtq+quktbZ2srAcDGAcMGONuwf39oPVSRhsDtxWyV8uNcHdw4J3N5a7A0ib2XJVsKhAPHysMjJZFK7YjZPKuNuXjJUiRcg74iBmRT7AOACJMAFipiRmR3T5lbiQGTIG7Iz0wM4LHCgBSgxg5q/MlJXfNbfo07taq99LPS6dnpYpK9rN8zfbS2mlmm9m10sk+Zy0FUxtJuG0hDGh+YYyMFtmGVVGAo3EjYdy/xZqeQh4CcnawPl4wGGFXKkqCSCvGD8oADHjJEUTRSQycEguQ4yVyyKACpADEZVm3ZGDkNz1ZIxIRRna+AzZfIKhTtZQozkKuSWHGAMFhSTdnrvtrZ37X2ey1301XQtPRp7a3TtreyV5LRrXq9bt6OLGEKXMmSHYEPwzgkNhVRuAcAKBhQVO7naSA+Jj1K7iJMFQuWJG3kAYK5xkqT6dWOaegUjeAoCoFO8uWOdu5owFJVstxkFkHEnHJcsakZeYAFMqSCwDHbkEoFBbOcq3OWYqSRScVzJpW3vftpdWb0012XTS9wVm+mlm0pR+HTmbTkle2idtHf1LS/dwAMuykEKGUPkL91d3AUncM5xg5yGAkUeZKi4ChG2KxwAdrRgkuT90jG3KgEEDBKhjSUSbVkVWO1tjx7lV0VQpY7QVHG0nJBYMcMOMC1ES8i5ZxtZeEJBAAQqW2DgAAALu2qTgHJC1MveTV+ltG1daX23u9b3vvfycZJpX2aSu2tUkvRN7ppa6a9bWgclRjDdRuZ8gnBOCepYMeFA3EAADBFOzk8BslSGViQGyQrZJZS3JIHGFOQAcgnmf7R1RQ8v2WIRxAl28osFTKliHdgCCSQCCwUlhu3DIvR30kmmm9ZEEoJVFAUQlw6xKwHUE5O3kDII4JBHBCvTafxJxjz6rezSutOz+btofD1MJUjyu8GpSUEotNqTS8tuvorGqjgTcuT82ScttdW24Xlg4AYMAQcA5zyoFWFe46R7VUxlwCpYkk5C5k28cE5UZOSpKk5PPSXer26Gd7C3jjijUs7AgmNnwCVMm4+YBjO04yQRu5F+51C5iisvIt4JZryLCREylgWjQkrsAJiy21SDgtvwQBmiFaN5Xc0oq9uV3abirJb36ab76uxM8NUfs+RU2paX54tLls3ql0Sd03pq3dmtIWkGxNyZj3M2Q3IOEC5JIwxYFlJBUkAghdzI5Nj7HZiSuU+V0DltqsEZmPzhs7S4HA4YMpIw5NS1O38t7mzszFNKsUZR2Uhnx+6blpFUBm+8oGfuuwXnQWPWZmDC1srUJGQn2iTMuB5bjdtVcBiQWXYqnlWXdw2irKb9xTUrLmi4v4XZrVcqV3brfprYh4eUV+9nRUH8MlVjZuPKm7XblZ76N9N9XeXzOHMjNheVBdlVc5JLAgNkMQrAY7uxIBpsF2lwhaNmDrIyklDG2eGyE2h2EmcnGN3RiuQKoz/wBtKEZY9PbdsVmDyEk5BAkLkEZIJIbDbTkjOWp3l687BWGnHCBAo3nnOFAIJDH5crgMXUbgGHTSM5KSSp1HbWTcHq7RtZt/ctW7+hmqEHB3q0E7+61VirLTRpRd3u0tLLW7NGSVIwjkHYJFJOHbJIAJUZJGDwWBPzKFHTLTJMpLAEMxQg7XcohO0jO35lILdMnaQf4TWPHLrB48vTgyybDzMBux8wJzhAc8hiOx25xUWNba4fybaz8zb+8AaVEkVipDtvKq+7aERgeVVsHIGWq1nb2VWSbSaUdei3V9O60s9bWF9VTVpVaSas7qrHlavFpNW+7ztom2a73LQq0kokaPCgFF5V2ITc25ixQYJ3BAdpDB88GQ3aBYi8cyiWNVSZggDO5IVDk4QttZwT87IqyMADg45XxFKjKLW0VWBhLLIu7YQoYhjIWADYYYG4HB2hQCBofEcSKHt4GRZkXO5Gd9o2p5h81XGzseHGSWAAFDq1LtqFXlsrJw95N2ck3fmsrrt6sr2FPRyq4eM9LONZLR216231to77WvbbZnTdImZCoBEeSVkddpcFiybmxuUNgFUUnB4p8V08sgJjeOJYw3nOybvMYKzRqoKg4AcnBcqrbgcA5pRWPiRnA+y2TmTkAsDgn5TuHmKDlWAJG7zOASwyDct7DxIzsBZ2Jdh82SgBBKqpB84cH+HnOckg97UptxajVS3a5Frtot+6emu97a35nCCjJOth229H7R9lbRJJtd2na+rdy25HlyM+SgXcwy2QFXdgBc7mOWwA3zAAqSCQzraVJIonDEq6A4Gd7A9cqFyrEkk5wRgegJSDTvEagOLewwd2GLMuBHgkjbJxgICQcsQcEhcCq0FtrKXDpLHbFpHBYvny1ZWQYi2SMrDcNuMKGwcfMQK1jJ3i+Wa0trB3u1F+fe9+nqcjpwcJJVqTatZqputmkrLbRrz2VjWRhjbtw2T6kKcBSMnAIYNxgbn4Jxt5uwvwMLvPHChiDgjkkkA/MeMg7cZ/h5xp49Tgilnzp+I4/MKjeS4Xb8vLAEkAgtwWb5WwRxa0q4e7gEpVY2YHPOFYqASU3hiUIGCThgcjYM5rohNXSlfS7akmm1daXu7L7Ldl0taxyVab9j7RSjKMWk2pO6leL7a3s12vfq9dcLut5IQzqJVkQFCS6iSMEhWzwcYHKnlt67MZF6GMRxxxJvAjVEQuQzhQqgAksfmKkZwMtwVw3NVCVCu8jbdgDlhuGAoDZ2gH5sZ3KPvAjr3vQ5byzkkYV8c4IcAgnaBtLAkjJHGMZxx2UlG6tu4qzTTevLdabRbvF6NvRO2p5tdycGm3bmUne9nJqOz272V3ZJ3WrJ4x++gIBH76Ebjk8MxAIOR6naDnPQA5AOnBGM3BbAIE3U5D425+8mTgDHcEsB1HNMRq7RLvdCZ4drKpLf6xPmxnIxkjIK7gck8AnXtF2pcq3zn/SeckkAsilGI3cc5yDkZGTjp10oPaz3TV3Z3snZru9Lu921Z67+VXqKKVnqtLq/Vwt1s/S3fW29uBDhSwC4a0y20btvlsM8YOMEE4UMSMtk8HsNOjbaAYwDncGA3O0ahMbs/dB5fdt+YkgqCM1h28CnG1R9+0LZ3uMmJgAQcgYxhMN83zHJ4rrtNtzKVOAse1l24xIWUICzAncFHynr04wSBn0cPC7SstO9t/tarZ2aa77W6r5jMMQ1Btu13fR3tpFKyWjfftvsrnQafbvJIgXEcfylmYKWGPLwseVTJAHLKecltwBwPW9Cs2Z4uvG1R1Cn7gAJz64yVOCF6EnnhtGsZSF3Asq7eQG3bcALhieACBjrlSoIyQV9r8L2AbbtUbVfAbJZsLySeDgEhRxkFsJkEkn6rLsPzuPLfVpWSdle2/ff8GvOX5fxFmMadOb9pdRTvps7JvXf8l2TWp6z4I0yZp1yC6HBETKWDuQoB+bHK/eXkBcjBJbA/ov/AOCP/wCznceLPHWo/F6901pbXwjIvhPwT5ibo7vxn4ghEeqajEDuXboOiXRgWUANDc6zFICHtwy/h18JvB+oeIdX0fRtIspb/VdY1Kx0zS7OKNnmutR1G6is7O1RVw5eWeVB8vUkE5C4H9+H/BOP9nDTPhD8PPCPh2CCIweB9LSK8ulT5dX8Y6shu/Eur7uDIrXU8sVu7hmSza2hH/HuK+1zLMKXDPDmMzKVvbOlKlh43tz1JpJW1Ts5OKutYpt290/lzH5ZjPErxA4e4By2VS+bY6nPM6sNVhMpw841sfiJdIuNCEox57RqN8iu2k/0Z0jTdM+HfgSC1OyC10nTTJPO4WMFli86WaQ8Ab5C7yNkgMSSTX8s3/BW39peWPw5ceB9PvHi134o3r6nq6pIUksPAWjTiPTrR9pyi61fRbnjbiWK3udpKyZr+hH9rv4n2HhjwkfDj6gliupQ3F3rd1uC/wBn+HdLQ3WrXcr5CxR/Z4zADJ8riR1GcED+C39rr423fxk+LHjHxqzymz1C/ey8PWPJ+xeHdNc2eiWUUQwUaW3jE8sYBLXUsrcls18z4T5RVpYfH8UY6LeIx9SaoTm3zODkpTqRvZNSqXa0unTi9OY+r+k5nmB4i454T8JOH5U6XDHhzg8Jis2w+H0of2mqFOnl+DqqN43wWFipqOq5q1WE0pI7T9gz4LX3x1/aN0S/+wPdaH8P73T9WUSRs9pN4vvJJV8I20wBKvDpT2d74t1CLY+6w8N3ccuFuFD+8f8ABUz4+WHi/wCKOk/BPwbds/gP4G2Enhi3KShodS8WOIB4l1WRkcJcXK3Eaae8q5aSWC5kyDM+fsn9nPQbP9hX9ibxX8ZNctkh+JGtafLY6DBcqizy/EvxjZxR3WyN1DsPB2kJpujFUdlhu9L8VxuP9NlI/n11m81DxR4huLy6ll1DUdSv5bieaV3mnury7maSSR3Pzu800rOSSWk5fPOB+iZpX0VJXbjKUHr8WIqKLrPTZUqUoUIvpOWJjfe/w/hlk3+svFeK4gqRc8tyaCwOVxcbx5qU3F1U9F++nz4nXV03gpO7ij6G/Zi8By+J/Ff9t31vvsNE2TB2UlGvXJEEJY71JXhiuFYNyCGBr+hP9j/4WjxV48sdQurYPo3gmOHVrsyLmK4165QnTrduSrm1TfeMpOA4tyRg1+a/7Pfw8j8EeDLKO4hP2owR6jqAVAXkvLgE21uoxl3VnVERwxDlVBOdtf0XfswfDc/D34XaPDewBNe1xP7c1xwP3hvb9Fl8huQ5Wyg8q1QA8LHhQCxNPEVnk2SVXZRxOL9yLs01zxTk0m7rkhdXb0bVt0fpPi9nEcDgcv4Sw1S2JzOUcZmnK0nDBUuWSpNJK3tZqFNx2cVP0f0cgEcUabhhVAHyj3wMjoehwOSOelU55iikIQSc98gEsQVwB24PBzjtgDdYkbZkEkgHvnnB56AHqcHPcgdcA49zLw23kZxz/F65HOSM+pOSQcEV+eRgpyTacrta6K+yb73bb7766H8/4/FexpOKdrRUdL3WkUrXuttN9e25RuZl+cg5IHBDfePUgcnrgkknqRwK4/UrlYkklkG1QrszHG0DaWJB7cHjuBjtwNy9lTAUEADBz0PBLDHHGcZHX7p9a+Wf2mfirZfDL4ca3q0lwqXs1u9vZIWCkyuhG5cEHaoy3AyCBknqPpcrwrq1aVOzTm9XsowTTlzafZWr0svnp+W5xiJVqihRvOrVlGnThHVyqVHGEYprX3pPTprrpc/Gn/gpX+0IdY1qfwlpV2xsdIWaOZI5CwkuB8rZUEA4wQDgqBncMDJ/nn8ca600s0jsxZmc7sqSD8zc9wORwegOeeM/VX7QXxDuPE3iDVb6e5aZ7qeeVnLbiSzOckklSTuPyDhVI6jNfn54z1kok4Mg+beRzjpnOBkgcYxknGeOwp8SY1X9lT0pUUqcI7XVopv1b1st35H9i+C3BSyvLMJRdP8A2is4V8TUa951p8spO7WsdWo7W5bdEzx7xfq5mneEMSd3UcjbnuO/Q/7R5OOhrz1mO3nv1Iwe4OOSfmGASpyfXI5rQ1Gfz7h3BLbiSO+RkYB/hIJHy4HKk9MkVlucEDPHJwSBwMEjb1xtGAxIwTx0AP5225tt7yaavq73Vr22tb9ep/d/DWXQo0qMeVLlULu2zSi766fds9BI4zJIoByN2BjnBBGTtwT1GM9DxkdMdPbw4CLjHIGTzg5APBJzyDgt1yTnBzWPYwkt5pzjOe2CSSQOmMDPOMk8Y9B0Vt80i5H8XQAjIJG0lmJ+bbwck8c9ufdy+hdRaV+ay0tqtGm3120Tv0tazZ+1ZLgnGkpNayajF/3bqylo9HzWb6O1r3OhsbXfsTbzkdABkZ6YPzHJwQ3Q8nivvn9jD4NSfEr4o+HrCS3aTTrW5i1DUmIzGLW2kErRkkEHzmURkn727kFuD8SaFbCe4jUjcSR/CSQASOfmBOe2DnGOvAr+in/gmV8NrXS/CWseL7iBPtN9KtlbyMg3GKMF5dhPOC3UjpjH93P774YZPTnjZ5riIKVPLKXt4xadpVbxjRg9NFzyUnHqk/M/Y+AMmWY5zhY1Yc1KnJVaqd7OFPllZpPrK0bdbvzP09tYrXQ9GRAqQWthZfIvKqkVvAccDBVFSMZyeTgDHJP89njjxEPjr+1jLqNw3naVYazcLYxOSYzp+gpLKqxg9RcTwbtudrfMGOBtH70fG06rb/CzxofDlrdX+tt4e1COwtLGJ5rmWeaF4o1gijDuzKGBQIpYv9xCME/jb8HP2EPil4y1iLxD40up/hposs/nbriPzvGV4rnkWWlwyqtgJA0is+qyQvGZd/2OdQBX6z7OdfEZfVdCVei8xjjMYrqMHTw0oSVOc5XinJtys022vK5+6cX0cwx7yfLsswVXFwWIhiq8IrloqNGUPZxrVX7lNbt87322sfXnhZoGsNQllu7DT7fT0U391qV7b2FvbqzbFUvcSIScAFYo1kZlG2NGJAatpn7KPhL4ka3F4+8fQarB4YlvLe3srrXtP1O0TxFczhfK0nwJ4FsGg8YeN9ZvZSItMmvZ/CWjeaWuWa/sIZpB7To2g/C/4MeJtF+Gnw68HX3xg+PN9aLqOnaFqusJqGoaDZLGnmeNviP4mvEm0j4c+E7NcXM10LW31O8RI7bRbSSeZHHj/jn49eINX8cXngXwV44sda8WWcNxZ/EX45WwOnaJoGnzOkN94D+Bun3k0n9iaNC7fZbzxVc3E3iPxRKst5d35gRIE8rjvimjmNdZRlVKOIxuJqqNOE4wnCjUna06jbcEqaam7p9G4o+J464py/D08Pw7Clhs64mquEaeT4WoqmCwEm1GNfNMVaPLTpJ3dGEVOpJJJcrucf8AFX4V6t8GPBnjrxX4cTwta+N9avBb+EPBHhvTNIm8U/DvRNHupbOy8ER3Wiyz6faajq7SXOt+O7myS4lt7dbfS/tUmp6hFcW/5N2fwz/aB1bUtXuYvBfiHUbrxLcfbtcutX0NL+5vb2Vmee6nuNZXaJZGcpGWMaxwHyQqwyMh/XaL4l/C3wXZQWeo+K9HtbeyiMah9Rjv7tiOZJJCxnlmup5MvNKxZmkZmkZiTjz7xD+2D8MLENB4ftdc8RzDAH2a1EMEjZXrJKA5XHPyxZK5OMtg/n0+CcgwNq2f8R0vrc1GeJWHqUUlN2tCEPfm+R3SfJzWV927/mGL4U4ewlJYjibivD0MRNe0rU6E6NONJyUHKlh6XNUqQpRa91ODaerd2z4P0j9kT45axBGDp9j4VidPmkmvLK2cliG3vHpcL3AYFAdqzqiYKYKqoPfaD/wTvvzcLf8AjPx9csBhzBp1q7FACNyrfX88pCdcOsSFc5QAkE/Quk/HT47fES8Gl/DX4RXTSSuFinksb69mVWYBWcRW9vCjHAyXc5OTggg19O+A/wBg/wDa9+NzRT/ELxfH4G0W5cGawhmdLhUc5ZWttMR44yM7St3co2QVZSQQOerX8PMtV4YPHZ1KDXLKrzQpSsko3lJUYWk7X/dvfRM/P804w8FOHqkoKOI4ixkfehTc2/aWsveVPkm0+86Tv2s7Hxlb/Bn9lT4Uok3iN7TX9RgAHl6tqVxrF07rgFRYW7shcjCgSLlShjZsDJ9B8NfFK61l18O/AH4K6trU7sIrZrPSBYWZOVVJDFp9pJcMuCR88sbMp2lRiv2E+En/AASX/Z/8Cywap4zOqfETW0KyTHVJDBpZmBJP7pWaadSw3YeRkYfKY+ob9GPB/wAPfA/w/sIdN8GeGPD/AIftYlCLDpOmW1suE+UF5I4lkkOAAdxQk5JODXn1+O61GPsshy3L8mp3XK8NQVaumkld1asI0lJpXdqctWvNn5zmfjljKUp0+FOHct4cwu1PETo0pYjltFqV7K7Vm3flaabvqfgD4L/YL/bP+M/k3Xj7xDZ/CTw3dBJHsbN/smoCFwNyNHChvGfaqqBLMnHJBI2V96fCL/glZ+zz8Pri31Txmmq/E/xBGFkuJ9bnlayknXks0LtLJIpbqWnCkbF8oDJr9N77UtOsYvP1O+htkUbh5kiJjAyNkbZBLfKx2qcMOrN08+1H4jrK7W3hTw/qPiC45CzpAYrGNgCQ3nyBVPU5IwcZBbIzXyuLx+d51VU8ZisZidW3LFVpypw+G3LGTVGCV3ZQjG9m9Ej8E4z8XqdN1MVxbxjKbvKf1aeNfIuaz5VRU20lty/LRXOo8HeDfB3gaxi03wf4U0Dw3YwqI0XTdPtrXYEUqoeVYwWYADOWyDuBY54m8ReNfC+gQPNrWuWkQXDNELiNnAAycRgsTgcHC556k4U+RXfh74ueLn/4mGuW3hWxcgNa6bme6CE5KmThAdo2gBiAd3y8Ya3pPwI8H2cq3WuyX/iK85d5dXuZJYywO4gW6FItp/usvQcnd1weW4WLU8Ti4zna7p0b1JtK11zW5Y6LZ6a6to/mziX6UnDmWKph8jwtXMaqTUKvI40uePKm7u14vdO8tHdp9eA8RftG3NzcPp3w/wDDWoa7dZaOOcW7mLduYBgUjAweTudhgZOARxy8Xh/4+/EJy/iHXIfBulT8vb2/N4Ii2WQKjKOAW4ZgM8tk8V9Faz4l+G/w8sHeefQ9EggRmbYbeGTCjJGFXLOAANoBIO08dD8OfFn/AIKA/DPwklxBoci6xeReYA4dBDlSQpZyCGCkcMcMAeBuwa9rCYSioKVHA0qEF/zEYyXJpde8k2l1V7N6p2TVj8Dzzxr8VeNassNkNGthaFRtcuGjOTjGTXu+0ajSjo2nzczStrdH1n4O+DPgHwjJHqOoLL4i1kEOdR12Q3PlygAh4opcxx44dTsZhgn5eBXqWofEXwn4agaXVdc02xggQjdNeW1uiIoUYUM6AHgnAXC9yDxX84HxW/4KVeMtTe6h0nUYtJtn3qq2TDzACWUBpSxCtgYOCOmMMMAfn149/a28W+Jnne+8Q6hdFiQfOvJnTDMRyrSbcckD5QAWxjPXlxtfJ6V1i8fPEzjp7LDxSpp+62oyeySWtoX669eTK/BjjviaqsdnOLnTxFazdWvKpiasbuLslzRjGzvZRk4rRJXP6iPi/wD8FIPgz8NLO5i0vVB4q1eFJFjtdMaM2/mLkAzXeNqKCDkoGJwW4xivwf8A2q/+Cj3jf4stdWl5qv8AZ2hq0htvD+mzyRWSqo+Rroqwa6lC7SWlLIoGQpzg/kx4x+Nd7deY32x8MW3bnbkjeOSrAMCM4JbaobJyuRXyt4q+IdxfyOizs+SS2GH8XOAFBJGDlskMSCx4wa+Ux3EeGw6lTyvDQw7a5XXk3Ku72Wkmly+airPReZ/SHh79HLCYOvQxOZVK+Y16coydTEt+zg7xs6dBL2cbPS7i53taS1R7J8TfjDqGv3Nw7XbsrNJkh8Fh8xCrgqQvUDYoJz1LZI+WNW1+S6aRmZ+dwyWIyOexI45HoOACTjIx7/WXuCSzsWycg9QT028E8jn/AGuWA5xXPSTSSEtn12nkcEDgk5POenJ4JI4r4ytiZ4icqkpSlKT5nKTbd1a2tnbVbbrR9z+zeHuE8NldCnRw2HjFRjGDcVZ6JWd721vtZ/N6F6a+U85O5s4O48+zAkjJwc5HA5JyAGzGldmI5GTtyQ3QgYOTwx69B6ZPUCIhtx4yTjjnGCcDPU+/rjkYAGDyC3JODwTjHy5HTk8jjH8Wck5GRnnSbb/q/wAKTV100V9tLn6FgsscWko3em3RWi3pa217aee41VyCd2R7kgAnHXbjIPBHT24FShV25HoRknIycYOcjk8jofujgHkrs2nKgDBwc5I4wM8YxkYGN3Hqc5MhUjJBBwRgcZPOMknIHTIOQcjGc5raFKUnqmra289NH0erW120+yaf0mGwEEk5K7UVvt9nvu47aaq+1tBu3JOCeuOvH1xjkc5+vyhs4NPA2kMDkAAYDA5B2jGfQgEDg44zzwBFJIAGP4jjJ6AcZOSRu9s8KMdhZihZhzwvRc87QSOuMZOeo6kjH3hzvCkk0tZSv0u7u0Vq3be120l1jJb39OnhoweyVrPqtHZXfVrr10u+mqpPIqkbWx97IwSNwJB4AOAC2OfU5AxS/bJWwuCO4OfYgDgnjBwMHBPtipWUIvy9GXHzDjJxgkcZyCcHHUdBgVCdiLuYjoCwHTaQM/wkBfXJA/u4HNbym4pJu2l29r6rX5W1vq+zOl1uWPKnqkk3oveuvPS/R63jr5uZbpnwDk5HysGxjd94AY5JyMc8Y4/hA0Le6dZVbPzbiMBiSTkZJwAQSeRnOAeuDzlR7GVpUX7oJ6DAYBSATzydo7DGRgANk27AvLJn5d2/7pXG3O3K/h2Jz0x2Fc88TKytNptJ+67b8uur1bb7NPtuebi8V7FRfMm5a6X2096+vdWv+DPvX9iCW6v/ANoP4XWUMkm6bxFbEiIgttRQ7nIOMMFORkbiNwx0r+iX9qDVW8Q/FH9nz4PSy7tB0zVtW/aM+JkYIKJ4S+D9nHdeFbS/RvlNpqnja5tZkSQbZm01du6RFA/DX/glp4Pk8V/tW+BIljV4tJhu9VlB5wkERUMVHCgswUD5QRtBBDHP6KftbfFi20Pw9+3H8dY7tVn1K/0H9kP4W3Qfg2nhSzGtfEa80513ExPrs4t5miAAuI1BZccfveS55PLvDqCrTbljMTiadPrajyU3O/S040KlNS6Sav0Po+K+KcXw19H7iWjhJzp5jxpmkeGctcZWnGWYQo4arXgt/wBxQlWqStpaEm3bU/nW/aW+Jd78Yvj38TviJeXDzjxD4o1Oa2aQliNPgnFrYJGx4C/Z4YQu35FQH7oIWv1b/wCCGXwHHxF/ak8F+JtQtPN0rw/4hl8V6hI8atBFoXwptLfxNLIzMCvlz+PdQ+HUIOQrC2nAwY2r8O3DPK7hWZ5XOAF3M2QMIoA+Ys+MgHeGI2k8iv6ov2JrdP2Mv+Ccn7VX7TF00Vh4oHgKy+Anw+l4jnl8f+IpP7U8ZzWspALy2Hi7xfpmj3bK4IX4eyBiTAQv4plEJYnM8Rjaj1j7SfNK+k6ztGTaW8IOU76W5Lq1rv8AjrxFxv8AYXhzj8sy9OOKzLB4LhHJ6EUrzxWbyp5bCEG7rmhQlWqX29y6bZ8efFH4ga1+1l+3F8dfiZplw0p8SePf+FcfDm6aYFIINW1L/hWvhWe1k5ijjsPD1vqniKZUJaO1tbi8VWCSY5Pwv4l0/wCIv7SHxk+Lvh2383w74Qgj8PfCi2jTzoxofhS30j4SfByzgjYgBJ0ttDvhbrlvOgupUdWiy3n3wmuZfhT8DPHXxImmkt9X8PfDnU9Y0i6LBZ3+IPxWnk+Fnw4ijc5/0/SNB1Pxz43sjtDwNpk13CyqkjH6k/4J0/DG1vNe+DPh7UbZXt9V8eSeNvEm5DlfB/wP8P3Xi/VRNkAC3ufFd/Zadu3COSax8sJ5sKvJ91ho+2rYLDpLnd8VON1aMuf2GHV9NYTnKLj1UF2VviOM5YXh3KMvyPD3hguFMhweUQila9erh6OOzZzasnUeDoYVqTd7zqK127/0Bf8ABP34K2ln8f724NoDY/BrwF4f8O+cyApJ4gXRLfS2LMQA0yXM2uTMznzGkYysXc5H7UazchUcAcAcEnAbnBwc9OOoxnJ6nk/If7BHhV7D4UeIPiHfxFdU+KHi/WvEbySDEh02C5lstOUM2cxnyriWMZCbZQVC8CvqbXpwzsBgKuTyeeMgEY4GSCM989yQB42cYh4/iCdJWdLBRp4aCW14NObS7upKadtH30Tf8Rcb49VIY3EyqXniJ8qbdmlShCm7O9uVzjKcei5tNXr8Dft4fGOH4Qfs/wDjnXY7gW+qapYS6HpA37ZGu79DAXiGc5jjMrnaDtAAwMhq/hh+MHip7ia+uJZ2knuZZnZ2Ylt7MS2T3YsRu5HIBXCjFf0S/wDBZv45Le+ItC+E+nXga20G1fVdYSOUY/tG8jDQIw6CSG3+YBzlfMJyTmv5YPiJrr3uoyRIwMaFgQ3K7gSAFGQCM9ME4IzySRWuf11QwuGwEbJwp+0qtNfxa6i7X3bhTUFbdPmTVj9Y+jFwXKWEqZ7WpP2mbYv2kJSWv1PDNQoJKz92dR1aq1d4zVl1XmN9M9zcFmboxPHHU/MABnOMcnqcZxnitLR7IyyiRsEKMDAYgsAP4e/HrjsRnPGRCpkcKoO4nBCncfmAPUAA8jII5B4J7V6TolgEjjBTG0KWJwASc56kA8jgEcHA5FeDleEliMRTTUuVSi27K7d00trW6uzat+P+nXCOVpRp+6lGnGKXRO1mtr9ddOtujsdHpGmPM8UMUZZ5WRFRVJLEnACgcgsSGJxkAhcAGv6L/wDgn1+znD8PPBUXjrXbFU1/xFEHtFnjIltrVhkFSwyhkU5BGDjBzzg/l9+w/wDAOf4u/E2xmvrVn8PaDLHfajKUzCzRsXjhyfl+ZgARgkBcnstf026TpljpOnwW0SJa2On2gjjUKEjihhQAsTwqIFG9yc4XPfr/AFVwNkscmyn+0qkEsdmMXRwatadLCuyqVUtGnWkuSMusFJ9Uf194Y8NKEXnGIhyxguWhzKzbsr1LNPRd1r9x5n8Yfir4e+Cvw+1/x/4jnRYdMtJfsNszhXv9SdHFtawAnJMkpUEgHCBnbCqSf5M/jJ8WPEnxf8ea54o1y4mvNY8R6jJKIgxkFrbSSf6NYQIGOyOKLYiqu3ao+bByF+2v+CjP7U3/AAtXxzdeDfDWoM/gbwVc3FnB5LkQazrEbeVc3pAwJIo5EaK3+8AgLjGQV+OPgT4PsvOv/iT4yJg8P+H0e+JuVws88Sl1ijDcPJkLtjGQXZFxuOB8d4l8SunGPD+BqtOFp4+pTfx1rJ+yck0vZ0Ytp3a9/mfRH5n48eJlLLcLiKOHrSlRwj9hQo03eeOxs+WFOnTivenKU/cja7snLrr9FeGrvT/2Y/hHJ4jMEU/xW8fW72Hhu1Kq0+lQTKN2oOgBeP7OHVkwoMk3lxFtqsD8A3tpqXxA8RRfD7StTjjuL6e713x74s1OVnsNPt7OKXVNZ1jVryMvIdI8O2qXV7dBUee4vmSzhjluZ7WOTp/iz8WdQ8Va1d+Ob+Ro7m4L6X4K0gF5EsdPjZoDcLEhL4RGJV41Yy3bnarBVAp63Cnwl8ETeD5hv8d+JTYaj8SN+DPZys0Oq+Gfhm7o7NnTma28UfEIGUg6udF8Ozhbnw9cSN+UYWmqtOcqyccPRpqddqTT9jOzp0VK38bGyjJu15U8PGTinzNP8I8N+FZ4Gjj+KuIL1s2zOccVmFSd3KnGS/2TK8PJptRivdah/LWqWasji/HOot4s1bw/8PvAemagnh7SUi8PeC9DYOdWksr+53PeX8UZJk8U+NtSeXWtbkKl7eGWLT4dlhZ6fDH+oHxBOk/sHfs3t8DNK1CLTvjN8VfCdt4n+PnirTZEXVPBnw81dJI9O8BaTdIN9h4n+IGZdBsUjZZ9P8Mw63rPlBbuznXmv2JfhZofwS+H2u/tw/GfSBrP9m3Mmi/AbwVdjy7z4k/E3VvtVvp9xBDIElNnb3KyTT3scZi0zT7K+1AsPscCt+VX7THxo8Q/FHxr4hutc18+INU1TxDe+IfFuvozLB4l8XXTRwzzWqHIj8PaDaxQ6B4ZsQEgtNLs1kiSOW7lx6maY5cM5TVx1Rxhn+fYdUcPTslPLMmlHkhCnFN+yqYmC5eVJOFFWjyykfsGPx1bIMrlNSjT4m4lwzjR5WvaZHw/NKnOqorSjiMdGLoYfTmp0FOStozwbxt4qvPFOtXus3pitIHMdtY2cbCO00zTraNYLDTrWJj+7gtIFSJcqSSnOWZmPntxfJviSExvG2A0vyEjmM4QEoWYE5bdkFeFO7CVPcwW7bmeKJmYZDFWlKtySxZuQThCwJCqoBXOMjMMaMWyhQI2AoZvkEbqVYrvY7EBwADjtgnFfgWJrValSUnZuUnJvq7uKd21pr57rfQ+AoqNKFOlFKMUoxS6293S+2r3lv5ybJZHZeQrNgjCjjAyuSMAgYXBIOOSrYHOa0ioxR3A/dtuQkAgE7VymBgEkg5yQcZJx1fHNHL+8jfzFIOGDHBKkM5xhWIB4GcnHJJBFMchd25i+7BA2kBemevyhQW5GB8wYqeqjlu5dNNHZ6KXw7db7Nd76WdzVTj6tJP4k43fK231XS8Y3ulqm7kDR4k3KGKtkkZb52B3KVIc7Rt2gjgnLBcgmlO0bgFYFhuIOGAPy+nAxt2kjkK3y4HyhXLjKKd537sMrcg4zll6bSAVIB45BJ6xNksN7KBllwOgKlcOWYhtrEAKMYzjB4GIbSSaTdmk1ulbljdvZaaavsraFRe2iau05Xe3NDXS9td7tNKzdxd+/AClRtKr0JK4QDaCVBPQ/d6D5hyAYy7KpKodxRWKA8FcLkkZJKkdSSWBACgo2SF+FZkYDeqEsNx+UqcnBY7uCecY43DGWNeW4jiyqnfKxHlwx7TI24KMgEbEUIRyzBNhO1ueeeUkmm29r26u9k0rp62skrN3fzdRla13rprb03Tvsls09SVyFUhscKTLlFUhkK72yWIAX7u0Ftp7leagnfEPmgnaFG3DKNo+UHLHC4HJYZyvJ6EgRL9o82RyVWIImy3UAqjAAtIzYUvgpt3LkgfKQegngjmnLxKgLFHl+bIAhQBnLAq4AUEHjAZsbRuAByUnJPS6s7J21SaUdrLXe9lK9nrsaXelrK2mrTvrpoujWu26aulcqJGyx7A7OFKtlgzZbgEMcjchONu1F/hC4YnDR5hZmLjygSpjWMhmYCMnzWyCDgZyOhC7iAxFTyCBZYRFcSNAM/aSbRxIu0hc2+GAfaEYq7+WR5gV0UA1YP8AZYyFnvQu0Y/0KLbI4xglfOLc7SQcEBWzlgOEkrJJ2UWo9FordE3dLqn6630pLe6T0011SVt9dXqrp7XV9N6PRQdmV6KSqgKG27jgK5O0EnA+bJ3KQpWmO+QAY2IJ2scYRTwcFnxnqSW4JHzYB4q6E07aQ89y+Q4ASBD+7GAGyrlC4AYMSQVB+U8kU7bo3y/6XeEYUeX9khGe55LkAcYXJDKPuoyngtdXVru2ultlbqvPW7b7Iu1+q5nu29tuuiS3d9unZvMLEMoaLO0hchRuIyCSWztDArkHAwnzHJxhxdhnMe9myF+RQwyARkk8gnkkAOw4XJytaPk6KGYNdXxOCDttYVLMBuDgM3ABC/LkEcAkoNtRtFpaKyx3c7oGYqPssTkhQBsJDMudrBsEYyBgqG4lt3Wqb6JNW5W1d3Tsre9Zfh3peWu101bdx1tptrftp86DMxICoAflYtjduYYPKg8gg8bfkYDAAPJN47AgrlFwu0HkDac8jc2MEjJGA+DjNt0sA0QjuJcYAd5Lb51IPzSqAWJUYwFJHDHuNxkeHRwGC39yW2lyTZKF3hgMZ3g7RhmUjJbOwg8NUq929ErN6u17W296zdt7O1u1mm7tvS2q05mlfZvrpone6erdrKyeTKinAZiOFkO0MThSu5Vx90HGQwKgkEEEZIAwMYYlWUr5YKqTjAXnABIVSxALfNjJGVw1XpEsfLkeCeWSZlbyPNtyscbMiFjKd3b5towyhduVBPEMEVicC5nlIVEXdb26NEJflV1KOVJWMLhVwck5jJDKtJJykrrm21vZJXVk25NdH6q93uXGN01zW273srat35XbtZXb6opyll8smYRgMu4eWCHXchCFtqg/KD93CleCSCCELlsgxbuCI+MBIyEDFQ24MhXsMZIAJGcVdeDTSFIurolGQ73tl+ULknYQ+CmACwI3EkBtnK0r/wBlAxbLu5YlEVw1oMEEn5wxOei8cfKeYw4BwuV2aso6K3vfElZJK7s9He6vte92Uk7+9r0bTum7Ky+0rveyi3pZPos2ZIptsTRMXEZcMgEZibG4sjKwKuAcgF9p3AtjkCiLS6kdAuoXAjHJ3RKXT5gcF9q7ycj73G7aWIyBXQxRaaqM73sgVmwsf2WQHYNvzbcgMz8BcHgliM7sK2OHT/M80X00apKAIvszN8mMOExIVG4KPlfJAAUrkhqynSjKzlurO0ajg3qrq6krq1n72j6baJxXNFtpWs782ijaNrtWeq3el+mu2M1hctgf2ncZKsSpRFIB+XGehPAweT1XjcGqNbGZi8SahOwWQtny1GCpBUZJLggkbcYUErhstmuhdNLZj5d7OOSCqW7Ywd20sTIxbGACwzkEEbgGKsFrp43uL2TOSUQW7jgYDHBbOMocByybnGW5JqZUI3jfn1S/5et7cm/vPV2u3fS/TRlckZd3ttK605dne7UVdt3WtraavBlt79FDx3s0jfLkMiRpgAsx34Yjaq9NjOw54QA1N9luigB1WYggPlI42VDjG0AKHxngkqqkgEdTW+E0xMbbtsCPlGtHILqCDlg4bg5PHIOFUlQoWFUs3fD3LoFkCxbrYnEZAYuNrbmwcn5yMbucEDMRowUleUnotFUk0vhXSVnpa95Wslppoezi2rtWdrpSvtya7306PXdKyvdY32W8i2sdSudjbiAsKhwRkEkGMHAwNxAyBg4YEkOitb99uNTnjUuqgPDCCMOiEAuUUkZBCbyMZckj5js+VYI0uy8lZmcf8u8jKqkkMRukKMoIxh8khmMgIJJtRQ6WjRub+XJYM0UllIxLqYt4BMhSNOSCEACkqFbbkAlQik3dpLS/tWv5bap7Lqt7P0slSUlvoub7e7ST5r3tyq22j36amMFjk0pt7Hi3n2nLIQw3ZbBb5txVSQF4BLbQ2MZ0Cb9ChUL1dH3NzsP2s5QgZbkHJGc42kZU1fRt2nTxMuGiguQr4Hlt8rktGzMBlmdwT3KMoCSZU1LHd/YsDBt2JI1ZPnYENdnhtgABbBEeOflkB6Bq8vdxutXQaemrtKO91fTVLmfXvc+RjzKE/wDsKi4pO9lurNb7LWy1W2hr6vOU027jx84ikUnIAMbmMF3LDMjHP3htPzcgEk0yJYSdFldSzfZWSN3bdjFsuAR5iAPu3FSvC/L3UqH35A0q9Yk7DBKUBUlyJArK7k9OWXnecHJGUfaGRSRONFhVnZ44zvLIgC4s1yF3D5g24GQxknGDt3gbtm71o82nNTp8ut/+Xi6PWTv3bb09Dmjf2DUX8Fau5a291UFfls/h1S1XdsZ4gXdFpsbdDfW7AKuOCo2ghQFJGMghvUgcsa6K5U5bcXCI7naHIQPuXDkkqzfKOVBIYDnLHFYmtRhRpUYOVOoW+5lbzDuKjqxwARwwG1TgDcBjB3plX5wfuljwSMkAnIyQSMHa2DkKcMTgEDemm6td20/dJt7bK/V2adm0mttdbM5a0rUcGm2tK1t9udfi0kla6WiT3tUllOwyEs0aRFmTe+VH3i42qQCASVGTycEHtmWt7BfySC2nuk2MrysxCod2wqqBjhTuGMEhgBkMoYY0I4QxBlZ5CrZjLYwinZgBcKxIOWbfnk7sYGaldCp/dxoNxG9QACFC8lwnUqCi88DAOCMkXacpQfwxtFyT1bvbXRu2tr9l13vClThGUVFyqSS5ZprljdxbvFq0mkrbpLpfcjxMY3G91LsqMU8zKFQod1Bch2YDgtltxDEr8oJHtMjnzpJHKqZP3r4UAq4wgAKtuOCo+VcFVwcmnYRVY4bBxjGGIZsYOMMMFsk54xgKPl4WKLYhjj2r1k3KS4YtjzGxyvzsOB90emQcVbVWtottXa9lZbLXXW3TtZGafuO2jlskl7yXL13tomknq9LdBk8vltG00kgjIAZVcou8qpTzCXY4VQXDBWwRuweFNcT3MjRyqJpIiW2yfaNuQw3rJGRgERLuzu3knlio+QTNKhk8okc7gGwGVlKgFi2wK3DEMATg/IGBIKywxpGqpGiKg6qMDgknCFiMKu5eFA3EAjcxOVyyk1aVo7uz1T92yvqkr72d1ts2WpKEU+Rubso3V1y6dE077dNrpJaDStwAoW5eJMZlZATI2zEn+juzSKgxG4D4UANl8g8OVgJPKElzLJNEJBI90xWMBdjmQFv9dIy7ggU7GWNVVkUMzizKrNsLFAxjVFBkZQAWwWAHzqxb5V3LuO8LilVgRCkaSHzsmYERKYkOws5yCqygKAFZgRHtC7gMK27NS5tVpa0npeKto7K/e3fzZlG9mnCNtdY8qbek0m9JOy1V9L3XkSRs8jRMl1PdQqQsw811CqE3IyO7Irt8o3KkRKKNmQeDrRxLgHLAADBLlQTlcqBjGTuwByCDkMCaoCQ7iMMQpJ4IXJXEaNH5ZIK4BAYjHykkgAVdhdiAr5YvtKtgBCAUyp3/ADAqcgEANnB68jekr3v7zbWl5K/w6J30dk09d3o9kceIk2lZKKTulpdrTXRpPvfdaJa3adeKRZ3PzMx8iQ43SMFJVMknBHTqGw2cH7pY0mmF0s4DjClF3FV+YkHYHLIcIQkS7iTuXcCcr8oW93NY3RQSEmErlTgY+XcWLDBG0kkrksmRnjNP0wJHBtYZYK8RycqQuAclgQWyGcbVztOTyvGkUvadvcWqerd4tXTtdtLfS/fcwnJPCtN3/eJqOj25FdW6W1to726m3bxqUBJwDgAnvkICMAHcAOAMsMcp6VO7S29tPIrI7wqCgZCQyqVAyWbJxxgdMkK3LA1Fayo6sigNsZVJChQ23YoKAbCNuQCwXGMcksDVq6jVrG4OBgQ5yc7lb5QME54BJGMAgnGDwa74Jct76qN7Kz17Nq6X5/m/IqycZwjNK3PBWaV9XG/NbRJ66bvW+tmXLFJV+xPPcG4e4eNli8pUVMohzGFKMdg3KSWKrvztAOW6K0UhbodXYXG/KuwA3KF5Awc44+7t+bIxgVmQ2haDS5/MxJD9mAAc5ZHx/Cykg7oxgjCgHDDcxzu2sH/H0pUh9k7fKCcqWUZbJG47s4DcnkAAZA7aCaklrumrtydmlzb3ur306u6XQ8LG1k1Jpxum07JRSUZJJWsrXST23be6SWrbRSxhFyJreRIGLDCuJoo5cqoVwqg+XtxgIckqQdxrsNIkwIf3EzA7QWCpglTH1XacsBktghdq5BztrLtbPz4GZj5ccUdttQEsN5YhmChQ20bn+bcwBYAgkFm73RNPGI1AAzGCzdCQNnAVccMxZuGGSOecV7uDotzi03aSXKpaO946Wv7q0aSv1u7HxWZ4uHJON03G6drd4tPpra6adktXfv2+g24nICIU+6CpwGQsEO0gsQxyfwwTwcCvoPwZoySGBmLZ+RRg4Bb58BiSoLKQBgHAwAxLnNeWeGdPSZ4/LbaTjzcL5eR8gwhIIkchgBgAoSRkkg19WfDjw1eahdadZWlo1zd3dxa2drBAhluLq5up1gt7aJFG6WaeeRFCDDNIwVAcjd9/keEdSpTXIruSWl79On322T3sfgHHudwwWExEnU5FCDbu49Em5b8uiu2un3W/aL/gkl+ztJ46+KrfEq/037TpPw6+ywaCrxkx3vjzXImt9P8ALLZV/wCxNPkmvyT81rfXGlSnJxj+37wTodh8OfAdraySQwpYWD3F9cNtjSWco091O7MTtDSl25OFBAHAAH5Vf8Ewv2W7X4P/AA78K6DeWcRvvDdmmseKbnYrLfeNtdhWfUsS7czLpaFdOgbBK21pYuvzLgfcX7Vfj5dA8IL4TsrhILzxFvtppfMCfZdLhG7ULhySBHH5P7ol/uiVyC20tXyvHNepxLxJlfCWXyk6NCpSWKcG3FTdnOUuVtWp0uabdrNTS3Vl4vgpjMH4d+HviH9IbiWKjVxWGxWXcKU8QuSdXCYeaoUI0HJXvmeZ+zhprGNGT1g2z8Ev+Crn7U0tr4N16ysL8w618V7yfw9pEaylZrDwDorxtq13GCS0S6zcNFbMT9+O4nCkeWc/hP8AscfCK++Pf7Q/hmyawOp6J4SvbPxNqkEkZazvb+K7gtvCej3IZWUQan4hezk1CAsG/sWz1q5cbLd2W5+3N8dI/jF8bPFes6bdGTwn4dZvCXhKInMD6Lo0jxS3sajC/wDE1vjdag5ALlJ4VP3RX6mfsJeE9J/ZE/ZM8c/tL+NbVIfEc+mJrul2V4gV73xl4gsZ9O8CaGI2UuToehaouo3aAq1tL4s1iKVBNphki/ZY0qGVYKhgsLStRy+hSo06a0jOvJU6VGErb81Rx52r+5CU3aza/mLL3ms8qxWeZpXqVuLOP8yr4zEV5r99TnmMniK84pvmj9VwspKlTtpXlCnFXmk/nn/gq58a7C58YeGf2evCV+1z4W+DOnCz1mRZBs1jx1qCJcaxfXYjwkl3AZ5BcMCSt7caiPlYuE+Bf2ZPhw3jLxrDql5bNNpegMt7cFlyj3PLW8RyW3cpvKHnCjG0jcPHfGfiTVvHnjHWNc1W7m1HVNc1e91O/uZW8ya8v7+6e4uJpGOdzzTSOw4wVBwMnFfrV+zR8O7bwP4FsZb+JY7m5t11rWpGGCAVLW1sSxz0ZFCNnDFlU/NivNwFGWOxyTftKGF1lN8zdWV+ac5O796tUc6jt1bXY/srw54cwvC3D+Hp1YQo0sHh/r+YTt7inGlGbg2krxhyqnTTs1Tgk3ZJL7k/Zu+F58cfEfw5os9uX0nw8IPFfiTcmI5GikX+yNOkZgRie5UTPExP7q2YL8pzX7eRRpbxRwoAipHsQKoUDC4Axj5QMcbRk4OeuD8lfshfDqXwr8Pk8TapbmLX/G0w1q98xNstvZOqjSrLBXIFvZ+XuX++8gK+n1q5ZR09TtJAP15ycAA4zwACO4rxOJ8weLx3sIPmpYWLpJK3L7R255ddpe7e6bsntZv+bOIM6q8RcQ5xn9WUvZ4rESo4FN6QwFB8mHSWyU1F1XZJ3m9XZEFxJtLDcDwuMd/U+/HTnPsCTWBdT4JO7IUEcngYHc+5OM5B644ANaVwxw+MdBjOOCcHBJOMgn5sck9zwTzV5JgZHBJwBkdOedpGRk85Ug8YPWvKwtFcyWjbt2vyvl27X3fm3e9tfzrOcZ7s1zfe1fddPX0+SvbG1G5jjSSSSQFUUuSeRtADZIx0UAgZ5PRuCc/z0/8ABSb9oMaprU3hPTb/AHWWlCSGVY5flefHzkhSoyoO0FuBliMgEN+xH7SnxSsvhf8ADjXdZmuEiu2tJ4rVWcBmldD8w6k45LAc7uM5OR/Hj+0B8SbzxT4h1fUbid5XuLueRj5hJO6RjnOcsxLDaAT8wIBK8V9nQUcvy+eLldVq6dOh0fIklOV3rq3a62V03tdeG/DlTiTieGJqQ58Hlcozlp7tTEysoRta0vZp8zte0pRb2bPmrxz4ge4nunMhclmwAWG3LN/CSRjjjrn5sZzmvkrxjqjSSvGrnJYqScjBySwBBzn7vGB6+leueK9XBilkLFQFk+6Sc/KT0XAyMFT0AyM5PFfNep3f2m6mkznLEAc5C5/If3fvEjkYGQF/OM2xLq1HHmbV23e3Szfl5LTs97H+lPh/kao0qU1T0jGNns/hjtpa1tdL6rzSM2T5jnjIBAOT0GNwOAQWAHAIGT7lqqBBI2zb0Iyeu45BJznOSO4Hp9akZwQcE545z0IIxgngZYjnqACp5zVuxiLusjA9eMnnIK8ZI44zjODggk5ArzsPTdSpFO2u93ez9310d7O97N3s2f0rkOBcvZRS1k4c3V2XL7y06d7q3poakCqsSoOCxwc5Bx9RjOSDwM55GK2bFEwMAZzgYGGYHDdSBk9c568gnnJpwReaygrkkjnjkALjJwTknOAUA5JyCMjprCyVpkQqzAdQAG+XuT64HqAO5B7faZZhZVJU4Qg0pOMY3dtG48zttdd12aV9z9YweHUVCMUrKMYpWWr0Tb7Nrq/LbVHrnws8LXPiLxBpWk2kRmuL68hiVQuXYyuFwOSxHzYUYGT/ALJJH9XP7Pvgmw+G/wAPfD/hy3ljgeCzjnvXwMtdyoGkBwMt8xPzFS20KuSBx/Nt+zj4k8LfDvxdYeJ/EsE9zFYEyxw2/lGYzgN5blZmVQFyMt3JyDwM/pLrv/BR/wAL+HtPC+E/Ck2rasV8uKXXbwfYVl+QqIrHTwZbkJ8ox9piiAGHlDE1/TXDlfIuG+E51sdmeEwtbE1VOvTlNKsqdFRVOmqcU5ScpXlom3ZO6ep+2cH5zw3wtl+JzLNsfSw9d+5GEm3UVOKi2o8qcm5y6XvZWbWtv2ZvNX06w0271O+1Cz0zTbKJ5r/VtSuobDTrOCIMXkuby6aGCNR1yz8j5QeBXwx/wu34rftM/EOf4L/sYacZzG4i8d/tAa3ZsvhnwVpMjtHcX+hxzwhHuWiE39nXd5FJe38ygaNpZVDq1v8AJfwI+Gf7UX/BSj4hWmleIdd1Pw78KdOvILrxJfW9u9l4Y8PadvVjbWWmwmK21LxBcoAtjbTPcGEus13J5ayMP6bfC/7PXhT4CfBhPhJ8AdA0zQIktjbtqV87LqGp39xH5V74i8Q6pHF9q1HV7gB381sm3XZFapb28UVuv51nfiJVxd8JkkquFwlVONXFyjy16tPRNUoPSlCSuvafxJLSPK1zL8j8QvpLTq0cdlvCEp4ejHnp18wglLFSbteFLkuqNR3V1Fud2m+W9n+C/wC0R4t8G/s0eDNd/Zu/Z3l1HXvFfiOUy/Hf44alO9744+IuvsHF9ay6urXVzDpolZ4hYxz+TaxM1qomdri4m/M7SPgZ8WPFkiQaTpOrJb3MiqsgE1rFJuICqipsaXoFAEZdtvCnBWv6jfCX7BPg+21OXW/Guq/2ve3EpuJrTRdOt7KJ5mYvIJNSvReXkgJJ3SQpbOW3MjLxX194U+EngTwZFHF4X8K6Tpdwiqn2uG0F5qbgY5fUbrzrskgfMBMqg8gKOn55OrUq1ZVJV6sE27NVHz8srXk6nM23JayfRvbZL+UZ+I2dwVaWX4WVLEYiUquKzHMKsnXrTk7udk+ey+ypzjpfRXd/5jfg5/wSl+LfjWa21HxLYz6Rp85jdrnVQbC3UPg7iL6eG/ugF5It4SpA+Vulfrh8Hf8Agln8FfBMVrdeKVk8VagixF4YYU0nS9yqAys4a51O5XjotxCjggKi8iv1VsfCl/csrRWkj8D94/O0jkEk/u1PIPJJDE8YwT1Fv4SFsFbUL6OJ1/5ZRDzJABj5eG8peANxGSMAjnAPPWxmEpOKjVXOv7zrVG7J31c9ur5YpNejPy/iTjmnBzxHFPFjcNX9Wp4qOGppLldlCk/aTbfu2nOV9tzwTwh8Hfhx4CtYrPwt4O0LTIoV+VLax8sDA6sJGmllkxxvleTrtIXOB6bGpRQpCW8YBARNsaIuNqhUC5BUEgc/KuN3zDbXdix0uAEQwGbjG6d8cAgkBYwON3zck4OQTWfcC3GP3cSBfuqEHQAgLgkMwBPI4XIzgnBrBY1VdHGrJJaOb13V9G9N3po9noj8Nz3x94XySNSnkOBqY6suZe1aVGlKXu+9OpJOpPXW/Ld9dTkpJZG+S3tLi7kHGQqxQgErkGRyAQ3Qeq7u5NZNxomv35IkvoNKgY8x2Q865wSMqZn+RH4B3AE8jg9a7WS5jQlmKonB+YgbQBtBLEhRjuu7ptUccV5d41+Mvw88AWst14p8T6Tp6IrExPdQeduUE4SFSSWPTaV/h4yeT3Yb61UaWGw3M1a8lFyf2btyfuK1tXbTo3Y/n7ijx2424hlUw2Gxay+jU9yNHLoSdVpuKVqnvVHJ2snFJ6aampF4H0G2cXFxFJqdyCT5+pSSXJDjILKjsUTGccICBwOla082naXbM8slpYwRKGJOyCNVAzu4AVTgA4YkqM5Ir8tvjL/wVC+H3hn7VZ+CLQ63dJvVL2dhBa5UkB1IYMw+VsMDkjhRuAJ/Ib42/wDBRr4m+N3uoR4ik0yykMkf2LTZDEirkqIzIpXnpkYIxkAsRivRcadKKnmWPhDa2HpP2tVq0bL3X7NdtZO3bc+Nyzw/484yxEatWnjIQqNSnisyq1G2pWUn7KTdVp9nGEb2s0z+h/4sftg/CT4YW9xHe69Y3t7Eh/0W1ljmdnXjaSuSpLA4LYx78V+U/wAaf+CpmpXD3lh4NhisISJViupXUzFfmGdgJwzDDHjJyM8V+DHjL466vrE089zqc9zK+8u0szyOxJPzby2SGJPzfNt3DHzEAeEav4+vLvzC9y3zliBvOOd2Bxt4I565ORnkE15tbibB4RWy7CQTWn1jE/vKrd4q65oqEb7pRj89D+gOEvo24Cn7HEZ1KpmFX3G6bTp4e9o6KnF3a/xOV9dNbn6G/Ez9sXxr4ynuJdV8RXlyZC5KPcyLCgJOFVAwzyQg46EKBnGPkbxN8X7/AFBpT9slkJ3E75GIDEYZh93nGBkZUtwF4NfLuqeMkXeWuCXwwbliMckNwCd2CBkkKSfmGeR51qPjZn3KshIOeuAQSeD1zj5sAkbgTla+Zx3EWLxbm6tWck7WXM1FLR2srK3no+1tj+n+GfC3KsrpQp4XL6dGEVFRUaUVZWg07JJea77WT3951rx9JJ5jtc7hljt39Pvdc4QY3ZAJOBypPQeW6v49JLq1wc8nhzxyQDvIxjBG7AGcZIBFeO33iK6u2YKxGWPzAjG35SAAxGDn6jIAAABrCZ5pWZpGzngZ7A4JCrnI29RjBHUjBWvEqYmdRttv5v8AR3T/AF63sfr+V8G0I8n7lWSio2jbRW3aXS1u62Wtzr9W8UTXjELIwznaSWDbc4xuOCRkL83y5Y9F/h5GWaSRiSx5PUtkDOMnAz97gnJ7DHymo9qgEkruHT06qQSSTzhic4PcjB5Zv3zkHPJz1+YdM/LjKkDqCOOMdQOW0pNat26PV9NdHpr+utnY/QsvyClQjGMaVlorKO+kWnfye63td76ETcABjliM4JwGJYADABwRjpgg5+bIANATJPJAwD2yOB2IPAA45wecHjIn2AgYOTjaQW/2c7sEdx2O5Q3fqCoiJ4GQCQSOQCRtxnG4ZPK7s568nki4wei5Vbo7q97q1ouK111TT17dfpsPl0YKKaSSd7JWa+FtPbTR7L57kSoOy8gjPuG2lssPm2sQAMkAAEu2MmlMY4OQAeoyMgnt8oIzj88Fs4q/FbthmZRgDJL8Y4A74PGcYI+oND+TGuXdWGMsPugHjsRjKnOD9SffojS5fe2231bs7Xav162utPI9anRp04xvZKy8ml7qu3pdOXRbJuy0KflE5OMjOM9Ac4BzkdApJ256YJ68y/ZSfvOqY5yTgkf7JyTghSSDjjJyp5Fea9WNSI1DrxyCAOTluQQTwB0b+9wR8tU2e7nK4G0HgAcnkLxgcnGD75IIwowa5oxteTbWmz3un231V18rbop1qNNuzT6q1rP3Va6u9lol8N7XNEvbxkZdQwGc57ElRzjPIbPG7PORuxUYvlKELjvg4AbnOACQCFOcHg54JG7ApLXRp5CvmhgGGe5IAxwMn5jjnHBH3sNxnrLDw6p2kxFyFBBK8DIXAyxJJ6nkjIBPJAImVblTs0k9Vtd3tu9dFdLp6dDz62ZRgpJSUVbyTbTSVrKy0lZpL59+SRL25b5flBxtJGRtyqgZJPG7GRxwMcHBDr2wuobZpGkJOGYtjCDADZHT0wCAAWYA5wDXs+l+FvNdW8tVzyykAMxyO+1m3de+dvGDxXO+OLFNOsJY0QKxyMnsCGztzySSoHAOAQrEE1jJzmnLaMUl31bTXq0/uvr3Plsbn75o0qdT3pdNdVpeyW77rTdaWTPKbS5Y2gQty0hyctnjjBOeCfUc4ChcCtexfDqAxzu27sdeQNxPPPuPQZ44rCtjEqRwtgOQzOAwJAYg8gleQDtOMcnoD16PS4madODt3AkYyNq/MW3ADkcD5sdSRjvwyqP2iW/vK6SfeOnxdrPqnbYax0q0KaveUYRi11TfKrde6tpsn0vf9wv+CTmp6b8OZP2jvj9rSD7B8JfhNc3Nu7AbJdTmhvbm3slZwD511PZ29tGM7jJPGMFmAHgf/BRnxTfeCPh7+zx+ztc3T/29ovg2++LnxOjMn72X4l/GTUz4z1Nb5VIZ7vT7G/s7ECT5hEgAyoAr3f8AYf8AD8N5+zv4d8FXLGOL9of9oi1bxMzNsU/Cj4MWNr408aPKSWza3J0230pgSyNJqJib74UflJ+1p8Ybj47ftG/FL4izP5ltrvjHVP7JQNujh0ezuFsNIhhVy2yKOwtbZI1GNsK5x0B/WuJ8U8t4f4ayhScakspo4mqk2k5Y+f1vkavo4UpUbXWim1qjTxYxsqtTw14Rpv8A2fIMhqcWZnGLeuZ5zUq0ctjNK6ThgZ4iST1TcJbLTH+AnhS38SfEvQGv7Y3uj+GEm8Ya5ahTILu08OJ9tg0rHO5ta1NbDRISyBXm1BFByVx/QZ/wU0hvvhl8Bv2F/wBgCxudvia+05fjN8X4Y32yXXjTx1e3FwLjUNq4Pla/rvi+/Xzsny7GyYoqRA18ff8ABGj9naP4xftAeA49Qs1udGvvGsHiDxO8kQlt08A/B5LTxvr8UpxtFvrXje5+H+iPv3RTD7TblQzFR0v7RPxB1/8AbC/b1+O/xH8LOb0SeJ9N+CXwccyDyDc3+qJ8JvBc9q5wkMH2iTWvFVwY/nhtjcX6sfLdl8bKcPyUqcI35q6VWqlpLlTbcddNaCnHq7VE9Lo/nrN50c+8Q+GsqrzjLJ+DcDiuNM7dROdJ4iNKeHymnUeynSkq2Iiulou60b8O+PF5aHwh8FfhbpkX7rx/rOp/HbXraNCJD4C8J/bfhp8E9KnXJAEllo3j7xLFGSqSxeN7C4TcZkkr9dP2FvAtzYz/ABY12KJWufCHgXwf+zn4aZAWM/j74m6o3jT4mSw/KMXVjDa3GlTOpEyQXEMUjYMZP5I2Wu+GPHf7U/xK8e2BjvPhh8MoYdA8IrJiS3ufhF8APD1l4W8MkqW8mL/hLB4S0dpcjZPqHiG63fvLpd/9K3/BMb4UahJo/wACfDuuQyS6rcadr/7TvxNNwo8z/hJfiNd2x8G295huZY/C1j4auo4JSzR/bL1o1ALivocuq01UxmY1HGNOlGrWjq1F0cNFRp2Wj5q9V8yTS9/mdl8K/E/FLN68stxOIm2q+Z1XiJwk05Qq5hWWJnRlpa2GwkXgLpJ8tSnG7er/AHZ8B+HLbwJ8PvCXhKzVI7bw94e07TQFG3MlvaxrPIdgUAyzCSVzjBZmySM1w/xE8V6f4T8O+IPEuqXCW+naHpd9qt7MzhVS3sreW4ckkqobCcMeeiDlq9Y1WXZGwHGA2RnrgFeOc5ycDPH9Pxl/4Kw/Hpfhx8DZfBFjeCHXfiVeSaY6JIBLDoNiUuNUl45CTOYbQN911uJFQlhmvnMkpPE4urjK7XK51MTVlq9FL2kr315pPZ9ZSSXY/jTPYYrOs0yzIMNKU6+OxVHCRt73Lzyj7So1s1Shz1ZO7ajCT00b/l3/AGxvjLffEz4h+OPHF7O7ya9rN/dxJIcmKzMsi2lumDlUjt1iQfKNqYO3LV+V+rXTXd9NI5OWkdhkjkg8ZwSp5IIAwOhxnay/Qvxd8Sm6uZYVcZLyFgpJ43Mfl4IHAy3I3E8nHB+cmRpZMKoYucDoSDlcdOhyCSeSRjAAwa87MsRPGYupVd5Oc5S0tbWzSutkrpLa6avbRn+oXhDwnRybI8uwdCjyQo4ehh6MVuo04U4Ru+W+yu5Wvbfa5p6La+fMJXQbVAwTllztBBORggLnJGMcnrnHtfhHQbvXtT0/SrGKSe61C5htreONSWZ5HCKqBeRgnJx1AB7Ajz3SLMIkcaZ6KWOCpJyxYEjnr1HJyQeQBj9iv+Cb/wCzqPFfiM/ErxFZ7tH0OTZpqzRlknvFBJkXdkHyQRhhuw2SORx+leHfDTzXMqFOopRwtJLEY2ok3yUKai5pO796a5acFs5TWvb+1+BOHKmY4rCYKlB2k4Srz7Qi4uUpO+nupJdG2ref6nfsc/Ai0+C/ww0u1uIFTXtYhjv9UlZAJS7jdHBuIyFjUhTnjcCACDk+Y/8ABQf9pyD4OfDqf4f+G9QSPxv40tJIJpIZVEuj6HIpS4nJQhoprkM0UOcMFLv94KT9g/Er4i+HfhJ4E1zx14kuIrXTtDsmeCFiqtdXexhaWUCbh5kk0mwKgUsqncwVVav5P/jx8WfEvxx+JOueJ9Vme5vdZv3+z26SNIlvbZC2VhCg4EcEWzCrgswzgkjP7lxTxBQyDLqmLi1TrOmsNleH0/dRpxjTVaMVqlRhZReilUs23yu/7/xvxHhOD+H4ZdhZxpVp4aUYu6g6NJRSnVdno2k0m+rei6+beG/DWpfEjxfaaZb72tzOst3cEttVGYNNNI3IAQF2BPViASSwNdz8bPGeliNfhz4euVsvA/gqIT+JtRhbauo38RCtbRyK2yWUzbreFFJ82dpXGVhC12V9NH8GvAUGi6YBJ8RPGaCFSgBn020uPleQOMFJANyR9AJmdwQImz8jLokvjvxCvw/0zVEsNA0dbnxH8QfGEyNcWOmWVhtn1jWrplYefDpqMmn6LYllbU/EF5YWUW64vYlP8u1qlfMcXUrzcq1TEVlCEXdvEYiTXJTUpaKmrOpXk2lGkm203c/hPBYbE+IPFKzzExnUyXLK86OT0Zr93jMYmlVxzTajKnTUZKlJ25YxnO+ia3vh4U09Lv47eJrK2ePT7+TQfhB4avY1lsdT8VadFDJNrd1ayDyZ/Dfw8tri01bUhMrwah4ln0TSmWS2g1gxeo/slfAbVv2s/jbDZ6nfzW/gHw9JeeKviN4v1S5eKCx8OwPcanrmranqVxthjvNZ+zzyS3Uz4trJWlZjHE7Hwnxhfat8R/FWh+B/BWi3sNt5dh4S8EeEoMzz6RoLXDf2ZpEghGJNa8QXU914k8WXyosmoarqF9PL5dvN5EX6XfGDU/Df7Ff7Pcv7MOj3UEvjrxXpel+J/wBpPxBYybLyRNTjj1Hw/wDCCyu4WDJca+ph1HxSI2H2LwrFBYlAdcuYx7+X0KMIVMdjG55Hkb9tVcny/wBr51P3qVDl3lRjKK5ouLVLC0oqSUptn7XgpYKnRq5nio8/D/D8kqdJPllneeVHbD4SktJVFOpFKTV1SwlNydnJuXhP7fX7VVh441TT/D3w7RtE+HPhjQ5fBnwV8OQqbVdC8BKsdjrPxBurNFxa+IviO9qq6csuLvTfCUcFsSJLp5pvx6vW8wNuJZgMZWQAqATtJIUbsh1cgjrjGMk12vi7xJqPivWtQ1/VJfNu7+bfIFBCW0C7Ut7S2QFfKtrWJI7e3jiG2JVCIMKRXC3BDEYBXAIAYggnjDAnJ3NuAGVwTkHBwD+V8R5ric6x+Jx2LqupUrVG0vs04OyjTpx1ioQjaMbJJJLe58bisZi8fisXmWZVfbZjmE1Wrzs+WmlZUsNRje0MPh6VqVKEdEoXS5pGFM8iiIJEblQ4RgzFXLF2O5C7bWKIqqoZQ5BBY7Qc0jcWsk0ikMkyCUFHXYVAYAsGUFHCkhA2c8YA4405FZgcKQd25xtByOjEEsxB3H7pBIGAd1UpBhQ/cAIXJJ2hwDu3AknnIxtIHU5I5+OqQkmrN2/laulzNXtfumnfbV77mCkntra2+7atorrs79tNXoVw0cm/ypUdQgVvKbgNtUj7q/uSAy5BG3tggnDAcgMjIY0CqzbzJj7rMCdrbcDjJHy7j17KbdI3eWCGMyEsCDvVJVJ8xlkIYKS2MBiMMBhcAbaiKF0KG3gi3jDJD8wIwOC29GG1lztwCCAm77pODclbS19rJ2b0SasrLzfe1tilLTlWzSs9L7xsur5V/dt3emgmY1UbriN9+SGeVAc/IDGJCw4UkKQVUk8qOQKaMMucF4+VBU854O4M6ndtyWBJJfBPPy4ia2ikMQeGMqMbN0a7SQDsdNgJx8qMQ7kSFVHUKrTtkAD7pYjOVZsqGAxyxXgbQmSGJBPBBNZXevNZPRJatvSN1ZteWm+/Z3uMvVvzT6ctra6t9db32trzRPEhkDZU7kORwVIYhSMgqvKHrzk9CDw0CxRDcoQAnoTgEAKhGMEsQWG7BHzEADHe2wbcAxz82B94bQQrE9yCODtLdTkDNMIc5CqSflBbaWQHCDe24OSRkEjOGwSvzfeyaV+ZrdNq6tZe7ZpdNN3dt7a200T5tLprbXo3a9+i9NbrVFJpFeWO1h2PcAAsrMyhEzHl5C6YTBJypYMx4AyQwpGB4DIBcyOjje7M2EDAKCFVWUCDMZXkc9MKQwGhsVUZY4RGshLzMFw8jE4Z3JcNsBCjaVABUDABzUT4dtwYYTKhchsgsCNqnJAOcAKAqjsoKisbN253Zt2TW2qi3p10T1TtproaRaVo2afXpvyt203dmk1rr3bKO9mdJS6KFiXMLhGJDSBt/mlgG+XayJnKbgvAIyjTRMpIkUKclGYqhG4kLldpcBvM9/m5XBbmSdUMTl13Kysq7XCkAgNkH5dzJySAQEwWGGXmrJCryxknHlLhlSUgOQ6JEZjtJwqLuD52EqNoJJZ8pcy25m2kvNOVrvtZWva/pYu9rb+9ZbPV2V/S3VbdUS7kSaKNpSZnjRm3EhXG8YOWCxoCxOBtYsAuCWYinltivnOMHaM4UbiAoUAEdSTxwpOOEJFUYpYxGhKyrufySuwEqVwfMeRmYbScMcuHTjCkOpq4MkFkYkMMuVy+9sA5DIAoBB5I6NlM7cinCUZaJq927XV9Un1fn1tfdLdlJp92nb1eztv222d/IT7y7kA2g4dSAeu1mBUYxgZ2kkkA8Z5NIgC5OQwxkckkJlQCB8gGcgEEEZ54HIBsVgik/NtZQS2FHy9WIVcA5xgHLdcMMBSshI28sMHcAcjbtJOCDnjJIC/N0IAIo5tE0r6q+qerceivflvq/JW3uqUr2S1+FvdKOq732W67u7e1m/dwwQMzkE8EFXOcFW3KMFQwAwwBIwuG+ZpZeNhHzMe2CAwUHpnOMhShGM4IwCMPYE7QQdowfM2qDvypZD8zHcWBO7gr1WmhBl8jaCSwBY/Kfkw45UBO5BBPHBzwy+Ky2fVpOMnZx0u10aezWy6bO+ytZO33e7pdrXbo+ys9bRKFVVWN+FIBBJbarFWY7s7icnHRtufu7TUgCtu4+VhuAO35j/CBwBx1GAF75BYgQk8ACM5bGeSAvC/OchcZ7FXyNxA+YHLssAuQqsoAAxgkYUjAGVxk5yMjaOQetKK7ap6Wlq0/d1TaatpdJvfotL3FJdrKzu7tt6bX0a69FpZWtqS9M5AABG4DqFwxwPQjPzFgOQeSTVJVDofmVAx37SFzuCqFRQG3bcnkMSSuxgQpU1PIpDBSMlgCAwAIHy5Xblge+QqfNwVZgciAkBggGARnI+c8YYrvO3BZsZ528AA7l4mXle9l0SdrLZaJfltv1pb7X+a0emjVm7Xvpe7utVewq5Zj3wuNvHUYwM5IwCAV4Ukc4yMUokCNtYZLLjOCo+cDaDuOACWzuUFiBkqcYp7B/LyUOSVA45CfKSWGGyVwDuAHJG4E5qIKVABO8qRggNncuwHbglV256Hg/e7g1EulrNST12bXu3t52eq8vIV3smtfeTS1ezbva91rdbX1exMoDAvgAsytuG3GSVUgsecMSedvJOMkgkSPvVgFQ7QC4YY6phZEVcrgZBJO0gZBUYANR8FFyVVdqBeADncOD1PBzuU9B8ykEhqSVnKKA7LtK7l+cmRQAGZ/XOFCkchcA5A3VN3r1ei1tpJNba6rp5XvuNapptp2i106QTte1k3e7WzSav0lWWKT5lRwAQF8yNYtx+TICsc7ckkAfLuLHcuchNzlyx4P3Tt4+XCr13DIJyM/e3feHyimDc7hvmIJCbAThQwUZX5sKvC4AJ2bujAjc4ZOHYfMGCluOFygLfNydxXDEgAk5wOhaeyV1a9tLa6aro0023q2+mxa6OS5Xo1K2q+FOWm/TumlZJWTU6MpkULg7cDAAwB8uARwMkcY3EAZKg4wZ8AuMkCQsPnZgAeV5YjGBuPDA/NyDkYJq7hHyUcqWw+3DFcsg3AHA4z3DBOAc5AFkFCVljw8YK4BG7cBsY/cU7ST/CQ3VsZwKd/davfayTvbZLbR/dbW3Y0jqnrd2V+lrRglZaaN66rT1RBCTNpsjMDkx3WflOS5M4cl5Ms2QAATydpJG5Q1UbBYxo0DS4KkAAM5A3fayEGQCMHcQQVzklh91a07ddukS4wx23uHPL/en+ZmILAnknKkgkgtjLVlWIJ0aEK2AssBaNg2GP2qVQFy0YYsCRgMox95txUHx7u8G7X+ru6dr3vFpvRap+t9bbXPiY6+2SbSjjIK6tdWTbut0vv6vVXNXUIo7TRLmBJRJshKs7kux8x4yMODtCZ4Vc5OMc44jNxHC2hucDyoNzYCtjdapgjbzs4zkZMZO4KSWJdqyxf2JKzJIj/Z4RlipLYeLBZmw23khODnIVgpXJJEZI9EUBBgxICDlm32se5gz5AKkkIdoK5IBGBVVHaeitalh7K6dn7SKs+qtpurv7SZnTs6XvNyc8RiL6q7tShfVbdNm1bR2JNTkLrpMnlmNZNRtj5coRX6KQSnVQ3Zy5JGAQQBjdm+WZl3PgNjaVOfMLY2na2MADIAYnPJP3hWBqjh10pUEi/8TC3UlsBR8oC+VuGduCSpAAU5BUMa35EEckqBmcGVpEaQEyBd20IzMwUYADfLjkFgN2Qemk5c9VN3v7JvTq4dvT7mk7HHiLKlhmly2VflXWznDrfvbXq7pW6Rk7CWLBRgsS7Eoq8M2SB/CPmHDHgkH+Goo2RsyoMqwwvzMQcKhOCAoYNj5SOBgdBgVK4LKN21gVYEFcjbkE5B/Ug8scjI5rM08XAhZJWP7uSVY4zHhxCjjYsm48jCMFG5iDjd97I2crSUUrqS6vZprVtbq19Er/pjGN6dSV0nGUNHreL1aWz0aV3bZ7rZaajaQpwyDILYyQQVwOWAx3+UEDB2gdl5YgHOAuBggkqdp+82RyQWDANu+bcMgYYHByeqhhkgdMdcY5GSc9QV6jcBml6AEDdggAbiWblQVbaSc4UnbjBOWHeq00v2V7Prfp3uu9tfuMet7NPa3T7N3J6pNJbX1vfpYUMxVw3y4KgBmyzhcEsoK7gGKcAYG44Y7s0vyuFUHfkEggkbXwDggHsPlYMQpwMN1IDuQAhQzE4GM4UDBDEBjkDkHJDN1UnaKkRRkKoXleilhydu3p1XA6KSVDHnBoWr2vqt1puvl+dvXUmcly3V4u8dm238F9NdX2d972sPUFiZFPQEMTvIYEqdnygMG+6oYjGcEEVIXwRuYHeMMu8AnJBJO0Icpls5yRgYxniuhQu64K7WDKQcZJ2sGXJDFFAKlRgAkcManO7aH4AIC7drNgEpuC5wwPJJIwUJCksuKcUrp2Sbd76Jbq/m9fvVtO0SbSUXqrJPW+6Wl03fV6durexN8rEAMRIvyoRg4PHJVeCrZz8xK4ATnODat45Fdlm2AKDh1UKGUeXlnGCIg3+sJYK2CwIIGapHyoMXMsnlxoDud3OGJddo2kcyruAA5O4AAEgim2sd3rTkgm002EK8rzF4vMjYKT9odQ27zML5Vup8yXdlflwRqpWkre9N2cUm0raau691b6tX7PSxmoOUXJtRppazaV093GmtHKTvZJbX3S1Lcl2b52sLNBIjMIpbgjcrA7FZIMKQxJODI42hQCTtww1o4zHDHZRyxTmJJJZmRVYSO7EGKJ2EZaONdiyAZ+6RuKlQFja0jgFtaAC22rGbgoouLjaThSBt8iAllLQqcs2GkZ3xVuNY92FCgMoACZUhdynHyAgsecgYycdcLneEHdNtc3Kr7uNrxbSskl63W2jexw1a0fgjDlgk37zbk78vvydtHs7J2VtbJ2LMcZcxnzNqowPloBkgeWBvbaFVMdI87iSOGOAL0yl7K5JzzC23k4IULk4znIwATkYAB5YA1DbY5ZlYEtsTCnJwU253Hqw+YkcYwOM86skebK4XAAMDhhgEghQcAgYAA79ug6V2wimnrKzj1unqlru/k7Ja9Ls8TE1rVI8z1U47vW3NF3ttez+d72WxLB5nl6QyPtRWjUrhmBJCgZCNz90tt7FwRliRXV2Ebt9rDR7yyOxYj+HcB1YkEYGc/eJY7sDkYVpCph0phgYlhHKrjBVQAMheAckADAOCDuGK7XT4VL3O0gSBX5PAIDjaMlSNxO7AGMn72SAD6mGpyc1a+0bvqvdjold626tdFqfNZhXSi5LRpy77+0XZu3S19UdHYKVh2qqjMURZmGQ/lPg5AIyD87HaCCoA2tya9G0C2EghI4yVwdoDNgKcEZyuMLtIwAAW6MK5DSkjTymZTuKxKNoDEk4LgMVwMK2TggjJxkhgPYvDloJGT5QWymNiqRgmPCgrtGDwCMEsduDnIP1OX0edw72Xu21bXLa+lrbu3Raa9fzPPMbClCo02o6tttdbXTt6X5vLtc9Z8I6KZGhDIFfAIcKFJIAULyOT1PyoMqD8xODX7lf8EsP2eB8Q/jNbeONV05rrw18KkstZVHiaSC+8aX7NB4T08qylXNg8dxrrRlSVm021V+LgZ/JP4e6G8skJMRkIZeFEhdmZxiJQSSxdyRtHzuznJy2D/cl/wSm/ZWj+Gvwz8G2OraaE1RIY/HPjl5U/eP4q16GKTT9MkOSxOhaZDZWTR5IjuLWVgFE7bvvXiaGQZJjM3xGioUJKitE51pRSjFdVLmaUXtzNadT+TOMI5nxzxRk3h/kkm8fxLmNLBTnFOSw2B5ozx+LqJNfuqGFVSU2l8Oq1SS/Xv4XeFrb4feAbOK4VIr17Vr7U5TjL3UqCWUu38QiAWFSeBHGoB45/n6/4Ko/tSHwt4A8W3umah5PiP4gz3fgPwWkc22az0KFAPE2uRY2uqG2ma2imXbifULUbv3ZJ/cn9prxyvhbwWdB0+YRar4iddLtSjbWgt24vLknOVSC23EyEYRihPGM/wnf8FBfj0nxd+NOvjSr3zvB3gpZPBvhYJL+4ltdMlddX1VFVgmdW1X7ROJVyXtVtgT8i4+W8L8vqVZ5nxfj4uVbF1alPCymv5581Scb9HO0YvZRpyVrM+g+knjsJjOIOA/ADhucY8N8EYLA5rxLTou9OtWw9KNPLcBibXjKo482JxMaivUWJjU3g2eJfsy/CS5+P/wAefDHhIWL6noOmXdvrviK3jLeXe2Vpe20GnaJI6spH/CSa3cafo7OPmjtr64vCpjs5Cv6R/wDBVP42W2hHwX+y34T1FJdL+HdqNY8b3NvtSLWfHusxG7vZZkRQv+gpezOkRAW3l1BrWMAWqRp6H/wTo8CaP+zf+zv47/ai8d2ccd+mjjxdaW14qo9xf3tndaf8ONAjaYEGZLHUbvxDcIjIUPijR5pFMtijR/id8R/Gmr/Evx34k8X63cyajqviPWr/AFa9nlJMk1xf3clxK3fYjyOfLAAAiVVT5AAf0PMq3sqUY6uo9W2tfrFWEW7tOzdDDTiley5sVNaShp8dwBlP+t3HFbH8jlknC8fqeCglejWxVKpy1Kv2lLmxVOVmteXCUJpWnr6N+zh8Pn8d+PrFrmIvpumONQ1B2U7SkJJjjbBK7pCAuD975iAMbq/eT4M/D6Tx5458KeDIoWNhNcR654iEaYSHQ9MeNorWTadqrdSiKFVYZIztAAFfC/7KPw0j8J+BoNS1CAQajry/2jePKArQaZBueNDuwQHQZILc7s5DE1+6X7EngB7XwzqXxJv7Ux3/AIwuCmleYMSW2gWbtDZKuen2kiS5wOSHUHgA12U3HI8iniZK2Irx5lzPVudlSV1tZe9bXZ37n7r4w54+HeE8Pw9hJcmZ8TTVOtyWjUo5clGVftJXpWp3dkpVLXel/uvTrSCwsbWzhRYYreFIY0RQqqkSKqBVGAAAo2jjAxtyDTZpOWORkDA7BujDPQdyfT1yMGp3cKMcEnCgHI+UEdgD1/EDn2rNnYKWPGBnjk5yCB68HI/iI6ds5/M4qVSpOctZTk5N2erbu3rvraz07H8sYqpChRjTjZKMFpbRNWSuvT5L0vahdyhRhiPug88YJBJxzgfxE87RznHGOTvZwiSTOQqhGbOcAhQzDGGyFHIOc44Jbbitm8lG3aCSTliM4PDduh9hg9B3Umvlz9pb4q2fww+Gmva286xXb2k1vYozAFpnRgu3jJGDyVGcEdCCR9FlmEliK1KjFazlG76QgmnKW32U3qtLX7o/Nc4xDqVXCmnOpUlGlThG7lOpOUYRUbWu23bZ6u9krn42/wDBS/8AaHXVNWl8HaTe5sdLEq3QjfiS55DDarbTtOV4A6ce/wDO7431xrmedzK25nZmYnB25ZhwQc9MdTnGcj7y/T/7QfxGuvE/iDVtQubkzSXdzNMzlyWYscndkZ3E5/3cnqMkfB/iTVVHnuxx94soJAHJOBlupOcZzgLnJrTiPHxc40aTSo0KapQV1bljy3eul2027O/fuv6/8HOCo5PlODpzhfFYhxr4mdtZ1qnLKe+/K3ZK1kvK7PLfGWr/AHoUbliyd+hB+YAk9NqjOFDDryAR5Q7lmz8p54GeMcKOSepORwBu4xycHX1m9NzdStww3FByM8tktjn146lcZPHTn5G44GMjP8ORwNo45yM9B16/3RX55Uk6k3q3q0nokr22tdtrW72VrLq3/cvCuVqjh6EOR3ShdO100opu/wDw/ZN7tWcnKgLhtvTO44PqRux04A4yNx3g43LVcIMADI6jOQdoXHOSQAct9OehNYtqnmSKW5wVwfUDbjk9O+OxH3j3rqre2JZVQHcQOecr6gBSRx+PA4JAxXrYGinySdk7JKyto7Jq3frrs/uP3DI8F7OLqqPTlSdo6Plu1psrK212tr3b09OQcFjwwx3P3dvBz93OMn5s988c9fpttKrl0YdhnBI5BKggggYwB1yuck4ODzlqsUQ8x32KOSHPUg4yCRjjPPTlRnIFbOnXF9rN1FpWiwSSzzuEEiqxc7iASu0HamQTvwTnkBV6fTUMfSy+MG23UVpQhDWcn7qTS1tdpq9k7627epmef4LI8LLE4utCnyKUuVytK6s25a2SSVuZ7W3016d9TFuy2sIe4unYCOFMsqs7DGQvU8khMtjgKdwr9TP+Cfn/AAT28cftM+MIPEHiO3vNM8E6O0N3repvCzFIgQ8Wm6bG6eVLql6FKQq2Y7OMm5lU7UVtH9gz/gnX4h+M3ifTNS123lj0uKaG41DU7mMtBawBg7rCJDia5YZCDJG/5nJGTX9i3wb+F3hD4N+DNH8GeDtMg07SdLgVSUjUT3lwVXzry7kUBp552BdpGJwNoXaiha66kcZjIQxuaOSpytLC4Bycedb+0q2s7PSysuZv1P8AOP6QH0svq+LqcNcMYlYjGyk6datTmnh8DRTSm3JS9/ESTaik1ZvmaSsnm/Ab4M6P8KfB1p4U8E+FI/Deg2Kxw2lnb24Z3EahZLm9uCge7v7phvuLyVzJI4O0LGoSvf18HatcZH2Vk3HdvlcRIp4HO6TJYjjcMc8gLg50rTXpbeNVRwNowDwcNyeOcAgY56gZ6YY0T67czE/vmPHOG46jAwDwehH9OteNicXmNWtL2dGhQjol8cuWKUVFKzimrLb5WPyLL/pGfUMnw+FhhYVq0ad6kpSk3KrJqdScpOacpSneUpS5m29XqhLbwbawIH1XUoIyvAgtx575BxhnJVRkZAwSB1IwAzaCDw9pgJtLFLiVQAJbpg5J4H3PlUgEZAIbvzxXNzagzcsd2c559ep4POSfqC2RjPGJe61bWUTT3d1BbRIpZ5JpVjQA8ZLu2AMHPJ5wT0BrCng8biXarXrVE9PZUl7KHvW91KCUmulpSey87/nXE3j7xHmSnSo4pYKjP3VDDS5ZdNXJWv8AFZLfzujt7nXLmVSiyCKM5wkahECjgYCkZxxgYz254rn7i9AB3P1GMkncSD+PUY5x07jrXyX8Tf2v/gx8N4rhNW8WWVxe24c/YrCVbmUsoOFJjJUdMckgHBA45/ML40f8FYoYEu7PwBpsVr8rpHqF9IHkHBwyR4CbjjcOpJ7nNe9heH5UoKWI9lhIJXk6vuzfwtWhG9STtbW1rJK6umfmXteK+K6y+q4bH4+VVpe2qufskpW19pO0OXtyNu2x+4mt+MNF0C2lu9W1Sz061hBaSa7uYoFVRycNK3bk5XOACCCxJr4V+L//AAUI+DHw7S6trDUj4n1O3DqLfTmU2wdRtCtcsMADvgdzg55P81fxk/bj+I/xBubptY8WajdRuWb7Kt3Klui5PyrBG0abT69EAxg53V8S+IPi9qmovIZbyRlck8yMflZjkkEgY2sD355Lcmtp4nJcvT5IyxtZaOVS9Okmkk/dT53vu5K6fwrVP9P4Z8Cs7zZ06ud4uVKm2m8NhU1LlajaLrSV9dnyxg1Z67W/cL44f8FWPH/iAXtl4YltvDWnt5iKLR83WwgAFpiAwYLgcHKkHIHRfy0+IH7TnizxbdzXWreINQ1GWVpCzXF7NJgksQQrnAXOCSV77s8/N8V6v47Dli0rM3zK2+Q7Qp3AjHIYFicHPdsjgEeaav46QBx5wwcjAI2g5JwAvJxkD72eNpO3p5GN4lqzj7OnKNGlsqdFRpwvpslZy2vdpuS8j+lOD/BDJMnVOVLL4OpaN61WPta0tErupU5pemr9Ej6N174nXt4ZN14d2WLEyZA3DByWOeVOSf4j0GeT4/rHjEzZaW8OWOeXHOc4O4kdAT1xgHIGcKfCtR8Zu5fY5ZW3FfuhsjJAAJGD82TkfezhlNcde69eXLE5I3YyWLfL/wB9FifQ42jnqON3y9fMKla7lNuTdtejTjda/JXVuttD96yfgfDUIwjChFJcqso3enKunVu61/Fs9X1TxlGkjeXIXYcKAQ2SQ2BgkA9CRkAYOCd3J4DUPF1zKX2OyksQMElhngnncSGO3I3A856jFchJ5kr73ZicnAJyCMr+YPHOOSScA8lh2qQcDLfNgDp/Cu0nrwOT6/jXC5zqXu27tP73Hp2bX83fdn6PlvCsYcj9jFJW96SWrSj0tfXr0dyzcX95cZDOwORkksWYEjAOSSQOpwAOoLA9KflE/NISScgccckEkYxnIx0zyuTkAAyAFsE544+8SMA9QOOnIzk8jPBGA5o3OzkNnHPIODtyDt5HHTnHHQirhS2crt9rrVpJLXr6WvZ73bPtcHkdCk4+6m9HqvKK2tZJN7t791qogAADgKMD5fyzgEnB4G4dyOaaDuyABgjJGeByPQ8tjG33AIIAFWEs5HwRkZAxgHsTwBwRzx05YsAc1djtFjBL4IxwTnJwR3J/vcn0x8pBHNxpX2VrbX91S0Vrtu270ja3z39ylhKVNPRaW7LRJdvdSvrtd/isvazAAA4bBx2BBII4X6dMZ4GKtx27soyBtwPmY4K9ONwPqRt6joMZYZtNd2UH3sMT02jhiOQATjPbkDqPUVnS6nJI2IosD7uWGTnA24OeMEYXA5wOhGatQinFW2a+FLlteK6tXaTS8101OhVKNK93FPTreyuktdWm9PPp3L7RRRn5yp2r6/KemCOny5GQBkYIwQRg05LyCLO0qzj7uPYFh0BxjkDPGRzjjNbyLy6/1m4KDycHCgDnBGRgbckjg4wfmArSttDeQDbFnI3bmyTnkAnP3ecgfXgctmk22rJR0trbT3rNvS2ltdFyvmaZz1MwhBe5pqrOXm9tL63enXbvcy5Ly6nKquEBGcjrjAwCeoHTGfmwScE7cOjspZiNxZjkZ4JGDg5GBkfL8oOCTjacniu4s/DEjj7o55+633lzjtgc9dvHPG09O203wq5KqsTMRjHynDEZ6Mec4GMBeAc43YwWlom7u2y16pe9bXW19O/oeZXzWMFKXOlez1d1fS+i00etk7dO55ZbeH55j8sZABzkjhsgY6rlQQDkgHqMZJGep0/wpI3HkkAHDFgxHbgDIGc856ArjIJIPvGhfD2+vpoY4LOZ2fG1I45JJCegXCqWPbgKAMjJyQa+3fg3+wZ8afitNbf2F4N1K2sZWXOpajA9pZIpPMjTTqoZFGCVXPGSQSAK68PluMxcl7KjJp7uMWklbRt6L0d+2vf4zPuOsnySjPEZnmeFwFCmrynicRTpR0Sb5eaSbfkl+Z+dOmeDSdrSJuP8SgMDnJyAAMduOWJ4I+Ug16p4Y+F2r63NHbaXpV1eTSMipHbW7zMM8bdqIctyOASBgAqQcV++ngv/AIJcfDz4b6bH4o+O3xB0vT7K0jM9zCt5a6dp8ezaWjN9dyIZSoYKYraORuDwT1s6n+1J+xH8A1l0H4X2Gma9qFmiJLrMdvGunmVZERmk1W+ia4ugPmYrawYYnO4k4H0OE4WguV47E0qKunyqSlJ6rayaVrWfxeep+E5l46yzapUwnAmQ5rxXiU3TWKw1CeHyynOy1q42tCNNRTV/di20tHs3+ZvhD9g746a14X1rxhB4Mu7bSNB0yfVb1r8rZTPZ2sIuJTbQTbJJpBGpcKAC20qisVJP5ifGmNLa6W1ChQgbAxtLlMqpYMflGQMKQykAvncxVf7Tv2NP2o/AH7Q/hv4iabo95FeeIdGskn1hBp9xb6PZaB4gsbjTIry3aaebzgl3LNb3UbxQhxAzLECFJ/jI/aGW2Pj7X7W2dZ7e31O+it5UVQJIFu5vLfaoAQNEikKBhQVyT1rlz7B4LCYVrB8zjCfLKpOUZKbXK7ppW2utErK92meR4Y8e8XcTcVcTZJxZl9DLcZkiwNalhMMqjlRo4qnUajVqTk1UclCM4SjGCab93W58s2qSC7MjsxO8YPOMnBAGQFOAOFAGepAPA9P0y3SLTr6+IG6O3k2AgZzs2pg8Y6jABG7HJGBnixEI5AcL25PJXJAGQckjA5OQfTg8d5FKttoaoyCR7h4YkjGN0slxNFFFGoxzuOcgjkZ44r4rCpVK0JNLkUo383eNtfJJ9FbqrPT+jcBXdKsudtq9+Z9JXikpO60eva+2p+r2ifECH4Sfs26trVhMsM/wx+Bt/wCDdCljJRh4z+Md0LzxDcKFIL3UBm03RncsJYY7aSC43xuiD8Q7CZpbkStmVwHZgBvZ5WOMnJOSX+6Bkkn5VwOfvX9prWj4d+B3w78B292Td+NNXl8V6yFUKZrDQIpra08wjJeGXW9W1OONAwjVNKt1Vf3Alf5a+BXgmXxp8SfC2jLaXF9D9vXULu3hgMkt3a6Uj3z2SIFfdJqUkAsIFcKk091GhYM6hvq+JMfiM3zrCqSfLSw+FoU4bqnTVKlGnBb2UKUYQt7trW0SaXFxDnFHMM3z3PMROKpSdHCwk2uSll+T4SnhaNKLu4qFOVGq10bm7b6f1BfsK2cP7HH/AATk/an/AGq7to7PxMnw1s/gR8MZpQsVw/jrxTNDrXi+4tCBlmi8XeMdD0m6kDEsPh9MJGzb7F/Mv4LXdx8JPg340+JQ3Q614Q+H3iLxhpF4QfPb4i/EaU/BP4RGJ2+VdR0eTxP4/wDiFp8o+ZB4dluYyTCZE/R//gqrbXfwb+Af7En7AOjTga/LYw/FL4o2ltJj7b4z8SXVxK73SoMOjeLNc8SzxeYGIgsbRxGEiQj82fj5fw2vgX4RfCbQx5j/ABH8Q6p8UNRRMuZfAfwwttQ+FPwlieJTsP2zXLf4reKY4vMEdw2u6dcxjLxtX0FPloQrVKbvKNNU6TaSletyU6bpq12+WNKo+qjOWz95fz/w5jamP4f4n4uqJxq8f8QTyXLXKyf+rOSRl7W6duWnVw2GxVNT+FzxNN6uSRf/AGWPg6PEWl+A/h+h8q8+Mfjvw14Cv5sBntvAHhN9K8b/ABK1YhSQsAkfSYJ23DzYbeaG4AaF2r+0P/gn/wCHorrwn8QPi79kFrB4/wDFcumeFIAoRLLwN4Ni/wCEf8P2VsAP3drCtrLDCi8GO3h7iv5tP2XfA0+m+KPH+tWNsZpfg58NNB+CvhARZb7R8X/jBezQ+JJYDkGS7srG58Sae8mz7TFFp1jDOxWOKv7AvhP4Hs/hb8KfAngKzRYovC/hfSdLl24HmXsNrG1/cNjgvcXz3Nwx43NITzmts1qRweSU8JD3auNqQpXVk3QoWlNNdb15O3eO9j+efFLPHicZ7FT9ymueUUvidSMKkW9Uk5UYYJ36TjNbu5ueILpYo5CSowrAEnGMKW4B9ePmPC7SSD0P8ZP/AAVh/aGj+Ivx98U2FhfCfQPAMP8AwiGlBJd0LXVoS2sTxqDs+e/MkO9Bjy7cZyNuP6hv2yPjdZ/A/wCB3xA8fTzIl/p+kz2WhxM6hptd1FWs9OjjXgt5csqzuoIAjRycbSa/gB+OPje71jUdRu7q5e4vL27u7q5meQvJNc3csk00jODhmklYszHBySM5yK47rLso5bNVcY1GLXSlTcZNekpqK7e5JdWfIeBfCtTivjnEZ7WpOeFyh/VsNJp8rxmJ5XUkm1bmo4e9+jVfrax87eJdTfUtQuHZiRvITnAKgsdowM9VA4B2gkgcCodIs/MfztmQh+ToQGG0k4HAABHuQQSMZrGTNzJyCxZyQDkkZwM5yRwcY6HJGQOQPTNEsCiwoqApwzArklueT6jqFyTg4A4HPnZXhZYrExhZtuUbpa+83FJdNvJ9Fbe5/rJwXkipwoKNNctGMIqL6ySiru+vrpfptY9Z+EHwz1X4k+MdC8J6Pbyz3Wq30ULqFJEULPiWVsE7QqbmJLHAHRgST/Vx8Hfhlo3wi8AaF4S02KFItN0+I3c2FRZbhUDTSysBkL5m4s7dBgHcVGPz1/4Jrfs7LoOgy/FrxJY7dT1hGi8OxzxYaCxG4PdKrAMhnx8j4AEQBzgjPsX/AAUF/aYt/gf8OJ/B+g36r488aWs9vG0TkT6PpDApPetty8bygtDbA4YsXdQPlNf1fw3leG4ayNfWZxozrUY4vMar0dOhBJ0qCv8AatZuC+KpJRteKP7U4Ly7CcKcP1s7zFqlWq0favn0lCjGzpUoqy9+tKzst7rdrT81/wDgox+1bJ8RPGE3w58K6gX8G+Ebqa2maCUeVrWvRkpdXUm3Ie2tCrQwcFTh3HJGfiz4VaPYaDpN/wDFDxQP+JfpuTpNtKoL6hqBysaRIxJYvIwVchgOXOQjkeOaFpeo+PPFaRTSSGFpTcX1y7ZFva798skkjEgOwyWZiAGOAcAiu98XeMNL1uVreJ/s3w6+H8OyNVXYmsajGPL+QZAklupV8m3QksImaU4MwB/BeKc/rcTZzNwko4eL9nh6TbVPD4ek0+Z391KKTnOT3d297n8m+JnEmY8b5/LJsNWlCnjanNmFeDtHB5bGSSw8Gn7s68fcVteX2lXVnE+PPGOrMLzxPftLP4u8WytaaFYwq0z6fp8zi2je2hTMgldXSzsUjTfJI2EDPKFatr9pb/CTwU3gK02XfiTUb22vviJcRSCdNW8YQM8um+DYp0LLPoPw9E0raz5Be11DxzLqjNLd2+maTPDsfD+aaJL348eJhHY3bzXtn8MLaSNZbfT5dNP2PVvHXkFf3un+C/Nj03wwAirqvxAnt5rd5B4a1GA+ufsffs+3X7TPxZOr+JZE0L4T+BLa48QeNdf1GfyNO0Xwpo8U+oaib2+lZUWe4t4JJr+5LNKfMuCqtIVxy4TBTrzw+EwcX9ZxylTwkpXccLly/wB8zGt/LPERvP3rWw8YwXNGo0fRZPlkqVPLsgyajGlXxdNUqSSUYYLLYKKrYiq9OSpXgnKTduTDq92qjPcP2Sfh7pP7M3wd1z9s/wCKunWuo+NtcmuvD37P3hXWlwdc8V39vObvxbdwSHzX0jSIhJqV3Pt2rYQLGsiS6pZ5/KH42fE/WviR4s1jV9Z1i71me+1fUNX1HVb2Utc63r2p3DT6rrt44P7ya8uGPkIFVLW0igtIVjggRF+0P28f2nl+M3jp4/CcEmh/DHwppw8F/CbwzHGbWLSvBlgyxXOtT2aMgt9V8WXECX17lfNt7MWul5a30+IJ+ZU8jGTIUHcQc46DKHaTkc4yVDcsxJzhuPG4xzTDwWFyHK5NZblqsmrRnisVKzr4us025VKttObSMIpKyaTniDNMFXrYbK8rd8lyOM6OFeq+v46TSxea1VrzSrTThQevs6MUotOUk8ueYuMjYSuM5UMDtxhfmZTknA3ZBYHqSwNZDnJBZWUjoQcEgkDdv5JCkc8cDGQSOdh4lclQvy9QRtI3fJjGRtXJPbcMfKPm5FB4XA3rudQQrKOcrlBuVmIGQSQNoxgjGfvV+ZYht7aPlaaur30Wys7rd2vpey7/AC1avrdO97XW/wCnW+yVtWu6MJ5GYv8AMoZWK79oOWUKWBU5ZQSCCTnsVO3JNaRmCn54g2RgCNWy/wAvyoWYrsHylQwK9ckcAbMlqNxwQuQM7BwSMAfcAAI3HBIYHOATVSS3GN5yMYBCsR1wwOVAUMDgkYAGQCDgV5E4zUtb3dldNpX5l1S0TvdNpbaXepMMRFyte+iV13TVr217K67ddWZ+90JVQpyGYFoVYqBkMpY5EhIGcH7xYnCj7rHJzjbAS0YHNtGSikgjH8Rcg4wM8EleNoqw8apl2UEEpuychSSGLkF9vBDFQ2T948BhurhfvFSrjdkhwGQgAHepztBIHAx0P3TXPNK2rl20s2r2u1fsn2+7rvGqnZXvez5Xyr+XR9Xva+jsrq73qee0m5NkI8koOIYlLlgrqFXcp2HadwOAXJPpgdgrM7JDIWjO/EYXn+IYEi4yeFB75OWwdzmZYQG2sVMgj+X5iMsrBh1U9WZx0HO3KgYay75CSMAFpMDBTGVyuVYE4G47s4YYHy5zWGt3GS1utV9y5lfpputWv71zVTdnLXlab3T1tbRrazvrq76qwwSgKAFtyW2j/VKxYk4VSSxAZMHBJxnJXrgtaV2j8piBGpL+UiqibgWUuFVlZ2zj5myc5yFyoVrlhgkjDEMDtTJYhQFLEt8z/eKkMcAEMGHMTN1zk4O07VABUFRvJY9AdoLAZJZahx3Wqe+uuujumn0d2k9OltU1vGTfKr9NHolfS19t1e/boriSHqTgdudp5yDjOGJ2jjG7huoYDFV2AyCVIKDaHGdxAKknJ24z2xuXgqQQQaUYXlflQqCWG8AgbfulWKnjauOdgBQEg5DSd4V1IZVVTnIYYLDGeAwCnOAw44bB4Ah9G30i30W6V+jXra3o2zVSWr0WzSb20jbs3q+Vfe7FUSA7mjDoxIUiSMxqeEGFDKwcEjIIcFRncQM5YURn3AjKoyOWLFCcqwR4wgX5cnphFwCONxq3hnz1IKZGdxYqQcEbmGAQx7HgbTtBCgbC5kA3YADAZwehxjIAA4CkHCtwTyQM1FxUea7el9FZdL6Pps7WW7WhqpX6JaK7vJ/yvq2r2euite9+pUcOW4LqNrKrkNneCpEZGc4wgYnOSMZJU7TDHF5Q8tC5VHd1DBhlBt/d5aTJJyN+Rhip6MebbEAOQN+MtgMAdwAO3HKAbflOcKxAwMHiMSFFAZF3GPcQAoAwFDLk52lNv3gwJPXaTmsXFNp6rVO60T0jG19lrayV+a29rMaeut9/O11ZrR6K79U0lr0bMM5JIC5yD1JCADfyRuIHBHAAABYHGaVeCVR2PQkNhgcBcYcncGx14DIvVckANDsc/JyFwclhuVcALyR6MAwbBxkYChi9VAJI4ABB5wQG25Hy/dzk7WJbGSVyCQLSirPf00vbRK+3a1272Seu1JbW1X3vSzst/Tz2e7Byd2AMAqF3YDDqowu0Z4fPOAOSRyCKgYbyFckhQUUHjkgbEOVPzDIGMbc/MSu3NOb59wBdMB1DgIxAKKAUDAZO7BBBGM5xmq8aeXGsLlpHjDfOSUDBeN7AszBtpDc5JCjKjAAHpKKa0s7Sv2a6Lf5dL9Lmie3m9b36crVlf0S3012uh5jYAJnJbafMYgliCowMk5UEbUBGWYHdtIyzHCICSGLcApltzcg7yCB0xyeoJCkYDNTmHzEhiWVgrY3YySCcAgnPPHGWwMkjo0JgsVLE4JLksHZdi55GRg4wSeWB5+UfLmmm+VaPSzeqkna7V+6/FpN9G7t6fJ+aXLdtPbqra/IhdVYKVYjcRnaSScMu4Ha2QB8pxnjGVOCcROsSuFC5dRksSAoUbeHLZDFlxnoCeSC3IsDA2kD5shSpbO4fITxhQFyBgZAXJxwOR2LKApGNmA3zAhvlymBwcDgqDyfukA5qXZ2XWza2s1slptdt2k9Ut2020XStpvbVWvZqO1t9laz3Vr6JJoOFUFchh8zcELgjIB3YYL1TJBAyR7o0q+YMY2iPPXhlO3CkrgE4GQeRyBnIwYFnVSIm2s7YYkrtXlguNzADcrjjgAkqCA27FhXABJxgNhSBhtpCjGejEZJIwMZIAzjGcXfl01vbXS2iW9/O3d99Ehxa92zlbtdX0ta95dOjez/lSI3wwV1z02gAlTtIXdvVQQAwONzZUAbehApRGyKGjJLjb5m7exwCoY/wgqACBxkHJwVJNPcsdhyroFBwCMhflCKBlC6AAtxnB+VSB91u9c5Kt0K7SVy2NgcjcSeCQCCPl6lsU7XunZW0dtUtFf79LN3tbfYet7O1rNR6N/Ck3yt3stE/eaa1SY8qGWOMkKHwW27RJtGwsoAXAYnP3cg8BScABDHK6/JMVKDBypdiQQNoDMSpIXDMeGJbftIWmI5Y7C+xTvjVwASmMjIxuzjdvcfLyq7RjBqfay7D9olyAgLbYCXJZchmABLFdu7IwVOAN+TSe10m9UtHy2Tsvdvpr8rJ9dL6pcyTjeK5ba3TStBXbTXd99L2aWrJAhRYg2GVVbKgggoCWBzIeCeoJzkdASSJIdpZMlI1aQqqybol4dGBdQeQuflUMGTHP3SQigAsx+55QBwAAQzcsA2SRgZzgnBIJxtqC2KSS5ZSXEgDb2RAAhUBNwJZZCPn4GXUsMgDNTNpXsndq2rabaUei3a32SfnuO+1tLp63tfSNknrez8rO6kk2ruXfcHTrkkptC3YCxjDeWXZQR8yqQjlgrKDuXaHOTmqUGG0MBY87BGSSAo+W6fLfOQSDuO5gwVWwpG4qTaLk6TOjI7bUvB5gwQuWYhst95W3ABlCDJHBfINSA/8U6W+QLuKg/KXx9qQ5D4DYP3QC3yAcjDKa8n3bpP3v9ndlLWz9zZvqr9k/wAT49QvF3ST+tQVkkk7aX8na6bX56mrr8pOkSZAy6RFQvHG6IsrAZ2hcKdu4DkEg9nzKZE0bYhH+obgtkhbWMdRvIIB+YdShzkYzTdd+XS5VADIYYxt4Ijy0eB2wchguMgHcQ2GACLO6RaRJIpKNbRIDsVjHugCIV2kHcGRjtb5RwCdshA1qR/eyTvpTo631fLON/Lvd6bb9+elF/V6Tirv29a6vrzSpxWz7Wu3p23RY1lmc6XlBj+0LUghWOQR0yT174J2suHOCa0LmQCWeRfl2K2VZ8KMDcDISMD5nA+fGdu3GKxL9XWTTQXdlk1KJyshJKbijBYirlPKG4gN97dzwMZ2LuITtOJS2HJVgGKBl8nG1tgBG0kNgYXO3Jworog5OVZ8tpNw0Uk72jpbot9+q2erRz1YxjHCpu8FGq7rVq8oK9urumvle+hSeZLeBbhnkKh41kBVnUiQJ/qMFY2VQu4ORyBjJUKauqwPzg4BCnOchg2GBYYKAEsdzYzliODWXFELSSZHleRSB5HmJvWJCRG0eZmbcxARgYgWJU4AbAq0gWVkYiVFOWyDtVmyjbV+UYVsDouSecA8BUpTTkpq3wx5b3s+91duLVraXVtdkhVoxaXLey1ulo4tRaW97x2s/wBC6ASchSRg4HIB4ABHAxyByRkDPJJNKv3lb5sLgbMEKDgYywZAuOqkqWJXg4zTtqkAsT8rKwwWHOcAEEnKj72GODnackilCr83zEgtnPzbiCQPlB3DaPujPAHGcdela3Tulpqru7Vui8/N77I4G+XVatxa1v5W+fyS17goAyOCwx97OCMJkhAMDjBznrkY+Wpc/OFwRnayEqgDqNm3OSdoLcjgKen3nG6FgeCpDsAm5CApxlQS4Y5yMct97rkEYw+PcW3LlwDtbKsxUHyzuUJhcFSo2AsGJztOQ1VtZfJ26Xs723eujun2sukfFrs2rWbbV/dXvLVPrZXd1/eva2PnJTOA6hHJwQVO0KVOMsckAZ5yBhgQSSc29kTJIzyXUqhI4Nxd3GEGERgMqBn96wBxnKlgDVOfUEtWRIcTXbBgqZXamQFElwcfKcHHl/MzYAA3bTVm0sFt2W91Fzc3UoJ+zFtpAYK0YckDyLcYyqIVmlAVSUjYgifM+WMfeWjk9obLVrdtarR2+4ORwipVbxg0kqa+OotHZbuML6OTfVRWmoy1spL7Zf6g4gtYm2xxKPlZlxuhto2VhLOoyWmkHkw/KAWAC1r3dwjRLAqrbWqN8kEW5wjPuBllIYNPO3yO8hG1ZFLIFQ+WjJJJJpDIyAndsWNF2RRICRtiRcCNF3cKAMHqWJ5UGKFVedgVZSI0CgvIx24SOMqQ+CzBXBYK2W5FaxglF8trPWcm9ZaJq8tLWe3/AALnPUrSnKD5Xyxdo00m1DbS1t3/ADNX00tdlu2GI1Ko54jJywboFI3Acc87R6ttwwzWnGqQgSYfYcGQnaxVjtBYAuBnHoMDt1NZkEl6wJFgyBuUDSAHbwxDKP4zyCPXcFC4NaML3hBU2JGMqP3oKjAwwwAc4wRknCc45BrqpOO3vXTsmoybt7qT67O6bWr1+Xl11NOV3BatOKqRvy6PvpyppNpX31s0zetI2wFChujIygEY+X5VbAySGyFwQS5wAQa1Sim0uVJZSYmAXGAQFVSc4GGxx0GehywG7HgN55aqLKRQeUO8thgUPAyuSQCdpbOBnAYLnoLVHnglikheKURspV8bXJUHKMSeT1OOnTI616NGMZXSTTktLRavorJtq/W/S60sz5zFScZc7lGykvtRk7Xjq3e7d+i00V+pr2tuvkaXvwyiWDDbCcDHPOTnGBwMAkk4B69rpsBJvV24/wBbk4y3LJkMd27HGGI5JKAcKSeZsYgLaxblvLlhZt3O0AFiSO3IOACPlK5+YLXc6fbus4lT54ZpQrhVyoLMvzAltrK2DlcAlt+ADivbwlLWNndtLV20jyrXSyer7Xve76nxua4hqElzaWk9Ekk+dS32ulo7LS77HX6HZl1CqrffQsHI+UKFJOCGYZ3qSDtOV7DJH0H4K0UPJbnbw6hmdhtCYPAy2cE7VUqAVA4+XBNeW+H9OvTcjZY74iQSqsSp5UgF1ACjKkqF3Y4z8u/P1b4C0K4VoDJZqgAUsWkAwCSDggDG7gDnPGBt3AH7jJMG6lSn7r3i3pe6bj5Wfe22i3sfhPG+ePCYWvL2kItRm7c8NG1dXV+nvd9La3TP1G/4JwfABfi38c/Cw1HTzc+FvArQ+M/EwMJkgunsLiMeHtGl4KyNq2tC3eW3YBprC2vvlKoxr++H4N+D4vAPgS1F1Gkeo3cTalqkjAA/aZkD7GO4riCIRwKVOCsYbALHH4Xf8Edv2U28EeAdF1fxDprx+IPEzWPjnxUs8RjltYZYSPCGhy7z5ifZLEnUZYHJMV5d3kZAyVH7ZftCeOD4O8BXVnZSiPVtZCaRpiowDrNdAxtKMcjyLfzJiQP+WeDgAV4XiJjKma5plHBuX3d6lJ4uMdlOpKLipcvSEG6kr9ORrSJ854CLA8OZJ4h/SF4lssDlGCzDLeGZVUo+1p4SN8bicM5NqU8bi1TwOGnDWSVWne0rv8Wf+CoP7Uo8G+AvHXiHTNQ8rWdce5+HHw+WOX99FNcxkeItetsZCmzsvNEVwnCzSWfILru/lS+B/wAMbz48/G3wt4IMFzd6O96dc8WNbgtIPDGkSw3GoWsbLnN5rc72+g2G7mTUtTtFXIYV9ef8FIfjtH8SPjHqHhnSNRM/hH4YR3HhPSWikzBeawku7xTq64YK73OpK1nFMGdXtrG3O47wT9c/8EwfhVonwh+Evjn9qf4h28MUFroz+M4BdgI39haM99a+CdIR2IKSa/r8N1r5RQSV0rwpcf6q4Vq/X8Ng8PlGX4LLKNJuhgMPTUoRWtSo/ZxhT0V+epVkoy7SnKW1z+XcPmWbYjBZ/wAeZtUc+KePcyr4qhUknKpQeOc6mHVKLblKlgMI51adPooQo2donP8A/BUD4r2/w48F+Bf2W/DNxbQXGlW1v4s+Iqac0a2reItSgSS00nbEQhs9EtJI7ayhIURW8OnxbV8gKPyn/Z++H8/xF8e6Rpzxs1nFcLfak/8ADFaQHe249P3hXZnG07lyoIBGL8b/AIk658Zvir4t8da3eS3OoeJtev8AUXdmY/JPcs0cYGF2RRx7IoVAxHCiIvyCv0v/AGM/hPH4b8GHxJqECx6n4ncGFpAd0Gl27El+TlUlOSG/iVVbqCo5MHQlmeawhO86eHvUrzUfdnO/PUnZpJKdSWiuuWPLFfCkf2R4M8FQ4dyLAUK1P2cnRjmWZym1zRvCE3TqTafNyQUKTd7ytKT13+wfB/gm58T6r4X+H2jxeXc+J7uC1cQrs+xeHLFomvZmC/6tDCuwANjc+Bg5FfvD4T0Ky8L+H9K0LToEhs9LsLaxt40UKqpbRLGMAD0Ubj8xLbiT6/An7GHgNNTv/EfxVvLf9zOz+HvCzSKcJpti6pcXcO4HAvbpXbcPvIqgsejfoqGCruIHHGAOQAOOmTwM8KDkk+tcHF2P+sYiOCpSvSw9m9dOdqOnkopW781z8B8QeJ58V8ZZtmiqc2X4Sc8uy1c14qhh5cs6kN1++q3ldLWMU9VZEc7jcRj5uRk9DwOwGc+mByeh9ca8mXGSdpUHk854AGAcYHr05HIzw2hO7AHoRjPOM9s+4PquM98A9Ocvbg/KCeDuP4KBuJIxkDgc5yCvAGDXzeGpXcVZfLR20d3ulHS/lrr2/K82xbUZtNO6aS3atyq//bu97NdFYyL24wHd84UbgSflx8wOMnJYE8FeMEFh1Nfz5/8ABTn4/rdaqPBmmXmbfTFk+0JE52m5dcHcBjJUZXac7ecjvX7PfHj4j2Xw1+H+veIru4SGS3spzbhmAZp3RvLRVOSOWPQ4PzcAAkfxrftNfFC78ZeKta1S5u2me9vLmdtzlsBnbaMjrgepG0Ag4B4+wwzjl+XVcZJKNSv+4oPS6jFR9pNW/mvZNNatq97mHhvkVTifi6jVnFywWVzjWq6NxeJk17KMt03GKc2ndK8Xc+UvHGvm7uZnMhYln3AkAcs+ABnHJPI5bGRgAnHzN4w1YRRyIrfOxKqAQQckhsHPTAHfHJxzk16N4g1FXaV2kPIJAwSUIz0ByepBwAcE9QSRXzr4i1D7ZeyBHO1WZVwflznlvvcD5iAdpG0nqeK/OsyxLqTd3fm1adtFdLW1u6enXr1P9JuB8iSVG0GuTlSdnpZLRW9db6O910Zhkg5Zic5ycnnJKnOM8nJHB4OTkZqo7KCegDEY5HB4GSBnG0AA/pnsrYDZ3seck56dNxxwdp+YbcNnuARxX8z5iR93PUkY4wB1wuOpGAR2z0NeTBpO7Vk7W8n7t3d6vVpfi33/AKRyfCqlShdRTSV3urrlvbbr2eju9DUtJBEeACeBu27sHCnG7GTkHHGMkj5SFwdtNTFuuRlmIOEXgk7c5wQAv8QzkYzjI528c05AKIcDHDHlVX5SWxgbmU9u+RyvBPQeHdDvdeuVjjV0tgyrJOQ5aTPO1AByOhwAeM59K7o410/dpK827K3R3Tv63W7utdF29/H8S0cowc7zjFRp3cnZKKVuju+ZuzWt9du/QaPY6p4lvUt7RGfL7WIBEMYIAyeCGYEZJPODwMECv1x/Yo/ZOn8YeIdMeaxZrczQveXksZyU3guELD5VAycglmwAAAK+d/gZ8KLVp7NriAJbqyOy4yZG4yWwCGJIA54AOeoIP71/s2+IvCnw6srXzXtLZY0Qsx8pD8vQ8jBC5ACkDnnIJAr7vhDIY4zExxuYyi4RXNCnN2UpJxSVmtlo3a12tbXR/n59IjxrzieCxeV5BOq6taM6c6sHLnSaSbVtb66JbPppr+1H7Pvw38PfDfwdp2h6JZQ2yxwQiaRIkWSSQIoyxABOQc9yvOeuD9KRsqICpwQMZIPbI54HX1981+Vr/t3fDzwjZqjXK3MsakMkbpjPb5uOuDhmyeCAuQWPh3jf/gqlaWcM8Wg6fBG21lilnlDAFdwPy46kjOOWPboAPp8yyydfFSqSxWGo072jz1F7sPdSSjHmdklorLTyvf8AzqwmQcT5lXqV/wCz8XiK+Im5zrVIzXNObTbcp2vrq3e9vQ/cCfVbO0VpLieOBFwWeaRVQAZGSWIUYAJPoOa8M8fftO/CT4eQTSa94t01JogW+y29wtxN8oztARjg54w2Dz0IyR/NF8YP+CjvxI8WC7hj8S3FjA6uvkWMjQoEYMCN6lfbIAIKkDBIyfzx8Y/tAeIvEM0813q13dF2YyNPcSynnJLEs7FmGRz0GSpA4I8mUcjwSvXrVMZONrQp2pUr3jf32nNxvp8Mddj9R4f8IOKc1VOWPqxwNJ8t4Uo+0rNPl6ytGLtZ6Rkrvrax/Sf8W/8Agq/4U0Vbu08DaU97MC6JeXkgjjOzIVkjGDzwcHBzkc/eH5S/Gf8A4KM/FXx3Jcxz+JZrKyl3KLLT5zCiowIAYIV4JyGyD1PBIBP5Kav8RLqQHzLtiGJON+Cd2flCjccfMN24g5AwSCK8y1bx18rAzZAyQS5ZskknIyRnoxwVC4BHBrgxPE9CjHlwOHo4WLjZOnFKo0ktXUneba6py+SZ+88KeAOW4adKtiMNUx1ZOMnPFt1En7qcowleK0atypLQ+qvFnx21vV7iaW41G4uZGZ9zSXEj4DZwW3FVyeAdpOefofEda+IN3dq/m3zMfmbGegOcAscjdgLuXaeuAR1b551PxuBna5JyxHucjGTlRjqTgjORtwQBXA3/AIrubgllkOMnGG6n7vXOMHHZenJOSK+RxmeVsRKTlUk3J3u5O19F32a63f3I/pjh3w2wmEhSjDCwgko8toWtblslGytorWvc9x1TxopBZpC5wQcvk4x1yxCj7pPoAcHBHHnOreNWywSQgqCODuJ6qe7H6nHfnkDHmk2o3dxnLsARtzknI4wST64+7zyfXGKIUnJYlmI6ZXvgHkEjj5uepB+i14ssTVqPd32s3dWdtXbToumnXU/Wsq4So0uX9wtktI63St09dX3Tve2u9eeJLy5J2u+STk7iSckgAhSBjjggd8ZzkVjyTzTM3mO+CTlSecDaQOSVwTz82eRznIAj28ZzjIyDnggEYycjp1HGOMEFjgtLIo5Y5GMYJPBPJ6c9cnkbVwSPXFRlK13dO3nb4Vtp0e3a7WzPt8FkEIKMpRUUrdP8Oq3v+d9VrYcEGSTkA+5PA2jrjHAOcHBGey4w4kAHBHqp/wB7BAI5zwAM7jk9G5poVmLgAkcAAAYxwckA4BPIPdhzxjFSpayM3IyMknjBHQbgcADglcAHp6nB3VJe7ZaJXb0/PV9r/mz6TDYGjTSSgoyUrK+j2hZu+tvK1l17FUvuY/L0JB46gfKMZAGCc4Gc475yKTbI/Ckjceu0jGMEAk888ggDBzxnk1fMMERDSShc4K4PzDGDjnGc53ZOMNx9YJNUhjO2BAxA4bHDA5OecHoe/QE4B7XCGqlZ9Fy3s2nZfDfe+q12u7tJHpRnRpLVpWst03dcqW2iva6S1s9UiWK0kx+8IXgHLcfwgjJ4OT25OQcnJxiyz21uAGkAO0YAPXB4x2I7DqSTjJ+7WGZr25JwxVST7nbxwACMA+ueSuBnobUGkyyEmQs3Q5PpknGVBJ+h6Hg8ddlG6vbV/wBN21S0SfXttoyWYQUbRS3TavaWqi7q1rq3fd+epLNqYb5IF3MSSD07nGC2ADxnI6Z655qoRdXTDeWA45XIwvCnk4BI2jjAwRg8tXVWOghiMI5yvy5HAbkEcjOQTjAwTjAyRx11j4XdiuYig3H5jkswXK5DEA7vcAk8AEHArZQb3d7Was9LtRb2snfXS/RbHFPMeW96lr6tbXuo6rq5J3vZ6aK55xb6S7sA6MzA8schhu54B5GeCQMDPJBGK6Wz8NlyCY2Kkj5zlRwBgLjnoRgDqTlTnJPq+m+D3k2iG3eQ55CoSQwwTuGOnGRySR1z1Pvvw9/Z68e+ObyC08PeGdU1CSbaoS1spnB3HauSkbKqnAJbcpHpkkHSjhK1aUYUac5t6WUXJt6LztorNddLOyPnsx4iweDhKpiMRSoQirzq1akYRitLtuTSS2Wv3aXPley8KtxtgyRwx2lslQMbief4T0HTA6tXcaP4JvLtkSK1kbcSojSLeSGI9FLcgEcHgnOTjn9xvgb/AMEhvin4wWy1HxpJZ+D9LfbIwvcyXpjPJVbYYJOONsjKoOcKSAB+pXgf/gn3+yv+z7pSeJPiFd6Vf/2dGJp9W8W39rpmliSMAsVhmkRXUBSwjO/cOQrGvocHwtiq3LLETjh4+67O0qlrR+wm3ez0b5baaH4XxZ9IXg7JJvD4TFVM7x7ap08JlUHipOd1FR9pFeyTbaXLzt3tZbH8zfwr/ZE+J3xJube28N+EdVvjM0aiRbWXyVyR8zTNHsVMkkHIABJzljj9cPgj/wAEdfEeorZX3xJ1uz0GFwkjadZxi6vip2MwIAwpwMADdglnODtr7M8df8FH/wBl74QRS+HfhB4Xu/H2p24a3gh8LabHonh1ZFG1VbV7mD7RMmRw1paXAcco4B3D8/Pi9/wUV/aS8f293bW/iPw18C/C1yjx7NNuFtNae3kyCkmpXLXGsyyFW5+yRWgLZKLwSfq8JwzgqVvZUvrdRXvUrytBNWu+WLstf55K/U/McTxn408cPkyTJaXBuVVlaGYZzJ/XpU5WS9lhZQddzcXdRWGabsudXP0en+Df7Cv7GWlR6n471Lw1Lr1pAJooNZnh1TXbmSNdwFrolqLi53MQNhkjgjDD55BwD8V/Gb/gr19mS48L/s4/DWK3iIa2s9f8RWwdh82yOWw8N6avkB88xfaWkOeGRiCR+TWv/Ej4Vi9uNW8Qax4s+LHiKZ2luLmaa9s9PmuWyx869vDcahcBmwzlEQsAMEFgK4W7+OHisTKvgfwlp3gu0TayNpVqYdQkWN0ZRcavd775SxUZ+zyW8pZiyeUWyfZeWcq9nzrluv3WHUZtStFJpRei33Tvo09z6Dh3wDxGbYujj+J/7c41zKUoy/4Va9XA5VGbSb9nglOpiJRbsl7WDpyjo4rQ9e+IVx+2P+0vfXGteKpPG+t27MTJLfxPpHh3TInk2gMLk2unWscRdQVkZVhXIYeZxXl0H7NPg7RNt78WvjZ4Y0EiRBNo/hZLvx1r6q21yjLp8sel27jIBEuoIyyE/Iq4rzTxz8ffiz4qs7LQ/G/xT1KPw/pUU1vY+HYtV1C4t7e3aXzZ44rJ5XLPLIVeUytJI7hpHdsIx860rxv4Etome9a+1G8ZnCRXtsWtcSIY0fEU8AhjRju82S3lllZVDAgN5jnlmVOpTjia+Fw7ulJYrExVRpKN/wB1Sd1dtWV4u/Xof0lkHhVjsNSpYLGZ/wAOcH4KMUoYLLKFH6zRilFqLnVVWMdkmvqUW3qm9z9sv2A59L+BH7LH7a/7QkN/c3Hhi30e1+H3gG41FLa2udQ12eHVJLAGATO4vVk1zQrh4kdxbt53I2SMv87njXVpdW1q6vJHLvI5Zm5PJKHrwCc7skZUkcZPFfqB8LtW+M/7SPw98P8A7JXw5ikn8Dp491X4l6pFp9tG063Oo6fpmnTaz4muoo7aSTTNBsYFWxt5ykSXF1IVRVaLd+avxU8E6n4C8b+IfCWrI6X3h7WL7SLgNhsy2U4i3AKzqEkChlIJ9UJyK+B4iyjHRy2eOpUm8rjjauHpVoc3spz+KNo3clemtHa101e97fOcMeE2d8OZrxtxxmdNYnD8Q8SLAZZmNKLdGplmU4LD4fBQc3GKdWolWxVRRjGEXW5N4HlLqPMGeAX+ZeSMHbxzleTgAEknlTg9PQNCsp9W8R6DplupkW0kjvzBt3rcXSNHb6ZbFQArGfU57WNUV98jsfKbd8tcDIrhzuADggkckjBHOcYPfkDIBGeSAPbfh1qSeFll8d3kcckulsdZto5AQJJvD8PmaNCyPvV4LrxPd6Qki4IkS0lOUeME/A4KjzVXJ8yjH3pSvpHls1dWSUU91a789l3Z7iHgcNKVFN1qjVOjBLWU5NLlSTW6Unu76PprT/at8Twa98XdQ0TTrhLnRvh7pmmeANMdJC6TzeHLcRa5dqzKm43viGbU5g7KHeNoxISRuP6j/wDBCb9m4fGb9qzwtrepWIuvD3g++h8Uaw80QaH+z/CU9tr0sEmPkaG91yHw5p0iODG8V7JGwVwCPw2na51DUpbqd3uLq9upbi4mclpZ55nMsrvtXLu8zuW/vu5bJKjP9dX/AATst4P2HP8Agl3+05+1tq3lad4u1nwpN4G8BSTEpPP4l1Zo7eIWjOqM7f8ACQa5pNvOoyyP4Vn8xswHb6+Wc1fG18VJ3cU+WT2jOq1ThbRv3IvmXXli9mlb8d8UMficr4PhlmFlKpmOfVsNkmGUdJ1q+Oko1pqN1aUoOcru/vTWl9H8V/ta/FjUf2rv+CiHx1+Ivh0tqlh4Q1lfhd8KIYiZFub3Sph4A8NmwwyDzL7XrnUvEUBhYyBl+0jekboPD9DuNC8Y/tRfEDxqjLqPw1+AOhWXgrQblvLaxvfCfwG8N6bpIa3TaYCfG/iTS01WYEtFNL4mkiuGE99brLgfs9Xsvw0+FXi74zajKGvvCXg/XvifFPch3a48Y6jcJ8P/AITFTld9zH4z8TXHiKGNwfNSwkuoiDbyk9f+zZ8K9R1P4U+B/hzZ74vEnx68X+B/B89wpIurfStW1h/GPizUJCcsY4NF03wm2oFl5gRGkGIUlP2FKnGosEoK82p4jkaclF05Ojhlp3nJwabu/YxuloedxJ7DIsDl3DVFxpYThbIcFlM5aRcsfmMaWOzatJR0VbD4Ojg6nPo7Ymot3JH7sf8ABMb4R3+v3PwL03xBA89/rF74m/an+JEkqHdPdahKmg/Dm3u9+Wbz47WTX4Ipd3lf2hKY8ghz/R/rdwsUDjBJbOAOD3wckcDJ64OSB2Jx+fH/AATv8F6d/ZnxO+KlnbfZtJ1zW9P+HvgaNkwLbwH8N9Oh0DS0tSQcQTXEMrZXlmiO8kqDX2v8QPEWn+HNE1jXtUuktdM0TTb3U72dmVEitrSB55XZj0Aijdj0JwMdQDyZpbF5xQwkLzp4KFOinFaSqvllUlaz96UnZtXeiu90fxRxzmbxNfHYpSadeclCN7uKevs421/duTpRf8tONr20/m0/4Ld/tAJFe+Ffgtpl9+60m2fxX4ihjkIDXt2rQaTBMFP3o4RPcAMflEyPzkAfyYeNNYfUtUlJdmCSNuxnDEsepPHVuuSeckbhk/oT+3b8db34v/Fv4geO7m4Zk1/XbySwiZwfI0mBza6XbLuYsAlnBGCOCDu6A8/mYVa5ut7AmSVzjk5JfnJzksQFGRnHIBwa4s4r+3xSpU/eo4eEaFLl1TUbLmS11qT5p6dWl0SX9rfRx4ElkfC+XfWKHLjsXH65i1Je99axXLVlFu2vsYyhRi9G1BWvY6HQLYyOJivyrwowTg8Bm3fdIxnB4IA5ORkfc/7J3wQvvjR8T9D8PrbSto1pPHf69dLG3lQWEEm54mYZw0xHlKDgkNnOQTXyBoWmuzW1vBGZJHZI0SPcxkmdiqogAyxLEADbuOMY5IH9Q37A3wBt/hD8MLLWdYs1h8V+LYItS1RpkAks7aRN1pZsxOUEcTeZMpOAxZTgAGv1Xwy4a+tYt4/EUW8NgFCtO92qteXLKlSWjuuZKUrXtGDvqz/SLwv4SWYY6k6lNrCYNQxGJbTtKStKFO+15te8kn7sWtkfUfifxJ4Q+APwp1HxJqvkad4e8IaMq21qgWM3U0MXk2On2yDBkmuplRVXH8XXYpJ/lI/aA+L3iT46fEbXfF+tzyz3mr30gtLRHZodPsd22x0+3XPyRQRBFOCGcgseWNffv/BSn9qgfEHxW3ws8I6j5ng7wZeTRX01tJ+41zxEgaK5uHMbFJbXTTut7YMWUy+dIPlZSPzp+GHg/WvEet6ZFo2jXniLxLrurWeg+EPDmn28t1qGveItTuVtdPtLS2jUyTNJPLGrBARlguQWLj0vEjiiVeo8lwdVtKanjpwd3Kt7qjQSW6p3s1s5tvWyZPjZ4jYfBUK+Aw+IhTwOXRl7aanGNOrWpqzbldRUKMVytuyTUpXseg/CX4Raz4zvJfAGjalY+FbZ9FvPFvxc+I+rK40P4XfDTSljk1vxFqzxeW8jRxzQWen6XA63ut6zfaboenq99qduB85+OLPwj8RPiDN4G+HTaz4a+Efh1Tq2s6pe5v8AWbXwvpaWmm3HiC/hDIk/jLxffzwW2g6HG6QHxD4h0fRoTHaLdSQfXP7WXjTTvgp4OT9kP4aaqvinxbqOvafq/wC0X4t8Oyf2j/wnnxXtp2h0r4c+H57Pe+p+DfhfcXUmj6fa23mQeIvHd3rGrr5yQaPFa/JviS2HwR8Fr4cS4gu/HetX8moazc2ssV0k/iC1F7pst9FcRF4ptI8AS3Gr+FvCrRSPDqvjWTxx4rjebT7Pw69fl1PDqjKrGtZ0YwU8fKOlSUU4Sp4Cm1dt1JpKvZ8037ifuxb/AJp8OZY/MqmM4yzR1qeX4+U6ORZdZwrZhGcoy/tDEwcVOP1mMFHC0nphsBFTfLXxM4qjr19r3xY8eaJ8M/Beii3RrvSvDul+GNJZ7iz0Kx03NtoHhGylB/0qLQIpZrjW9SkBfWPElzrOs3jS3M4kb9OfjNBffBz4e+GP2AvgfYXevfEjxhBo+u/Hq78OxvLqV7dXQh1fQ/AH2i2imeKGRPK1rxEzqyWmmwabazJi5vUfhf2R/Aul/sl/B6T9qvx/osetfFjx9dP4O/Zr8BXsJnvtd8WainkDxDPZ7WuLjT9HNzDqGoyJEQ+bWwDJPqcVYd03xf8ACeh67d+GPh54n8UeO/HMMvjnx18erzwVe6n4j1vxnfrqdtrPhjwXrM1xFFaaVZSfbJ0uUgEmsXdlJLaodOj05F+6o0J5Vlc8Zj3Up5tm9GMqsadNzqZblM1z0cFCKa9nWxMUp1OZxjTp7uMkov8AWOK+IocE5HHBrF5fT454yopQhj8dQwUMmyOrKMXKrKpNTjWxaaUaNGE60qXLBRgpylD4z+L37K3xP0rxfrNjHc+GdRSCzsr/AEqO+1mHwLf6ppstnazhtE0P4hf8IvqepwWpnMBubGK8iupopprWW5iUuvyB4m8F+JvCGpHSPFnh/WPDmpiNLgafrWn3GnXcltIqtDdW8VzDGbmzmUhoby3aW2nGHglkRga+pPEnjr4iT3kL+Mr/AF+/1exVxZSeK1u9SltLG7OHsre11WBol0+RCIRZQiOGOFFggSOOPy6/Qb9l74V/Cf8Aa78CeKvhXN4uFj8bLWxutW8IfDnxjqVkPhx4qkjunmvT4HvbtY9c+GniaWFgjSeFbua2lYGTV/Duu2LSxRfncsjwWeYzEUsBXlhcVJTq0MPi5uaxDum6cJckeWXK3JrmnorRT1t87wvw3xDm0KOBw+aZTmWZfVeeGDcPqM8bVpxUp0sFiJVp0KleaT9jQnTo+1bVqkZWT/DCS0ypJGNvyDsS3yDhsZ25yM4GenDCqTWr4+ZRkBV+UAsEwnPy7ssM7TkLyQxGDlfpj4v/AAP1z4Sa62n6lFOtpLqGt6YiXxtk1jRtZ0C9Wz1jwv4ktraSSG017SDJaTO0DfYtW0vUNM17SSdP1SOC08Zk01snCtgoFIO/5+Bw2VxuJ4BU84CpzuFfB4/B18Jia2GxNKVOvRk4SjJdrNNOyTi1ZxadnF31vr81iM05K1ahUU6NWhVqUK9GtHkq0a1GbpVqFWEkpQqUqilTnB2lGSaldJ38/ktkDAAck5wMDGCG+bBAB46ZwOTjGAaMlthnbaGD5xtXoMKQGG4jAzlujDO70x3TWJBbKuORnOCMfIwJ6H5mGBgEDoRng5E9ntJ+8yn5tpB64GdpBUZAxwACcDG4tivInST1atG/a6TaVtFZLu7XTTva1kOjj1Jp86fw29690uXZXVkl1130vaz4uSHapA+UnhkbALA4BbA35UDHJIA+XHyFqpPDHtxnjAb7wyCzBtxODyT97BIPzAbu/SzwKgJO5SCAwCgcNt2gYXaQ2eCcHJIIwwzkzW5VWZQX48wpuBxwMbONhOCFKnALLn1LcThfe+jT2tde7qtLStZK6S6LdO/q0MSpWd4p+7vfX4babXvvsr272MWRGCsQG3qOcEZO0BwSeGBJHHOSTggnpUPRWJ2PtHDfwlgo2k5bLdeSOckAjGK1ZI/mkYn5TGMY+co4OCzE4csCuMkMMjcCckVnyfLsJHG4bAPlzlU4GwFhgZwuSUwGxk1zuNn5LZ23u4p6WutelvkenCfMrX1lq9dLaKNtVba/d6W6MpyrGxOY9xAZwxO1l+VcDII44AVAcdCpUgk1fO27dysrMBtygGeEUZY5Gecbmyrc55yKvbWBkjBysgyAc8ZHzKy7m2rnZgEjLYK5IO2ptJB2llA2hwQWZsbMhgWOAABtKhdrZxnaCcZp68tm3rf0sr6tJqz21a106HVCW1001az11T5dFrdX1uk9ktGQbSGBU5JkbcGJICZHKncBjdgHABVPlbcM1HLtCgsXjG75GyyrgEEAD5hyNjBWBG1T0y1SMVDlHBXIBQlR+8BIVSDlmLbgDtOwHkk7iQG9VGSACoARgM5AXa7jG48ucA7XUZBAZQBg03eKsraWau76JX69NtXZ30RtGWy721u7pPo7W0tddO3UayZPzg7VfAIwWB4YeZ83K8MMKoweSS4K1H82CpAZeGB++GQY2jPUKx6HHI4Ow8VK2QfmVsklAGGdx3LtIYkYJONp5IwckGogGfkM6AHyyOBy2ASGLKcAnkAgDncvrk043afO1yrRdfdt33W1vLe7NoyaSd73SevVLl+0lbzs1q9tEiN2QruV1AZlI5UlyCob5doc4IwAATgnccEGmqAwboVPU5OF+6GHQdCMYY4zjkgVEF8wsXX5oR8jhjtZW2qrqm5iCzqc8gYz/FyZI4ySx3nGSChyB8oXr93j+7wSD6jIOcXJu+7ulqtVdRWqdlq023rq7ptaveLe6bdrdrpNJ3drdfXy63iJMatIMyBMyYDEqCNv7vCgg5ztCZOedpAG2kRSFAJYsy72G7IDELlU2L9zjapK43EDhgBULyRtIlvIjurAyEjb5T7JF43HaVwVLEEfOcZCk4qcnLJkg/MODkDBI4ZycD5ycAnBUBWORkpJuTa+GNo9dG+XmXRuytbfRaeVxvdNapPZ3122vZ6Xu/R9hQ5JBIAJjyAQDnGAeSRh88HAAwAGBY1A4fKsjAhiQ+RuUsNuQMAYLLwQG3JkDo2RMzLjHygAk8Z3N0GVPPcFiM7jjBGACKxPzIQSVYBXQ5wrAKyuS5UDJUAnHQsDz1bbTTeuq33V2lqlZNN663bvtoyr2srdVe7WzcbvRq6tfe/Ts0P4fjJGABtUYYHA2HCYIZsgAE5PJU5pFITGQSwyCx+6XwBlt+SGwBwDwBycsTUCozK7yMRI3yqRhgn3SoyNp3nHPqpBOAAKn2BUGZD+7UHcQSXwR/ESepAO4kBgAT84zWSfM3eNtFra+t46dFbSza8rW0Em2r21a2Wuj5WktVFRa1fT00vCd+/gNlVwxAUDgryBtwQAOeRg4GACwpm3cXGSWJGQOCrbVOQqZ2biCO6/w8YqfcrfMDjAG5jzkDAzk5JH1BY8Ak8VWQq8jsCQcHB3MAeE+b5gMknjAxgEgYADKrNSV7q+97rdRjo9U9NLbJ7vs7ar3ntd+9/gTtfe/TW3mrpEaxAKO5BDbsljklCwJwWXAAO05w2AMkU+KMIxO/kjgvlsqCu0HcQC5GF4GCCNrBsioGOyRGUM2DlyxLAqCFMYDbQSSCwPzZwcjBFTKyswIDYyNrEKMgkEdMkMoY4K8P6knhaNpO2m71ej5W27vpqttvNIuCTTV2traa3vFt3ukurV13ta7LD5Y5AY7GUDkEnBXdjJJG0jCqTgD75AINQs7IwbjLsrKcqM5KAqwAfdyTubp8qg5BpUYyM7YZSp2BVIDEgKdxBw4BKgYIDEgKxxyWEO8isWABQAqAUViGQ7AdyoMgZbPzEcKQRih6q3Sy3dlZWSu+tvJ/i0zSylyu7bV7tpXjrBayW72SWjd/NcxEYxL93LMArgHlDw+TtG0YLZVeD93IAODccbk8sBVLbVUZGFXC5bCqxPTAI4B54AFVhGQ3mJt2FCTgOAWyoyO2N2CDkkEqOV62EZlKsN2OFwQclSFyrAAYJBOSQTkgAFCcLRq2qtyp2u3ry62StdJ7u2i7bXHaSaas1F95RvFtu107p3T0Xa1tUnKoqEhmO5I+CQcbsclmP9w5O3GCMhsBmjRXWcmTd5TEEbVKhHbYW5LbARj5shs4Xq+QZyUmSRkYhSrLkDBLMOG2gM4AXCq2/Gf9kEGSBFVYxvGF2tJ5gAd2BRvnLlip7LxkqXBycLUSjzLfo5LXraz6pvruvXXUJJ8147aOztqmvdvZ6vrd7WaRlvf2baXJbrcR+a0UpERDGVmlIYKr7XVtxJyVyj4GDna9RINvhxXIkXbOQ2N3ljFxGWU4JZWUc8rxkIclqtW58NbiZogsgJ3Mba5dDnA2ja4w+dwJCqACflXCAapv8Aw35TRqieSyhWiW0vFhUnG5/LDHJ4UhiflJb5W3ceSoOXvTq0IpUnTjHm13hZtNPayenVtHx8qnI1GGHxU060Ks24JrRWaTvbVNWWt+jMrVNRsLjTpY4bhJHCoqR7ZfMkBaNnO1k4KmNlLBiGxtUY+9NPKILbRZpGjKIkRceW7GNFiTLMFOCeJGibOVdXA4LATk+FCybYUUkEsRb3uMYYAH5sY5DMm0ZOQNo6Pe/0FisUoSS0BUfvEvPLG3cqxomzCKFYFWBYooJUliwOtm5SbrYfmcIRTU20nGUHd9bvWOnTvrfFSShCFPDYtRVSc5KUUpPnio+7Z2vfu3fdrRlO8v7G6k0uO2nWaVL+GWR/L2qgG0AMWRFViwbp8oCAgn5saepSCK4YqzYmljBwJCChB3IAGG9VEa8glhkEb1Y7a8c/hqJt0f2FJWXMbtFcFkfOA25o8ISSGyFbaRklskCp9ssWuZHmu4ZoiuyEuJZCqbwxySiqshYsyERhcFmB3AAF5RvepTcqko6wlZKKjGKveSaTWt/Ls9Z5FNwUKFeNOkqnu1Ye9JzlFu2jS1v06deujLCZ4vKWUIpaJw6GRggTcxAZcAK4GSdzASYPy4NW8vGy7U3lsZZUTEYBVQxznO8YID7SzcbsjBpJqVgqhBd24QJtUYfcF6gYKKAxbliAASQy4bq9tRsGCk3kQCMCdryDcVwCcqgzvz83OcKB8mTnpg6aXNGpBTajf310tpZvXVt6q/q0c0qdd2i6NXkXM7KnK15JW2X5tJW0NRSAdxXJGBkdDtIAOR1yOuMAE5OTyVyuQTkvtLBsLsDfKBu3sQATkrwdzDa2DjGeNVsFCt9qhKkYwNx5yoyFwW5BHLMQo+XPAyxtSsWhZVvIkTJyVDNKTlcMcIGCnbhkXLHPDKAc6e1pqz9pHo7KSb0tZ7pbtW1TV/mc31eu2k6VWy0bcJd42218knrda23NMIrDIyQy5LbiAT8q5HG0DjqSCpPPygbqMt7LMVs9LXzJmZYzcIvmeWxCkxwhVDSzMQQSAAGPO3jFPF5rMv2a23w274JcAJJcAFVLSFQohtiQCxlxkEsSR8o6ODyNOh+zWiI8zARy30anKjGHhtGbaVUEN5k5PmOp+XaBhmnKpouaMFo5W1fwvlgtbKyXva73VnZhKEcOlKfLUrOzVNfBBaa1LOzab0g9G469UNtbKDSi3mKl1qSupkaRy8Vs7AgvITxPdx4K4AMNs2Btd87bCtvJc7y8zhyxIJZixYliCWckNkqckjkEjAqJYg0hGPmG3DLwQASASxBBLFmBOBkDJAyBURneVzZaeA0kZCz3ZKmG3AIB8tuN8nAOQxKnBXPKjZRULJLS9kkrvp829L3b2Wt9LcsnKs+aUm3vKbfupabqzskmrRTbbtZNu5fkuFikSGJPtF04GIV+bk7CJJWwCgB6BwcjHPGTp6ZprSyiVyLi7J4wcJBGQOI/lZUVMrvkYAYBLHAJo07SYoi6hgqgb7q9nJJOWU45XJcqCwgTLuxC8AMK1ZrvFubS0jaK1bYskucy3LcjzJ5PlxASoZbeNljQheWdQT1UqcYvnqWfw8sL3d/dfndvWzez2PMr1r3p0E2mvfqSVm01G+q1irP+Hq2/iaW1xLO1ilZZL62L9GMazyKjZO7a6qQ3QLhSV5zngA6cMFntXN9AMKCw8u45IIGdxiJzkAnJwTtB3MDXP26b2JbCqBjfuYnBKnHIbB6K2G5yGBPFa8UW4R7iwxsCkDdkfKRhiygZHTAUEclt2CO+lqk1GKVrJap2923XXR9+10tzxsRdOzqykkk3K0U/s+Tbim9FfZ9rG7B9njiT98kzF1QlYJF27lUjc77SgXBViQCSxbkfKu7aZDA8sXBIxkhSSF3AcLs4BweMYZeAQcGzyNyEYx8pUtnK4A5xk/PnGSSR03dK6GwiI2BVPlghjGRll3OGJjdiRwBna2TuIZQMHHo4dXskkltZdHom3dvy21TXXp83jnGKleTerfWzW6UbJWbd/V63dzftIisypIM28ucjAAjdkYDG4n5No+YEH1yMAj0XQIBBJHuBktJW+VCGYxyMysCC2MIQQdu0ZByCGAI5WwtzKFZVIQofu4zyQoXheBgnIByAwcMSOPVfDNi0LxeaokhLBUIQPKg4wDuJY9AcYLYfOcgmvosFT5pwVlZtWa3Wkb37J22+7y/O88xqhRqO6ulZxWl0rcvI3tK2r7p7p6r1rwfpd350Txy7ohs2nzCURXVDywQgoFQu+TuXquAxA/XX9gD9n6T4y/GXwxpeqwyXnhPwuU8W+MZMlreXTdMuITY6RKQAN2u6m1rYtDgh7Jr2VFzAzL+avgDw7HcTWswd4XU7pY3lMYMZEZyAqsSGVcbjtKn5SrIxFf2e/wDBHj9kpvDfw30HXte0/wArXPiJPZ+OdfMsBE1p4YtkKeDdHlLFiiXdvJNqz27HAGqSLjdAoX9FwlXD5LleJzTF+7Sw1GU1dq0ppLlSWicnJJRSaTuktdT+QvEfE5nxHmmXcHZDernHEuYUcowkYRfNSWInGnWxNWULtQw1BzqzqK0YWUnoj93f2efBCeB/AFpc3UKQanqyDUr4eWIzEDGotbYLtUotvbCOMxjhH8zaQCBX5S/8FL/2po/h34I8d+LdPv0S80eGbwL4AiDrvuPGmtxSR3eowKCSRolok90z9EksyGIEyg/rb8cfG8fw9+H2oz2bqupzwR6bpECqC8t7d4t4FROd4jZvNZQDmNGPbFfxA/8ABUD4+Hxv8V4/htpGo/a/D3wsS5sLyWOXfDqHjjU2SfxPfuwwJHsWSHSlYswjezuTlmmIr47w2y+rmmZ5txnmEeeTrVYYTn1vKbTny3b0hBwpRW3L7RdNPqPpE4nCZXl/hz9GzhiSWW5ZgMFm/F86LivaYTBSh9XoYlR058wxiq4qupPmUnRqWabZ8LfDnwFqnx2+L3hT4e2sspTXNUmvfE2prulfT/DWmq+reJtWkOcvMljBdMnINxetbW0ZaaWPd+xv/BSD4k2fwS+B/gH9mbwrHDo+peIoLLxb410q1YI+k6XFaw2XhDwrKAFdYdK0u0tIXSTIc6dazkZmIrh/+CUXwY0vw/oHjX9pT4hW4tNDt9Mu9WW6u1CrbeA/CFy9ywiMm9CfF3i6wghiBw01l4TvYomaK+Bb8x/2kvjHrHx/+NvjP4g6xOzSa3rd09jAXDx2OmxSC302wiUn/V2llFBCMDDFSwA3HP6jjcR9Xou9/aySqyW7daqmsPHs3SpSnXkmrqVTDSWi0/O+Dsglxlx9haFOEZZBwhCEVTjH9zVx1OUfa272rwp0ItOy+q4iP2mnzHwU8AXXxB8d6RpEUTPHc3cb3LDJ2W0ZEtxKwGR8qK3zH+I4Oe37v6ZokiWmheC/DcPl3+tTWfhfRYYFw0MDbEvLpVUAhYYN8jNkEMR8wGM/GX7GnwvGheHJvGd9bFNQ10G00revzR2CsRNdLnDYmKkKygblVjwTk/rn+x54DTxj8QNX+Id1E0ui+Dlk0Pw/5i5im1CQhtQvY92AxTbsVlDfKsfzfMMehl9OOTZLVx1ZctfEwco8y15bLl3s7y0l581tkf1T4rZ8+BfD6tRw8lSzriTlwGC5fjpU6kOWdRX1jGlRcpuS2k4dWz9H/hr4OsPAPgrw74XsIkjg0nTLaBtoA3usamWRyMbmdyWbPU/xHGD27yk4YZzkZ6DK989OgA+XggDJODQvGO5P8OAARgjPPX077R0+Y8QyOvXdjsflweM8Y4Byeg6ZJzkYNfmFWrOvXnWqPmnVnKcrp9WpPby2S0t07fxE2qGGhTV4xjCPM5O7k0o3cr9W273fW+5Tu5QqkEgY+Zj/AA9xztOOuCTwpHIxiuTupyQ7tjbjIGOig5PTIJIHTJ4ycjit2+nXay4BLY+VuRz94nGTxuIAOTn5ckjjwT40/EKw+HHgTXfEV5IkP2OymaFd6jfKE2xhcdCXwckA5+bk7q9bLsNUr1adOMbyqTUelkm1eTbS0ServazWvRfCZ1jFKUlBpuyjGKTlKcpOKjGKT1cnJKK0eunc/H//AIKf/H9IlTwBpN4oS3DyaisUox5jKcIyg8qME89DjOAOP5lvHuvyXl5cOZCzZlyCSeCTuI6jnjDZ45wdoJP2X+1N8Xb3xx4t1zV7m6LteXVw6bnJKq7vtHRsAKAApIHYnOQfzl8R6mXaRs8fO/Vfl4LZGG5HOVxkDoQMbRtxLjYJwwlGX7jDQjRjayTa5VKX/b0k3ppfRn9Y+CPBU8pyfCzr0rYzGyWJxT5XzKpW5XyJ2T9yDUFre1l0POvFerCCCYqx/eAjjg5YEAEDOBySzDBXsNoNeKSyF3Luwy+WycZLEgjLZIBOQCRlQRkDOM9H4l1P7XetEHzHHnPI5OeepySTx0yPXnnj5ZAWOc9DkEqMksOSSvyg9OmAD2JWvznEVXOo9E29Fb1SWvqrXta902f3Rwplaw1KknCztGUn2+C1tno1v8hJZsnrxjkKecEDaA2BjOMDHPtkCq7S4IznHIwCN3QY42liO/GD65OaikkVnUIMsQB3OenfggAgADC9DnBBrqdD0QSsLm7+YjGyJicHCg7n746kFsDjHes1JycVDVtLTs/dVl376dtU9UfZ4vNqWXUZNzs4qytu9laK0d7N36bq+g/QfDcuoyRzXSsIdwxGc7pBt4OD6EZYDdx0weR9Y+A/CkNssLvCscYA2KUCgKoOAeM9MDJ68AHcRjzbw9awQGN5MYGBxxjBwfl3EEAnIByBjPTFetweIorSERoVAA4x/ukHjJByMMCSBkgHOePXwVCnTXtKmslZ387RvZ3snr0+69m/wji3O8fmkpUKMpqnK+iltdRV3qk763139Ln074b8T2+gQKI2RGjUcYAPGfUA+hyBjAwVx16HUPjZdxRNHbXhjGD92QADqACcgjd1VT8wwdx5Uj4ovfGkqq+2Y4ydpMmAcHnCqWyDuAXgZGCDnmuLvvGsoVmkuF2sTkKxJyTzxnLAcg5A6YPGK9yOfSw0VTpy5IpJRs1rdK+iet/PorI/Kn4dwzOsq+Jo+1nJqTcoXtrdNc3S173UlfR9l9a638W7+6Llr+UMu453uxOCRglznnr8oIxtHavJ9W+I91OWJu5GBJyxYg55BOT8xBGMhgpAIzwBXzjqHjlEGBLljkjkAscZGcn2OSTnBxyOTxOoeM7iQsEY/wB3jIPUbeB1ye+cgYzgcV5tfP69W6dRyb/vPT4bX62066+T6/XZV4X4Sk4OOFjGKSa/dpXatfS23S++u61v9A6n453BmklBY527mJx2KHJJGAfmOcZ7A4Nef6n44yXKzAZIwc5GcnvkADJHBHHGT2HiVzrl1O2fNYg4ym7IXdtYEAdcZ3A7tpx02gis5pp5cl3bGOSc8Y29cE4Jzx37YXNeTVzCtUd3J8zWkUmt7aapO7s7vXyv0/Rcs4FwdBx5cNdq1m4rdWs10T89L226noN/4xllL4kLEBgPmyOcZ4UYxleSAM+gJrk7jWrq4J+ZzyeASACxUHKr7/xHOMA8Y21krs6cnBDKzEYyM5wM5xnvgY6kBjku3KG64wMsOinIB4yQOfUhuvYkZ55Tm3eTb0Tttb4d7bN/KzWj1SP0HAcMUqST9lGEUot2Vrv3dPLV9PTmsSMzS5MkjbmwMnjHTqeowc5AUDBIwowS5EVACR7klsk8jbwDnOMbgPvDoBwxreaNrYYkZ5yM+mecYUHJ6EjjJJzTo1lc7VBIY5K4wF9hgZAxkjJO3O7jGKlLW127tabvokt0r20dtunl9Phcpo0+S6TtZ9Gm7q68r91tyvS71maVRtwTyRgZ9wACTzlic+ucDnFML5IIOM5BzyxbhQCSCT654GORls5sJZYdd5RAWBPOABjGWIyccjPPPOCVUmnvLZWowzLI+NwA2HGMZySDyBjPIIx0yQTpGDSTfuq219k2tbb9Lv5NW6evRo0KCbSjHa99Gtne1t01vt5dq8cE0wBCkD6n2OegPYcH8eTiri20cYUySRquMHJyflwf7wwAcHHbnqASM6fU7iVmWBGCg5XGS2MkjnsSQCePvH7xbFVktrq5IMrOWx8wyeOMdflzgHjgAk8HrWsbOyipN3V79HZX6eS3957XFUx9OLtF3e7aaUW9Oqs9Vdvtp89eTULWAYjG9iCQFwRnHRgDweh7jnpk/LTa/vLgFY1MSktnPJAwSODjsOT2HLDHNW4NHZgC6tg9T95hkk4+XgcYGOBngkjp0lloJcKoiY9CGbOCuAc853YBPA68tlRxXRGnOVk01qrrS+8dr6t3te/Z6728+eZ2bbkoxsn0XSKa36WSurt7d78cljLIxaVmbk9yMZPYfewMAfMo+9z1Fa9rpO8KBExyASQDlSccDKljxjIwDnHA7+kWPhbLjcjMWByqqWOemCqgcH1z75YcD0nw/wDDzVdVligsNMuJmcqqbISScnbtCqnzM3yhcbjnIUcmumnhW9FzNvl0Su23a70Wj7K97W0slfza+c0KMOapWjGEWm5zlyr7Lu3J22butunVnjdh4ZlfaTCVLAHeQAcZxwSSMc9MFjyFwa7rTvCJkICQNI2OQF3EsQSAOMk4U5BzjJ47V+kHwR/4J2fHX4sTWkmmeELyy06crjUtViksLNFcctvlWNnUKWO1FKnsG5r9j/gn/wAEdPBuhJbX/wAVvEratcIqSSaVo8fkWoOAxjlu2JkYMRgBfLIA4HJz7+D4fxteMZul7Km9ZTqvleybai2m0raJJ2d7H5bxR428G8NKdLF5zQxGKprTB4N/WsRJpRtFwp3UG2kk5tWs/U/mp8KfB/xL4kuYrTSNEvb64lYJHDa2c0zkluAQkbHIIAwASdoGASBX6R/A/wD4Jd/Gv4iPaXmq6SfDWlSFS1xqatA4iJzuWN0EznkjkKMj7pY1/RlY+Cv2S/2YNI8yeLwP4RFpHu+1apPZ3GsSlQozHCxlvJZGJUBEjZix+VeAK+Tfi5/wVM+F3hGG6tPhh4auvFV1CjpHq+qbdF8PxOoZQ6o4F1cqMfKoit3dcqHGSR9DhOG8BDTEVJV5u1qcLxp2vGybV5yXkradD8dxvjV4hcXSWE8PuD8XUhUfJHMcbTl7KClypSc24YeLS1tKtJ9FCTsnX+Df/BKP4PeCEtb7xtczeJr2HZJLAFW2sFKAMQzFgSmSdwZuRycZK19MeI/iz+yP+y1Yf2al34R02/s42SPRvDtvBq+vO6LtRHWzSXyJGPBN28aDAyTgV/Pn8cf+Cknxu+JjXVjN4xvNL0qXzI10HwaZNHsPKI2iKa7hYXt2pACsrylW6+or4O1f4meJNTkmluL5bATFmeeeZmuH3liWMsrPM5YHqNmTnncxr6zC4DDUYclONPDQV42jFynJe61zNO9nfW8tN31R0ZX4C+JPHVSGM8QuKMbGhVnGUsqy2o6dJRdvdlVlGNGCSdmo4ee141NLn73/ABq/4K0+JJBdWPwn8P6b4Ssz5kKeI/FUsd9qewghZbXSoitrbSfKGQTfaMEkMjdB+SHxT/ah8QfEnU5dT8eeLPE3xD1RncpDqF9cW2kW7bjhbTT4TFDDEp+TbBbqpRhhsqwr49udahuJN9xdXepzEjncyx5PQBnJkIxnJUDAwcEAtXQeFPD3jnxxqkGh+BfCura3q9y6x2un+HtIu9Z1SR2ICqI7WG5m3H12qOSVIORXu4HLViGo4XBVMQ7JyqNTcUlZttRVlGK1s7K277/0dwT9HzhHhv2ay7Ko1MY1GMq8IVMZjpyaSaWInz1Y8z15acoQvqopWRu6z488aXsZGlJb+GrF94LWyxaePLIHDXs+LlztIY7WBYnIUjJrxTVtY0i2ee68Q+IrzU5shpY9OEl06/NyXvrt440Vj8obLYxgZGAf1k+D3/BJX9pz4rT21x41h0z4Z6bMEkk/4Sy8n1XxN5DKSfL8KeHf7T1WBwvIj1I6cqcGWSIECvrTxh+wf+wH+yh4G8Rv8cvitol/8Rbjw3qsGgzeKNVsbqbT/EHl7tOvtO+GPhG91K5vkiu8RPFrWrSMIpCZ7JghepxGU4jE1PYfWqFBpRbpU26kkpNJzapRnHlhaTm5SUkk3bRX/pPJvA3Pp4OpjoZbhMjwlOi6qxeeVqOCqVuWKko0oV7VpOTVlzRtdpuXU/nR0zxvf6hcCx8BfDi/1+8dlihnktr7W55HZwiBLexi8vezHO0z8BtpLANir48b4vaHDpw8aB/DUWtW891puk6XNpEl1cWsNx9mklksdEudQvLZGuIpYUGqS2TO0UjBJAMG/wCPfiXFfzxRaFZrDHpd1cNa3sBvLWC4eSZmS4i0o3KWlnGsczGK2gh2qGCuhK4HgWr63qty2wyLbQiNUS3so47WGNFbeEjSIIFUMAwVflEjNIAWZs/G5xh6GX1akKWY1MU0kpTowcYc+l0qk5RkopNq666rRnw+KypUZOnRrSbSaqS95rmVl7klNK0ZdUmmtl1E1K4NupMkaNLKu1Vv7oS3DSnBBeytNwRSCWDTTDbjyznJFZdvJdkly9rksHMa27JhSQxIk80ncgDAM2GHHCjdnHMyhj8y79+7OdzMRgFWO3JbOCwPUH73QmUXowpU/eCoyqWLA/LvXt64XIyOM56j4qpUUqvM5u+jSbk3a6+9ppLra+vVnkyyyMW5uU3K/Vtp3s7O7d77NPyv2X9Nf/BFv9qjwPfeKdV/Zwl+FvgzwfrmueCL7UdH8f6Pc6rd+M/GGs6KIptS0zxBfate3QmtDpct1qOmWmjwabZ2Ysrk/ZriSUzr85f8Fd/2cI/A/wAVYvipoVlt0HxrO8WpsihYbfxJDtEqkpgIL2BGlBzlpInYbTnP5X/st/GjVfgF8evhb8XdM86STwV4r0zU763jcoL7RWkFprunMw2hkv8AR7u/sh8xAknDcbTX9J3/AAVpu9L8WfsyeCfF+hSR6lovinxRoniLTr6Iq8M9hq2lXN7YXEDdP9IgfgqSu7/WAtk1+zZHLD8Q8I5xgsRGHNRwknFQSjy4jCU3Ww9aMElGHOlOm+VK6c7q7bf9UcNSy/i/wH4oyjHqj/anCNenmOBUIU6c1QnyOnO0Ix5+bmxFGrL3pPRzbkk3/Mx8OPhXr/xU+Ifhf4f+F7Ca+1zxRqdnp1jbxIzsxmbfLJJhGYJbW8c9xNJsby442kcYjJDfjBa2+geT4W0+QiG0eOylCP8ALMLAC5uzkDDrLqV28bEENI9rFvCvHuH6e/8ABKfSNPt/2kvFvj7UY4nsfhX8DvjT44WSVcJZ3Wi+CdWtrO6DDHlGKTUlMbYVsxuQcjI/LX4y3UI8azaTIpW80XTNJstVEuEceIJLKLVfEAkySQ8Gq31zZOH3OHtdjHdwPxDHYKjg8BUmo2q1ari3a1o3hGMUnpr77as1orb3P88cTVx2b+ImdZXo8t4dyvK8TFK95Y/MamNc1J6r3KOHw7hfWPtJc2jRF8Bvh/L49+JnhzRFsp72OO5S8ltIovNfUWt5YUtNMRSGBfVb82umwocb5Lxdj+dgj+lX/gsjqf8AwqL9nj9jb/gn/wCFJD/an9l23j34g2Nm+GvteuAbCx+0oozKt34n1fxLqIWQeYTBaOqkRrXyb/wRN/ZvtPiH+1B8KLq+theW3huCT40+NJZYFNvYeH/CscEvgbTHLqrRyar4ou9L1O6hlV4Li2XTpITJh2XH/a2+Kl/+1X/wUh+NfxE0ffq2i/Di5u/Cnw/gjHnRXdx4Vlh8G+ErSzRSVc654zvIb2COPLyvch4/MJdW1wOBeHw8KLu6teFOtVUbXi6qaUNt1h/bX6RckkfB5pQjxD4u8O5bXdOWVcF4DEcSZqpK9OFaNPmoKtf3YzpOMMRT5nrFXWzPBPj9GmmfDT4O/AXw26pqPxg8dWuq3DI6DzPh58IpbvwB4MmkjQsFsdc8f3nxM8QSRSkqw0TTLwKQivX6M/sn6Ak/jrWfE+n27SWPwc+E99J4URI2Zl8efGWa08B/Dy3i4ZXubX4b6bHrKAkSxz3E7MzGQsv5ragLXx3+1v8AEGey1BZPCPwH8N6L8CPCOrpIqWiDwppf/CFa/wCJ4HjLgrd30HxE+IE1wu/Y873kzMqkN+/3/BLP4Zv4+vPh7qV5pwgsviF458RftBeILIxfJaeAvBUsfgr4Q6LPGQY1t3axurmKHLRNBcF4QgAVPey+UYzxWKnFKlhoT5OVpr2OESSnF7WqV26i5dHKe73PzHxFzerHK8VmWI5lic2q1MdUpySjOFXOZ+1WFqRd25YXJ40sEm3zXoQUnG3LH+h34JfD+3+FHwc8AeBLeNY20Hwzp0N8UG3zdUlhW51Sd8AFml1Ca4clsE7sHpk/mT/wVv8A2gYvhV+zvqvhWwvhDr/xNnfw9bhJAs8OiwKLjWp15DCN4NloSuQxuzsyQCf191y7S3tJGJA+XaBnAwcjA7Ac8ZyFHJBBwf4of+Cw/wC0hF8Svj54h0LTNRE3h74cWp8KadHC5aGTUosTa5cJhtm5rz/RC68MtqM53YrxsBOpGGNzOqr1HKfJe/8AGrvT/wABXNUj25FdO9l/N3DWST4u46yTKGnWw1KvHMMe7XTo4apTlyy0StVrypQlF/HCdS1+Vn4dfE/Wn1PVZYgxIViWBJIBPOM5wAo2g8dQQM5NcJotnvkMrKQFYJHgZy2QM7gox0OSP15xHdzy6jdySA73mmbgcnbuY55zgEYOM5zzkDlfUvA3g3UfE+uaJ4Y0O0kvNT1e+tdNsbeNC8stzcSKoIA6Khbc7DdtXJzgEBZVgq2Px1GEYSqSqVYRhFJtzqSlFRjZaW1TbW762uf63+HXDvsaOEo06TfJGlCEIx1lUm4JJJavtbe7XTQ+6v2Af2e2+LPxOtfEWsWbS+E/BkkGoXjPHmC71NGD2NnuO5WVXAnmXb8qgE5Lmv1k/bp/aWsPgB8K38MeHbuO38eeM7GfTNHjgcCfR9HCGK81dlBBhPlOILQnaTMzOrfuSR33wg8CeCv2Qv2fZ7/XZ7e1t/D+jya14p1BgkcupaxJGHe3jLEGWWWd0tbSIfMxMSAEZFfzYftH/G/X/jt8TPEPjXWZZSL66eHSrFpGaHTNJhcpYafACflEcIUzMAPMdpGY5ZgP6RzrMcP4e8JUcDRlGWb4uNo8j1eJqQiq2Ikt+TDK1Ok3o5JNK3Mf2BmuPw/hxwbDA0ZReeZtScqjUk5UeeCjUqd0qUfcpNW5p80ov3WeZW0l74r1vy2eR2nkeW4mlZmKoCZZZZX5O770jEnkkgnIDD9GdA8ZaP8AsbfCC++Klyot/jr498G3OlfCKKKRF1D4S+CPEEU9hd/EKKNtz2vxF+INg0+lfD/UCHfw1oJ17xNHC88uguvyz8GvDmh+G7W68b+M7RbzRvDwtdQn0VyIJfFmtSF59A8GQSbgy2M0sSa14xuEaM2HhO1ul3xXeoWHmeRXOp+Jf2s/jTe3Ot3Oq6z4a0rUk1HxPfaXCiXGvXl/eJY6Z4b8Ow4FtZ6r4r1A2vg/wPpMf+j6ZprSX3lwWVhdiD8Dwqqv/aq7VTFYuralCTlKcp3U515LW8KS5m3dpy7NH8TZlk9bj/O3Qx1ZU+HMvqOvms63wY6UEq0qE5SdvqsIxdfGydk6XLRfNGrVidX8FfDsGi6DrP7QvxDaZM2V9feFRBPLBqUNldXmo+H5NX0qaTzHtvEXizWrTVfBfw7vT591o8OmfEH4johuvBmhXFx3v7KvwPl/ac+L2sfEX4kXen+GfhN8OreTxd8QteuIjZeHPD3hnQbYSrpFkuCttpulaZYxadZWkYkkWCCK2jE11JCsvIfErU/EPxq+JPh74MfDu2sr3T7LWbbSrax8NCV9Av8AxKtjaaFLNo6hS7eGPCej6dY+DPBKYCjwzoiasYob/wARay9z+sg+FPw98H+G5f2VdR14eHvgJ8BNK0X4sft8fEay8qKXxNr0dxa6h4K/Z60S9V9t3r+v6wYEu9LhlnaC98p7iJ5PDt1FJ9Pk+CoRVTMsTBYjA5fV5sPQlJRWYZovfpxna6nSoNudZ3klGLtJxlZfc4XOMo4aybNPELPKdSHDnD1Gnh+H8pUGq+Z4uTjDLcDhsPFOdTFZniuSrUpxi5Rpeyw/KpLXw746fGi38NfDi9/ax1rS7XSPGPj/AMP3nw8/YH+FWqSQi4+FfwW0rV7XTvEvx/1bw/cQ3Fsde8ayxX1l4ee8gSUXElxe2LzWml6XJF+eN9/wUM/ap1mzisdZ8baFr1lHYR6WLfWPA3hO+VbBRxbea+kpMYnYbpFWUb5N8rN5u6Sup/ac17x9+0N8Z9W+I7W+j2mh63pmn2XgDwfpus2T6J4E+GOh240vwx4I05Y4oobCz0HSbaFJEgt4HmupLq7jjeWYqfny5+Aut2+meJ9cV57SPRNQsLKxsbjTNXns/EFzf2tzfm00DXlshZ3l4IbdprOwZIpry2k82KRWQxy/I59mfEOPx+IxFDEYlc86lWq6VSUIVldc1RxXuuKTUIQt7lKMYra7/KqvCOH4mp/67+IuW4HOuKs+xSzKu8dhqWJ/sGNdU/qeS5dKpCTw9DL6XJQk6SpqtiHUr2XtbR9N8A/HnTPE2vT6f8WdM8PQ6R4j1FZ9Rv5tP1KTwvA09vdQTNdaFp8kmpaErPOslrrng6ewutIu0ivJ9L13T4ZtIm5u2+H/AI88IfEY2vwuuNb1/wAR6JeQ31pf+EZpLi90q4tYrG+e4hvbcBZ47A3Cumr2ZWzvrVI7yNY1n8hfCbSyc7c/60jagO3KNySrqVYA9m3AkHJC8kV+iHh/whpPjfwi9j4UPi7xVqWi/C3R9QstQvLC607UrkWNqk/xJ8PTXWn3Ysr7T/BN9qVpd6LdyW0jSWEl+ryM80uo3PLk9DF5lVg5VJPE4eanSnRShWlJWe8U3Lks7tpb6yeiOuWe0+FHRq4WrPD0Yzpqm5VZ+wwc4TpqlOEudOim5RVk7JKLSjGEkvoL4h+Ep/20fCGjap4H8I69qXxxsPCmqah8avDOiaHe33h6zvfA+mPd/wDCzdU1nS7G30LR9XksLLXdO1BIJLx9V0WC2hkaS50eOBfzd+LXwG1/4W+IBoOqXWj61b3Ok6Rr2h+JvDd4dU8NeJtB1uwt77T9Z0HUwiLeWUqSSW1wDHDNZX9teafeRQX1lPCn7I/8E1b3xFpfx78NeAjH4ouvCXxOaz8M+JtE8GNqSape2jedLZXUaWSpfSvLPeXGh30wcPLa61qcVwBaX8of0L9u79hHxh8C/BukWmreGtO07wf4T+IPxA8I/Dd7Vboa1pvgXXbyTxpoGheNI7gFYNTtNTvfEH9nbXlBSa6KOsMkKj7fPsky3PMB9bqYijDiBYOFd0I8tOeIVGvKnWfs7tN8kqdSckoy5ubR83ueP428YZTkuC4S49xfEuUxzPjDP58N5xkNOlSw2IeYQwKr4TNaPs6s3Wq4yNFLFTlCnGpVqOSXMmpfzY3+iSwkqy8KRj5c8ZGDnaTlW5zgDjkk4rjb2wdS+5Qdw4IAHBxwQflOGyevJ5wDnH1n4u8IvZXEq+SQ2XGCABwx+TkqA2R/tA5znPXwjV9LeORxtJOSAxywP3RgKBsIJ54ABwASvIr8XxWBlQlKLWzas1rdWvbro9G/NpI8XJOII4yNOdOpdSimrO6fw7u/4rXrayseLXtsUHAOUxgrhSQCudwI5I5zxgZxtwQa5ue3PmRYONpdioAw5fbyTkZxkllUcEZTL8D0y/s8bsAgnhgvTOVBJAA+YjAJzwODkYA5O6tVCsVJAUDcSpwGOzsDgEAgls4DDABIIHhVaFm9Xy3V7drrvtqreaWtuv6PgMXzwjq3dRuuity6tppOya1e1nfQ5GSJxkkFtinkDI5AIYcjd1ChugOQQp3VjzxRg7ip3OMDJIAOEIB28AAjK56ggqx6V0Ny6K8UeWYuxUMATsCgMWcuNq/LlQM8szLtJGBk3G0FVUBgzoNrNtwPXgcthSAqkeY2RzyRwTUbN2d4vllpZ2suis+qb0T1d77L6bD1XZRslJKOt0o20StbqtFq/JNrUxWjYNtUbcqc/KTvwUXGCFUN8vykdiAgXDZjcAkKRg4yDlVzgJtDA/MARycZTkDJJ3Vaf5W69WOHAC8ZUAtw3OOVxwoAKjHKwbFCnZuJBXduLHdgruAIPTuo2jGSCRXPKKu7XV2m97Rene6s9L9vPY9CM22tdLR6pLom3ZWS1dl8r6XKM0qxgu0cipuwSse8c7ckgYbaOM7go+Ur8x2ikb5woXghVcAkZZflKruOCAwGB1Xjs1WJFL8KDjKhiOMLlTzgnLDjHZSQyYGcQuoBRmGCuORu+X7hGTnaScEjkEZJxwcc8otSd9vdV7Jb21T0XZW6fedFNpqyv5PXpZJa2unt52s7WRWw+4jAG5coTl3O7ac/ORgE9DtwRgHaSrVE4G1ckAHaOFwpI2YJLZyeuDjJGS/I5nkTK4ZiedoIJ7FP4hyVxgkBsc7up5YvIxIMH7uMKCfu4Kg5O44B7knoBk1jOLctWtLWTXXS63v1s3be97Pfqgv8t79Yp6aPW+jtvZNMq/M5U7thU7iASQfmAKEL15BOS23K4IAwALtbfngqCGAP8YC8EctjrkYILEYOSpDiGUE4DMAAuDnKEqTuJBUhssAVX/exgmoGkG5Ai74yd0r/ANwKsZCINqkvypbaTj5iuV6Yu0FdrV2SWuzcVeKWlrWdr2Vm3qzpjols09W1d20j528297X2TaHHc5OQVyqkA9CcoQACODuAJXOcnaDuUYaeBkjjAUMADknBA3N975uFIBDHAOJBml3FU5yp4wRwQcrtUtlsYGTzwQeACxpjFFwWY7wANw3EncVBTA5b1wMhgecEZp3Wnom00+tujs1f8P5ro1Vt9Fa213e7XS7aaeqTXbmtewmWAGV5BBYFR9z5OSx53Zx0UMOTz2Zt4VQhUEo4OVZiPkyi5KgMQSC2CD1BZhTtyk7UKlkwJOCcfdJZgw+YkZHGcEYBO0GkOVGM7gAOOclRjJyckqD8wwBuyeh6S1fTa7b6bJq/R6Pfz79no3p1urvrqtNb2Stez1asuqGLsfcG4xgZY5VWyp4+U5CkEYwME8/NyXZIX5mXGVUbsnJBQDJbnORhS2Qf4jkqaCoPDFVLKR8mMkHgcAFsjAyCcgkHuKZtwFTIZlCktIFyWG3aTycjbt2jAzgZIbFZ6LSNkpKLTbafM7W63afbVp9bWsJtWtba9v72m9m2076WSatdoayqzHcCAVJBJGOdoBJwMsDyOSN3y43c1VWPqWOM/MMAr8vygZcknIAGBj5sAMQdtTyNvHBOQynb82Dg85wOXHyZ4AHG7OAajBYEAjBz1CgsEyo3dcnJHUBd2RkZGaV/eaer1vZW0aTXVLRK127tXut0Xo9bauVrtNP7PVdbd+j6JERlGcY4OIiQpPTHAxg53bhk4kyAdpIJMoUKinIGBhSAGCn5CMYyCMY3HbgMS4wwIquQA7n7wKB1G35huClsNljkNgrkEjIKkhuHA7wIwSq7clztJdkCkBVfZ6YcKDhSeQes3a6X7Lq37tmt7Wd/T8R2V9r2suj1XLbW97JaaPbXsnKxdl2uyleGG0qNzfL96Q7cnjdnPzrxkHFKwTaiYbhd24EhtqorEBnIwzlcgqAGOOMkmohiVVwrfLgDoA2CAV2uSFXONuCCOmQ20mQOQVWJMlAVV2yVyCOAzkY3Ho2CpACMuQMzr7y1bla7d2rWTv6teeq67X0Xo09HtfZx0Wl1dOyu9mu4OwBhUhtxlRQF3Z6qScED51C5YMwABBzkHM8hQPJudSuAgC4UK2EDALuDMBzgkEgEuvJ4jyibiAG34wGRWI3FCcsDhcZUKCcH5ePmwDCkK65yAQTkBt3BzsGeckLknDHjBUnBpazd7tW05Wmrei1T79FY0ikua13zJPpppG6tF626W3ezV0yzGzkROSCuAqkIOMBcbgpwCARuXJZMFgSOk5IAwd4U4ICAZ52AEYGTk7sLzknOQcgV1BjIjXp8rMrZKg5QMMfLyxPy4+6RjC4IZXaN/wBysgWRMMRuIbohBHynByckKcg9+Vwr8sb2TbSdtFfbysvJWf5tNWUdnfZK/VJX1tb0te1nexZgOmD95dRXfmAEKqC0fapHRiY1YjaGLKdpG0cYOatSHRgUWOC7YlwJSfsgwCoJYAIwY8E78AIpBYY+as0OPl4PzqRjgKxZgCxO0qfv4Vsg8Y5ABEiKqsuOPkx1x1OSDtG3cxLZHcHKnoo4F0SVP+ZPkV+jfTrdvW97va5+fyV5Xcqq/uqbitl0s3fS+/W2qsaaxaBIMm3vWCkoSFsRGBwd3CAFRkE8kAYJODw82vhxSG8i+kyN33LHAyw2j+LHbA5PIwMHFZsYXk424UbM4OW+UgncASCMgbQcn7w3YyPh1C5IDYJPHHK8YIU7GJOSu3I64c8bR5bO8IN/4I625Xe+uunbo++vO4zcre2rJN2uqsr2dlda9dL2av1vqaTQeHwN0cN6QHw26Gyx5QAyUbAO5NoGQRgE5ySKl+zeHXUF4r5RkuieXZYxn5FQ/KWDZBJABUnIGQSMtQCGPI4O3IA+UgAbeM4zkLkHaOGJ4yueVb5TlVBXlRjIUEqAwAUMSM8gkDGOapSVtYQ000iujjqtdX0V7p7LzmUZ7e3rrbX2kuiT9F1SurpNJl8roC+eRDehombGFs2LxoAWI+VeoVWfoDnccEDKqmht8yLfEOpO0RWsgRdxB37WyilRuEnO1ThgxDk5xALg/MSqBQc7T1Vhu4ZCrhtoU5yR1IIAp28kjRsfM3CNHV45YgSjqWYpGY2DCFQDznarHa67HNQ52aXIteZtKKbsuVX33t5X9GmXGm3Fy9tVfK4vWrJvWyst3q1e9nq30szcii0uWEsYbhSGI2+bByiFdpfCAbZRk7wCSSBxgZS1tdNaaRLhJY1RwEMPlTYUlNqlXAO8qu7eqkKF4UMGVUj/AHkSscooCkgnDBVHKkKMZQdD1xkHjBD4kSRVdcOCp2MCQVJOG+4Bt5ONoBznIznjVWXLflbs7pxiua3Lq9E3u3ot1rZGLlNOa5qsVzJR/eOyejVnff1vddmtJmuUiX7Lbq0UEpVRg+ZLMQWQfaZFILDKq4t0xGD8ww4UGZNqoC21URRuZxgBlyNzSHcoXBIHUkEYO35hWaRYbfzrh0iVTlkBV2baVC+UHXLSMpOWTADnawJGRVt4ZtSbzboG3sFIaO15QzAEENMVBGGwuwKCScBVK7mWlNqSStKT0Sd0oq6+LolrdLz23IdJOLc3yQi/fk25Ocvd5VFXtNva93Hq7aFhJJtS3R2uYLPJWW6AIkuCCAVg2hjtcD7xGDx04B6WwtIbazWQKsNuudqr/rrllAB8tdp3EA7ZLggrGWwNxJV4YVsraFZZCJJB/qbJVKRoihGVrhyifuAV2CFcu/ILKwy0klzJcyeZNtDiIKPlARApG1I0DqqKAQAFA3LlhhjXTSjGPvStOo9E9UlezXRpWadkt3e+u/n4iq6toQi6dCL2atzWUUm9Pek1q5NWVrRTvcnmuDOVVcQwIQIrePLRpuZoxvXeHaQlV3uxJJAIbACo6CRwRGcEg7Tu6O2EHLnchyQCGODtXa2GCkwxMC4OCpVVUZ2/eDKMjcScEkLljk87sNjOlDuDAYJBXAYgcZ2hhlgpCscjHJJ5JBAB6IRcrNu/bTf4bKzdk10tpFbdEuCpOEI8rjdpXspabRers23rZvdaO+pctUY/MWkJcYaMkmPJKqPL2qGUDaCeM7jk55A3raMqqrtJdRnPsNnIJ5A5BAJByCejYrMhV+OCeRkc84wMnGDxyCcHsD1JrpLGNnUALtLBcg5LLynBUcBjnk84BAwa9GjC6SXZO7d9bpvytbo+tne12eDjK3LBy6vS1rt+8raK70abTXk9tS7aRkSo4wFYBCTglc7dhJPzZGOc/N1ALcCuusINzYJxvAwAcFcbTuG3GDkEnPoCvJNUbK0UrtZORjbwMqRtYHgA5HOAR9088811+mWZYISCSxXnd3O1TwRuB77Scr97vx7OGp+9a1uZLotfh1te77NvXVaaHxmaYuKi9bcu93Zd091ay0W2nTv0ekWWJInYExAqrFRgoxdcNhyflwAxYgbGIbLAivdvDOjtI8HCuCFwpyVO7gEbdgJDKduCQBkEZBzwOgacd6DaAOQw4IIILFWwM5xjOScAckcY+mvAXh9pZoIljPlqRtY4+VSzFlyzMe4AKhlXIBYHGPtslwXtatNcvNdxVrX1bitU9NV626XufiHGOdfVsNXqOai4xku11eN9NHfprvf1R91/sOfs+T/G/wCNHgfwRJBKdAa8GueMrmMFUtfCeivHdaqGZPlSTUWMGi2zNkfadRtyD8r1/oU/s3+BLXwf4Ht7/wCyRWUuqwwyxWyRpElnptpEsGmWcK4XZBb2aoUjAUx+Yy4BAFfzv/8ABGj9lNtP8M2vjfW9PKav8S5Le/3zRfvrH4f6LKW0y35w0I8RagZL+ZVIEtp/ZM4XEJB/pS+K3jW0+G3w+1PVFC+da2a2+n2y/K1zdzILe0to0GWLSzNGoCKSFJJGFJrzvEjG1a88q4Qy686+LqUZYiEG0m5SjCjTdr2Tn77T1Spp7M+J8AcLl7zTjjxw4mlClw/wTgcwwOTYmsk4zxVKh7fNsbRckrunSUMHTcXao6tSMfeikflV/wAFKP2nbP4Z+E/GfiWC6if/AIQaxbTPDtuXBS++IGvRPb6REqgkTHSYTJqUyqGMUcMoYYyK/i08M+GvEPx0+Leg+Dba6uJ9U8Za9I+s6rJuuJLPTy8uq+JvEF05IaQadpsV7fzc5k8lkAJcK36X/wDBVT4+3Pin4g2nwmtNTa6t/A8lxrfiuRJA0d9478QRJLeLKVOxl0PTWhsVGSIJ5r+N1DZFdV/wSV+AOnXtx4m/aA8dQrbeH7e01JLS8vUC29r4H8LOl/4s1MmUAY8Qa7baZ4cgYEedpmn+K0ThWB/UssyvD5HlWBymm17LBYaFTFOO9Wdo1JWvvOrVlJQi9faVFBdD+dFnuY55U4s8WM1TjnvG2Y1JZNSrXbwuDqP2OUYaKf8Ay6w+FUa83G0ZU6bbXNe/sP7ePj/S/wBmj9lrwV+z14SiGh698RdP0vU/EGnQuBd6L4D0e3is/Cnhy78v98JWhiin1HzAGlvv7RlfLXRYfip8EvAt78RfHGi6HCjMt3eR/bJQMmG1Q+bdzucnG2NW5IyCejA4Pon7Zfx11T9or4/+NvG9zNK+nXWsT2GgWrSO8djollIbTS7ZEJ+UJZxRblUkGaSR85JB+0f2H/hSNH8N33jy+tgt5rP/ABLtJaUf6u0jYfabhGYcCVv3e8YyAQOpFTQw9TNs0p0JxTjSm6uJcW3BTcoyqpP+SHu0Ka1/dwj2s/7A8AOAv7GyPARxEJPE5hbM8xqVItVPZNRnThVbTl7SUbOo+tarUlpza/YENgmg+HdP0TQYTHdXkdn4c8P2sSDcA223M6KgBDKu+UsM4k2liC/P7UfAb4eWfwx+GvhvwzFCEuY7OG61KTChptQuEDzsxwCxRj5a5ydqrz3r85/2bvAy/EL4wrqkkIm8O/D6L90GAaCXVG2FjjGCVmAjJGV/cyEEkA1+uqAAAAZUYBAyduFHQctzgcDPIPYmq4yx0Jyo5fRdqcEnNJ6csbRgmltezla10uVo/EvHLjCXFnHmJw+Hqc2VcNxlluEitaU8VeMsXWUVzRaT5aSa05Ytap6yyPk7QVHQDPfHJ9CeOSAMEccHrnXMw4AI+UZBGSPTIJ4O0bvXHGfm625GGwHgnBBI45Gck+nJ+g4wfmzXP30xC4Ug8EH2GMnByMHjA4I44wCSfiKNNylFKOjeu+j09fx09en4VmOJ5KcveTlZW01asne/XZa6va7My+ucAu2Qpyd3bAyDyDnOerHIxgnP3h+GH/BTr9oFLK1XwHp14FYh5bxY5SV4Hyoyg4wOpDDsCOpNfrj8YPHdn4D8Ga3r17MkSWdlNMuWGSyxkqBnaCSSBweSQAAAcfxy/tYfGC88deNPEOsXN2ZRd31yY1L7ikKs20bcrjC8gHGR14PH12DUMBgauOkkqk4yoYe+/RznHs0mo6b3bukcvAWQy4p4sw0Jxc8HlsoYrExXwyq80fYU30bunNp6Wiup8W/EHxHJeXlwxcEtI7HLMeMsSPlA4yBnr3+7XzV4n1cQpKQ2c7iAzcglSVPOT3HcHBHNd54n1QvLK5fAG4gnnncQRt4HcFVAII5xjGfnnxHfNdTlFfKqcMOMA7gPlGQOMjGc7SWVTnp+cZri3Oc7t3k3fq1e129b6u6fZra9j/SvgfJYU6VBunG0Ix6WWnKrJdum9tDmZrh5JHkYgMxJ3EAkZIAOTnJbHXqx6YxiqLs8rhEGc5BxncWYgYB5POWzgenHUCdY5Lhgka9CRvYhTyw6lgMghexDE8AkksdS2toLYbmw02BuYhcKxAxgYPGQR78/7Ofn7OT/AM9Wtl0SWrflrp5n7FDHLC0+SnbRJcsNJaKF7qy0TXXom2N0/T1iYTShWl5KqSpAGCTknGCMArwemeT17SxkAYPnAGeBkk45yQSAuAQFBJ6sST0rkluUBLluQ2fbrk5JxnJzjO4jr1wCybXEiHyHOBk8dx0w2duCR0xk/eA3ZFbwlCCTblpZavVLRX7q72/K55GNeIx0nfXmUbdErWenS23N113sj1JNZW0TIZSBkEE9TjoQMEAEEZBzuxg8YOTd+MY4w4MgOASApBAyoGFU4GSBzjcMAkbeh8kvdfnnVkVtoGMH+I/N2J4688Lg4HGemIZ5pnyWYlgTnLYAGQc4yfRiABuOM85NTUxknaML6dO9urtu9bvfXfXU58Fw5CT9pWV5PZWvo7Pe91ra2/R9D0S+8YTSEmOTGcjBLfNzkEZ4LNjDYGRuyxDfKOUutcu7hj80jHJ7t0z3HLe2MnnjbtJrGEbEAs5PRgBg8ZGVOQT2985PXqHoAh4IKhs59NuMgjoTwOmCF49BXM5VJPVrXVb635VZpW1veydl26N/WYPIYq3LRhDb4kk9baNdU99bOxN51zIWbeVDD5jnIwcZ6HAA6+h4A4zTlXpuk3HHBzuBPB67unoSCDgkcjIgMhJ4HAwCcEdvlC56YJ/hGeScbjSqzOQwyQML0PzZwATnd6cEgcj0GapJWu7t3Wt2lpbok+ur1u1pp1+hw2UUqduaN2krppJJ2Wmt0rW3d7b3TSLa4yclV/u5Gc8g5JOD/F2yQM8EkUjSjJxzkgZ6/dKjjPpkDBGRjHJ20iQSsQSMYOcEk46Y4JJ6A59T3Jq0II4QTK4UjnllySNoJ55OO4B6Zx0BPSkuVSVlotko6+7fl6v7tNX019SFClSirKKilZp8sXdONnfXXXR3117FdfMfgdMjAwAWzgjBHTkkEkdRjrgGytq78MNo4G5sgj7uAc5IAGM8EcZJHWq7X8acQx7mGPm4wQuMZPU9QOcYGMc8CJri7nU4BjBOWK8HHBBJ5HGCB0H0HIV0tNXqr287XvZ7b2vZ/ilEsXh6em7TXwtJPSNtu1+lttb6s0SltBzI4zgdCCR0GMdcgYIB+XvnriBtTRBttotw+7nH8PcA8HI+UgHGQcdTiooLB5CC4J3cgkkk89xgscDhuhHGQOa2rfSHc58snHAHZuw3Z5Y9MYHy5I3YJNaxhUnpFdU3re+1mk2032d+/Znn1825U0pRhs7p66aO/X7tPltgA3l0dpYqjdlGOcjPA5JyOmQfTGKvwaW2AWGcE4B3Fsc8gEkHoF6AZPQgAHsrPw/MxKvHs4yAFJbJJUEEdATuzg8Y64GK7XS/CFxOypFazSuMKCUfGTz8ygk8gd2/u4yV57aWFnJq+t+i16x1tq7b9+ndnjYjPqFNN1K65d3eXu6W7tfJ263s0ea2ukM20JFuzg5AJB4GGYAEgYycgAYA5HUdTYeHZH2llxkg42kjJAKgkruPOcYBwDg/MK+r/ht+zL8SfiLf22n+F/CeravPOyxrFY2U8gG8nBeREKRgE5YuwZVyTjJI/XP4D/8ABGrx94hWz1T4navY+DbCTy5XsI0+36ttIVvLMKsLeFiOGMjMyvkEAjFe9gsgxuL/AIVCfJonUnanC3u3V5Jp/LzSW5+YcUeMvCXDUJf2hm2HpTWqoQqxq4iTiopqNKnzTeqa+Gy2bPwd0fwTeXzLHaWE08hG3CxOxIJOeSM9Rxn7owWB3Yr69+EX7E3xp+K09unhjwVrNzBK0YN2LKWG1QMOS908SwKgB3M27OFPyjINf1S/B/8A4Jyfs1/CaK1uR4THi7VrcIW1LxIwuYzIoVvkslCWygOCQrLIeu7cev034p8efCn4OaRu1rW/C/g3TrSI+VZiS0tGVI14SKxhQzyt2jVYWAOMnPNfVYXhbDU0ni8RdJpuMPdjayTUqknv/wBu22Teh/OvEH0ocbjazwfCGRYnGV6klGlVxMZS5pPls44eip1J33s3B9HqfhR8FP8AgjPrUhstR+KniSy0a3HlvJpunoL/AFB0+X9200gFvGxC4JAbDDccnmv1g+Gf7HX7N/wJ09dQg8MaPLcafF5s2v8Aic2r+WI1BaVmuiltCFwzA4GCvUDlvkb44f8ABU7wb4YjvLH4Y6eNWutksSa/rfk2OmRvyBLBDPJbS3HOGV2c7hkPbspOPxa+OX7cXjr4q3NyfFXjrX9bt9ztHo2jyppWgw5+7GF3/Z2AAILpZkuMkSAfLXtUqGWYNqGGw8HJ2XtFHmtJWS5qku76RSW+6dziyjhjxw8U68J51jsTkWUVrOVJQlh5ck3G6VCnKE2raJYitF36S1P6IPi3/wAFCv2ePhDHLpmj6tB4r1W33Qx6Z4SiiOnpLGCojk1TZHZfKw2lLRrnA27I24z+Xvxg/wCCpHxe8YfarDwutr8OPD8gkVbqKWKHU5IG3YIv72KW6Mjgbs2unRYYsVyACfxU1H4o6lePJ9gii08NnMsRkur5h6/brndKoyWJ2MkYJOxQMmuetP8AhIfFmowWGm2mqa3qt7IsNvY2NtcarqN1NI+FhgggjmdpHfO2KJGkbAxnv7WHwtXF8sKeHq4iT0Uaamoq7TtaOr0vq21vpbQ/pvw++jbwLkMsPi81wFXiPNOaE3VzCbrUvarlbccNBKk0pbKXtJp2Sm7M+nvGv7QGqeILy5u7/XDqt/MXeXUtUn1DXrx3YnMjNeGKytgSwdIYrV5PmIZlDFq+ede8dXOqO8k9xe6iwLFWvZfItlyc4S3jOyNf9kbRtBwQen3D8F/+CXn7VvxgnspL3wjD8N9JuxHNFc+PGubPU3t3LHzbPwfpltqPiu6LKflkOkJbtls3ESq239LdA/4JUfsnfs76RF4u/au+MlneNaxieTTNa8S6J8P9Gn2qZHgTR9M1HxF461AsSipara6JM6l0lFvKGhPr0cphScaeMrYfCTly+zwlGPt8ZV0XNGNGk5SUnZ/xHBbXerP7G4a8J8yrUaMsDkeEyPLlGKWMzCNPL8LCmkkpR9tyynGKSacKctL9nf8AnL0u28Z+LtTttF8LaTqWqaleSLBaab4e0u5v7y4lc7FiijtY5LiaQthdqclsA/N8tffXwe/4JU/tS/FS5s7nxHpNn8N7K5EU7f8ACXzXU/iQQSYIkj8H6JHqXiJXZQXjGo2mmwdZHuI1K5/RvxH/AMFJv2Iv2cdPuPDf7LvwStvFWoW8bW6apoukS+CPD11JHlVm1DxJfXNx498QwF2LNFcX9nYSKELWSuu4/mz8Zf8AgqD+2F8XI73R9F8X23wh8HzvIB4b+GFjDoO6GU5kW71aFBqV3JICFklefzJOGcsqg17tLJ8HCKmsHOpJfC8XVUnJOSipQwuEc0p02ruliMVShK9oys5W/VMBwj4f5JGEs8zjE8SYqnZvL8ipqlgudcvu1MbPlc4KV4t0lB21Wp+k+gf8E8/2Jv2YbGDxJ+1F8W9Iv760UTzaR4n8Xaf4fiuGjVWKW/gTwVqGt+KtSJPyrDca/ppdiI5oYj5pE3iX/grB+yN8DdJl8Kfst/ApfE728bwR6hJo9t8PfB0zqnl+dcWlmW8ReIIWwGP9v3WovKhKOYxI5r+di9g1nxFfTat4h1TVdd1S6d559S1i9vNSvZ5HIJeW4u5JZWLHDEFuAR8xwwrptB8LS39xBZ2lrPe3txIqQWdrC91czyN8oWGCFGkkkbdtVVRm54DZGfosFkeOzKXs44erOldKFCkqmGoaK0ZKjhqnNzKGklUr1YylJtp3svfocWPB/wCy8IcNZVw/Bvkp16VB43NJJuKTlia8ptydrtKLSeivbT7c+M//AAU7/bA+M0N3pcPjdPhj4TuvNQeGfhlZp4cgNu+QY7jVLcHVLokZWRmul8wEcBF2j889VsdV8QXs+p6vd3+q3905muL7Urq5vbyeZjnfcXN1JLNKxPJDuzddxwAa/Qb4d/sNfGfxqtvcXehWvgnTLjBF94yuH0y5aNlVg8Og2tve6/I5ABXOlojMcGVVANfqF+zr/wAEcb7xpfWcs/hzxt8UZHaPcUtH8D+BkJILCa8Ms2r3sIx1/tLR2dRzAFNelmOQZdlWEnXz3NMvyXBU1z1PrGIoYLDwkkrtwvClGpy/zqMpJpatxv3f6l8bcSKWYZ7iKuCwHK5VMy4jxv8AZ2BpQunzU1ipQvFXVlQpS2sle5/N5/wqDWdX8M634ugfQrLQ/D7Qxarda34l0HSJhJMYmC6bpV9exaxrcyLKsrxaLp9/IkYzIqBgTwPhv4f+GNf1630XWPFUeg2t2NRlPiW50PWdT0SxhsbYzKl1Y6RazazNLfzoLKzCW62/mTxvdzQxpKR/cv8AtBf8EXvDXw+/Zd+JXxI1j4f+GYNT+GHwy8W67oHg/wCH9lZxanLdRC21LUf7b1y5tr7Vb+1fS7O8t7ie1vo9Stommlt76Nm3L/Hrb+KIPD3xK8MeLYvCWhahonhLxNo/iGx8DXWn/wBreH9V0+x1KG8m8O6raTXFsurWd3ZF7G5jvHW3dsbyxGw/k2IxfBmfRxWK4YzGhm+DwmKjgcRWpRc1GvKlSlKcPejCdNc6dOdpRk00pTSuvxziTKsvy7Na+XYbOMuzjBp0o081ylyeGlKpGKr04yrR5pzoT5rzVNRmuSUbqR53q3h/4J/8It4of4d+G/F2qaXocz3HxH+IfxE0ez0/UPBXht76wsdItPCugaS9xpdrrHivUoWt9Ol1i71C+je+Frp0bAXtynyn4z0Gw8OX1jZwXTPfRWkH9swEyyR6fqcyJeHSo3khgM0uk2E9lbag+zH9oG4CbQi7v2n+KXwcsNW0HxV8SvBes/BrwV8J9V/t7476P4ft9Ss9J0E694lv4rLw/wCDPE9xdTahdeIdW+FllfnVbnQtAtr2PwdBqsllND5uoWS3/wCLvxJ16y17xC66bcPqFhpcctnFrFxaxWd74kvJbmS61PxNe26MPJn1i9uHuIYmBkt7IWtvIN8DAfGcW5VDAYZVKjw0a75KdJUpU4ScVafMqMfegrNc058zcm/eaat8RjOHMdkOPxeDxNZYii+avh6qqSxHtqU2nCqqjlKNpRV1CMYQgrRjBWbnl6Xd7mhPRojjOMksVGQ38QJIJ6A7SOOWI/YuL9qjTPib+wHD8E/Fd403jL4U+MPDbeECxjkkv/BFz/azNBMXZ5Gk0K+ufspGABps9nEuFtiD+KltL9nlBDBoy2CCeAAy4zxgMOTzwDgqcYA7qz1ie0iPlzyIkgAaNGO0hmD7HIKowJGRg/eHGAWB8jhriaeSSxVOcfa0MZhquHqxutHUg4Rm+l1d3tum1ort75JxVi+GpZlQptyw2cZdicrxlFv3alLEQUYy0bSlSqKM4ve6s9G0fr/+wVrum+CvgZ+3d8VtXKLYaL8Dk8IqzOkbXMvjPxFaQX+lRucFpdZtIl0iIH5VbVIzKQEIb8hLS31L4i+Pbq51SaYf2xrt9r3ifUoUYi0tr3UBPfzlwHxI89wtrYxkMsl9Na26hmuEC+36V8bbvwv+zr8Tfg/YpNEfir4w8EaprN6r4jPh7wZFquqnTSGBHn3+uXWk3pkikCMNNWOQDMbDR+AvgafVk04aNA2o6zqepx6pfWEdsLmS5s7O/tdJ8JaIjEFop9b8VX8c6WxwLx7TTZoSZIkKedi4RzTFYDD0uV0adN4jEyumpPncuV63aUEnNacsbvuj8cyvKP7NzzjfPsbKKw+Z47C4yMrx9zLMqyfB0lCUrq18UsZJtvablr1/pW/4J9TW/wCyV/wTX/a9/ba8QW66Z4p8b6ddfD74axygo8FroqJ4e0m3053Idoh4u1mSyCRBUEHhGJ9gWILX4+/sz6kPhj8MPG/x11gxnU9Cs/EfxUjmvCfNutU8CvZeH/hrGTlZJV1X43+OvDk7xAFbqPw5cOCRaS7f1p/4LN3cX7P37Kv7Gv7AXhST/iZQeH9D8S+OLKzb5r/VLKJYjJOkYDSHVvGOo65qKqyl5ZI4HPQY/H39piKTwh8Gfh/8FdCPm6p8RvFej+HwtuVYXfhT4NyXFvqlzGVw0uneKPjP4w8RNH8oWefwFFJgtFGV6qcko4jHQ5pKUajoe7dc1VqnQdm7axjTn2Xtno72PwThSVXMMp434xxSccV4gcRVOG8scv4iyWlOo8UoSi1yewyqhjYXVopqm7rRrmf2fvA2sf8ACoNO0qyE0njL40a/o3hqwmYsbufVviLq11pD3hkJEkj2ng3TvED3DN+8jj8WNdMAkiSD+2r/AIJyfDLSvDPg3xP4u0+3WLSFbRPhd4IOxFCeDfhhpkWhrLBgYEepa0mo3U7R4WaaHzJCZAxH8xn7NngaQ/FrwtaafbtdWfwQ8CX3iiyhjiDJd+N/EQsPhn4At9m4h5mns59fsCQv7q/8+L93tNf2hfCHwNa/Cj4S+B/AtsgX/hHfDen2l66gAzak1sJ9UnfglnuNQmuZ3ZsktIC3UmjF2wmUQw9N/vMXOnhn7uvs6DVSq4vf3qslCVt0uW10fgHjHnLqY6lgYzSp0vaYurGL+F1HD2UZK9ko0KdKVNa2VWWyZ4n+2l8cbL4D/AX4i/EK5niiu9H0Se20ON3Cm41/Ux9i0uBQSC7LczpIwAysauzYCM1f53/xw8dX3iXXNQu727e5v9Tvbm+vZncPJPPdzyTTyO7ZZjJNIWZiBuIOOAK/pk/4LvftLxreeE/gFo+oL5WlRN428Xxwy5BvLpZLfQLG4AY5aK2a5vPLb/nrbvg54/kv1C6l1nVpZySwllZIjkgou4gkr3GDt4yAAT0wB5mNkqNHDYGDXNFKtWt1qVVFxg/8MLNJ/DKcktbn330ZOCZ4iGJ4nxFKXtM0xEKWC5ldrB4ebhTkk1de1rOpO/wypqm72StoeH7Pzp/PZCNhATIG05HzNgjbwMnOfpk9f3P/AOCZn7Ny3t3L8bfEunEQ2xk07wXHcxja7ZMd7q8aspGFG62glAwuLgrn5DX5c/s9fB/Vfi38R/C/w/0iOQnU71H1S5jQstjpEDCXUb2UgHASIMke84aZkTlmFf0O/tG/Fnw5+x9+zzbaJ4WW2tPE2o6MvhXwDp6FPMtRDarBea7JGGDNFYRN53mFcT3s8Kk5LNX7N4b5Jh8BhK/E2Ze5QwMZPDymtHWjHmqVI3bu6MbRhazdScGrtH+t/hlw9hMswlTiDMoxhg8pp+0g5RuqmJjGMm0mlzcnu8q1vUlDW+h+ef8AwU7/AGoF8S+IB8DfBuoo3h3whcbvFVzayfudV8Sp/wAuTPG22S30dWZGUMV+2tJwTCuPym8A+GRr2o3GqalKtnomjJ9s1XUJl3RQQhyAipj99czPmK2tl+aR2UBWJxVSWDWPGXiExrJLfapq988slxNI0jzXFxK0k1xcyMSSu93lnmkIVAdzEBMV13izxJonhDwrL9nKT+HPD85t7FAQD488ZvujaZwGR5dJ0t1kaH5iBbxSSBWnnTHxHEOcVuJs4xGY4huOEouSw8HzctLD07OMbd7WlO1uao3ZN2R+aceZ/juJ82r8tWUZ4qco07Nv6pgqdlFJLRT5LqDtrNuVtJI4z40ePNY106H8O/BmnXk2u66YtI0HQtPV7i8sbPWLtEit3WJCbjxF4muHSS8uOWEPkxEpZ20ES9hr2paf+zn8MdI8CeGb63n8a+JIdSa41nTmG6e5vIbzQPFfj6G4Tc7WIs5dS+G/wpld1f8AsOLxv8QbVUl8YeHriCv8FvD1p4H8PeJ/2hPiktzNf6jpon022Er2eonSfEv27TLPS9JuI2W407xT8T47fVNJ8PX8A8/wp8OtM8a+O7OCW6Tw0bvtf2TPgzqX7Unxp1v4mfEq+sdB+G/geObxp8RfE9zGlh4c8O+HtBtDJHp+nxhfs1jpuiaRp6WGjaZbIYrPT7G1s7OCRktIW4sLhcXmmYYXL8HGcMVjIq8pWSy7LYWdSpLpCXKpVKstLSUYxknTSPFyzI6ucY/D8G5VB06V6M+IMQrWhQtDE08tnOTsnKKWNzac3Llo+xw83zVKqX2x+xf8OJf2bfhVbfH6+0CDXPj58Wr4/Dz9mPwRfQhnfxFfwr9s8X3sM2Fh0PwhYzjWtav5VFrFJHZ6fNLCLuVq+Nf2o/jxZ3tppv7OXw28Qy674A8G+JtR8VfETx0JpTefHj466pIyeMPifrdxuE1/o+nXLz6B8P7G4LLaaLHNqQjGoa3etXp37Xv7Ud5DcX3iXQ7efwxrfjXwcPA3wa8MfNbXnwa/ZzkJRruS2DA2Xjr4z7P7Z1qQFLyx0S7SxEzxXMaW353fCDwzrHjnxXpGk6TZNfarquo2em6VaxKHafUbuZY7VWDjaYLYMbm5lfARU3klSWr1OJcfh6NfBcL5O5Olh6VOkopNVG6jXPVqLS9fFN+0knZwg6cNJc8SOM6GEz3PckybAQVXIuGKi/svC8l/r+bTSp1c3xMd5zgnyYKDVqUJyk0qkaco/Snw88N+Mta09dItPDmo6lNP4h8PnT9Q0pdTk8QJd2drJdPpWkjTorltRM6KpltZA8emqIw22JnZuzj1fxt8QdR1HRb/AMT6zeaxqXjbxP8AFDQNNvHhihsNUstPxrls8tvJpyv4k1mfSo4ZpZJfsU9zbym0s7Y3Er3n67fCT4feA/2X/gV4u+OFzf6Xquv+FNB1Hw/8M1e9mgfU9a1GX+zrjxdA9usDXUniXxjGln4fUBZIPDPhfxRNHJNam9uJPl34wfAR/gzqPwV1g2cL6refDrwV4k1C6CSBpfEOoMuv6nI5csZJr28v51nI2xzMArKysaxxmVfUaeXRljK06mIcljMO/goJ8sITUlZ+0a1d/dbhKMr2ufKcaZjhuFK+V4ariaeKzbNsJmssNhHG6hTy6lGcoSfNyvnqSUUrNxbTTTUbfnd40+DGraT4T8F/F1I3k8NfEK/16xZ4bC+tdP03xDoV1b2+p29tNcL5VzY3jSmewmhbHmRX1k224027ih+4f2K/iL4Q8D+IPDnh3xvoy33hXVPGmlX2v6xbHyNY0/Rb/Tr3QNe0+LUAxnbRdStNT83VdOj2RXq2q+aRtUv/AECfH39l34d/tUfsLeCfFfwv0DRdAi1vww6aVpWjwRWOk+HfHb3Mer2t0tlbhbTT57/xHp9/4d1W4SKPzLHXrOWQNFbRrF/LP4XivNC1SXTb+Cazv9Nvp9PvrSddk9rdWkxgureaJlEiSwTI8ckbglCoBAKnHZgsLhssxNDG4GUpQU5YbFxqRjFwxVBqGIi7N25vdqws7qM10Sb/AICq+IGN8WeGeK8lx1KtkmY0cTjqdCjh8RNYvDYHEzqvLMTCrD2cvb4dJ0JzikvbUJSkrs/0h/2AvhL8Bvhn4ROj/Dj4c+BvDWp6fHEza3o+i2Q1nVLK/ijuLa6uNdlil1W9jljCD57x4N0QMMaLtFeV/wDBTb9nC0+L/wAMPGOiW1pC174n0s3OjTGNVFl4w0PfqGg3KuwIj+3SRNpl1KRuNpdSxkkOMfDH/BIb9qB/GXw28EjVtRabV/BEkfw38Vb5N0stiE+0eDNUn3NuYSWIfTPMdSxlsJnbIYV/QF8UPDUHjbwRqFrGiTXLWYurNzgslzFGZYyjY+Ullw2ByGYdCc/jWezxHCHiPhs2nVqVMvzRxcpTnKUFRryjGtT1bSVObVVQjpGPKkrHk8Gxx3jH9G/ibgPHP2niV4T5vVq4fFVL1Mfiszyabx+T5i51OatUeZ4Pnwcq85OVWXtJOT0P8uv4weBZdJvdRtprWW1uIJriG4gePZJBdRSPDPbyIQGV45o2jdWwysrAhQAK+IfEujCKZ02/KSxDMNpxuXapJO4ns2BgkAAHv/R//wAFRvgCfh98aNc1my04W+hePopvFNjtjASHVXlkt/E1gCERRJHqqm+8oLlIr+AYVcV+DvjjQDDNKVQty2TwoVsr8oB9+CoPHJByK+74hwEFJVqUU6daEalOSSs4zSa2drK63Sex7vgzxy8+yLK8ZOoo1qtGMcRSc/eoYmk1DEUZa3U6dWMotdHF9Vc+QNY0/aZFVSCOzcqcAZA3gYVj0IBB46nFcFfW7OCAAMADOMnIKjqQCoOOcg8DghuK9z13T0Jfj7uRkjIHYclunTGBjBC5z08n1OzJMikkZOCVJyQccguActnnbjIyDlsZ/PcTQ5FJWafS26tZrW99e+ll6n9c5HmCq06d56Nxu7yS+z118vuvZaN+b3dsvzk7VTksCSFVXIAO8YAXJBHGARzyRnBuLUOJAvOeUZSxIIIKsMYVsdFO/k9NoyK7S8tmycqrfJhs5YYAUYYHcx3EKRk8AsTkiudnjGSoGFGQOqgYywAzgDIwOMg4wCCFz4VaFpWXX77vlWr0V1denqfd4Wu3azW6aV+rtdKz+LZNOySb2OXeBeduVO0huGKMoKY/i5YEYJ7dA2eTSdSGYkYOQRgnhQUG4cBwWzg8MONpxnB3JYgzYwA2Cc8bcgrxliMjP3gRuOB0YDOVMG2NtXDDIRm+bJHfkqQSAAM7VwR/FXDNNJvva2zS+Hv6+mr1e57VKqnba9tWk7rm5Wlrvpa+6Td7u1iiVQ4zkLyuApyGO0EjYFydx3HAzkEgZqtnHHAGNxywK8Bfm3Dcd2Bj7oUNlPlXpcdRuUNkZXGApyCSBnlcjOQcE7hg5IyMVmAwQflwQmcAcHaARkFmJK9R1BAIORXPJLRrRW63sneNru3fey66X6d8JX0s7OzXVvRLRa+d9UtNrK6oEqzKyvvQqAibs7CCu5mAVSGXawJzkYGCVOAApgEkBVBx0yAdvHILEE+pwDlmKtnFkoSMADBI3DGMkkc54VVO7jCgZyOoxVRhgfMdzKCVG8g87cYOOcfiCcn5c1g4yXW8lbVXs3Za6Lbfa6VtHZKR2U5r4rbW01el1bW+nW0knrbfSzHGURjjcMBipBKghWBBCkn0+UgknJDZXMTRqAcAL5h3Y+ZsElSMbsgMByBjjAxnJBnIOQOvRiCCduNpwRn6EHJ6gpkHmI/MeDhSNpGNg3Ng4XOQCe2FH+yTjAwsutrq1u1tNe+q7Ns6oO+u7snZW3STu7JW7LTfy3rSbWUoyrINuFUZAUbV2E7ckYwGGcjLYwMkUxioI3ptBAcE5BXH3QxyzI4UqMAEfLk4OCJ/JUZX7vQ5APLAKBkEhQDz6AgDgEU1spwcuTwRnjB25J46+vzblyDjHInqkmt11vZK2re3VW189djaMtEpNN6d0ndR3ei/FtN3aeqIkMbfMoPzZAzxzjJzwCeScE9eB14LcleAcqRtJO4hW+XCkDO1sA9egIIzuqXgqOgGDwDhlOAB0GVwOQMn+8pGeKpCozgKQC/Q7mXdlTkoccbyRkAkDPQgExN/Cut10dnyuO/ztZ6Le71Gruzv16qy3Wt32eurttrtZ7MSr9SQDyxAKkBTgqBjHY8Kp4PHUwnZvUlig8sEEsMEll+ViBu3qM4BGM4HX5hJuRgWBIYEMo5DAqQeQFHy4PykluMB+SaawZtrcdCuNucJtUncD8wOAcDkx5wAQcibJpvTRq1n5+rSd9XrpZa3vala+jXTRaW2et29t2r3ffe0YYgkYLHOw5Jcp8yLhgDlhnH9xs5AwRTXHyBgwB2lVY/KrZwANuCC43AckEBQASQafJHuV2fKqCPLzkgjKElsAFgTnA5BGTt4xUPlhVxKpJIGBuJCZ2ZCqrBSo4LcgHPQE8l9LOydo67N25X0s9XtdK23kUnte9rK2mn2dej0fddbeRCwWLJXJVn2kMCcg7cHbtAIABAJHB4AI5WRnx8xwVBEY2AfdypGcDGQMlgxGVOADtAKFI0ZcqGZlQDEv3hmPLHDfdztAUgEEAA8sKfHGpB35IAI+fhMDYQw+VclWAzkAKRuzurJWe1tPkltdp6pa79Nr73bST0b02Vm7LRW2k0tld/n1cYwzqgH3QCcYxgBCScDChgCA2WyMDqeGtsdgp6BQwOev3CAC3zENsIPC7yFHynYGmISILsO59rNuLAgAgHleMlPu7QANp3EA9GsyMuMqChyrKBtLBVIwVIYksegOGZsH5j8tOKtbaTtdN2btbezd3bfTTpoaaNKzXNdaPZrT/Cl2k3e+/mSQtEwfeD0AYMeqsFBcA7iOpxuAKYO4bW4RlB2sjYIYBSQxxt2/wBxcDjAKkqQcDB3Gmgucum3J+d/kKkRkENkkjJ3LjeACNxBBHJVBukOPlR9rbSDtLKyrwMkKARnOcBTgNlAtK60VtrddFt1b1tpa3ppdGi96yaSTsk76Je5Zp812lfprtva7sxD5gAPlcZUkE7SQoBG4ktux7AnoARgxSANOAT8wwVPzZAcqRkBR8xJwf4tuRy2Kl4Octny+rDIKqCpYbjuIIwSWAAUDdgEq1VkVVViFIPmGQl2dmB4yp2sSeT8nykqoBB3HmJ/DZW1u7tJJK1+2vr8tdhy922qadnrboo2SVvTls27qybSuRixvQADqcxRsFisUeecc8sMNgDGPmGARkHIVNMusqDqV0ATkfKisQCCCNxACjJYhThQd33q0m1Fo1Vlt7M/MikCy3liWHPB+ZUwCCDkHJA4xVo3zyIUMFkuRjclsnB+XaNzSYGSAWwAOWwwLZri9nRad3NtWbvKb25bJa20s1a1lsuiPg/b4q0W1SUZbPkprRcq1XJuuy1avzWvZY4sbsnA1C8bGWDBY1DABBuG8Bio43YAPy5BDcU97GZ0Tfqd0mwBgcJzhRgDGG3E8jcSCByMncdeO9mRRiCybJK4a0iyAoCBslsgDby2fmJ5DGpVvmBYfZrBlYEAizQfMcAKAGPAGPmBxnLAsp5PZU2rXmvO89nZdJNO9u2lm92mZzr4m+kadltaNO+670+qvbR2T2Rjrp1yVGNWuCu0jcBG2SQuAOCxB4yQSSQMZzkOTT7qTcF1a6IUlAzRxYUgLgFWBbIGRkA4AxjPFaZvmYCL7PYZ+XGLbLA53AAB2Ib5lycfMo4yOS/7fcKB5UFiQNodfsaYwSowST935RuKjILYbOeL9lSWvv2tfR1PhdrN+899HvezVm7on2+Jd0o0+ZtWUo0tlZ7Knu/R6316GZDptwkfOqXLZYk/JEGCkJwVkVmAJIwBggehPL20+XO7+0rwEgYYG3RSQBkkBcBsM2FPzbCehbaurDrTFnAh04sh2yL9ijMiEhCCyqMDAIUnc20h1Jzglk929zC6GC1j4JDxWsSkshVkwcn5SRjHBbJDADGaVKkopxcnZXvzVG38Gl3JJ3vHta+3RZ+3xanacaaT5eZ+zp3s+V3t7NXtbst3bTal9jmwv/ExvckEAeZCMY+XZnyyQQDnGBxgLjaak+wThc/2leKTu24e3wpUEruBjBz0yOehI+YBqmN5OJBItzBH+6O5vslsymVSzrj5SwAKtv3dSp+8GUVoRXs8kfSBQ6qT/oluxGQpDHCEndywAbAB4YnFaRVJ+7aSaSd25dk+k7vtfd6PW13MquIjZpU2m7L3YtJpxet6VttG9XbW+hn2Glxm4Yzyy311GQIY5nDH53jWIpF82WYFdzFdqqyllyRjceRIZGDqGu0JXJwYbVsAnACr5s6lWVmXOwgFdzgMmVA16bh7kyxwMS8ZbZGZihcMigRIgSGXJEhJdyGySFAzf2sdjFhwE3ggsJBuwSGLMCxOFDAq7Z+YnbV0kknGMWrSu292nZqTvdvte+nRX0OXEOUpqU6in7iTUXdRenSySVrvRdru10OwxMhcHeWOWb77gliX3MSWJ3NuIA3Y3EDOKuxqrIpxkLhlbI3MpVSQXwxPf5gSM45znNNmkZyEQbFYK3GW2khCy7DuVQVKjJYh2wMscVet49iCMAsQBtU7yMqV3gEdeeCMBTnIxzjoho9E7WUbtO6b5drXT80r37duCq7Ju6T0cUttk030ve1k777XLa5A+UAuSNhbdsYEqQxJUnHGODnHGAfmrStYHAwzliUGTtUYYbVKrj5guR1xz0JBGTTiQsQQuUGA/BVsAocqWYHYT94tjJbBOMVt2yAhNyk5w3BORu246lucYzk5BAI44HfShFyTirq99XZ2tHV3Sb1dum2nZ+PiJ8sUrp3vzNq+1tLte6r3Vr2W6utHoWkZKqWI34TkHJAG3gk4DMSD94YIx1611FhAgdCcgclR93ByncgYHTAIPytg4NZFpFl1JX5lXaMAkAnbtzu+9g9wfmAyAW69hp1vwAcZwCMYxncpxk9j3xnJBDfMQV9ShDVJXXTdtX92+vVPVbb+Z8vmNbkU7O6tffa6SSS3TW21m9dzd062yVKjjI4yeMlQc9CcYOcsNvIIIIB7/SbBTIHwhDEZVVI2nC59duRyCTvU7RkjIrnNLtQ3lkkbmOW5OBznqRkY3c8cdRkmvVNCsHZkCqDg8h1J5+U/Kowxx0yM54X1NfR4Oi5TVtrpPfpbrbmTbeie+99z81zvGqEJvms3e+ui03e3yv6JXTPQvCWjs8sRCgjC4Vl4J2jhRgA8jjGGJGT8or9Nv2OPgTd/Gb4qeDvA8Uci6ffXn27xFeRp82neGNLEd3rVzvX7kk0CfYrUkhDf3VsgB3qK+IfAmhmd7cKhGGAchQDg5wQSDyOhbhQOuAM1/Wl/wRw/ZRlk8MW/j/VrBk1T4l3a22myNEwnsPAOgXO66uA+3MQ1/VoWKMDh4rXTpgSrHP6RlfsMswWIzPFtRo4ShOrKXR8sU0rtpt3Ttbe1l3P5L8Uc5zDMa2C4cyWE8RnGf47D5NltCn8csTjKkKKn3SpxnKbk1ypJXaTR/Qn+yZ8MbHwV4Et9VisIdPjv7OzttKsooxHHp2gaXCLXSrOFQAI4UgXdGFAJhaEEfIAPj7/goh+0jpXwy8J+LPEd1NDNpvw20w3cVmXwmreM9SUWvhrSVXILbLmeKeZYy7LA0kjDED4/TDx74i034ZfD/UNS8uOKDSdM2W1sgCeZKEENtbQhQQrSzeXEoVSNzAjAAr+Kz/grh+0JeeIPFWk/B601Az/2NcSeNfHgSQFLnxdrsRbSNNk2nhdF0udpdm4LFLqDIy7oQR8J4f4arxDxFmvGOYQvRw9Sawimm06s0oQim9P3VFxhpZqU1LdM+v8AHehhuC+B/Dn6N/Ddflr5nRw2Z8Y16D5KkstwlSOIxs63K+aMs2zH2ko8zdlT9nZwlE/JuW18XfHn4tafokNzJqXi/wCJXix1u7+YtJtutVvWu9X1i9YKdltpsBur67Y/JBa283IC5H7z/tX+MNF/ZJ/Yv8NfB7wezaX4g+K2kWOlWduxEGo6f8MPD6PHpz3kYUPFd+J7qa41rU1+VmvtX1eFxvxs+O/+CS/7PyeOPHfiD4x+KozB4d0WHUdEsb65XZa2+iWNqt98QdZ84+YEWS0m0zwpFKCUZdf1XynR9Pl2/MX7d37Ql1+0P+0B4t8RWs0h8OadfHw/4StCSIrTQdKLWmniKNQqqbhEe9lVVwZrhyQEAUfrWLxPsKN23KpUccTPV3bvbCUujs6kZ4h6f8uqN9Jq/wCacOcOrjDjzK8gwtOMeH+EKNKWIjGP7meKUaXtKfLbl5acPZYVRkmuWeMUfhPnz4V+CdQ+IXjfR9Es4nmuNT1KKNiAXKK7l7iV2yM+XGGZiMN949q/ftbGx+HHgmw0jSolX+ybC20XSoujT6jOEgiOMgl2lczSN1KhmJGAa+Hv2D/hStnaX/xH1K1w+06fohkByWPy3NwjMGGSAIg+0ncXUYIAP6R/DTwhJ8XvjXonhtV87QPCcv8AaeuOozE13hZSjn7uYISkKg8LLcnkFePZyWjHK8qr5liGoVMTFzgnrLk3V30vrO2t0lds/t3jLO6Xhn4aZtnr5KeZ47DLB5TB2UvbVoeyoRhta0m6rtzaRi33P0S/ZM+Gn/Cv/hbpkl5CBrPiADVb+VwPNYTDdAHJUschjLjJ+eVyAMmvqQDCZAxnseePXJAKlSPoPQYNVbK3itreC2hURRQRxRRRgARokYVVVQMYUKCAMdOflGSJnJAwcHGMnpnnIzwTkDpyc57HBH5jjcTLGYqviJS1qSbtq0o3SjG62SW2nTRM/wA1lWqOnUrV5udavOVWrUk7ylUqNTqSbeqbbd9XZa7LSncybVOTtCnd1HHv07jnj0Pfpyt7dBVdicDAbP8ACAuCc8kdO+QONxJHNbF/MMMpIBxj73LAehJAycA4IODlhkbq8V+KXjC18IeF9U1GaZYjBbSuC7KuGWNmwcnjGMk7stxjLcHty3C1MTVo0oxvUqTilbS0W1drZq3zv12Z8VnWYcim73UbqyVuabtGMV1betkrvXTTlPya/wCCmfx+/srRh4H0q9CvciR70QyMDsXIVWCsRtJyRnqARnHT+Xb4j+IZbu7uWMpYsWDDO8DJcgdu5ySdwJ9DjH3x+2P8YJvGnjfXb97kzR/aJo4CZGICBnUnaDnkKRtyNoPHGDX5W+KtYV5Jiz8hnODnJxkg5YnJ4yMDb8pBZWDCu7iXFQpuGDpNKlhIKmuV6Oa5eeXZttb9vvX9TeBnCE8vynD4rEUn9czGosVWk17/ADVFDkhpaVqdNxilt2SPM/FOpbFdQ2N5Zcgn5QQ2QevH4qPTBIryC5KPIWckgnOMkdwuCw6HOee+SO3HQeIdT86Z/m6EbeCRwxGMD17cYxwprgbi6LBwWOM9eckjB4zzyc/wnHA6nj8txNRVakm2nd3V07WVrPTrbr/deuuv9xZHgZYfDUoJcvuxutE2/d2dviSfld3v1vfa/VGIUAHAAwduMBQMk7chRkg5IAyOp5oy6mGXJc8kkfNyeB1JwcHOOR0HYkVlM0jHGflOQWySwyQT2Y/NzkEAk9Qc5EZiXk7iSQ3PAbBHTLdc+oGGxx0FckpO1o2TS0XZ2WvzdnvZO76M+pw+AlUaahvfmbTWj5Wv83on0stGWJb6SUYVhkD+9yBkLk5J5B9Bk5+Y5NVCZJHDO5I6EqTk8rzgZGeDg9hgHHIoIwMqOO+TnPTk9D6cnJGclgTUYfPfOMc56ZyOgwAfQnoccZxnGTd7yezVl1u0tXZq2r7PVa20PcwuUe6nUdo3TslZ2Sj5arftvuncf+7U4B3DIz1POecFTuI49vmzjgDbMr5JIwoPIJyRj2A9OQD24xuqBVlcnap4YLnBGAAFO3pnJ4+mMKSMG6lqRzIeMdS2Oee20nA49/vYHOC4Sk0lBLTe1lfWOq31a10u3fpqe3RwVCkl7t3pq2m3pFX2btptst7EJyUGCC2cE5UAkEZ4wTnb36E8DuKWO3lcnLMFI5GG4x/tEcfjnA6ck5naa1hGCwZsEgE7ugGPcdjwAqnnqcipJqEjDbCm3+HJCnk8cErn5iGxnIz6jGNIRdvelZtxs1q0lZNu+l9Htbv2NqlejRScqkVJWtGPyV1Ztpq1rJW7dEXVtohkSOAq+hI2kY9y3QjA+7nJODQbq1ixsBkYBsBATzxnccDpjqfTaOAc0EguZiS24g5BU5KgY46YA2kDjPBGORitK10iRipKnrkE7mPOM5JAABAHPTkYJzg6xhLXVpq3e/S/d82zbVtNDysRm9OKfI1BJauTu+147W720av1bsoTeXMhVY1ZAflLAc5yDxjAAAByMA4ORgZNEVlLPlnYvuJAG/Oem0gncvJ5ORg+/Geus9Bkc4wBkZG7JZT0O0fTqeR12nPA63TvCk0rBFgeV8AY2kjr8vyr15AXBAycHhsZ6IYapJveS0VraXSSVkrO6TtbXTS1r3+fxPEFKin7SvflSu73jpy7apW0aavfbzPPbXSHfaFjzhgBkDG4HJOWIbkk52gZ6deR0lloEzMCsTFg3IVGI7ZBOPQnnBwByQcivoLwf8HvEviS5httN0e8uZZSqLFa2skkhJyFA2Rk5OeOVI4/iIr9KPgb/wAEtfjb8THtLu60B/DukzbGe+1lXtVEb87ljfbJJgZwAqhfmIBbFe3gshxeMa9jQqTX2ny8sI3StzSeitfrbTVK1j814k8V+H+H4Snj8ywmGUY/DOtHnbTitIJuUmle6s3Zaa2PyG03wjNOU2wtIxGNqRtuxnjjb13cYPzDLEgjAr3LwP8AAfxn4vurez0TQL+9kndVENpZzSzMW+UDbFGzegBYY7EHkj+ob4Nf8EgPhP4QW0vvH2p3Hia9jVHksbFFtLHeuCyPIQ0sibuoZgGGMYzx+j/hX4R/Br4L6QH0Hwv4U8I2VlGBJqNxFZwS7Yx80k1/c4bIHJ3SH+9xxn7DA8IKKU8TWjBWV6cFzyT6q9+XTXZtp7+X88cT/SdwvNUw/D+BxOYVW7QrTTpUG20otKzqyu3dJU3fZM/mQ+Cf/BJf4zeOFtL/AMRadH4U0x9rvPrTPDMUJzuWzUNO5AJwCQoPVcZx+svwh/4JV/BD4fpaXfi9rvxpqcRWRoZEWy0pZAB8rRxL5sqk9nkBI6Lgkr7n8Yf+ChX7N/wrW5tR4pXxdq1tuVdN8Mxi7jV0KgRyXo8uzRd3yApLJtXna3Ir8pPjN/wWA+Iespd2Pw10bSvBlgxdY724KalrBQkgMDMDbwyYxgLAXBywO0bq9+GGyLK4qVqVSotffkqsm0o/Zvyp69VdJLXq/wA8jmXjX4kVOTCUcVlmArW9+MZ4CioStZqrU/2morLV0otS6W2P3p0rR/hH8F9CP2e28IeAdHsogTPIbDS1VY0Od00nlyzMAASpZ2+UcFlGfkn4s/8ABTX9n34b/abTw5e3XjzVog6gaWFttJSVMrl9Su1RWXORmGNwQcrhuT/Lt8R/2nvil8Sb6a+8U+L9d1+edmbN9qF1NApJLYih8xYY4x0CJEEAwCTkgeHz6rrOqP5k80mxjhXlJQLuIB2795AYkEBArFvvAHAUecVsQ/Y4DDznzWUbJtpuyTtHRLZrouut2fe8O/RnVadPGcX5zWxdWTUqlGhNxjKTs2p16rdab2vy+yk+3R/tP8aP+CuXxY8Updaf4SuLTwfp0hljjg8PxiTUDCzEKJNWug8iOFA3NbRrlskEYNfmZ4z/AGiviJ43vLi81TW9RnnnkLvc3l1cahduxbJImuXk8tsqx/dJGBnjggj0X4GfsF/tQ/tBpBqPgT4Xa+vhiYqX8ceL2i8G+CFjbrLHr/iFrGHUVUFSYdJj1C4J6QZHH6v/AA5/4IzfDL4faTH40/as+O+k2GjW0Yub/TPCl3pvhHw6kcahnjuPHnjh9Na9Q8hxoeiXrNErPBO/ylu2hlOLqWlj8XTw1217OU3PEKTUXGDw9JVKsOZ3SdSMIXu3NJO39ScEeEvDOUxpxyHI8KnHl58XONNR0teVXFV7Rly6tqVRy6pO7S/nzur3W9dudite6leTOESJBNdXEkrEAIsCLL87Ehdm0uw4Azivr/4Of8E1P2vfjkLbUtO+HN14I8MXIimHir4lXSeDNIFrKAUuooNSEGp3kbKytB9isLlZoyGh8wFa/X+5/bb/AOCX37HkL6R+z58MNM+JnjDTUaJNX8JaIut3Juog0ayXHxU8dQSuis4d2k8J6bbKrndaXUewCvgr44/8Fj/2qvia13pvwytfDXwN8PTNIqN4UsE1jxg0Mm4PJceKdVhuLqC5kVsy3FpHBcbiczkktXv4bLsFQknHC1MRNO0amNnyQcoxSlF4TBznVbcneEp4mnFwTc0pOy/o7JMh4dy+NL+18weJ5OX/AGHI6SqOS0ajPGVlTpRVrKShTqLX3Zd/pnwl/wAEk/2fPgrpdv4u/ar+OOn3VtbRrcXGnx6zY/Drwm+FL7BqGuyy+MtahdVCI2j+GIPtONkFyoIeuivf+Chf/BPX9ljT5/D37OHwwg8ea9ZxPai88H+HZvDOkzyxghn1Hx/4hu7nxhqtsXRHxY3NvayHBltSSVP4B+L9c8e/EvV5te+IHi3xR401m6d5ZdT8TaxqWr3Du53NhryaRVXcSRHGoGSB8oBByrXwwSyIIsMxVRGEBkctgZVApYltzBVPGcqeOa+vwOHxuLUcPhMJUVKSjH2dOH1eM0krKVLDSUpzUm2pus3K1pKysfpeX8UYXK0qPC3D2XZXLSMcfi6bzHNJNuNpxrYhOFJu6vGnSir/AHH6W/Fb/gr1+1h8Rre80X4fTaB8D/C90ZI2sfAloX1u4t3LLu1DxJfGa7uJ9rYkuFjilbbuQjrX54eINY8bfEDVJ9b8Z+I/EPivVrtzLNqPiDU7/VLpnc5b95dyy7AW/gUBQOcbcV9D/DL9k34uePRb3GkeDryw0uba39s+JSvh/S9jc+dC16EursYDMgs7W6ZhkKCCDX6i/AL/AIJV6v42vbaLVH8V+PL7cnmaJ4A0S4sdJVmZMreeI9UtZJzFuA3PHptmMZYToAWr7Klwy8qwtTHZ1i8Lk+DhBVMRUxVSlgoSUWmpV03F3e3tK611bno2fa5dwrx7xUvr+YVMc8E/3k8Zm2K+o5fTho3ODxM6dJU4q1/ZQklFXs1Y/D7TPBtzcOiJC8zylVSKKPzJHYkbQkaIWLAsAqg4yQvQmvqz4ffsUfGrx6LW6tPB8vh/SLnDLrHjCVfD1g8bfMJre3uk/tO9XglDp9jeFwoC9Rj+wL9nT/gjXP4bjsrm88N+DvhNCVjM13BbJ4p8byIBg79Zvpb2e2kcNhxb6lborDK2wGRX6u/DT9gP4AfD1ob6/wBCl8ba3GAW1XxVML0NIuDvWyCpa4LDdiVJiOu48k/m/EX0gPCfhGM8PgJ1OJ8fSvanlkY1cMqkVa1TGOUMNyud/eoVq8lFJukm2l6MocAcM2jm+fTzzF0+Vyy/hqEa1FSVrxlmdZxw7XSUqSnKL2WjZ/F38Dv+CQHiDxjdW32uz8YfEe6Z132HhXSbzw74VSQ4BS58Ralay3txbdAXitdMJQYWZQAK/dL9nj/gjHeeGYbSTWLXwl8KbIon2i28KabFq3ii4jOC8V74hvzd3rSMDksb+4QMciEACv391/xf8K/hLpCvrereF/CGlWkf7mB5bCwVURQAsFqm12bAG2ONGOFyFycD8+/jH/wVH+DfgS2v18I2c/il7NX36xf3EXhzw7blCQZJ9R1IRssQIPzNDGhyCHx8x/M4+OnjV4hzll3hrwasowVX908dh8H9ZqxhJJRlWzHFU6OW05JXld0lUi7cs3o39LkPFvF+afuvDLw+wmTUlaLz/G0VjsVTVknOeb5mqWX4Z/b5YQ0fwvVHu/wl/YM/Z4+FogvW8KxeKdai2u2s+LJP7UlaVCuJFtpkWxjORkbINwPJf5a958Z/Fv4PfB7Ts+JvFHhjwra2kJ8q08+ygkCRr9yGzgzOwGPlWOHGABg8Afyj/tHf8F2bm4XUNM0rxvcOpMsY0P4V2qPGMFl8u78Zai8Fsno8mlXGoAgEiM/dr8MfjJ/wU1+Lnje8uz4bisfCv2hp3bWL+eTxf4pkAA3TSarrcR061lJ+bfZaPHNCfmhuN2DW+B+jZxxxViY5x4rcdVaabUp4SniquZ4yF7SlSU681h8K0nZexoV6KbsmkjhzPhOOKxH1/wATPEarnGKi1J5TkNeWc14WteisZVnTy3BuLbi40Y1I3b5VZWf9oX7T3/BWf4H+HPB2vaJpVnZap4c1y2n8P674n8YTxaH4XXQ9VU2GrNDBqKCbWXfT7idUs7aGR5ckmCVf3bfxAXvjX9g74T+JPFHiTWdL8a/tHavF4w1OTwv4F0+Rvh78NY/Ddjq4k0W713xhcyah4u19r6yR1udO0+x0tVYAR6rIH2xfA/xF+LXjHxxqNxq/i/xTrnibU5Gdjfa5ql3qMw+6AsX2qWVYIwcFIYVSBRkKiAhR8+6vrTTOWL/Odw4IDOqnnhSWGM7ccHJHGen29bhDgPgDK6mVcL4fGJ1qtOtmGOxWPnUxGPqUk401UcFCnSjBTklCgqcbNvlTbZ+acdZdwhmuFwmV5DlePyXA4SpUqV8Ss0rzzPNXUVOH+2YikqX1ekowvClg/YKDbfM1KTfo/wAffjDo/wASda8QzeGPh/4c+HHhfVPGWs+LdF8LaFPf38fhW11q1srT/hEdL1DUp5bh/Dlh9i+22lpMu+O/ubqZ5jm3hh+VJ3+YkE7iQwKElWHy4UEActhlwDgYIPPI29TvTIzH5sqeORypwOSMnGC/UEYHJ3KCOXeV2d93k7VJ27Sr5UbF3OzMCVcA44LYwjHKnd+N8SZlPGV+bmlKMIxgryc/ci4pR5nd/Clq3Z3XNqfA4iFOhShh6fOqdKCpxc6tSrNRjGMYqVSpKU5Ssk3Kcnd6yd2yfzS2GB2lR8ucAHBUkZbpnoRtx8uM5wW6TT7jfbqZM7lyM46ttChfm3ZYMSCSTwMHkbjxqzBxkMQPlO04V8gIOQCzAAHAbAPHI4re0p22MFb7sikZOSoIGQc7mJ5+YEYLYJGea+ThX5pcra3uktXf3W1dt9Nmn3T0evymb0P3DqLRpxkmne+sbtdt+j1snuteyRWlt4w4LxRkMsR5HICPjgHLqyKeynnjJLf0J/8ABEf9neb4pftF/BnVdZsvP0LRtR1j4qaxFNGGgXwt8HDb6b4QEqlFja11r4pa4rIHMqTnwxIdqPAVr8AdJtZblIILeNp55pIoYY1G6SeWQLHFAi4LMzylFUAl2coqhs5P9m37G9jYfsL/ALDn7XH7Teqrb2+s/D74c+H/ANnzwRcb1AuvE/gLQxF4tNlMn+ubVPj1438QJctFw/8AwjwJJMKlfsspTo5fm2N1TlRoZdhnzf8AL/GNKTSe6pYeNW/TWN+h+Y+IuPnlXhlxbmEG/r2avL+Esnhop1cxz2uva8q3vTyzD420or3Jyp2V2j8x/wBtz4vv+1N/wUv+MnjmyY6z4V+Ck7eG/B8Cs01vcy+BJLfw3okUMStiSPV/Hd0t2qwndKjgxsx4Py/qOgyfEz9tH/hHLa7in8P/ALPPhfSvh1Z37OrWg8UaJIkHirX3nYbZYbr4ra/4y8VtdYJmtLNbiZXS3mUzfsqan/wgngPxb8dPEYNxd6fB4r+L2oz3ZVvtk/gdX0zwFaXZkGZ7fxJ8WfENkktvISl4NKi2hmjU1X/ZW8ParafAP4qfE648+58VfEu5svCWjXcju97fa140vtQ0VZRIR5k102mv441WSRSs3nPaXIKlBn18NhFVp4DDwS9j7GeOqXu5Ro4aEVSU1slUbpQStfmp3sj4GeULLv7C4aoyVPCcI8KrGZhVvaH9q57ThXxWIqXso1cNluEhNt9MwmnfmP3I/wCCV3wpt/H/AI00fxtLY403xt471L4jNbzRHMfw8+FNlZ6F8PrCbdnMMviGe3k8tsxyXGl3UigM7gf0f/EbxVpPgrwn4k8Wa7drY6L4Y0fUNb1S7kbYkFjptpNdXUjZwBiOJhzjJ2qGPFfDX/BN/wCDlp8OvhxeapFCPI0vStB+GehyFAN9p4OtDN4lu4HA5XUPGeoauJZVPzmxjJ3bA1fOP/BbX9ohfhT+zE/w40y/Nt4k+M2oNojhJQk8PhTSTDf6/P8ALh1juiLPTN3R0u5hyQQPJzCpCpmUKSd6GAopT10cklWrtXXxyk+TbVq2uy/hnilYniziueHwrblnGZU8JhbXbhh5Sp0qc7K7tRw8VKfRxg+mp/IF+2r8e9V+O3xk+IXxH1Gd2uPGXiTUL60gZmIsNFSX7No9iuOVS10yG1hICjLKxUZYmvkbw/aM0rXMi8Jwhxkscc8EZJAJY4zg4B95Nevn1nWJXRi6GTyovmLBVyQMDoTgAjgEFs8Y5+xP2OfgHdfG74s6F4fmtpH8LeH2i13xbOEIiNlbzKY9OLAYEupXIW2A5YRi4kwfLJGOQ5diOIM6w2GoRcq2LxMIRe6TlJNzlrpCmuacpPRJOT0tf/U3wU4FWCwWSZRgaFlSpYbC0IqN0nGFOKk/5Y04Rc5Te1uZtO6f6wf8E8/g3o/wf+FWvfHLx+sOlXut6VNqzXV8vlNovhCyVp7dB5gBSfUdhuZEXDOrWsYAdAK/Kv8Aaw/aE1f9oL4o6x4ommlh0C1kk0vwlpTMwj03QbaQrBmPhRdXh/0u4YAkzSBSdsaiv0B/4KM/Hy18LaJY/s7+C7xbeKC3sr3xuLB1RIkWNG0jw9+5KqqLGI7u7hGAp+yow+8B+PGgwofP8Q6hbG7tLK5gtdO04As+u67cljpujQJz5keFN1qbLkwWMbscSXEAf9c4+zahgaWF4LyeqlhcDCnDHVItL2taKi5xk4/3m51I7OrJRS92x/SviBn2HynBYfhXLaiWEy6nD69OLSlicY+W8JWerjJtzim7VJWfwJvs9FsRo+mS2Dzpp2sa1pjajrmrSsIW8I+CwhlmJlwBBqmvwj5AxzFppVkHmaghHm/gDwzN+0b8ULOC20uW5+GnguS307RdANydMj166nFxc6bpM19ITFpn/CQR6bfaz4l1qUhPDPgbRdb1u5lKabIXwfiHf+IvE2t2/wAHfC041jxZ4p1GC68dajBIscD37g3X9kNdbvKtdG0O1El1qc0kkVrY2tr5btFEtwg+ividd6X+zv8ACjRPg54RY/8ACZ+N/DUVx4i1KJDDqmmeCPEyW17LczIAs1t4i+McEdldzeaq3mi/B2x8L+HyY28a+LbOT8ynVhFulGP7rDuCnBNN18T7rpUU10pykpVEubmq9HCldfhdXG1cBSjXw8FWzzN8R9RyXDShz8+J5YyrY6tBtf8ACflNF/WMQ5PlrV5YbCL95iLHmPxA1DXf2gPiX4c+Fvw587X9Hg16aw0SawtGsbfxb4k1P7Lp2t+Of7NjDNpum3NnpthovgrRyGHhf4eaD4e0gmW9g1S7vP0a+M974A/ZW+Cs3wEsHtb3w14AutJ1b49XVuyw/wDC0vi2Uh1fwr8FoLiBmmudA8PXSWviX4hrDIAkNlpnhl5La6+2+bmfshfDlf2afhmfjrr9rpw+NHxKsdR034K6brUa/ZPB+hW8JXxH8WNcimGyLSfDNlJ51gJkVdU1H7HYRebFNeqn5RftIfFd/ih4li0TQby+uPBfhe51FdHnvpZZr3xBq9/dyXHiHxvrUjlnudZ8Sag8l7PcTF5QjRW6OY4FA+xqYinwVkGIzDGKFTiTPIQ5aU7upQwsrSpYa124Q0hVxMVvH2VF/HJn6HahwDwxLCSqOrxLxBTVbMMRVbni6OErtVJxqzeqxGYVW6+J92/sOWk1yzsvGfFvinxP8VfHGq+KfEl3JqOta9qEt5cFj8iSTOSEULlI7azhIgggiWO3tLeNLa3UIgz+xf7CX7PXl2em69cxwxeKPHFpc2vhOa8nNlF4U8JkXkfif4jardvBNDp9xq1jYappvhD7SrrHpljrniNYHtNNheX82vgD8Lh4k8QR3mr2t9N4b0mSyn15bEMuoalJfT+Ro/hPSZApEeueKb8Jp9uw3/YbP+0tanja00e8A/dO80TxJpnhr4X/AAV0l7W1+LX7U2tWun3sujo0UPhn4RxTRWerarYxriXTtE1PT9HHhjwjb4iW1+G3g26mhjEvi3Upbj5rhKlUjXqZ3jebEZnjqsqeCc/fk6+Jn7N4i07t8spckJLRS952UbHyWU4ieDq4atQgsTxBnmIWXZDQaU5LEYlqNTGuN0+XDQcqqk2veUbe80j0j9o7SvD91+zZ4Y8XMLmfwz4w+JnhvRPhpZOZrOyvvDGmeZp1/wCJjpjSlbOyvND8NLZ+E9K2mLw94d1i7ZGn1DWb69ufrL9vfwJB4k+HHw58caVCjQN4ctbGF0T7kSWUF1pyDAwARGYo9oCnIRQEO0eFf8FNoLLwh4Q/Z8+HmhQLbeHPClrqq6baxhVRY9PtdG0ixAAIBeO1t3XPA3SuFAJwPszwFNH8ef2KdGjDR3eq6DocMGdwklS80mJVjXgu4DIoGSSCHCsctz9XxNQWHxNPDKMlKhh8PGpNtydSpPmqTm3J3u+aKS0Sa89fwz6WOV1+COPvDXEU5T+p5FR/sbG1XOTVbF5pQoYnFYms5uz9pJyjqre4l017D/gjz8W9O8d/Dz4r/st+KrtFa7gm8R+EhMwzbreltPvltATlTbXp0u6gEWDHI0rBVAJX8V/+Ck3wPv8A4N/tF6l4lgsfsOjfEi71C6uVSMpbW/jjQriOw8XW4GAF/tSZrTxJEuFLJrJVAxjcDovgL8YtS/Zf/aa8I+NoGeCz0LxPBFrFtGwT7V4d1QyW2q2cqgAMGtbqaIblKq7RsBmNMfuB/wAFYf2f9N+O/wAFf+FgeDYIdSn1zRbTx14TvLRQ6y+KvD+n/bJIYWUnjxb4QlvYolBJnu7G2eT955Zry8IvbYjEYVf8zSgqtFNaRzbA04txiuksZg1yrbmrUY3P4Q4wg/DrxTwuZRp+zyPO6ko4ma92k8tzrERUpybsmsqzipHE1HdtYfHySSSd/wAkf+CWfx0X4dfHKz8G6pqAtvDnxYsU8JTSSSBIbTxLDI154Sv8kqiuNSDaX5p5Cak+cBSR/eR8BfGA8bfD/TTdSltQtYDYalFJnzEurb/R5VkB5G/Zu567s54r/MN+Hup3mnahZXtnNLZ6lY3UN7Zzxt5U9te208csMiMAXSaCeMMpXJUhcnhWH97v/BNb9o20+KXgrwZ4mluY0m8caHCuuW6sqrZeOdBC6d4otPKVgYWubiNdWgiIDm0vInBINfE+ImTyzfhR4mnTk8XlE3iINRvP2ceVVY3VnrBObdv+XUV2R28H5tDww+kPk2bSqqhwx4m4ePC2eRk+TDwzeK9pk2NntDmqW+px1ty1Zyeuj+df+Cu/7M8fi74aeKdW0nTzLq3g+STx1ohSNmknsPLMHivTYSoO4PYldTZAPmlsIAQCAW/iX+KPhswS3JMbKCflyNowSO/O5R0IGRgYHUV/p9ftHeBrTxd4LubqS1ju/sUMxlhkQOtzY3cLwX1u4O4tFLbyyb0GcgbOhxX+fv8Atz/AS7+D/wAXvGvg1rdxptpftqfh+UjAuvDmqlrvS2VwMyC3jdrKcqygXFrMgIINZcF5uuIuFaEKkubG5Z/s1VyknUdOEYqErN3d48r5npdtdHfoz7IpeFHjTxJw1TiqOQ8S1Xxdw64rlpRhjq3/AApYOla0IrD4znnCnH/l3Pm20X4i+I7Bw8oMYDZ6AHKqCOMkYJ4wQACPQEDHjWrWmFZSrEqVwTkYB28jO0tljjk5zkZLEg/VvjLRvs8shYcYb5sbWycseGYscDglsckZYYAr5+16xO5uBgDGSQOPlwByTnv0J7+hrxsyw/JKVrq23TRuPdfJb2vv1P6h4VzdVqVK07pxi3bvaCb2dubu976W1PF763w3ykkDgjOduAOo24wTknJwMcgkCuXuYCcsRwCCM9cZUYJOMr2UYIzwcPjHomo24ZjuVhngEg84UYOWwckjGcZ77Qy1yF5Ap+XbjoGf3+VsZJ5GDwQBu4xlgM/M1oKVpXtbrbRbb7u11vbRJdT9dy/Fcyi3JXsmlpZ3UfJ9tdlpvY426XOMgPjo2MY+78xZiMjH+6QODg9Ma4iWTerAsCgbOQScBfnBIU7cjorfNgnIJ56i4iXdkgAYCKeM5OzGWJGD0xkLkdSCMjCmQ4ycg7gQCSCNoGQMZIAJzn5R/eJO015M4rbe92tbvorO+rTv6rRWtofT4SrGSjzXTdknpdXs97Kyb3Wz6aaGLLHg5DYyCDnlSCBtG12IJwAC2cEAAN2rPlUFkJVgyZ2kDDKMA8Mm0kKcEnoRgE7QVGrOoyCOoAGcHkDaQMdMthjkAjJDYwMHOZVjGVLHeOhzwGC4wSc7QcHPXcwYZ5zztRvqlqnfTeySsk9FfTVem+/sUp3Ss3e2iW+ysv8ANb9emtSWMcHlfuuCTnocFfmYZVsBhgYOcbS3zCswYgkqd3BHQcYA6MxIBIC87cEqrhwATcaRQygc7SAGAGTnZgH6Z525J4bAOc1WGAzYz0wAxO5TjaCeQQP4ycEZwSMHPNN2b6NWvt0s72s9Um0+ttFrodtObcVtpbW6ul7r0vblu0ttregwRqSQDhmYPgnkAbcocE5H91cY4OMiovu7ixRRncvy4GePl5J+bPyhfmAI+UjrUy8FTnAKnAyMBvlOG2rkgnGQMkcEHk1E24sVOCCuS+ASCuMqxJY4ZTkLjcBgkkE1zTVoylbpspbO8bLXZvra17Ldu51QlZWuk726f3bPRvXXayvbfVsjY71Xhg+5f4fmbbgFcnJBHHXggHdg80wjacAZBBJBy2OmSQMYwRwTnGRghBTH80MWHlsQy7VO0mSMjli2Vbd8j8Y6DJJIIobfkckgkA8EHOADlQOQOc4JJDHAIPOSlpJ21vr6Nqyd07Re6T6NN9Gbxbsr2vb77uO3ra6d79Xpq64YqAGDAOQATyx+6CSh6sTkgHGASemBT2DPlWGAV56NlsqV5YjgkAsAOuCOTSlTuUj+HG9drhV3bDwOgO0EBhyvCjPJDTjBPKgAgrwSQSAGz8+cY4wMgfOTzQo6tN291rSyu3a7S662V9UlpZ3Zqlrr0t6O6jdu1uy26OzdyI8kMnzFSoc4z8pIwCGbJUbQNw+6cDJ5agbAcuCMDoCANvBByAuSDyvpwSCCBTsgEZCkgBdoAzhhgE9gwzv5IYnkFlYYjclA205O7buAHHCA5GcEgMflByF+7nmoejul7q13W/up39NHr0WjbdxrV6X93VdNbrRq99ei6pLq7tZQDABtJONyKCGJUAEkdlyuQQMkZyvGKgAAAA2kumShPJHyn5lw+0DIwRyNpIB5NDOyheS4yBIB94AgMXTLBC4CksgyeqnlhTmIwWIY4UKMlUPO1gAEODgnlc/K+SPlwKUppv4laMVa6V7aS0Wm/lo9NbItSWnZWT5kltyW13ff3ddOXsVpVbKKGJCgPtGCzMXXKgFVwQABwwBPIGamwdoUEhgyjqQQcLhSzH75ZgMqTn5gTkjLHQqwVxnf8424ODlVwRliACCygA8DJAU7qkZG2siAqeGGSGyPlOFbkBieSVBBA4BwMym3d9Xpvsmk16KVmumnS4+bW/azTV+8d1e6W93ora6tJixuC2NzbSSACGHLFTlTIB8xJ7bcAHdg9VjG793jaVLcMRuJVlwVYnGWIzwASTkqrZoVlLF9oAIKlwBgkbAC2TlgTjkbScbcAgUvmiPOUOQ21nABJJCgEgAkghScgDIG0kHFTe762Vlda6O1tW1fz30taz1LTutW7XS33vy2Tu0krW1lZWTTvbWdXLORtOdiksSQp4QFRvwQzcjGMDHGMk0iliDgA4YArleAQvcqAV46c5IOWB6RmTEZBUAnGG/uq2wliQGYkehIPOeBgh0IzgZBwFOccnGBk5LDGCTkgc9OV3Uc19bX0Se1tbXt566q+vm99o7R62XvPXpyrsm9W7rezT3ethlIPykDAVirsSVxtG7BOCSSTgcjb83y/MtR1fexUqw3YXagOwsFY4LHBb5sYZm+XAQ8lRYSXgkqQwG1G9RkIeWxndnkjAPQ/NkmEKS5BfdsJUowIBGRgZUhVXABXHzgnPAywmo7rRXvHXl8kklf0urvRLddRSimopW1SV9LaxStd6aPVXTenzSLiENucsqDJ3BTIgG35QCxJB27guATk5IIwZ4SZVRxuXeP4tysRlWDHagwpHOCARnhQajjZWXIIKkE9cegLMFyQMHBDbVB5weKLXYFcpvCSOzLvZmbA2qvGQVXbkliDkncCEAWvPi7bPR6Wb3do66bp7K+1r66I+GltK6tJNa68rXu3StpfS67rV7FjcC+OM4HBJ54XKnAYDOPvHA2nsajRWTexVXycqI+CkeFADbiV+UAkkKvIUjOc05GQqcE4ZtpG0AtgqrZAJchScBiACuSSFFSqSfXOBxweflPIHAOSAw3HpxnNaW2d722as97b3um7NX9dib2Tut7X73X4Rbvba2qS0d2xyAFjDOpfBVkIJ3q6fdKhgmwkh8um7B+bmpoweO/G0nHTBAz1IJIyeMEE4J2im4bs3zE4PB2lSAWVgOGyRknJLc4PAIlH3dx74wAu0L90tzkHORnOcBSQSRWkItvXZ/JWTT1vf8ADfySMpva26v69HdWXkt33d73IUit4SyxhFkkYvyx8yRvlwdzbi4yVwOgwRnkgzqMqhLbhlSW+bajkjsMDAAKqpwxI4HpA+ftCfuwyLGW+0YJKAOS6qTsZAVVcMNzgcx8ZWnwgFo0YPjYp/fBAJMygKDyxwu3AXc24DapRgcCmk3BJcsWkraK3u9/s7vZv0YppySk580nFN3d30SW72W9306MsSE7H8xCwBT5UAO6NgAJAoYuWAPmAKTjbuONuaktFDor5ZlO7yy2WJHyk/LgBSg7B8AgsDhgDYUqMcksuQOFHUDBHf8A2QzY7cf3ki8wPJvCNHuHkhQpkwQCwfJwPuNtIH3gQOOatK007vom7LTVat7Laz0fS9tDmlO8WkktU7OTsk3FJRVnre7bvtfRk1s0gV0nCgpKyjYRl4wFKyEAsAdoYcEFzzg/eq4jRFuDukbdtXdzhsFnU4ALBmO4KCeMLwMGqGQErI+GfMijpnkKecYBUkhTgb2JAbOMWIlSRUkHOCgU72BAwMjaACVJK4DABQMHIwRvH4VFNN7O/Xbd3aSSafXfqcVV3u7OKdrWjZa26Nt2cuvyTRZRV3I7BiFH3tx28sjDduIzg54BwP4c9a0IlZtqquBgOWK43Y2EBc5OCoJbBOcnaS2A1WPaNgOcucKu3hSQoJJw4AztJUA5wCGHFaFtCylQCSRtCfMW7jjOPu5yVXALHJPXjrhG8kns7Nvmva6Vt7dLN3s10XbzcRNct22nZ8utr3tfTS/5trSyNGFBheCAMHBO7jr056Z4U4wp/h4rbtogoDNyWwrbhnaDtxwcDJJ6c7iWOQQaz7dCrKQQehIxjBJXk8Egdsg5UkYHIFdJaRhgoKg46fL91sqQRgkkDv0HUYBYGvRoxaaUb623VnbTotVa/wCF3ZbeBiqrjFt2XNpZbt6JLa/TVWT0NK0hBYJuXcMYIHptHJxyM8DaFzhgdpArsdOtSAigsSu1VJJz0wTuYAFs9CB/shQ2S2DZ2wIUoQpBxk5kyhC9uMIcj58nPJAB5PZ6TA2UU8yZQkkcsT5eAhJxgDvjJwN4DEZ9fD07STfklK9+i3Ssu+vVdtEfHZliPddmk9Va736N3aXRfdsdlo9ojOAARlcA/wAORtwRng44wOSBk4Jbj2/wppXnSRqVbHybeMA8Lwc5Y4A4yRgMSct0850CwL7MrnBCk9SQTycBSWKYJA+XIxkZAA+nvAOgtPPEdrAFkwW+XI5543fw8knAIBG04zX22T4P2tSEbXbcbu12vhd721Sad1roulkfinFubLDUK8pTs0m9d9Eui2S+V9ba6n19+yx8EdV+MPxN8EfDnSoZI5/EeqQw315Gmf7M0W0xea3qrsMbUsNLgupkZhtklWOE5Z1z/oPfsefCnR/AngWwuNO06LT9NtdMsNB8N2qqFFl4f0KBLG1jTIyvmmJnkYAecBHI2T1/m5/4I5fsw3F6JPibfWLrqXjO5k8LeFZZIzvsvCum3Cz+JNWhzgKNR1C2jsYJcDfHpU0SZS5G7+s3xFqukfDD4fXd4wS20/QtJPlxLgELDBtSOMEgs7sqoozlmIA5rn8SsxnRweX8L4BuWJzGVOVenB3lKDnCMINLfnqLljb+SV9z888A8swef8b8UeLGfuFPhfw2weLp4LFV3/s7zh4X22OxUW3yv6hg1KMm1eFWrCUdYs/P/wDb8+P2h/Dzwv4g1DU5wdD+HejXHijW4BKFXUNSH7rw3onBwZdQ1CWFBGSD80TkbMmv4OfGet+M/jv8WJXQyaz43+JvjJY41LZM+s+ItRSKFSWwIrW2E6ruz5dtaKrY8uFgv7Pf8Fef2lL/AFOfTfhFBfMdU1y+X4h+P445ctELgPD4P8PzHg7bW1MuoPE5xGZLGTGU3D5m/wCCT37PDfFX4r3/AMUNbhZdE8NS3PhrRZ5MpGt9d2JufGetRytvjX+xPC0raRBMwAh1LxTp8qMs1uCv6HkWUUcgyXL8pjyxdGjHEY+ok7yqOEataTaWtvecFu4uEXqkfh+J4txfF2dcaeMOZwk6ue4urg+GMNVlaVHKKNRYXKsNCMn7vt3CFWsoe7J3raptn3D8b9Z0X9iH9hLRfh54VuFt/FnxT0yLwto9wq/Z78+C9OkmudZ8QSIV82CTxnrV/qWsyZc4ttbit0ObKIx/gZ8PPDOp+PfGelaPao1zdatqUcClVLEtNLmWRsZG2MFncliRjI3EGvsf/go5+0GPjz+0Fry6Hcf8UT4KceDvB1pbnbZppeikWn2i2gT92iXkqTXICDCLMEGdiivRv2BPg+JptT+JOqWuYLBXsNEMijBuXVxcXCM3y/uk+TOD87nIztB1jQnmmZ4fCcqheftMSk7+zTUf3a6Wo0YU8PHo3T5tGz+qPo5cCVcLlmGxGKjKWOzyt/aWOrzi/afVpN17zb95Sqc06zi37tSs4rRI+/dH0/TPhX8PLPSbKNRFoWlw21vGgG651F18peF5Z5blwWboBu4+XNfoz+xJ8L5PCnw/k8Y6xCRr/jaVr95pA3mrZM7PHkkBlE8haUDgGMQYAAQj4H0vwzc/FD4teFPh5ZhnsLS7h1HW3UFkTH71lfacE29oskmOvnOjcM2R+4WkaZaaTp1jptmi29pYWkNrbxRjakcdvGkaKFUDgKAAQDuABwd2a9bjLHRo4ejgKDSXLytR1ShBRTtFW1k1GK/wyV+p8B9KHjmGe8V4ThDA1m8t4ahF4mEJL2dTHzUIqLSdn7GmuVqXwSvtuavyxjA54x1zweW5HofTjt0qCeURxk9sHpnJ49/fPA/lxT2+8SDkHkcdBgnvznrnHG7Hesi/mIVhjgA9DkDlsDsNpA4H8Wc9OK/OaUFKUPRKT89N92t+iun8z+VMfiXTpys2rJpa+dubrvpbTXvojBv7kRlpCSVGTz0LLzlhwTg8DnkEc8tX48/8FDv2hbfwv4ZvPDVhdhb69jkhCxvgohBDltvOXBxkgDAJA5Br9HvjT8QLPwF4Q1XWbqaOEW9rM8e5goZih5wWPG7AB4O4FQCSa/kJ/a7+N9/488W6zqFxdNLEbi4jhjaTOyPLgAAHABwADnjp0IB+0y9Qy3A1sxqJKrJOlhr76pc1SyV7K9r2er+7yeDeHK3F/E2Gw7jKeX4OtCvi3vGcoyi4Ub7Xlu09opXVmfFPxU8Xy319dSCVpGLyO5Zs4yScYOA2QOGwd2CScECvkfxNrRxJhtuQyqM/MSQevIIGcn7wIwAc9a9D8V6s8rSyFwcl2OTk5A425OFOGOR2HTLZNfOmu37XFwydFViCQSwPIGcHaOxAG0ZPJOeT+a5vjZVJzfNdzk22n7yTauld3vq1fu23pqf6ccBcO06FGhGNO0aVOKirWV0lZK17apXXbQwb24EjSklWyRjJ55Jx0YkjoQDxnP8ACCpxpEJYMx3cNgK38WcgHGRwMcYHPI4y1XztVOepLk+p+YYGeS3diDt9eMEVUckKSSQMH/ZIBwcHnHOeQc4J4/u18yoS5td9Xs2na17taJ21enp3f9B5TlXOo80PdVktG20ravT3lrZaeS1sVW2qckZHTaTgn5Rwcnls4PcdzlcCqxcHJXORg5GDgcE8gcDJwcHjIXOOBZ8ne7FidueBjHGR3wFIXgYwDwT24SS4tIECMwyAMKMEnI+6QMHJLAE8jIAwclhjJ20Vlo7O6V1dXSTtq9FrZ9rM+tjhKOGprmtFJJJ2Sa2atzaO/wB9n1aIlheQ/OGUEHHTJwBgEkkgdMgDuCV3AESmOCFVeRwPl5YsB055B6ngZA6McZO0Zx59VkdituuwDIDkchQSTySDlmB7HPUc1mmK5uSHlZ5ewzkhVUAkkc8cdCBjuPXOK0+6/wDm7J3S69zhqYynDSCctVbma5N77fo/S7Zvy6xbqNtuhlYg8gDbkYwST35IyM8cDksao/ab26IJZkHdVzzjoOCSScerBc9utFnpzNsGxhwAQc9edxPJzgDgE9/TAHYafobSlCUYngKNpJO0Z6Ek8EYBwck9MAGt6UJNpK6Ttrq0kuV+m3fys+p42MzRwi3UqOKaV1F7L3VZt6N9E76a76HOwafK5BYNyRwflJGCTnuf73TAHJHSunsdGkbHyHbgMSFzjI9cEngBuTxkZ4zXomh+CL/UJEFvZyMWIwRGXJJAU52joNq4Bycn0Jr64+Ev7I/xD+It7a2Wg+G9W1OWeRAqW1lK6gMQMltgRQAQTglQAcDBOPYwWWV8VKMaVGpUe6cYyera6q+ie1rdN0z8+z7jjKsopVK+NxtDD04LmnOrVjGKtytpuUk7Wd/nd21PjSy8MtKUARmIAIxG3JYgAgnp0OSMg7flAJBr1Hw58Ltc1qSCGx064md3RFWOGRmfJCjAVdxJIyAATkjq1f0I/AT/AII4a7fix1b4nalb+G7IiN20+FftWqOpwzIQP3ULMG53OuCemBkfsP8ACX9iH4AfB61tX0TwVY6nqFugLaxr8UN3KGQAGURygQRBcEkiM7eTkAMT9ngODa8kpYupHDxdm4Jc1SzSbTS0T73aaeqR/MnGP0msjy91cNk6rZviVeK+qvlw6krfFWfutX3dNT20TP5ZPgp/wTl+NfxQe0k0/wAH6lBYSlCb2/heytEVsAu0s8aBlBOSEIwCfvMVx+vfwX/4I6eFdFWzvvif4hS4njCvJpGixKTxtYpJdyAk8ghiqEdQAMk1+p3xI/aK+BHwVsJB4p8b+HtLa2UhNI0yWGe8yg4iSzshI4IOEUSBFT5gWxnP5f8Axk/4LCeHNJNzp3wn8JLdzKsiR634jk2QgjO2VbC2cuS2AyiaVc4GV2k19LTyrIcsgpVZU6lRWadaV5acrVqUbu3k07rTe5+J1uP/ABk8Q6sqOR5fisBgqr5Y1KNKVKMYysnKWMrqMHypf8ukpeT1R+m3w2/Zg+CHwktIn8OeCtEsGtEDPq+qRW8k67BjzGubrKx92JG0c84BFYnxO/bL/Zx+DEU0GueOtM1HU7ZCF0Xw8yalcB0/5Y7bUm1hcEAFZJQRxwBiv5gPjB+3t8evi3Lcxa/481aLTZ2kC6Po0j6ZpoRs4i+z2nlLMuBj5/MyMBmJPPx3qXi7WtUkd5J5izuS0ssjEkkYJMspZjuJJ4AJPA6ZLqZ5T/h4OjKUUkkoxtC6ttGPdLyb63R9Dk3gDmuY1YY7jPP6kqkrTnSo1ZVamvI3z4jEJrbSyp6vaVrM/oH+Mn/BY3UmW7074T+FLPSIf3kUWr68xvb0AZVZI7SIC2jc4yol3gEFTjBU/kv8Xv2yfjN8Wru4k8V+ONd1ZJmcxWguZLbTIlbPyxWFu0UKqOmChQowLdCK5D4KfsqftFftD3scXwr+FvjPxnatKI5dbt9OOmeFLMNwWvfFOsNp+h2ypyzma9VgqnhskD9dvg//AMENvE8tomv/ALQ/xg8J+ANKt4xc6po3guKPxZqdrAqlpYtS8Xa3PoXgrSJUAYNNFdaxbxEIQp2gnjlLH1481aosLS0bir87i1F8yoxUqso2avJKSu1rqm/1PLsm8KeB5Rp01l9fHwtFtyWOxntE4vlsvaSpt2ejjCN10sfgdfa3ruqyOxaT5mYmR8RrySBsZgME8jO5mOCSTjK+1/Bv9jL9pn9ou5T/AIVR8JPG3jSydws2uWelyWHhS0BYgvf+LtaOneG7JEHLtPqSkIuVDYxX71Xnif8A4I6fsPXBj02w0H48/EvSN2bh0j+OviFL2EFQMOul/B7QJ/NAxJFHfz2rjJWZUBb5Z+Of/Bcr42eL7aTw98Bvhj4d+G3h63Q2+n6n4zaPxnrdrbAbI20/w1a2+meBNEMaKfJhGiaiLcfIrupJp0sBheaM/ZTryfK+fEScYdG3GlTcp1FJ2jFyq0Gld6JWl+j5ZxJmeZRhTyHIZ4ahJ8sMXj4xwtLlSinNQaVSUbO96Sn093ez/hb/AMESdZ06zTxJ+0p8a/B/w+0OzUXGraP4Cez8YarZxR4aS21fx1rFzoXw90CZY+Xli1HXvLONsLlRXrc3xo/4JFfsQssHw58M6d8cvidpKlE1m2toPjJ4lF/EDtZfE/iKHTvhL4ZmWYEG48M6Xqt1bNkJNMEy34bfFX4x/Hn483f9q/GD4peNvHZdxLBp2r6xdf2FYqZGUxWHhyy+z6Hp0cZIMcEFjEixtiP7igeaWng4EISgjQKGUkBACTk8EEsegAbvu7gA/V4DCVKjjToUpQjJNclKMqNKztzQlCEpVKtOSdnTrVqllo38Tf3+U5ViZuOJzfMvrFVWboUHyYaPwtRvJR9onvdwjLpdqx+qvxr/AOC0n7Rfj+W4sfg74W0H4R6V+8htta1KX/hO/HEduCQkkN5qVtB4b0NghCiHR/D8CW7D9xIhVWP5jeNPH3xY+MusSa58VfiB4x8f6rNL5pufE2s6hqMUW5iSLSzkl+x2sbHaEitraKIcKEGAK9z+Ff7LXxb+K0sI+H/w68ReILRyBJrH2QaX4cgOF3PP4g1M2WkptIY7TeNKq52xuNor9P8A4I/8EeviL4subRfHGvPDPIUb/hGfhxpc+vaowOMw3PiK/tbfTbWRSAsj2Om6zCckrKwAc/a4XJp0aLr5ji8Ll+FhHmqVMTWhhqUadk3KcX78opW96SaT3a0t+k5XWlW5cPh5Opa0Y04ztFJcqd9VFO+qTtfe2p+H1p4VChGCiIcfK3y4XcACV2Y3fMBtP3TwTtwa+lfhf+yf8Y/ie1tL4Q8AazdabNtzrurRJoPh0KSMynVtWaytJ1Uk5W0e6mCgiOJwa/rt/Zy/4Io+HfC72F8/w88O+HJozHJ/wknjyZfGPirIIPnwWd4tzZafcYAZRZ2Wj+XIMKygYP7BfDj9gX4L+DWtrvxBbXnjnUrcJh9YIg02N1AH7iwt/mVFYHZHLcTRhRjYAWr4/O/Fzww4Sc6f9oS4kx1Ne7hsohGvS51Fe7LFOccNyczadq8aib1hZM/UclyuFNwrZjXlTp2TVHDR5qs4+7ZSnOyi7KSv7y1s13/jF+Cn/BILxp4zurWLxHqOp65dsULaB8ONFu7iJGYDMdz4n1aySGJAxO97XSLlF6icLhh+2v7P3/BEK18OfYr+68L+E/ARVY2fV9RQ+LfGRUH/AFgutRWeOxmcfejsm09AwH7hOi/0aBfh98NNGwE8NeENGtUBwosNMt1VB1I2whm5BzyzHnk9fk34o/t9/BXwJDeJo91c+Lbq0WQyvYItnpcJQctc6ne+TCkIOd0qB1VfmJAr89Xj14p8V1ngPDXhJZbTnKNOOKoYSWYYqKk0uaeLqwp4Ggm2v4saijZvnbV1+s8O4nHxqQjwnw1RqYiNl/aeYU44udJrl/ee1xHJgsNaybbTSVtWct8NP+CcP7P/AIEaC+13Srrx1q0Gxjd+JJme08xdvKadCsVoVyAAk6zgKAucYNfWs2qfCv4QaMq3N14U8GaNaRjyogdP0uBFQE7Y4kWNmOAPlRCxPQE8D+cT9pb/AILoeHNGN/pXh3xjY2c6+ZENI+HcMPirVwMEBLjXpJIdAtJc8Oyaok0ZGfJzxX4L/G//AIKwfFHx3e3z+H9OWykmZwut+M9UufFmtFWY7ZI7HzLXQ7RmySIpoNTVCNgZgcn08J4E+J/HVWGY+J/G1fBUZNN4Sri6mY4mmnJPlhhozhgsMtXZ0IVYRsvcs0j6vGYKtmDU+PeP3XcbP+x8mqvNcRTblHmpKNOdPLcJLaN05KPZ2P7YPih/wUz+CPghLyHwpDf+OruzSQzXNsV0jQrbygdz3WrXyhY4VIJMi27R7csH24Y/jF+0f/wXPjtft+mab47sNFDGSIaB8LrWHxNq4Odiw3fie4mh0e1k/heS31OGRGy3kn7tfyL/ABC/aO+JfxFlLeM/HOu67DuZksrm+eDSoM4wttotl9n0y3A+XiK0T5Rg5AGfA9X8ZM6oqy7SJIwPmKpk5ALE4U8D+6eDxggA/r+Q+DPgzwXGnWqZfLiHMKVmsTnVSOLg5rls44SywqW8k44aM07LndrvXC5rwTkavw/wrRxeJppOOacTVHmWIvdWqU8BB08BSkt4vlqPVH7K/Gj/AIKl/ETxteXzeH7EabJOWDa74r1Ofxf4iYncQ4hnSHRreY87Uks9S8s7Qsp4I/NP4j/Hrxv4/uXufFni3W/EEmWeOHUr+aW0hzklbTTo2SxtVJ2lVtbZABuBAIGPmO98TPIzIJiWOWbMjEDBCk8LtbgZB54+8CAK5C/8Q8EtLlRwOmTggkYBZmIIJPIIPHTGPvMTx7hcuoPC5TQw2X4eEI04Qw1NU1GEYxSiuVXaUUkk293s0zPNuOs+zWHs8bmmJeHgk4YSlL6vgoRVko08LR9nh17uitBtJWvc9N1LxeX34YngiQbmO0kfKCABgfMCGOQMYGQAD53e+ImNzKd+8eRISNzYGWIwVAx1xjJIHzZ4xjiL7W1cbUkZX+UqwJGCdh53yMMtycgnPXj5SeTuNVZpmIZwphkDFS5ABVflIB3dSSTywDAgnO5fzPN+PMXXb58RJxbSSjLo3FejWzabvu2lufHV822td8sld3VnzWuvOzevZ32Oo1HVzNj94Tg/LjIDZC87iV6kr0G0gdic1x93fEOzb88OCmSSoPIHsMjBPBToWPIahcagGJGQVxt59Mg4PLEAdcDkDvghqxJ7kkBVjO7H3mlDA7dg27WwxYj3GV2lucEflOb5/VxTk5VW7p3TevbTV3jr3vqtrnhYnGOV2pX0669Fo1r/AJPpcLy43gqzcBgA2AMHgrliyfKWZd+DxwR82c5bSRuxZTnblWVZHJVsK20qQGUKGUKTxk53dKWSXfkDjqDgAlcgABQcgdQf4gNu5Sc4NJpV3DcymThUfJV3QAFI8/KX5IKqwO/BJyQQfgcViXKbfNu/tN94uy12+Xffc+exUuaUr2Vr3er1TS0d3fVXS8r2WiV1WJZRgk4AOM5IG0Djo/ORuyDz8w2nNdJo6lmPVRuACk7RuUDjaD1PQBicZOME8czCpbaA3zBgcKOnQHO0jPpk8nJUgDJruPD9qD5bYYBmHHryp2kDIB5AOCRx6dOSnHnqxeunxOOy5mrap38tmltsfM5zUf1ZpvSThGKdm9bNJtays0+rslvo7fan7FvhK18T/tBfD6bUbMahoXgAah8V/EFo0fmw3unfDizk8S22mSpja6a7r9pofh1EbImm1aOJSzSKr/0Jf8Fi/Ft58Av2HP2Qv2KLa6eTxt4xtZvit8VYI5c3Opa7eXF1rmoS3wQ+ZK+rePfFGuXSbwxkn0y2AwVQL8Uf8ERP2fx8Sviv/bl9ZNNp/iTx94Y8I3DSqGhbwP8ADKSH40/EncTuzb3+uaF8JfCcx4jk/wCEikhblijZP/BQX41J+0//AMFQvin4j84ap4D+Bksmg6bFGBLavpHwmtzHdQxL93GveNlnjhIIE7XsfLMoU/o6w0qOXZLl7jKFTF+0zSvrq1iJPDYVWenuYWliqseivdO+35Txnh1nfGfhfwG3fC5TSxniLxNDTkj9ZlDB5PSxCekZYbDYV46nf/lzjJvmsz56/aAlHw3/AGdvD3ws019+seP9V8MeD/JhVjJJ4W+EMMeqeKNsaDEkGvfFnxKtom0M81/4Ru1XDx8for8FfhyujS/srfCWxs1mHhTQb/42eKbOONX+231v5PhfwJZXagMkjXWp6Xrl/ZhwRIniOKSBi0hY/nffeGdV+NH7aHgb4SWjC8Hwr0vwj8Org+YZov8AhOLm4j1/x1cO/wBx5B8S/EviRpZCMm30ovJuMBz/AEL/APBOTwLp/wAZP2mfHPxOggWfwbo/iaPRfDAaIPAfh98HYbTw14YeJuU8jXvEFrp+pYT93dPZXjsqSFg3sYepCjh8yzKpdQjL+zcNFtL9zgoxr4mKikklPETppWule2vT808Q8/eB4B4x4rUnSxPGGaSwuWwkuSbweOqU6OEhGO8fquSYfDwcU/jbfk/6A/hX4Oj+G3ws8G+DPle40jQbOLU5QObnWLhP7Q1u8ZiQSbjVLi6nkZypPmYJZiGr+Ir/AILTftQL8Z/2oPGGlaPqIuvC3wyib4deHVjm3Wst1p0ry+JdQhGdpFxq5ltjKoy8NlDgkbcf1+/t2ftA2n7Nv7MHxW+KTXEcWsWOhPo3hOORgHufFOvA6ZpKwqSN5tp52vpFXJENpI52qtf5wnj/AF698Y+K7q4ubia7uLq9nubu4kZneSeeYyXNxIxLb2mmd3Zm3bshjknJ+ClVfscRVmnKvjKr2vqnKM6jt0Tk4xXblkuqPw3wF4Pln/FzzerH2mEyiEaVFuKknjcRGKlJO11KjR09MQ7apW5rw/pUlzMswhkkknkWKGMBnklllIVVjUKSS5wBt3OAQgUt0/oW+EOh6J+wt+ypf/ELxTbwL8QfFVvFfLYXAVbm68Q39s40TRdhxILbR7dxPfKvyRyC7YnJAPxD/wAE8/2dI/in8TIvFWtWiyeCPhy9vqNzLcqDaXmuoHm0+0diAjR23lNf3QbJVY4hIQsoWue/4KEftGR/F74nT+GPDF48vgTwDLcaJoSwyfuNQv4nEeqayU4VmmuEMEDHlYIlIfMpB/W+GKdLgrhrEcU14r+08wpzwWR0pJNpzuqmJtbmauvdt9mDV7VEz/XfhLD0OCeGK3EFZRhmGKpywmSwmtU5JKti2pa8sU7J7Pl5dFM+LfFPiTxD8TfG2oanqN69/rfiHVLzU9Uv7uRtiyytJc3d5dSkkQWVnEryTPxHb28fOEjVTj+MPGtl4O0KDXrUBfs9tPo/w3s7n93NNLMMav49voGw0dxqGFmtEkBMFothZkhI4nk1o7G18OaRdWepSrazXenRaz4zvHJRtH8OyBbrTPDKy5DQ6h4lbyr3WoVUzw6IttaBXkvbtF5j4LeAdY/aa+K512+s7ZfBugXRttOtdak+xeHRHp1jd6066zchlWy8LeH9C0zUfGnxCv4SBpHhDR7uONhcSWIk/OqtbEuTrVqjqZhjasmnNuU1JyTq1XzW5vZuTtfWVZ21cD8dx+Ywx1bF5jmGLVDAYONbF47F1vhjRp/vMRiqjb97S6hFJynJxhFSnUjF+wfs3eF9E+D3gDxL+0N8TdNi1a7kjsho+gaqz+f4o1vW0fVPCPw/uInZJ5bbxbH5Pj/4nssbJa/CbTdP0C5uoLz4p6Rnpv2a/h7c/Hj4neM/j58cdYvrvwP4TvLnxx8R/El1GZrzxDrF7eloNH02JVxc6zr2qSwaZo+nQBUVp4LaBFAhjXznxt4h1X9pf4teHPhr8Mv7R1PwZot7PoPgsXdutlea/dareR3Hiv4la7YwboNO1fxxqUP9rTWnmTp4X8L2WgeEbW5fS/C9iK+tfiz8SfA/wA+FWl+G/CpttQ8P+Cb64sPCkQUG3+K3xkgtzBrfjvUEDBb/AMI/Dk3Eln4ezm3u9UlWdWkV5BD72RUsLhKdTPsxSnlmVy5MDRqNr69mEVzRlvadPDuXtajWk5OKSUqtkuHsThsup4rxFzvB1FUlCnl3COQ1/dxEoNKeAwbp3fLUr1P+FTO6sVaEnChKbpUKTXkf7b/7SWrarf6l4ZtxHpXijxXpmmWOt6PpsitZfDb4caeqt4U+GGk7CAlybQpqPieYBTc6ndT+YpaSUJ8B+A/B2reLta0/SNJsnvL/AFG7htrW1TYGkuZyqRh2YiNYYF3y3NxK6xQRI1xMwiR2HIW9xq3jPxFfazq11cX+oaldzX+oX105llubieUSTTzOzbdxdiY0GFzhVUKMV+n37M/wP1vXL7QfCnh3Rb3VfHfxBOlaTb6Vp6F9Vt9L8Q3KW+ieHLEhC1vrPjwSG41G4AD6d4MV9zKuuXPk/M1sXjeLs6q5hmNWTw9OTm221ClQi01GKeictXq7NtvRJ28irj8XmmMxGa5/i+bkVXHZni6klCjRpxXtJwhdcsIU1H2dNaJQinK6TZ9zfsK/syeH/GWsX+o6xI1l8BfgR4Z1f4lfE7xuAbe31yKwtLmPWNYiuHEcgm8RPbz+EPhxaOXuLHQhqXiEQLe3lx5v0/8AsJW1/wDtGftL/GX9rDxFpqWmk6IE8EfDfS1iC2PhyzubZLS00rSoQPJt4vDvg6zsNIRIVUD+07hsh5HJ9V/4KPDQv2G/2Q/hn+wt4Lv7GT4ofGV7H4j/ALQmsaQQjzaTpcscWleHoimHXQ31m0TS9Fs32IdL8LTXDRq2qTiT6A/Yd+GCfCj9nDwDo0sBttV16zfxjrq7cStqPiRheRpIWwxa309rG0ySSogIx0z+lcCYeOaZtPHKKjgMtj/sceVqLkn7KjUcZOyco+0qRu29ISbu2z7n6MOFq+JPHuL44rUJxyPKIVsJw1QmmqUMHhasaUsbyu9quNxac4uSUvZYWk1ZOV/kD/gq1ZAaZ8Lr8qcxrrsCsBnDCWxmClgCQPmLHHUkkrgcH/BML4vRPY6/8L9VuD9nv4/tFjDKf3eHV4plK7/Ux7gBjf8AO64AA91/4KL+AZvGfwUXWrSFprzwdqS6k4VNz/2fdq1reHCknClopGz8uFZuo4/FL9nH4h3Xwy+JeiavBM8Is9RgEyh2Uvb+aBMjFcHHU5PO3k54I+p4vwE44qhiZX9ni8MlGSWinCSg01unGydnf3Wumpp9MrgGrxPl+eqnRk8bCjh81y2dve+sYOlT+HrFydKVO3RP1PqT9tv4av4G+Jd3eRQPFp+oySbXH3VDyb4mVxkMVV8A9N0W0fIFA/db/gm38UB+01+xzrfwh1e4jufHfwsVLTQ5biTfOUs1e+8K3Dbj5rRsLe70eZiNpsrdLZgEfD/GX7YfgSz+LHwisPHmjRR3UyaXb6ik6IHaSPysuG2gqVfLl1BIRzwSJMD5b/4Jj/HaT4CftM+GbXUbw2vhnx1PH4M18SyeXbRnUZVOkXs2flH2PUxAWkIBMCyxnyyzE/nE4VIymqLccTQnSxWEne3JisLONWmrWatJqUGre9Gcltc/y247wdPjfwrwudVKTnmfC/taGZwUXKq8FyLD5hG1ua8aFsXBWT+sYek1rFHyL+1F8J2+C/x78S2FnaNY+G/Etw3i3w3Ey7EtrTVrub+0NJH3gsmiaxDf6Uy8EC1jLBQ+G/VX/gk5+0Jc+FvFurfC2e98qPWTD458FpI5CR+KNAt863p0Q+RR/b/h5JnZVAL3Glw4GS270T/gsX+z+kukXPxC0GxHnaDO/jrTngjUs+g67cw2XjXS1MfO3Stb+za40acQW95PxjzGP4dfBn4kav4B8XeGPF+gXLW2r+F9Z07XdPdXZQ8tjMkpgcKSTFcIj286fdeKR42JDED35Sw2LUWoL6jnGGjWjTdpKEqto1qU0r60a6nBxa2Vna+v43mWGxPHfhtKMar/ANY+HrU6OKTaq0s0ynkrZfjYTspQ+s0o0anPG3NGpO2qP9MPwX4jsfiD4F0/UojHPb6lpqFlysnEsKh1PUZDEqRjt0r+Zb/gsj+zQ0/hyP4kafYBtQ8B3r6LrTxxkyXPhHXLkvpdzIVG910nVJUtyzMwCX9wWwq1+v37BXxt0fx14T02PTLpZdG8SaPp/izwyu/zNmnavH5t3p7EEDztJ1A3FhMPlPmRHIHIHrf7YPwh0f4h+AtcsNUs1udM8QaNfeHda+RZCLPUonghuVByDLZzSLNCxwyS4lyNgNfz9kXNwTx5jckxDcMBmFVwpc1+WUKkuahJX0bXNKnpa89Oh+w8YZtV8ZfADgvxdwEOfi/w6lBcRUKcV9ZUcGo4HiLCVFrKKnGnHGRUubkppySuz/M3+JPh029zcBUKqXZlGP7uTjIxz8qjJJyTkEgkj5O8Q6dteXGenUA/wsPvKuSFIAzk9OF+UqB+rH7Sfwl1b4d+NvGHgrWYDHqPhbXtR0a5yhVZhZzOsN1Hz80V5bCK5gcDDwyoV4INfnT4t0nyppvkwAzZ44xuHI6DOTtHPBYKuOlfe59gHCrNq9lL3WkrONotNadU03o07J73v9Z4c8SUsfgcDiaNRSpYihRq05KT1jOFOS18+a6v1bPmLUrQqGDJzyQ33uAAQT0bnkDIIJUg4PNcHfQoQcjapBIyST1XHzPxgnHGADyTtYV7JrlkBuIOOo28k5wmG3kjrjkAcjGQDjPmd9bbc7hkg4XjnaMZ55J/2m4IGCwPJPwWIo2crdbbeVtHZ2en4q+ltf6SybGqcIPmu2k7XavazvZNLtpZvy0u+AuogTjHJwACucj5c88A/XHOMVg3CMGYqFzjA4IBAVcggAhlHPJb1ABFdfeQ7VYnjkAgZHTAC4UkkYwTkqckdUrnbhFDcnJA6Fc5UheA+cdc7CeSxOck7T4tWCva3ou97Pla69dGtfnr93ha1+WSemlk9e11umultWk+l0zlZlb7hUkYLE8AAAD5Su772VLAD5eAASAaz5Ufp/skgkDodi56NyMcLgnIOzGGNbtxGNxxjh+MccEjB+XAHYBhjBHQdDkzRkKyk7fQnK8gr1xkqTtAOAo4J+VskcEo2bT+Wisr26W+/W35n0VGcZKN3d2Teid7Ja3d17uujZk54yPlKsuScDOMAkAgMxPJJzwDg8YqJ9rnac+YpGGGFGBtYg5I5C43E7cryck83HjO31BCgZ3EE4wCQx5J6njJA68AVXCKCWBOSCCmDuOMA5xznp2zk7T8vI5ZrXfR2v8A+S97q/yWi9T0qVSz3s7pq766K2u+2llZ2eneqwOQcEr9xlGVGOMOQcYGBkAYzgA5BBqnI6B0QDYuPMO5kV3jOwboxuU5JI3FcjAIz81XpPukFQW3AgLgEH5RjjgA5HHBBwAcc1nTWUdw2WLGSJiysrOGTaxdkVhjKZ2ZwQcjJAwTXJVjJR91N7NbKOrjq7NttJKKejsm29Gjrg246SstLpWto01q3slZq/a70bvJmNwCrHGBkKxO7pkg4J43dCOdozwwNRspA7Ebc5J3EEhcAqyli2MMQTnnghcABEhuGAx5Sxp153SkkgpngKoTDLvJDAkjjFSAKAzAgcYIyeCQOCBjAB6H14Hoc4/O7Suk21fTVX1tpa639Lt9cHor311u1Z2umrKzfotbqzfcrMSAqtgspAJUKQfunLEE55AwQAxA5UkDEZZmJwO43bcDeo2jkruPOMkrx3JwGqQAF3UNgFuAfmBGVKsAQATyMYGDnBKHOSREVQckZAVl5xkgctggc4JHO4YwBzynqne9vdWqTSejW2929UnZ2aXnsneys9bWd+rS6Jbt3+VtLtFcKMYQ8HDdSe4wMLwOMEEYBycck4Vt2wnhflAUtgrgbSMqQepxtOMgc96UheAzDAwF6HeAQc/NwSxyAuAp6suOkYJALsMkAKABtIGE4wCR65YY5x13AjKVo97L3bXS+Fwau1zJXffvq02yk+2ur0utV7tnezVrp6N287CY2lcLgAKvQDGMcgDoDngsSVXkFmIYRsWKFomAYnOSCyMAAzADCjjOM5YsDwVwdy4R8KxJQ4yCNu3/AFZwzdMAnpk8EFT8uKUoQVWIF+M5O4hWGANuW2FiMscZyd5IyAtJqLu23dqKunZq6ikml+O3ysOysut0/tatpRSuo3tstd7q/kQhgjhlUtgbdmec9SBtxtOdwY5yAc5KnAQhpDjZ5YUgBuFAUHOwEl/mOSQVI4wTgqpKqGYB1BOWGeMgscAAgg4UnIBK8H5eOMyJ5o4VUUctk4Y78AsgKrkE9G5O3gAkAVNm+trdtLfC7W7b6dfQqMbtO7d9Fo3b4el+y2dnfW1xoGSrBgHXByS20klPk2EjLEAgAcHhcAgYcJT5qiWP5duM/MSGDKrMQ7bgwKltjZK5yG5Clo3x8FS6YLqwbkFSpaJgC5YjbuIyFUnLHGSrmDMoOAGYg4GMlTt3L8uT/F8+SCpOQRQ72um03btfVx9L9E+byfRFx0cGt9LtJNp+7byatrr162sSKQV6oVZmiHCkMCRg8YG4nkD72FIJLApTWj2hWjyT8sb91OCrfMVOVYt+7AweNpA6ihQQuyWMOQDs2lPm284AbJySM7iFyDhhnGJInyd+AOwyFXLYX7vIwc9yMZOBk5wrO6bSV7Wa5elrWsteu70V/i1Nklyxu7NtaXjzLbRbNPdK6d1Zq+zki8wq6sMMGxkhWO0FcDOTkZwAMYJ4Yg4qGNdyuB1V5AHUckZUFSG3H5FOAMAEleOCakDyllj8sCMrvD/KWOCAFX7uW4Zhx91iyMGGC1ZCXOGCjed7Agk/NH9xk+bAcMDx94gE8jMyas9k1q/NtR16XXS7etnrohvlbVk7pN217RbSvq3d69el1dp12O4qqOitGVmkRh8qgAAxlQoLEgn5SQcDawAIq4G3cEdlCjG0DhcAgliBwSFx8owRkEGs2OG5Ta8jKVZ13xop+cnYN0jFgCdyY5YkvwxKk5vuJDhoyNy/KVKts2bQzLgkLu64APOeMrgV51O+rakno+V6O3onZvq9F5pXVviakU3GPNFruls0lbm2+/W107ljOXyVywGM43MMEdPu4yflPBJHDDuH8HHOBj0yFJOcY5yMZ4GSRkg4yKrpKu9kDKDGVYg4BKnYQzE7gQd2HAPy4GSe04BweQV5IAyMDCkoSRgnPQ4C7QSDgZrZWtdNb7aOz93R2062Su/LTQwas0nvZaaJ9LbprRNPVdH5Xb5mGaNY34j8wNgFQCFVWZnC4YlSUBOPlVcgnFTJ+8VSCzbTgSAEM+FBbcAW5bGACRu/iGOaqlvsxaQyySedLgxkbwC23hRGw2hOeWznc2Pl3k2Y5xI7EIRDs3rK4VTKcqcKmAQiFc/MWbuDgqq1CSvZ2SulZq9lo72Widrb91voKaeko+8o2blZq8lyxdle1+iSXe1wgaeTc08SwqWxEGbMxClRulIyoJ25ACqccnnBqd03SLkhsEuRuKqVHJBBwGYnbkEc7c980wsVZADgEkOWG4LnGWJ4BJI2gg5bnAPQPH71iSCCrgAIeBtK/McNypzgZfoRnoSbSXwv3pRs9Vo9m9l8rdrHO3f3mlBO6SjrZXsrJtyei11d3dstxkt86OMYCsfmbjKg8lTgYz8247TgkkVImXTgjDKduMMSTj5lIGNuc9uWycjtTRvMAXY0aMdrg7AAm1AVVSSTnO1h96MdeNtWBGR5KxtsjSQDYMlXjBTK/Mflw2DnAyWztzkVrHrfXS2mqeq1Vt73utbXsk76nPOOyvbVPVXVlumk7u/S2nmWooyNodsxlc/OAHDkoGBLsw29XIyu0H5eRViSZYgrOrlX2x8AY3HaYy5ZVQAAEnBU8AMcsNrIiA2OWBBxjC5BwCCynATJBByAcDnkYsLEjqIcsFwARu+ZiPmycZPUjAwp2ggkA5G0YXTUW3pf5uy1t010vtvZ6W4pTi2nKK6XSurrTVK71VlrfbbfS7ApLbnIdcjIxnGWU/uzhR1Ucjac/LjGDW3AACMAguVGAwBOQgBCnP1JHfaQcVmwI2UHUsM8bjtyBwMc7gMgMTkENgsCQNm2DBkZUXaOGJ5LfMmFUZUddwyc4K4JA4PfSi2lo9nez7pJya1dr/K10mk9PFxU7p620vq7WV00le/rvqr7JmjaRmPEZU7hwC/Ib7vTdwScYXAIyexGR0llEN8ZwQMDkjh2YDAGACuMZ3FSDjG5mUVmQpyvBwMA4POTgE8Ant3I4OeDmup06AkKSFKqEwSEZiDtIBYnJYt1yeQmCAQpr06MXdcqs1a2qs3ol9/ztu9D5nHV0otyejS+9qLfnslpp0s7G7Y2u9YgxkV1ZSu09SSo2sOM857YGRkcA132mWe6SPbjkqTwo/u57ZAwedwHPfAxXN6fbbin3mcsoBU87/k7DJOCeucluT8q4PpuiWDGRPuAnZ0O5WwEYfKF5653bsMT8uMbT9DgsPKbgttY3cvevt06vztdb6an53nOM5Izd7WUte22j3f5a9z0fwtpTyPEVwSUHdnGWUcbQAASANpJBBySeK/QT9nH4T6x8TPHHhHwHoMRfVPE2rWumxyhCVs4JJBJf6hOEOVttOsUnvrg42rHCxXkZPyR4G0Vp5IEMbZJXqCc/e9VAUsccnHTvnB/py/4I7/sx3evahefFW701hNqt4/gjwW8kP3IMxXHi7WoVIwVhiWDS4p0IGz+1IgysCD+n5JRpYTD1cfiXGFDC0ZVqkpNJJQgnbm06XdldW1P5J8WuJMVSw6wGXRlis0zTEUcryvDUk5VMRjsbVhh8PTjBazbqTUrJ6xi3rpf+kv9hX4KaN8PfAulSabYLaaRoek2XhnwvGybWXStJjWCe6bGA09/dI091IV3STo8pYtKxGD+3T8bdB8E+GNWi1i9WDw74S0e78X+LSHA32GkgzWOngbgHm1K9SO3giz88nloFJkAP3Ew0j4Y+AD9y003QdIJZjwEjt7cEsxGNx+Tc2OWOQck8/x/f8Fg/wBpy7utMh+GNnft/bHxF1AeMvGEaSDzLPwnp83keEtClwQf9PvYpNSmhJTCWNpIBifJ/P8Ag2jPi3jDMeKsbGUsDl039VjLWKmrQw8I9LwgvaNpaVXF/aZ9V4xYb/iF3g9wF9H7Ia/JxLxvy4ri3FUG/brAOcMVn2MqzSc39bry+p0XUt7TD050krRR+Gvxo+IHi747/FnXfFM0U+qeK/iL4pA0/TrfdM32rVrxLHRNGtFGT5VnBJaWNsmBsjjjAUA5H776rPpX7BH7AX2DTbmCLx5480i6+H3hq6gbyri5lunlu/iD4uhcYlMWp6tLdQWczc/2Va+G/KfZGGH5pf8ABML4AXvxn+Oa+Nby1Mmi+A7qCw0q4lRni/4THXLa7f8AtKLcCjnwj4ftdU17eCVh1KPQkcK91Ga2P+CnP7QNt8XfjnL4L8Jzj/hXvwmtY/A3he1t23WcjaUFg1PUIgpVXNzdRtEkpDN9mgtgcgIK/YMRVjTpyqT5XKo1Wnr/AMu6U19XpbaKtXgptWTdPDTi21Ox+SZTkEeI+LOHeCsupKGTcO0sPicyUEvYvkpUlCi1HRqlh5xp8u7ljObelp8HeEtB1Hx14ssdMtY3urzVdQjiQKGZ2e5lGXYAZIVnYtnsMnpX9EHg7wzpXwb+GGm6TEiQwaBpCz3eAA1zqUkQdgcDlpZ3CgEFh8qEnv8Am7/wT++EX9q6/e/EHVbUGx0BfK08yjKSahIrZZSxAHkKOW+XDMpzkV+ifxClvPF/i/wv8NNHUzXGo3ttdanHGpOd80a2UDhcMFLFrhuvyIjEZBYexw9hPq2DxGbV7KriNKSf8qslr3nJ3enwJM/0SljcJ4a+HWc8V4mMKFWngKlLL6dRKPvxp8lCEU9feq8spJO/LDR62Ps39hX4dzmy1z4pa3Hvv9bnmgspZFJYITuuXj3cmMfu4EweEhcA7icfpBGCSCpwOCQAe3Ofrnkt68gknNcF8O/CVr4J8HaD4Zs0VItM063gYYA3zBN00hAAO55GcseSc4B6A92pJ5zj0Y855xk9MbiQOxHXr0/Ps4xcsZjalVu8IuMKTbv7kWkm+a79+V5aa31SVrn+U2MzLFZrmGYZvjasp4nMMTWxVapN80m6s+fV3e0Xa3bTfUbO3ljO5RyTg8Y46Ak4Az8x9Rx3WuSv7kKrvIQFUFwdwwCOcD5jjaPQA8twMGtq/mGCAw6cr0BxwAMtznptIPv3z83/AB3+JFl8PvBGsatczIkotZkhVmxhyjDIyQcL/ex6jGDkPLcJPEVqdKKs6jSbXRLlTl20W7v57nyWb4rmfJTcpyclGEE03Ocmoxilpa8mrJrfvuflF/wUp/aCS2tJfBek3oVcSfbPKfH3cjadpY5JGem05XgZzX8xvxJ8Qm/uZ3aZi25yCTkjJLcncSCSdxUjncSMOBX2t+1L8Wbjxj4m1rUprp5jLcTmMly2VLsAM5wCcYPRQvBw2TX5jeK9YMzzO0nBLDG4jA56jK4J4KgccDnOAOviXHU48mEo/wAHCxVJXeja5XOT/wAUtfw2SP6v8FOBnlmXYepVp3xmOksTiXJK/PPl5Y6u6jBaJfPXVnm/ifUlVJWZsDDYxnOAOMZ+bvyOCDnJHNeNyzNK7zH5dzHkt93OCOMNzjAO35SCx5yFrovEN+Z7gxrISoLFwG4zn5QOeCeAeDnHGAK5N5OmenGevYKMn0B7DnGc9Tx+YV5OrUlKza6K70u1d7vr0Tu3r0P7z4Xyf2NCjDl1ajKTad9l6383vbp3axZj1+Uc7R1OCNx68cbSuezf3TkRGMevXBxnlORgn1weMgLg9APvVJHE0sm3PBzxu4CZA9SeOgUfMcYGRkVoyxLsA24IwBjAJGBntuJLegGSTwOtXTouabbsrq731vHR9erva9mu6dv2fLMuVOnFvRWVrrzi7Kyt2te/XSxz19J5VuSpG4gKD8oyTwM5H94Hp254LLXIGOV23NubPXHAxnvz9O/zHjgZrrtTtndDsDMu4HIHBI4PcNtz90ntyDxxRsbF3OwnlhtG8g88ZySNpOeMAZwN2Vwawq4d30d1100b91pptq2tle1+nW7yzXBTlJqLaUUmrbN6aPZPaz0urdyOz04vh2AwcdAM9uTjPOMk+3OcAV2Gm+HpbhwqwnnByFLDjGD7sSOO+D26jrPCfh77TNHEYw+4qoBGccscjkhcNj1I6dSAP2t/Yr/4Je+Lf2gtDsPHmq6lZeGPAs93JDFqVwpnvL9rd9twtpZIRlIzmPzJXWMupALbSD6OU5PiczxDpUIc0o6ylK3LGEXFczfSzdnrq0ktlf8AAfEPj/J+AsFPH55io4PD8/sqcppylVqtOUaNKMVKUp2jK0YJtJPm2Z+QnhT4S674iuIoNO0y5uZZGVPLjhd9xY/dVQvLMcBVG5gSRjCnH6l/s8/8EsvjL8So7LU73w7N4f0icpIdR1tGsYnRsH91FIqTy4HzAhcNj5QAQo/pQ+Bf7Dv7Ov7PWmw3tloOn6zrFjEjXHirxQtu0duyL88kEcqi0tVVjvUjcwADNLwGql8av26/2avg1b3NrdeLrXxJq1sjBdG8LrFeJFJHwsL3ERFnEAQQzBnZBgbc4z+g4LhPLcLy1cxq35Wm4p+zp20unN6vV9Lbadj+LeK/pGcX8T15ZbwBkmIxM6zcKeInQq15+9ZKcKVNNQ1tJSrSjFfajc+Wfgt/wSq+EngP7JeeMrqbxRfQ+Wz2NpCttp6sBkq8jB5ZFyGLkspbJHAJC/oRCvwR/Z/0EvPL4M+Hek2kXMkslla3brGoyMsxu55BjJADksfunDAfgD8d/wDgsd4+1s3uk/C7S7XwdYEzRx6g2261Qx8gMszDZA5OGIjTfvO7O3GfyM+In7TfxE+IWo3Go+K/F2ra3dTOzFry+muFXcf4RKzImASAu1VAIKfdyO2vxFkeVwdDAQ53FRV6S5Yt6fFUlaTe/Rrt5+Blvgp4scfV45hxvnVXA0KjUlhJTlWqRXu6LD0pRw9Jvo25y/mjJrX+pD4w/wDBVz4OeCBdWHw6tLnxrqUO5Vv7kyWWjpIpIBjyhuJxkHGEiDA8dsfkv8av+Cmvx3+Jf2uytvFD+G9Hn3KumeHA1jGkRDAJLPFi5l3KACryqT0boBX5W+HJvEnjYXEulQi6srBrZdR1G61HTdK0XTGu5PLh/tHVdVurSxtnd8FEe4ErqSVjccH75/Y9/Yx0v9pb4o6d8OfEHxf0bwVLqOm6nqNjPpPhbV/Esut3Gkxw3V9omi3uqSeHNHa+Sx+1XsmoNPdaWEs2htbi/uZYrZuOOZ5nmqTw9J0KM7SVS3KrJJyfNO0pLuk+mx+lLws4C8NcDUzLOMO8ZVwlNVK1bF054yqklFqaw9GnJRejfMqS01u0rnyfr/jrxJ4nupri8vbu8mnkZpJ7yZ5mJZgSfNnJVAeSCGL5J+/0HRfDT9nz44fHDVF0r4XfDvxp4/uWdVkPhnR7u80+03vy2o6vJHBpGnQAsS895ewxgEEFdxFf0EH4K/8ABJn9iaRZ/id4v8OfFXx7pYDNpviXWW+KGvrexH/UQ/D3wUp8J6ZIXGEt/EbkQNhZ7k7Sa8h+LX/BbSz0zS38HfswfA+x0TRLVWg0/WfH6WWnaXaIMxpJpnw58GvZaXCqgAoNQ1W8Vh8ssL7iBay3DQtPF4n203aUkm7fZs1dNy72tHfRq+nkQ8Uc+zFfVuBeCsQsOnyU8zzaMctwEY6Lnp0789amlq1GaqKNl7N7Hjnwd/4Ik/GXxD9n1H42ePvCXwn0qNRPf6RoiH4ieM44ACzJdNp89p4Q0g4XDT3PiG6SBm3yW5wa+qoPCn/BIv8AYXYTeKNW0D4x/ErSgpMWtzx/GLxKt7Fk7YfB+hLD8ONDk3gGNNYuHmtpOHuJAh3fit8Yf2rf2pP2hGmi+JPxa8U3eiTuzjwnoEw8KeEYY2JPlroHh9NPsZkBKhXvFuJWyS0hIzXg2m+B3dkP2dufvZXuDtyzHIZhySDnHfdgiu+jKEbQwOEdtFzSXL2TaScpu+7i52ukrWVljVynizO4+24z4ynhqErc+UcPJ4Wglo3TljKiVWrC3u2qUpWWqnd3P2y+MH/BcHxnf2snhr9nH4RaZ4P0W3ja20/X/iB9l1O5s4AhSKTS/A/h2PT/AArpaoMNDFO2qiL5lbeuEP5WfFb9oz9oz9oK8e4+LnxW8X+LbZ3Z49Dk1CbTvDVspJ/d2nhrShZ6PAoOAgW1J2kB3Jwa6f4Z/s6/ED4l38Gl+BPA/iTxbfO6RtFoWk3N5BEzH79zeCIWVpGOS0lzPEigMxY7Tj9XPgj/AMEZ/jJ4yezuviHrOh/DyxnaNm0jTYn8Z+LXRiD5f2fTpYdEtJWX+KbWJmjfIkt8qQe76nXhTVbG1aeDotKSc5RpJJuLbS+KVtW9Ha13ZK5vl+ZcBcMVIYfLsPhsRmXNZOPNmWZObUVZtutWhzu1uVQhdpdj8I4PCskr2yqirGsbbyyGMAkqNv3QuQpwruWZfmwDtyfoP4UfsvfFv4v3qWPwx+G/i7xxL5ixT3mkaTIui2jsQN+oa/eLa6HYIg3bpLy+hwikrk4r+w39nf8A4Io/A7wW2n6lf/Dx/GerQGOX+3vircrq8aTDGZLbwlBDbeH4gMfLHe6dqLodwNwxANfsL4D/AGS/Anhazs7W7ghubWyREttJs7S30vRLNExiG002yiihhiUAKqxJGNoKhVHT5XMvEPg3h9Tg8T/aeKhp7LDJVI8ysopuMnF2s7qpOjJa6XufvXCOW+IfE9KnPK+G8Rl2CnblxudReDhyOz51Sk1WnF7x5IvS13e5/Gd8Ev8AgiJ8XvFLWdz8UPF2ieDbebYzeHfBdlL468T7SQxt7jUP9B8MWExByZbe91tI3Ybo2OTX7Wfs/f8ABEr4S+B5LG/X4cafquoQsjnxR8VJovFepBwBie00Ca2j8PWMi43RhNC82IgAXBGK/oN07w94R8IWxNlZaVpNvCuGkVLeAKFGBvlYAngc7mOOSe4rzrxf+0J8PPCMUwF62r3EKMxttNUSZ2+spKx7Tnll3gc4BxiviK/jHxlnVR4ThHJnQ5m4xnRoSrVFzNWb5UoU73X8apVgnr01/asv4AwmWRhV4u4phKpZOWCwc1QhJvlfLq5VasVblVoprXZ6vxzwN+w38KvDkdo/iCObxHLaqnk2UgTT9ItgmB5VvY2SxKkA4VYkeONVwqxBa+nrHRvAXw70srp1j4e8LaXbpl2jis9Oh2rwWlkxGZHIzlnZ3Pf0r8Yf2lf+Cyvwd+FSahph8eeGNL1aATJ/YXh5/wDhNvF4dSVEUlhpAubXTJyeCNYn0pEdSJJU+8f59P2jP+C2njrxxcXsXgXQL64WR3EGt/EjWLi42huFktvB/hy8gs4Dx+7S68R6hEQVE1s2THXpYPwq8SeNJU8VxrxHUy3Aykp+xxeIniJxjK0n7HBUpU8LG7suaEpSVtYs+2wWbcM5VCNHKMKmkrKrJOVSbVt3Juo7/wB7lV7W03/sc+IX7anwa8CG5itNSuPFep2yvvs9DiDwLsxkzX0gSBIuDuljDoiDcRjmvyF/aS/4Lk+BfA/9oaXpPirw3ol7H5sX9leEinj7xaGAKCKY2LnQ9KuARz/at/pbRENuJCnP8a3xd/a/+NPxZaeLxv8AEXXdR02Znb/hH9PnTw94YUEnCf2Bocen6dOARhZL2G6uHY4eZ2G8fKd/4zkxJHGwES5DLGCFAGV+VVA5b5eckDIJDHr+qZD4S+FfCypVsXhq3EeOp8rdTM6nNh+eKVnHCxUaE4OWvLWpSkv5tG19LguKZycZUMFTnN2tLEx5o2bV2qUXZtPa85K+jj1P3v8Ajz/wWS+I3j67vT4X0uZXmMgXXvH2ry69qAVslZbbw7pklro1k4zuWG5vNZjQ/Jl1wD+V3xT/AGpvij8T5Jm8aeO9b1yBmd00t7w2Wg25YnaIdB05bXSUAIXY4szIRw5LAZ+KrrxTJk/vvlYE8E5Qtt3EhOdwXcVXK5wcElgtcreeJGf5TKflIGTxznlQSwKnO4sw4Yg4OeT+kUuM8HldCOGynC4TLaMIxVOjhaFKiqcVFLli4rmSt9lSsr7a2PpY8S5vjKapV8fX9g7L6tSkqOGjH3YpKhS5KbasruSbtZO6dj2LVPGzyCTEgVFBzhlXGAeNrBc5GADgkDjBOa8/v/E80jnfKVG4yq4cKBHuCgk5J3Nzh0BTIwdpJY+b3WuFhy2AGABycMBhcFzk4yecj5hjGMlxzt1rKgxBSyMVlVpMsylCqlQAHAJJJwSpwh3MC2Hrw8bxviq/NzYmUtVzLm93dWSTS0bvez3d9dT0MLirOUpNL3U7R6t8qT1XnfRrW3XQ9AvPEgk3hJdwbKFMuwBIBywOGIHddxI6Ek9ORvdZl8tTLKsknn2/zEgbMEKVBDjqDkE5wGVQRg54+71Nw4CqyhiFYAHagJDZ27vlbjkggqoGCcjOJe3+Y1AdiDNAPlJLEh16BD0yeT94ggng4Px+M4mqzlPmrSeiSael3y2V3/L131210W7x0m371k4q7i2tuXW93fRemrd0drc65Kd2MYHJZmZxtJ5bBIHTeC44+6NmS2cWXUwGeQk/OSRuyQitsHlsqn5eHOV6kY5YZWuYnvy2ZCxI3AAYGSByemcnG1skYG4ZLDBOc1wrybn3ELygyuxgWUqz4KfdAymc8jLZLEH53FZ5Vm/4ja83fV23umm1rfXpZeUzxk3dcya0S6K3upKyi3ZNX12s7bq+3c6kysIwHlyN7soASONmUhnyAQfvbdhwwBIIBwMVrwh5W3HCJKNmCSANmDhSSy45BLZDYJyCQc4XDLv2ENuZnBCY2o3GwknMnRRg/dDYAXvUW62TThjlmglBXB+ZTGpBwCFA5ySeQSrOSMlvnMRmU5NNzfK+jezsldpNddbadktDmliHzLmbfvR9bLlS2SuvXrutDSM5+eU4HJXbuwcEKQQAQedpIOSVQZOV4qkZykfJJB5CqB8p+XGACRjHJyc5xglelF5GZlyQDgALn5CW4IZckNnkgsQvLYyvSKWVYVDyFiGKrgLvJ3bRyoG1VzlixIKg84DYPg1sXJt2mrK9norN232bvd2l0to0tuOdZ2bb5XfW9l/L2d2n9lbX62RbZyCkZ3srlv3gdSIxGqMC+Sfv7QqsuDgggcZIy4AVtuEbcASeOAqsAvGSSGxyozzyTmsZQGXgkqp+VWwQSMkkoNhADEbix6qccYpybmZDzuGON204+TOfmJG1Sc5xnvwcDg9pzSs7N2veys7WTs7W0s3ur37aHDUnrpK99VtZJJbuz63V7369jYtYVIHz9snliN3y/wAOSTnA6kk9Q3p6joEawxo8uCsMDzyHYMjA3rkqB0GcKdpJU4yDg+d2ESu8aAZ810UBSTtY7d2QMnAGTk9+QNpwPsj9lX4Uj40fHv4U/DadJH0jxH4xsZPFMi5H2TwR4bSTxF42u5CCMRW3hXR9WkZmOwPtXl5Ap97JsG8VjMLRjp7etTgnyr3U3Hm5tlyxV5Nq7Svd9/Lnh5Y/Mcvy9WviMRTjJyaSipypxu7pJKKcpNt2STvpc/q4/wCCfnh+y/Yn/wCCffxV/aM8QWcWn6z8N/2d7iaykmXypp/ib8WoLX4k63ZnzcN9pt49U+D3hF12Am50SW3I3pLX8/f7LUkOi+HvGnxu8bxNqJ1DVtd8feJ570CV9S8L/CO3i8f6vY3BmwhXxx8SNS8CeDSZAVuPtFzbBS7lG/b7/gs38TJ/g7+w18A/2ZbbFp44/aA8RXPxR8e6Pbx+XLb6V/aE3i06PLAuDHBYavrehaFp8GApg8OxwJtWFAfw8/aKtn+Ev7PemfDqyZP7a8Xy+FPhjNBAwJay8LS6f8XviswADeYLjx3rngDQJ8gs02gXduSPKRT93jsT7TMMwzKk1OlgqFSjhIWbg4UYRwWCjZN2U4U3OFrN/Wb2Sen4Vl2b/wCsOa+KHH1C8aPE+eU+A+FKzVn/AGHl1P8AsbD1KE5ar2GV4bF4ipyrl9pSUkm7M9D/AGCzrOm6L8c/2mNdklvfFdp4Y13WbG+kQvc3vxR+IusXvg3w1LCSQz30viTxJqmrxKoEkUWkQyJgCYr/AGIf8EvfgrB8JP2etLv2hAutZtLDR7aYjJnsPDSz297cxHALpqnim68QXaSgBZrf7LIQwIJ/m3/Zx+FN5oXww/Z0+ENjp7Ta38R/iIvxB1W1aINJe6T8Kk/4R7wmtyDkvBqnxN8Za5eOrAxyNojMisY4iP7B9R1Hwt+zx8EbzVNWuIbDwj8JPh7Ne6jcuQg+xeG9Ga4uZSSdpuLyaB2Y53T3FwBy0hro4goyyvK8pye7jXeEpVcTzNOUq+K5cZiub7XNCdSlRblrJU2tErH4j9J7NI4KpwjwVg48scBlX9sYunTabljcw5PqicU27wwkYRhFWajO9rtt/wA1P/BwT+1Ot/4o8Efs2eH9SWSw8F2h8beN4oJR5cniTWYWi0LT5wrYZtN0p5bvy3IKSakhOWVSP5nPA/h7UvEWrW1rp9tJf6vr2oW+maVaRIZLi5u7yVYbeNEwSXklkUAqdxyAAE5PfftLfGzxH+0L8bPHfxH12d59U8d+LdW1+cOxcWtrd3b/ANn2Me4/LDYactvawjgLHAgVVHFffv8AwT5+Fnh7Q4/E/wC0z8RkitfA/wAKNOu20SW5RRFda/Fb5uruAS4SWayjljtbTb8z6neQbMSQ4Hk8KZLPiXPqOFp2jg8NByxFaWlOhhaPLUxFeUr8sfhly3snOSi9bW/pv6L/AIX1MFlOWYTFQjDE14/2hm2IklCFFSjGvXlKTaSVGmlRi5fEoU111+lvjT4n0n9h39krw/8ABLwxd20fxZ+Iunyz+ItQtmAurGG/RRr2peYhEqGTP9jaY25Wa3gaSPIVjX4kaTatAsvizUIIr/y79dP8OaZcgSJr3iWRfOjinU8SaTo8Ui6prjElWiFvYuQ2pRsPYfjR8TvEf7R/xe8Q+M9Yu0s7fUJ7ia3+1SH+z/C3hTTY5DG8xVv3Nrp+mws8pX95cT70hElzcQxt8+/ETxvb6BpSavZRzWoa0n8P/DnSLlAbm10wyEal4k1C3TeBf6tcyPe3hUZlu5obCEvY2sat9DxRm1LOsy9pRk4ZJk0fquXUEvclGi1CVaEdE5VJJKN1eTdOLTSlb90484ieb5nDLctbjl+EgsJgqUdo4em4w9ooqzVTESjzXsnyRSb0jfgfHE+t+O/FFr8KvDN/9v1HUL271Xxlr11KTbNd+XJqGta1q90PlWy0u1Se5uZCwWxtI0gUm6nfy/qD4167Zfs5/Cew/Z18GRy2fjjxjoVonxIm2GLWfD3gjVLqy8Q6d4Gu0Vmay8X/ABJvINO8ffFRG/0zStBg8B/DaU2baN4ssL53wR8Mad+zR8PNU+OPjvT7HVPGF3drpvhbw1rlol4viX4kQRw6vY6BqME+Y7vwp8KIL3SviF8VbSZZrXV/GVx4D+Hd9DLbSeKI7bmfgJ4Fm+IHivxT+0F8XLrUtf8AD3hjV21/WrzUZXvdY8feOdZ1B5dM0KKWbe99rfiTWZBLdqBI1vayy3M5EWWX5jCYKrmmYRwtKbpTrRVXF1X8OAwcYt1eaTtaFKk5Oo2251JO9/cb/OqGWy4lzmGRKr7Dh7h+vHMeJsXNRjh8Zj8LCniaeBnV64DJIxeMx6+GrmCo0JNvCVKcvoL4O+B7H4AfCaTWNfu7bRPiT8SfDl5resaxMym6+GHwkjRRqWqbAS9r4k8XxyDQ9Dt38uWZbpjAY55kc/l38XfijffF7xkL62tX03w1pEKaD4M8PI5eHRPD9sxW0hGDse+vHL3+qXYAkvL64ubh8eaqr7n+1z8cNa8R6vq3gJL6JtVvtSg1H4lXOnOPsS6rZRiPQ/AmnPHjOi+CLHbZvEJGhn1RbiZlc29sw8F+FPgi/wDEmqWVvaQK91dzCC280iKOJFXfcX9xKx2wW1tCGmnuXIjhjQyNuSPjzeJs4eY4vDZBlHNHKctcMLhaSvzVpKabrVGnZ1K026lXTdxik1TjaM1zWlxDmVLHYWnOGS5fCeB4cw07qToNxVbNKsL/AO85jNe0i2v3eGVOEbKU4n0D8CPhwNRnTUrvTzqFjpc9nGbMkxpr2t3Ic6doQkyCLItDPfazOsiC10e0v5mkjma1En9nH/BIz9ljw/8ABT4ZeI/22Pje8FvIPD3iDX/Bmoa1Clv/AGV4YtbS5uPFvxOmt5EX7NceIYYJNK8KJtjex8IWMbWcSrrERT8fP+CYn7GCftGfFrw/oEtjP/wqDwRYJ4h8ZaqLea2kvPDzXSJOPO3J5Ot/FHUrMaTpkJcXWl+C7C7nC74Fkf8AV/8A4Lt/ta2Xwd+Bvh39lHwBPa6TrPxG0uyvfFdjpQito9A+GmhzpbaJ4eigt1C2kHiDULBIlt02qmj6NNbbfJvVz1VqKwGBpZdTknKrBVcZOnd+7penddGmopdnZ/HZfzn4wcY4vM83yfwl4Wrv69m+Jo1eJMVh3zexwt1KWGclrFxpqVWtF8rcFGD5lV0/Dj4k/FzXf26/25dZ+IOqmX7D428daZpmhadISyaP4StrqDSvDujJwAq6f4ftxNdBQolvpLq5cb5nLf0vaTBHa2tva2qpFBZwx2tvGuAiQW6LDCm3O1FRECjAGAAQMcj+YH/gmzoY1D48eDZ7kCV7P+1NalLnfiWHS7v7OfubgVYq+CcZx0IIP9PGmyDyyQSCABljkn5hg5JAyQcEDtk8dT/QnAWUxwvDdPEez5KuKqc0klb93CMY0oO+rS963Vb6NH+p/wBFrhLC8M8Gqnh6MacE8LhKS0v7HCUabVna7cpVHJvq/ebbZneN/DVn4p8NazoF/GktlrOnXmn3CEBgy3Nu6McMCuVLB1OCVI6dDX8qXxg8Eal8Kfifrvh+9R430nV7i3VipXzLdZd1vKp4BWW2aMqw4z61/W0yebHlgWDAK6j1Ixu7LgDkkjjPAPNfi7/wUv8Aguv2nSfibpdttN2p0vWXiVQv2q1y9lNIRj5pId8RyMnYoyeBX0Wb4L+0slxFFJPEYO+KoaJyago+3prZ2lTfOmnb3NL3VvvPG3hiGZZJHHxpxqTwkXTrWik54es0m3u7KVtNrSdz6V/Yh8f2nxX+Ceo+ANYm+03Wj2kscMc3zu1jPE4XCn5jGMsHQ5PllTw6ivzC+OPgy/8AhZ8TdUtIhLam01U3NhKhKNFIrm4s51kVVbJAVdygZZCx2kc3P2FvjFP8OfihpNvd3DR6dqU66VfIzAJ5NySis3zYBRycFgR91g2flH37+338K49Z0mx8d6Rbq5e2RJ5YlJVgFE1rIuf4WZHVQSTGzmMnoK/D8VBqqpqDWzau/ijy8z01Ttr0d0tD/FfNcipcEeJ2fcKYyklkXF8K2MwUJL9z7SvF+2pJNKDXtJVI8qe0oq2tj9Vvh94x0b9tT9hbQfF19AmseKvB+k32k+LdMOJZr57HTv7H8X6fKhJYL4g0Etq8YO4vfMJBuaLJ/kq+IvgnUPg58WfFfw+v2Z49C1eRNMvCoVdQ0K9ZLzRNSjBADxXulT20p2sQrMwYhxX7Mf8ABG34/L4L+K+vfBPX7tRofxPtRdaXa3TqLYeKNLjnZ7WNZfkD6rp7XFkYl2rIZIS+7aAfN/8Agrv+zhJ4H8W23xC0izfydA1CDQtSmRCTdeDfEcs+p+CtVZlHzjSr1tR8OSzHhWWzhLBRCp0y5t0cZg4u88N/wq4KDd70KtSEMfQj0tSrOFdLRKM5y3bt/KWBwNTgPxFzfhXGv2eW5rV/s+hOaahKag62SV7yspOph/aZdKcVeVair33Ps/8A4I6/tHTW2n3fw/vb4tqnw1vY/EuhxmU77zwN4kvFt/EFnGrEl10LWJIL9IwMRw6nPIpVUYj+uW5t7Dxz4MkiLJNbanpx+dSrgh4MqyMMjdkhlPIJwRnGa/zcP2PvjVd/BT4v+A/H6O0mnabqP9l+J7NGyL/wtrEZ03XrV1BGWWznluIASVhuoYJUUFF2f6C37J3j2z8S+CodGW/iv/7KggNhdJIHXUNHvoEutIvomwQ0VzZSxMGUkZU+wr8s8XMsnXweX8TYVSWIwFWFOtOK972acHCo2rq0Ktvedv4v91s/RPADE4bhDxV4v8Ls2UP9V/FHL8Vm2V4as19X/tqnS9lm+DhGS1njMNNV5RWjVNWvdn8rf/BYb9nafQfGWn/FWzsRHBryt4V8UvFEUSPxBosbDSr2Yr91tU0mNY0dvmY6cpHLEt/M58QtFNvLPuCqY2cYAAP3iMk4z06EEDJzw3Ff6L3/AAUb/Z5tPiv8OfGXh77LD5ni3SHk0W4ZR/oPi7RwbzRLlWOfLE8sQtZ2GM2r3CEgOS38B3xh8J3ulahqdjeWklrfWdzc2V5azRmKS3u7aaS3uoZEOHSSKdHR1bGx1YMoAxX1WW4+lxJwzgcyhaVeNGNHEWs+WcIRi72Te6krvflvrc+W4TwuM8P+NuJ/DjHzkp8M5rUeWOouV4jJMZUeIyytFtJStRnyPkTjDkjF2Z+eHiDTzmTnDKxULkhmwyrgHBJLEkA4xgcsTivLNTsym4tzvAYEbuhKkgAdQO+eeVPILY+ivEemBJJMLg5Y8AAk7VPQ4Ybj8pHzDoVyQTXjOs2pyzDhlJB5yD90bjnHHYHkDJyMtgfG47Dum5XvdLp1Wmuyvvt238/644dzD2sKdpXbjFW+Sb1i1q18k976nkWoW4Q/dyrdQckAcclQDweCeTj+EkHFcrdxYyANuTkNkBQcg9eTyuAexz2zmu91GLDOWwSSCA2eMFcbd21RnJXB+U84OSQeNvoto8wAbs425AwrEfMFXYcAEguckHAxjgfMYmN91az13TaSTtd320Vr211/mP1fLq/Moq+6Vnro2o2u7P8Aw9L8zTOSuY9xCFSpXoRg7vu7eSeDnO0jBYrklXBIyZQQwJIyV5JXp0HDFcnngdGI6qA2a3rkDK8jcQAuVxvyUwhLB1zuJIywJxgY42480bbl3qAdvJ3ZAyVAAQHaSeeejMOijgeVNXb0vre612UdNnZ9Ve3V2Pq8NU0XS1ttLfCtU+66aeVzGkVcn+LDADBAGPl+U5zjoWwCMsOMDFU2Uk43jA5IxlRnDfMUPQ5zzkc4ViMgasqbQAAM8KSRk5GBhlxwST/vLjC4IBrPePqeVYEr2GFyuNpyQ2MZwByO3JrllHulfT10Ude2m1/XR7Hr057dLW0e/S2qeisu6/CxSaNgOoAzlmwSR90A7QABkDk4IAyTgkgQOMFgxG7Zw+QTgBQCCSA5zjhcbcbm+VcVYmGOAQcc5Hy/NxnP8Q5J7ZGc8hhUDhhGCFLKdoI68kqTwN2SDx83JPAG3gckou1ui93mtZ9N7u199Ou19En6FJppN21S26P3Xa1rrXa7vvsr3gZVVgMAmTjbkbt+UVlYsdgQg5AHGdpBIJxGBj5iScDCnAxjC/eY4JdjuByAOcqMgCpTs3bSRgEEqTt67QDxgDKsw6kE7SvVaYyjBJJByGUMGB2rhSRkZ4B3Z74U9lJwaeqetrPV37fFvrd66aPezV12UrvR3trfTyitFrfW19d7O12mq7B3C5BjYEOVyrEr8pIyPnI6g8fK20DjNKwVgTngqMDcQQeCOBnkEALnPfBAPJIygAnPXy24AORghiHwSw4GOpBB5IwYpQX5AGQRhgANy/L8jbWAJYAcqGDKMHHBEvS7T232ae1/RpvVaXb36rpi7Jpt3WqVnd3tddl57aPXW9kzubaVw2QT0GApUc7snax+7gbjjDAnJpqqQwRT2AO8EgFsdcnsMEA8EBguDzT3OBuUZDFRguFDYCZJJwckFcNkEjOWYDAjMmT0yvB3ADaWJUYzheh5P8AHJGfmrKXxJLXa127Ne7ZP3rNbpqy1tfdtu6elrv3bWSezje2ye/X7uqaFYF0x0ydx4BK7cNg5X6uBhD2zwY2UqQEberDJ3AHYQVDEDPLZXG0fK2SR02hWZlVWdVGSFwF6oVVgwbd/EMgtzgtuYFS1RM4ZlCMyjYQCFVecABQScqGOMhWIH8JBwTN1ou1rW2aSjvr7zaa0s+q6K9JWS3skmlbd3ja60u3ez0b1sntd20j5TgKHADAKueAB82do3DgspyQCrbWxgI3bjE2GLhWUFmjJJXK4yCMEZ+6eCeR0LFkAjRXHzHgjncV+TJw2SQCOq/M2R8uesyCIMx4VtuG38j7qjJDYAIP3TkBeBnPy07JpJ2uknpo1otOui1tsapXd7Xd0n0atZ2TV72eytvfXW7aNiy5YksVyMnamdygg5IAQ7WG5QSwGDjOKEi2Zk4yxbIywAU7WVABjjjg4HTcOPlp7AErhm3HBI28KhI+XBDDLHGMEBsE4JK0Aluin5CVw2CSpYAuM9ccEEg4yAeuQmu/lbW91Ll11u+vS3yuapRbTf3K/aKTer3u7pWfxWavoJ+7dSpwXP3iBsUnZhSMFR2KtnDYHYkVKw3BlyRjkHJHKhODwW52gMcYbKgDOTUY+4qnDEMCh6uFGAEJUqQTuDc8g4BI++HJtG9uSScEEgbRlCAAGKgKOCxJ5/wBnaTO6s2+lrPe/Lo+269bvR3d6g/d15baO1ttE732vdLX1a1vZ+0FVLLg/KSO+35AWJJDEEA4OQVAxuxyEG1pAA4+ZtpIYjLEL8pIBwSMYX0wRuIGJQSB15AVSMc7SF6kFxgZxnPzEjAIJNRbisowCOSWJKrkNtyflK/KRgA4Y+m0lTUv10adtbNaL5bvt71/RutdLJvR6va9o301tu7WXfvciETrCkZBk2hUZtxwQVIL7skFRw2Svyg5wSN1SrHgBQQcR5Uk7ipGMZwNi7uCT93oVO4Yqlb3CLObZjJIyKVMkmGViu0MBkg7AVbyyVLMRtABBUPMqSMVSRw0ZIyu8EKm3ou1WYEg7sYxjBA6150Zxkk19pqNm9U/dtru9ftbdb6nxM4Su01a1p3to7tWutGr7eVl5kzF12GNRknDNkBUUvyzZXLNuyNpG5fMXOGwamhMod/NwQD8mwAMEHBL7tpOShC4UFhwdpwKpiWOWJjBN5ZDKqOq4YMpBKquN/JHY9Tj5vvi5E3UYOVAIJADZwBnJyMsRuUbsAlhxt5uLTd09LJ+69Holay00/G6WtmlnJON763dndPmVuR63ulrol0j01IZXKSjzFVIgV8sbRJ50rYGMAb8JtYgZPbjBwLnmOseY4xl4yQJSqIpOAQSvzccBRkDooBG3EFxGZRE6qG2SLIVZiQVA+Y43Llvlz8rAoCCFfdkyoQeRnoNwUgM/yrjhdy7QMAKCwGB2AxUeZTkruzasn8tE7K1mtr73d9yJ2cKcrJ2vfS6veNl5uS1evytoJbytvuIvmZoshnZHwHcRsqDDOhCtuTbnCjLEHNaCgIqh2BG1csQQCeNozgrzlsHA3n5mxwapMJtoMLqjSK/myGIFmPl5BjAXJYlVycZxzyRgzosjQLG8hL4XfIEcNvUZ3dVxtYqmMDLYOMgtW1PmV4ta20bso/ZdlrfeVm7XbUrtmFZRkoy5oxTavFNuSukm9FZK/R7WTu2my6vU4IBJUnlmGBjrtwpwMjjBI5AOMGwoDsGOQNpAJzgFirDP3Bu+btyDt2nqDUYMjA7gBIjMzupyG3DYiud2/JHyg87izFl2ipbddiKgLyYQvlyGJdgCoJ3BdrbmA4zwHGMDG8WndWdlZvba1tt2tXquqez34Zpcqala70Svr0d27LRKzfn0vcvW0hKn5CuGITcF3PtCjdjqdxOcAZJOCM5zehGXBPzSA7c7sBVwmcDAOMggHoOxxg1ThGY4icb3K7ioxjdgZGMsSuPmG4Ekk/MeK04ITkBWUEBVJwMnIXDMeSSQ3UHnIZQfvHopq7jaN1Z3utLpJe9qt9NFy67db8FdpQk00m7pLbROKbcrt63v5avVPXRt4gwBHcjBB6cLhcbvlAA5GM/KAoIya3LQIvlq2AzFApIJDEFAG3fdVsMQMgZ4JySCc62QKFUEFQw2jGeeDyuFADAruz1DEqvTO/ZjtsCtwHUMpUZKEEHBPXr/ABIflY7fmr0qMXpZNNrW22rjs3td9tFva2j+dxVTSd03FOyafflS1WnK5afjbRG3ZwbwOig7QpIDKMkEEdstliDjnJCkFsV2NhbEhABkBSMkNgMoUEhjkspK5B4wc5IIyOdtYnVAw3MzsirjdjdlAMfKcbVwTx0Axnknu9Otmd1yVXauCABtf7mQoyQeVK54yM/xcV7OGotyTtorW7tvlve/VK260VnfVHxWaYhxg5KSUbtaaWtytvfvZ7b7M6TR7R2KfPGrfKoV8btp2Z5Khi5ycA7eBhiDjPs3hfSi0icEkkDIyT7tjaFK/LnB28jDYA44TRNP8x0+QscZznA5wWC5+YFh0xkLwSCwBr6N8EaIZpbdSDltu4sCecn7uepYnCg4xwMZGT9pk+C9pOMbNu66bq6/VK9r3stlofjfFObqhRqydRWSejsmrW6pK60vfVp2ezu/pn4B/DPWvH3jLwt4L8PWoudc8Uaxp+jaZEI8qs95PHEbmRicrBaRNJd3cpwIraKWYkKhr/QQ/YD+Amh/DHwDoFhpdv5ej+D9ItvDWgySRqr3ksAMmt6zIMc3GranJPdXD5yJZJ1B27QP5oP+CO37Ndx4i8Wah8XLrTnlaylPgrwR5kZMTatqcKHxLrEZ2suNM0iRNPEkYBUalfch7fA/tA0Ww0v4c+BYrYeVb2WjacxklcqgxHDvllkYADczh5JGPVixPOK08Sc0eW5Phcgwbf1zNXFVYwf7xUeZJxtf7cnGG12nPfRP8t8EeH6PHfirmPG2cqH+qnhdh6uMVavphanEFai505ObvTl/Z2FjUxE3fmo1/ZN2cj5E/bf+MOj+D/Clxo1/qkdjpVtYXviHxZclwv2Tw1ocZvLpWYnCvetHHawKxHnuxiBy4B/gE/aS+LmtfHL4veKvHV2k0194q1vy9H0yLfK9pZeclj4f0a1QbmItrVbaCOOMEtJuIGWIr95/+CwX7Usz6LN4Lsr901n4pXsl7qEYkIl0/wCHehXPl2FqyZJRfEGqpJM0eAJYNPc/dkBP5Vf8E2fgBffHb9ojT/Ed1YtceHvhzc2GoIZIt9rJ411iSSDwpCwO5JF0RLfUPFk6FWQxeHTDcbVulJ+z4YyOnw5w/gMta5MRUprF4+Tskqk4xnNybdv3UUlq2nGEeu/5HnXGtXxB43408XcdzVMtVStkvCGHldf8IuBq+xwvsItJ8+Z4v941ZPmm+jP1O8GWFl/wT7/YF1PxBMsFt8TPFmn3/hHQ5QVFxP458SHzPHOvwvtZpBoiwQeG7O4hdkSHwxaSKc3zlv579Is9T8a+LLe3AkvL3V9RUAcvI8t1OGO5juJZpHyRycjBJJBr9Mf+Crvx9sfHPxdsfg/4Luf+KA+C1kvhGwjhl8y3utctwia9fsY8JPMLmI2b3GN0zQO4LM7V5j+wL8IP+Ep8aS+NNStmk0vw0qSwF1JSTUJAxgjBwU3RAbyMggqpOMADtWHqZjjsNg4R5ZYipGpVi96NHliqdNq7s6VBJSV7KtKq1dSP6O+jhwHiKkIZji6bnmfEWLeJr1pRblHCuftXK9tITcp1Kd0n7N04Ne5G36e/Cnwdpnwd+Fem6TIEgNjpjajq8mFUy3LRPJLvxyPm2x9QBtjX+/j239iDwHc+NvG2v/FzW7ZnhguZG00zISPNkUxwpHkEEW1qVCkDIkfPUceCfGLU7nU7vRPAOklpL3xDdwm5jhyWWxjmVIItoGUF1KcgMcmPJJwfl/YX4G/Dy0+G/wAOPD/h6GFY54rSK5v5AgDPezKJJiQBkYZtuPvbVGMgZP1fE2Khl+Ahg6FklFUYJWVvcjF6WSfJDS9tHJW6sx+mPx1BYjKfDrKq3LQwMY4jMqdKd488YwjSpSSla8Y6yi0neUt3ZHsqsG46YIxk9eMcdyAOB1I/nJK4QEFtpGeOnTOcjHc9AO+Ac8g1xncpJGFO4dgDkDPTrz8oHXjJ4Oat5KBuGQCo+YgA9/lB6jI6gHqWI61+WKPPOMU1vq1subX79NWtnrdH8Lzq+you/wAXI1ZK12klq9LKOu+3rvh6reCFHd34UEkjPGATzzxgDjoQCpr8G/8AgpJ+0AltHL4U06/XJWRZVSQttVfvhsHPOQuRyUywIy1frN8ffiRY/D3wZq2qTzxRyJaz+WrSKhJCMcjk/lnPKqM1/Ht+1P8AF268aeLNb1Se4eYXFzcBMuThAz5wAQFP3Spx1+UA5wPqsMo5bl1TG1FapWTp0G7X5WoqU46pX1SS00fQ7/DvhutxRxTSqVKcpYHLpwq1m7yjOupR9nDezau5O/XlWj2+RfiP4rkvrm6Ak4y+52bhiS2cHI4UEncOuSOtfK/ibUyiy4cdG56n1/iBOM4JJzzzjpj0DxJqYlaRiedzH7y5yM5GOOSWBGCQM/Mw+XHgnii/LMUJ3sz4ZQQxIzjB/iwTyMZOSx4XAr81zTFyqyd225Sb31vdPS2++11006n+l3AeQQoxo2p3jBRS92y0UWtrWts2ne/TqcncSmWVpXJO5j0J4UdMAE8jHr15w3GabEuzMV4zgDjodp9RgHA6kAHqSDgSFlCqBzwuVyMKODkj685BPYjC9Wxo0jgA8ZxyNpA+Xjb93g7QOScH5RXiU4SlJKy3SV3u21a+1nr5q3c/pjIcBbl929uVW7SXLZva6Wqe6a07Wt2y7V3kckAFunYbScDOThc8HdxnAPEsmfULzlsckkqvBx2Uc5yDg46Cn42rkfdUAcHB4I+bPQYPPA7kZLDBijjaclVK4LEbeOVBwOuBkAKenB7rjB9mlTajCnGLupWvpbVrztulra1rXs7pfpVClyU4xS1ik7X3Std221aSsm27skit2unVCucg7eASRkMAARjpk4wc5JJBINez+C/gV4z8avF/wj+h3l0zjzD5MLELG3JYkIQFfk5OCWPUttI0fgt8Nr3x54y0Tw9aQNJLqN/b2wwpYgSON7FQCSkabmbrsOCwIGa/qW+GPwV8H/CnwRp1la6faRXFlpqNf37QxrPK6JucO5Qkbj94FiCAQeQCP2bw/wDDKnxRTqYrMK0sNg4OMYzjGLnUk7Nxi5uyUUruTTVn3PseG+Eo8Rzq/WJujhaNlUqKKcm2l7sL6NpNO/q30P5o7L4Xa/4A1i0tvFVpJYolwiztMrRlF/dsVG9fv8bhlvlPB/vL/Vh/wT0+N/wvg+BUPhO08ZafCPBwvtQvLfU7qC0fTtMld5pJmZ2USxnEkn7svsXDFtpJP88H7aXxVsvFXxB1DTNEWCOy0ud7fdAo2TTQsQxJAwwQZyQpPI+YhlU/IkXizxb4W0iWSLVdS02LU7cwG3trmS28+ym3FjIqlVkhlcsU3E87cfKRj5nMXgeFOIsyweUqWPwWHnUw8q0na/JJbSgrWTXVdNNkfx99I3wKyfxEhUyTC5xWwf8AZ+PjUw2KVKNaE6kJKE4zp3i5WhKcYuMk07N3Wj/ZT9uD/gop4o+I/izWvB3gbW207wBpVzPYWY0i8lWPWhCxje/vHUwvIkrj91GGZAgQBd3J/JrVPFev+Kb1LG3F3qV/fTCK3hRZJ55ZpW2xpBHjBLOyoMhS7MAN7Yz45aarcajN5aCS4kkfEcafOxJ+6uxQxYKCSzMCQCThidteieMPHHg7wT4f0yz8OC5uL26tYn1fUrtIrfVdX1Qx41DS9KaBmNn4dsLhIrZrxmllubiOVoWaQPHbePF4nOHWxmYYr6tgKd01e+ra5aVCmvibWnNsnqrs5OCfBXhvg3JqeHwWHo0aeDpU4zrzpqWMx2ItFOUb6zqTd5zlKXLBKzklyom1L4PeO471rfxOLbwmBO0M8GpzLdasgRv3sqeH9Ka/1YRJu2/armG3sFkDJPewOpC40sPwh8ETTJrOtw+IbxWXyAQus3IdELFT4f0XUrfRLYvJhAupeKdYwBi506Ms6r8+6/8AEHxZ4qaRL/Up4rWZgv2CyKWtmVQMq+ZDb+X9pk4IaWcSSu7F2bOWPMw6W8gDhSAR/EMepO4kZzgHg/dxkkHBPhYuWXUpw+oYSdazX77GTc3zaJ2p07RWtpJv3rdNNPrY5XGgmmoQgmknb3oq+jW0VLSzUlUg9WrJH0TrfxmXVJ9Og0HT7yHTdFaRdLhvDp1koJuJZoZFtNEsNNgsUhjlWDyrNkeZFQXNxMEQL0ulfFDx1qLBU1u40pJHLSJoZk0xpdymJlub23IvrhSh2MJ7qUFSV4BZR4N4b0Zby8tIZTc22myXVtDfapBYS38emwTTRrJdtDH5fnPCjlkg81DPIFRXjL71+9/hF8HdV8X3V/pPwp+BPij4q65pNyq3zam2v+JJ7PTrVFa41S80DwUul6HodpOpNykWteI7z7IhSO5u3wWk78teZYurG1adOLabjFyjF35UoqMFey0TurNd3e/5pxrl2DjQqYurgY42UI2lUlClKnTS95SqOq40oqP93W13a23n2gaHcaqQU+eR2Jd23MSztksZGViWYEjLMSfmJyT8v078L/2efHfxG1GHSfBPhLxF4u1SVk/0Lw5pN5qjx7yD5l09vCYLVMbg01xLFCg+YsuMj+jb9gn/AIJXfD/4weBvA/xG8deA9L1zx3YaN/wi3ivTjqmkx+BItR8MancW2k6na6R4Quv7P1PUZPD8umaVrs93f3yXGr6Tfvf2gv3nml/oj+E37EPgXwLo9npv2PS9L063VCmg+GtLstC0ePYASot9Pt4EkJxhpSiSHHzMxJNevmPE3CvDUJLNcX9Yx8Hrg6H7yrq0/f5U1BO/MlNxunvuz+WsBgvFHxCzTE4HgPhCvSyrD4qphp8Q5xOGAyhzozdKq8JN+/jacJxlFuiuZW1SbaP4+/g5/wAEdvjl4u+yXPji78N/Dewm8t2tHc+LvFTRuQSq6TojnSrWU4I2XmvwSRyEiSFCm0fsf8Av+CKfwl8ONYXuseE9T8f6jCI3fVPiBKINJ8wEZlg8Laf9k09ox1EWoSauAMbi/Uf0TaL4A8CeEIU/s/SdMszCgAmdImlIwTgyy5c56/fwOcelZfiH4u+CfDEbBr2KeZAQtvZqJHYjqoMfy5GPUHrjJr4TFeLmc4+bwvCuReyvJqFV0nVqWslGVoXcWkrtus43d2tmfptL6POW5Th1mPjD4o0MHQjFTq5XlOIp5dQfLZzpOvXaxNdNXjyxoN2vZvW/zl8M/wBivwN4K0+1s3s7CxsbZVWLRdDsbPSdJhVAAEjtbC1tYgAMgskaNgYLkDn6l0Xwb4I8GW4Gn6dp2nJGgDSlYlcqABl5pMyN6ku5I4bPY/nj8d/+Ck/wi+EkN0viTx74T8JTxI7Jp17qH9qeI5ABkeT4c0hL7VxIR8oEtmkefvSoozX4f/tA/wDBc6xla9svhn4Y17xdOplWHWvG+o/8Iz4fVskLLF4c0WafW72Huq3Gq6LIyjDxqSwHIuEPETi6Sr5/mVbCYabUnTrVHGPLovcowlCi2rqPxOXZOzR3ZX4h+CXAX+yeGfBM+IcfTfIs3q4fkpykrLnlmGPU8RLmev7umlK/c/qu1/4z+CfD2+GO9GoXMYO2109PPkJzgDMY2YzxnJ4ySB1r88v2hv8Agqn8Dvgil5a+JfiF4R8OarDG/wDxIIL0+K/GTMASsf8Awi+gLfX1nK44X+1o7G1B4kuoxlq/i++Of/BSb9pH4vi6sde+KGqaF4evUnRvC/gN28HaG8Tbd0F0NJli1bV0XOw/23qeou6sdxPGfzq8Q/EGaZ5mMpZpGkdyXLO7EOzM7ktJIzBhuLHJ6tnHP02V+GPCeUyjVzOc8zrxs5RlJqm5pRldLSDi3dOM6UrpK0ne8fc/4id4h8TqNq1LI8HUaX1XLYeznGErJRliZ81bmS0bpumnuktj+mj9or/gvZqutT31l8K/BepalgyLD4g+JGqNp9mB8xE9v4M8KXpnxwGjW68WRcYE1oCxSvxM+OP/AAUC/aH+NK30PjL4o60NGuJnQ+GPDE7eFPDQifJMU+laE1m2pxISAW1u41KZhndK+C1fnjqniqaViWm+8CykMOd2zr+8LZJ3MxxznHBUEcNdeIsxykumDLGpPmE7S0JwRnAYEk4IJ2+pbIH6Rg89yvJqUaGT4DB4FQUeWVCnHnjJWfMptNxu/ecYOMdkkrJL6XJsrrVpxxGJrV8RXm71KtarOrUqO8b805ynJyu291572fr+p+Op3keNZxGvzMuzaijc3A4xuJ9QAGPAORzwd/4rklBZp9pc5XLdT0LHHzZOQMYBI64yCPL73XhvyW3NyTgknaWVuhU5+Y8kAgZy2cgjm7rXJC5AJCnIA6EH5cKCCvzMoJBA3bSOp5HBi+LcTWb9pXnLmd/i5tfdTWkrWtfrp6H6dl2BjT5XyprSLsuum+2t72e6fyPQb7xDuLL5o44DbjlugBBJyR/wEg8DIZQ1cje645kMYzwpYNuLAAlRwrkA5HQ45ztxlV3cbcaqXJ5I5wNpOf4cfMd2QPbABzmsibUWK7gRz7qCCduRkEnPcgnBHIypJHhV8+qVP+XkttFf5PV7NdtL20fVfX4OmocqSvsl0cWrbOyWtvPZ6rp1NxrTHAUkhR8wDMB8pDZ+UKAoxgk4AyQR3rFl1TczbnAVvmUZUfMduAfv7Wyf9WcjuMgmuVudQYyIu4EHaNyqzeXyhBJLD5mychgeS7At0Oc9w7MSWZSgAXb8oJ+QhWVWVHwAS2AcglQAcAeVUzirJ6Td1bXe22qv1XbbTXrb3cPU5WtGk9NtFqle73srro9fOx0suoGQPg7iMkncMrwARkjLZ5BODkgZAyTWbLeYWJUcBt0wZc7dyYjyxyGJRSCF+6wwRkIKxDfL5nlFiH2+YMEsG3Mo4Yg5+Y9McAA7iQwNKe5/e27KwU7Zgfmba5wDtTaQpyWyV+6wB77RWKzKXK/e5tld7rWOrtve6WqSVtz2MNWfvOTTslfZtPmik+rk0tV2XRGxc34RS5cIvCsDu5LOvAGCOAd2c7gATuOGAyLm6bagLq372HHAC/KfuqQSmQcNuyep5AAQ0nmJyVZAzMu0uh2qVYHZtBIJ2kYIy24AZ2E4y7u5AijIJwLi3iYFixG18nG3B2ZJAyMsVOQSa46+PbUvebejslZO1rO93dp28ttjb22j000e+yuul1dr1+56La+0feYSA4YjGewxk7UUDA4+9yOOG3Yqt56yKBvypwVYFc5IUA44YZbC9+VyOazZZRtkLru3HHykAlSVAUKuPn5z8zHkgj5QKgacNtOB5YUtgAcgbSELbiynC4J3YBO4/eJHBPGtPrbRXTV2209Fp8/W2qRTqO12ktmrKz0cdXqmr318ndJrbTlmX5V3gHZkMS3H3ME5BYsx745PXaduKH2g+fJjaVMMpCqMnPlJuRiSASOD8524DAg5LGr5ytGpTKhzwN2CwCgyAqANrDGVyW2gFhxnDLdt1zcKWARba4fBwxUmFeq7WJIb5sZJOCwJBw3DUxXM42bd2rXs+iavZrdK+yWuz0Sxc3zRvfVqz+y0nG6srPTVvbVx01sX1cRjbnzEkUDgkEMdnGeFGBkhSDg8rnOKVHbAbYwHT5iQpUbQcnncPl5PUk4PANZwn3fJtddrBSG2/M3ygMhIJPPyluTxhT0FWIpUckZBKHaQc8MFXBDH5mGOSAAEJAIOQa5HVTf3aX2fupNrfS3a9t0nvLn6vfe7191bttKy7bt3a01sKfLBjQdPmHLdCRk5LYYNzxwe4G05q7bgbwxKrlQcHvnBVRkEccjqQc5zxVJQTsJ7kbsg9DtOSM4bHDAk78kFeMZ0LZDuGcZyNrHk44UdcgcZwqDJ6EjODdL4kldat2tpZ8u1np1tpvd6X0yk2k32T6XXRLb+nffY7TQIla4D4K7I9w5OPMf92uQwGfmY4wcjgAdAP6Hv+CFX7Oh+Kfx+1nxbe2om0zT49I+G1rIUwrxeJ5Ljxb8SZo3wFXy/hj4N1jw3PMDmKXx3p8Z2tdxbv58/DEKYSSTCq8vmtvO0CK3xs3EqDtL7idzcgdRgE/2l/wDBMSw0/wDYr/4J1fEz9qHxDarZ6x4Z+DWvfEG3W5AV7vx98aI9O1rw3pis3K3Nv4C0b4OW6IVLRN4lv7frJIB91w/H2MMbjot82Ewc4UG1/wAxWLUcPQad9VTlU9o+0YPe1j834z4ilw7w1xXnlOXLioZbLJ8oUf4lTN87tlmFWH1X+0UIV8Ri6bTbTw7cbtH53f8ABRj4vWP7UP8AwVN8bXss8Wo/Db9nKE+Hre3ibzrKXTPhlb3Gq+IUSNCqKmp+LFudPV1P7wvZDc3lgV8UfEfR9W+Kf7Vnw4+Fojkv7v4Z+GtMXxDBLl0ufid45v8A/hPfFlpcKoIa8t/GHivS/CN6FI3weGZI8BYMDe/ZTjhTw78Q/jX8QHkvm8Ya1q2p+Kb24cyT3/hHwGr/ABP+JMoeQENJr17ZaL4YRnO2e41EwbWeUofWf+CXekTeNvjL8Sf2m/iBF9pt/C9t4r+M3iK5mUmKS/sJNQ1a3idn/i1DXr8/ZYmIKf2daBV+Zgv1WR4D6w8lwNmlmGL+u14ptzlgcDyTtJPeM1Toxhv7ylu9F4fD/DSw0/D/AINhy+wyjL45vmltp5hm/LSeJm1rGVDAUMxr1L2aWLUn8Vj97P2IvhJYeKf20fFt5FD9q8H/ALMvg3wp8LNFuHjD28/iHw/bXF/4gu1kEYVpbjxzr2uXs+w5luNISRiTCgWL/g4B/ari+FH7OmhfADQNR8nxX8dL17jW4oZgLiz+Hvhu4gudQ8zaQ6prerGxsFJ+WeCG/jwyqQPt3/gmZ8NLvwT+zxb+PPEYMXij4u6hd/ELxFe3OI5ZF1nztXkubh3AZY3mvb24UyHbHbvEMAiTf/Gt/wAFVP2mp/2s/wBsj4k+L9KvnvPBmgai3w8+HyiUvbp4T8JTS2TahAA2xU1rU/7R1ouAdyXi5zsCjzuMszli81xk6fv+x5cHRaV7yXuyny3bu05STTbuo9rv+W8Nhp+MHj7m+cyjKrkuX5vLFRjyv2McDlU6eDynDwdrJVJ0YVPZu8Z041VZrQ+LPhH4I134meOtC8M6HayXeseKtWh0qwUIWW3jds3V7NyWS3sbVJLq4kziOGJySQRn9Kf20Pifovw78IeEP2QPhpc7NC8EWVnefEO6tpFDav4keNLuHTbopu82aKa4k1TU48kjULqC3IH2DCY/7MGmaR+zJ8BPF37V3im1gk8T6vDP4H+CWkXygnUNRuA8F/rccRyWt1ljkmklTj7Bp9wrMFvIw/wJbavrFzeal8QdYeXWvE+va3eDw9DekXEmt+Lr2T7VfazdJJnztM8Pi4TUbwn91JeyWNnjypZkX6Sknwlwrhsqo/u+IeLKcMRj6mvtcBkK/hUeVPmjVx8/3ll704OEGrqLP9N6lWlwHwZQwFFKGc8Q0YTxCVlVwuVuyo0Ere7LFSXPN6pUo66K5vX0mnaDpGoaRqd2tlb2kFvrPxFvxnfbW0ZS40XwZbSA7jcvOIL3WLRid+rNYaYcyaXcF4v2e/h1efHDx/qPxT8W3MHhPwH4MstS1xdY1G0F9o/g3wp4USOTVfFc1jKYoNWTwv8AarCx0PRzJGvjL4o+IfB/g+Ig6nKY/DX0zWfiz460v4R+FLu9v9NstRS+8X67awTapcarrU92kV1cosW+fVLv7bcpo/hrTIyJ9V8Q30dtaGa4u4in2b+0h4r0r4W+FNO/ZW+HRtRcaNd6bL8Y7/R7hL62v/F+jCf/AIR/4Y2F9bsYNT0L4UyXuozeIr21Z7LxV8W9V8U60k99pOieEXtfk3WjOLp0k5Qw9RUqMIv+NiU0opJfHGjdxVrKdZzqRs1FH5JjMZjMN9VwWWt1OJM+nOngZJKby3CxUY4zOasbNqGChOFLBU5JfWMdVw8NadOvKPlviG/8R/tU/GHQPCfhDSrrS/DOnRQ+FvAXhqe8a8PhTwbb3dxdImraiyqt1r+r3lxqHi/4h+JZhHLrvivVtc1q4KJOiR+p/Hn4q+FfhD8PdJ0T4f3EUmh+E5dT8PfCqSOFUPjDx6sS2Xjn403kcnzTaZoBll0bwJJIhJuGt76Jle0uhXVeFfD1n+z58L59Cv7uHR/iZ8TvDb6/4/1xnxqHws+DkyrNcRbwC9v4u+IsLLpdlauY54dHnJjCHV4povyu+K3jO7+J/i6fV1thp3h7T4IdF8IaMrlrfQ/DdgTHp2nR84kmlTdc30/3rm7muLiX5pSB0cQYuXDWUzy2i3/bOZKE81qqyqUYrllSy+DXvQjQio1MRZXdWVOmm/ZTi8+JPZ5Rh8J4cZZOpTUqVHHca41VOaq6E2quFyOdXWcsRj6zljM2lKUqkqf7uo4yqRb8+0exvPEGsBD5lzc3crPJJK5kkkkkk3zTzTFmeR3JZ3Ln5mJwxLKK/Un9nb4M6vr+r6D4B0LR77V/FvjGXSrG406wic6i1lqk8SaH4UtCq7odQ8V3DxT6iQVS10FBIzeVfXDQ/NPwP+Ha29u2u6jpwvXM1sLS1eM7769mLGy05GYHakki+ff42mKximdTvRVP9lX/AARh/YlXwh4eb9qj4k6aZ/EOvre2/wALIL6HEyWt4Htte+IJjdcxzauWl0LwuxVfs+gw3V3bxrHqdvIPnOHMB9UpyzPEx5ptOOHg7KTm3fmv1u/ifSKfdH5j4j+IOX+HfC+Mzuo4Sxs4vA5HhVp7XFSioqry3TVLDq8ptPSMdFzKx+kf7Pvwr+Hf/BPX9lPVtU8Y32nWjeGPD8/j74veJbdERNV8QxWMaRaJpjOUM1lpoFp4Y8MWQwJm8uZYkuNRmz/DV+2R+0Z4q/al/aA8afFTxTMwu/FuvTXNpp3nF7fQ/D9owtPD+gWgJyINK0qG2t1IQedKstwR5s7tX7n/APBdD9uqPW9cg/ZQ+H2sK/h7wbcwaz8Vbuyuf3WseMlTzNK8MSPC2JbTwxC5ub+LLA63cCOYGfSlx/MJYXRv9WedyTufap+8CCw4HPBIYgc4HQHvXqRk6+MhGo3KpWrRnWvpaPNHlhu2n1eui5Yt+6flv0buDcdm+aY3xDz9VK+YZ1UlLDVa6cqjoVJxqVKsbx91V5JKCimo0acOTlUkl+tn/BNW4WL44aOJuBLpuqRoAudubQoqngkfIuFHB2nIBXJP9IFhLlVO5cDCqeh4xj3LDdwBnkfN3r+Wb9jTxjB4L+LnhTUZZAkX2tIZizgbUuf3UxboSuyQswJONmQMLX9P+kXaTRQvGyvHMiyRtksAHUMpHOD8pXBzzu3Zbbiv604YpR/1ZwcabUvZ+0pyta0ZXU7aW1tLT0e6Vz/arwYq06XD08MmlKniZTcUrWjUhTcXp05o2dku/XX0q0IkjAPBZSFOcA5A4zwMY46Dls5PGfE/2gPhvbfE34Y+KvC8saPc3GmyT6czKGZNRs1NxbMrY3DeyCM88ozBtwJDeu6dJjvyACPpgkkHcvrkKwyB365v3kQliLkblCsuM5yR8oBPJxjcuCeQcDFbUpewxKcrOMlZxtZNNJSjJWs002mr3s9FbU/Yc2wFHM8qxOFrJShWoSpy2b9+MUmt7Wbuv71vI/kWltrzwN42mglElrcWGoshTmOSJ45iNuSDhklHGeRt2jsK/oX+E/iCw/aI/ZuXT7yRJ9XsNMfT7gsQ0qXdomYpnLAtyfLLEjJ4Vvlya/Ln/goF8IT4H+JkvibTrTytK8TbtTheNSIxdM2L2A8EA+d+9HI++SSeo9G/4J0/F86F4wl8G6hdBbDxDF5cUcjgIL+JX2fIcLumQtGRj5jIQWBGT+S8S5Z9QzPFUYpqlUksRhptaOEmpQStZfC2mlqmmr6O3+Nn0s/D/E4Wgs/wtOcM04RzD6zCpTi1UngvaU1WjdLm5ORRrekXvc+Y76/8Q/An4z6f4i0aSbTtX8JeJrXXdMlXfE8Vzp92JJ4eG3EAIYypJVoxyDkY/qK/aH8O+Ef2zf2S/CPxO00QNp3jLwWfD3iJ4israTba60QguZQrhg/g/wAcWmmajEhIZbX7RDhFmkL/AIc/8FAvhONG8RweMdMtgLPVB9r8xVOwzhAZU3bcATRfMM/KzRtnDZB+/v8AgjV8Z7Lxp4C+JX7LXiy7V4prG91vwrHO4LHTtUia01m0t9wJ3205sr6EIMxPHJMMHOPjVN4SrQzCEZN4Kt7WrTUW/aYKolQxtHTdSozc9bKLhzaPU/hTxvyyOecPcP8AH2Wx5cSqWGwuMqw+OjXhWhVwFeT1aeHzCKopq1oYmo5PTX+deLTtR8GeJtZ8M65bPbapoOs32iapZyjD21/pl1JZXKEEksnmxOoIzuXDqcFXP9cH/BIn9p2TXPh/4SsdSvxJqnw8urb4d+JVklJkm8O3ay3HgnVZi7ZKwwrPpJdhwLA5ILV/Pv8A8FJPg7qXwr+Ow8ZmxNvYePGubPXGAYRQ+O/DEkOna1nqsLaxZpp+uxBzmRru52f6tgOv/wCCcnx0j+GXxv0bTtTv/svhf4j28XgjX3km2QW11eTJL4b1WVjhI207WltopJTjZa3d0VZQWB9PMsroY7C5lk1aMamHxlCboztzKVOtBSpVIW0blCalF9Jcr5tHb8u4rxuMzThnhjxL4fbo5/wrisHxFQ9k7SjicuqRWaYCTVpezqRp1qU6dl7VRScXd3/vx+J/huHxv4IvIIVWS5NuLqyfPMdzEvmxMCDkcgK395Cynhjn+Gj/AIKt/AD/AIV/8aL7xbp1h9n0H4lW8/iBEWHZFa+JrN/sXiix4AUSS3Jh1VlOdx1J8cKzV/bb+z94zPjLwBYRX0ivqemxvpeqIzbnF3a/uHLE4/1qqsy8Y+cYYnmvyG/4Kyfsyr8Q/hZ41/s3TRPrPh9JviB4U2RZllm02Bx4l0mBsZP9oaS086QoMyXkduNvyqR+IeGuNqZPnWa8I4+TjGdSoqKbVvawmleF9Jc6UZJ3+Fyfm/2Px2nhM6yrwy+kLw7FSwOaYLAZRxPKmk/Z4DMYwqYaviZJPlll2N56VWT1Sap3VrH8DXjTSPs89wuRsJPAHQjqAAjHC7QTz09RnPz1rtp1ZiMD5c7iAPu7eflYMDkBejcDnAr7g+JXhx7ea4McYIUudp4BBJbHBBbrgvzgcDGST8meIdOYF18kuVd8Ayg4GRyoKn5mOe5HygZ3Abfss6wbhOolG3K3fTSytrotNVbprqfbcFZ2q1PDST5lKEHdSVnomra32as387nz5qtqSWcKvyj5ipyRgqM7geSCMH5Q2QBg4Brhb2IgknkMT/DgjaAMNkEkLyWY4ZTz0NesazGQzKbeTcM7tsiEkIM7cnLH7jDjGc4Y55Hm1+ANzC2nB5XA8srg7QcHuFKE8/KoA3EZ4/PsVFR54vVt6903bS27W9mu11bY/oHJsapKF1LRR1dt7K7dlqr9H623twdzaKsJX5gCwfqzESblGfkIzkE4AwOjL8g21iXSyBW2o7sCm5hn7pZAXAOBtzght2TggjrnrbhQhKLBLgoV+eRFJPXBAOA2BkAcYAYfKSq87clgWUW0zBRgBWhO5QUG47iqvnnb2PQ84A8OqopuzSem19fhs3dX0bsrL13Pu8HiYzjG8ZJtxu3fpZNPurNPRX6d74ci/Lz0IKgkE/MoGCAMjA4IIJHPBINZ06sjYIDMUyrALtAYAYOSS3Un5cFuVJAyK0mZkUlbO6Z2PBZ4MLg4bA83DBgoUJhR0C8sQ2Zcu7kgWV1kDaTutvmPCknEgwcEgMNuOFBBAFcUpRTs1JqzTSV76q/T5u1t01q2fQ4aopNJ819LO2jj7qXXez+SXTVmTO2Q6RSJ5oUSHf8AM3ymP/lngkBs7d2SASNzKeKRVDLtyM7BuHZWUbSACchVZQAWGQcEnHVkiyvOJhYSgxxtHHmaFAN7Eu5VWBZvl2rl2I5BAIQrE8lwob/QHX5tpxLAWweW25wwIBx6KpwSRg1wup7zcubtonZpcvSyV/LRWWh6cJxjprfduTTTk2nZq2jd+jTu9VZaP2kKCwJBBJ4Ayp2DnAwGwd2CRj72MkCkJKnoclTtO0DCnYNrHJXJHqOcnkdKjZ2HlAW1yAoVsBrbCnjIUCTaOV+Vc9wwJK5EEriRQrWV0B3w9upyMHhllDFQUBfncd2Ww/zDCU+rXVJ2TXb+67b3slolppaJ106qSUkrXurWevwpprRStsrednfQcRuUMFyF25O0EYyDkHjgMflfb17bjio2TcUUE8bZAcYHOzAAPGcg5O3BYcYY5qOSeRkKfYpzhscyW+QFUYXO/P8AdLcqCvIwSTUTXFydp+xTggBTmSMEJxkE7uBuBwWxgFgRkGspVE+9m020pWfw3votNO1uW/Wze9OqnZcst0le+/u7eV0kr3Vt7WuSSKJFdSThxglCyk8ggghQxCsPlUHOcZwMComkUN5eMlVJBb5SyDC78kuSMcOchSQoOfvBryzuwJsJM9t08QYgZ42gncASBgZPHUkiqhnvFlLNZzMfLWPBuIzsG75QAMDDqOjEqPvAjARsZ1IxknFPmfKm1CTtqrOzT0vs/e7o1UrtOz1srtPpy6atv0et7aJO5ZYMDyTg72GcrwcZBVdygEMDkHqcZIBIagK4O0K3BDBRllAXG4/MSBnIYgZbBKpyVo+ddAEizmIYlc+bGBtAHHy46BThduTyOmRS+beAcWMhypGTMgBwcDhcKSexAI5IAC8UlVglZKbVv5G1b3b7RTv0e6u3fV66wktHd77WdtLJuzTv5NW+fS66BQPLIDkqxyuTjA3kkHYOVGMjCk7gQMmg7sDJPBUgA4ynA2/JnJ/i6FRgkZUgiiZ71eP7Pc4U7v3qkHPVmG0k5ww44/hAIHDBNeASH7AxHOV8xFCx5GQABt4A4fBI28HAOV9YirOMJra7UJJJPl7LVu+vd20NVKOiSetumjej6WWzab/PpqZKqFYb8srDB8wqrDPcgEDYcKeuNw4DKI2ZjgEFdpAYiMclSA3Oc4AXDOMh8Efe4qmk92AR/Z7uChGVmUDgYBIXCgcZAUA88cEgqZrkgAaawVQVJM8bD5f4twAI5xnnAwcrkipdeL15Z9LP2cv7qu/d1vre33Najvon1sls2rO2mi+5KyuzQUEu0gUqFUMwdmPBKOQp2npkn+6hIzkErUyggFlUgkLuXYDgYQkkDJOe+T07lAAMzz79cbdO+ViRzNu3KRwpBIByVJAGQWBwpKcL9t1QZU2DNgcAyADGAVwMoSMg52g7SCM5yQKvG692pbbWEk949ORbd38nsa05xileMvuv2vrbVbN2u7dd0apjRUY5wuUDBgCNx8s4O0gDjJLE7gwJHy9WjMhUgbVAJBAU9QoztB7gg5yd2fuqQM5f23USBnTcKQOsoAwAQCEbGD3DA5VdvAAzTlm1I4B045Xo4nTcTkYOW5JPByOCQWAzjE+3hr7lRpJWbhLbkTe8d9E9Frb5DdWySs7WVlyt2vGK6302d1yvT1SszvtTCRln2OUAAZRtxuJyuDGA7AqDngkYIBVsUTOFYPDuQRk+XGp3sEVjG+12YgHOXyBIAQSwJxkM+qoVObVuMABR0GAxOWDDOdzBihwwJDdKQHUJGba9mj79rqFKMzgDAwAOAAcYIUDeQcDNecqqUknCp0snFLa1rO/d6enQ+U9g7W9pSu1dvmbWtt9G36ppXt6mxNtSJZWcQosivCwQ4Q71Uhtufl+YbVbI2AjjOBIJDv2ADY6Fo5AFJIHykHkn5iCYiEDEsPvNuWsdxqs0W2VYXVlII2KASoKgkgKNyk5DAllyG4AU0kaaoiqiGJET5gGZWER5AILbyM7uVVio6ZAyKv2srq1KpZ2duXV2ST0vy/C72sm+1zP2KcGnWpOabXxJxs+X3k2lLm0u276N7M6Fyscbvh2RDuwMu7bcfKCQRkYIIIHyqxXHWlwDbkOGjfasoQHmM4V9o8sEspGADwVwAQuDnGVtZVw5lgJL5ZTECO4LMFQYGAcsGBJHVsczSy6kWSFpLfc+WUrBIxIVUKszEOBGxIO4dWGBgkEX7VWvy1L8tkmkkneKW0k3pptda2SMVQd7Rq0ZPmv8TdopK6slps3rpqtddNsYGC2wA4+Q5U4JXCox5Y7WIXblgCVwx+YSrGUXzIESQO4aRWd8lgdzOjsVG1cEFFXDFypJAyceM6izCQvaBi3yyskoKs2zDDJwGcnc3qxIOSSBeRtRAJWWwYg87o5OhA6uCVLYyAcYOQAW6jaNVNpyhNNWaly8z+z1cttHstFp3tzVKDily1KT195OT5Xs2rJXut7tp77amsisu9SCybiwJVVdSANsY5OVxg52krywOSMW4IQCSoIGS2CWc8hT8n3sc4xxtwQP4mFYyS35Ckm1R9wjYEPkH5VBJVgcAqSpHQ53OuQavIdSPWaywMEnEg4A5HVc4HXjB3ZxyTXWpLtK7Su7X/l89FrZ72fax59WlK7ftKSVtbSetrLVJOPztbyWretDGULKSXP3lBXGyPcpKZJ27lIBOQCSCc4661tGNq4yEUqVYknJwpK4XoABncMgAHtWDEb1W3O1ttJXBCPtG8LlSGIBBXAXdke5OFGzbC9GArQBQ4UsVYhguNvzYCqBxsZdow2AcHnroys0kntd3umvha63b/DTvqeViotwf7yF7PVSdm3ypJWVtNXd30utNzooI2ZgOQGAwzEYABVScMvXIbYDuwPTBx01jACF2hgV27jkncCQRuBHJ42rkDI2hhgFq5m1F8dvNmwyDghwNoPPcDDsCTjDA84BwK66xF2CoVbRmbI3DzASAFXPOPlGMZxuYdcdK9bDRjdWjPyurWvbe9nppo/nax8pj5uCcVOFmrv3vJJq3TTbfVXex1unQBdq8HdjGSNwcbSMdCoAG3GBgFiDg4rvtHtC7I2PmBweTgf6sY5HUlSpI7HdjdtJ47TIbwyBj9mwcYChjwQMAcr1xx8wzz05x6joNpeErjyQGKn7rckHrk8DIB25BIB7EHH0mBp8842jLluns1vyqWltV8r99rn5tneK5Iy9+Dfe78k7rTourPTPC+mmUp+6LbGHygHJG4ZAO7JORnI6ZXILc19q/BnwDrHivX/D/hvQ7B73WPEOq2Gj6VaxLmSXUNSuYrS3jyCWwZJVMjAjYu6ToDj5w8E6WLh4VVWjlTaWUoqqpAQtscht29shVJOQpHz5G3+iv/gkR+zlceMPiFc/FS+043Fh4IaDQ/Cwdd0V1411+Lynni3gq50LRnmmdsboLrUdOlJBUNX6fkWHpUKM8XWlFU6FN1G5e6rRS3k9ErrVvS730d/5J8V+KKuAwmIp4VSqYuvKOGwlCCbnWxWJlGlh6UIK8pOdWcVyxV7XaVj+l7/gnT+zhpPwj8A+GtGtYFey8E6Rb6RDdmNQup69cg3fiXWjnBL3mo3EzRyEl0hcxE4QCvfP2vPiZZ+G/Ck3h2S/TT7e8tL2+1++MixppvhzSYGu9WvJWyfLjFtHIm5sKUL4yQFP0Z4R0Gz+HfgS1styxx6fYGS4mYBTJN5fnSyOx/vybnbOOTgDGRX8w3/BYH9qeXSPh/rHhzTNSZPEXxjvrnQrFIpgJNO+HGgzRtrN2oBLIniC+MOnITtWe2e/WPiPdX55w7SlxrxxjM9xV55ZlVROhzXcb07rDRTbdnKUZV5K/K5R5dmkfW+I1PEeC/gJwr4RZXUVPjzxRqSqcQ4im/8AaadPH+zxPEOLqOPvuNChOnlsJXT5NY2cGfzw/tb/ABrvfjl8ZfGXjxhMNP1PUzp3hawG52sfDenutj4f0+KFTkSSWiRzTogDtdTzuBlzn90f2edBsv2A/wBhTXviZr0CWPxG1XTbuPT459iXM3xW8aWKwzAIcSOPBGhpZaSMGWNLyy8QISrXLsfx8/YE+CF38fP2jvD8k+n/ANoeHfh/cWHiXUIJ0JsL7xBJex23gvRLpsNGYZtYCapfxsCf7H0nV5XQojA/Zn/BWr462useOvD/AOz34P1Az+Ffg9ZNaapKsildW8bagi3GvajdBDskuoJHEM2WO3UJL7BHmMg/ZsTWjKEp1HaNVOc7u6WEouEeTR6LEVlToW60o19LKx+J5bw9HMs64a4ByuNsFlscLisy5FeMIUqcfZU6jS0lClzVm3r7evhJvW5+TrPqfjrxdLJK0t9f6vqDzTSMxlmubm7nZ2Z2OWeSaWQnnJLMSS2ef6F/gH8O7D4NfCLTbK5CW12dPfWdenKqjLLJCZZFcscgRxkQr1PBK5A4/LL9g74Qjxt4+/4SfVbUy6N4Y2Xr+apMcl8C/wBmiGflYxnLsBkZUngkCv1P+OfiSSDT9P8ABmmHdqHiOVBcRR/NIunxOqxw7V5H2mUqoAYExiQHrg+5wvg/Z0sVneIX7yq3DD8yVn7yvJafaqLlTVlZPdM/024Ro5f4d8C5zxjjoU6EMBl06eXwmlCD9nTjGnGN0rurUUYR00SbSau36D+yL4KuPiv8XdU+I+sW5l0nRZxPZiRSYlkwVsoEDfJmGJVnkUZHmOMEEYP7MRhVQYXCjCgDqRgBRyR0A59Bzjsfmn9l/wCGUXw1+FujWUsKx6pqMCahqLFcSNNcAvtYsC37sFUUAgKMqP4jX0rF0zkgcDB9Mce/QHjoR0zivjuIcc8VjpRUnKFC8LrZzdnUlbr7y5U1f3Uttbf5E8X8T4zi7irOeIMbUlWq47GVakZSd7UnUvTtdvR/Fo9paXRIzqilsEHA28YYnB4yM5I44zhRkDtjltTvBHFJK0hRUVmJyuOmd2eeFGSD2DAHBG6t26lxnnChSGBGATnoDyGXgYHQEYwSQR8sftH/ABQs/h54B1rU5bhYZ2tpYoMybXLlWBYZwwCgn5skhgM8iuDLcJPEYinSUfilHmdn7qVnK99LW3a1000vf4zH1p1pQoUbzqVJKnShHXmnNpKKS3bk7PTq+qPyG/4KT/tCl5Ljwnpd6wt4RIk6xycs4EisxCk5H93I4wxYdx/Nj8QNfkvbuaRpM7mkOS24jOSS2STklvQZzkjOcfXX7S3xUufF3ifV9QnuXnWW4uNm592Qxcg5Y8ckZySDnAHPP52+JdUZ3mYsDhySMnABzk4XHcDlTkcA8UcTZjGU1QpN+xw0VSgk3ryqKcnbu3rdaq99Uf2r4NcDLJMnwkatNPF4m1fEu3vOrU5W1J66R2V9bJ+pw2vaiFR5M42hsBTg+4JBJxgAHJIxjkgMK8YvbhriaSQtk5yqtkkAEEAFsjoBj5j1OBjIrqvEeos37pWJDkqW6cAnJwBxx1AyCMgHrXEt0wTg5C9OuMFxnJ53cHptyT97G783rVPaTb77JO/RaeWy73at6f2nwvlfsadNKDSaTtZOWnK7Pe+r/u9epEGJ69SAB3wOM9OCSR2bjoDkYbQs48K0hBU5wv5L9M84OenRfvfMaS/vHQBc8gDqecgDPUjjjpzwOep2FXy0ABAUAZI5Oe/GQe3AA5Yk84zXThIKT5tuVJtaXu3HTqvN2d/S13+5ZNhPZ04SfRJ263tHXS7Vr9+ju7Wsx1DYBO3qCG4OOBjJ5GQoAIIHqwNX9LtnlmQqpYlgFCnkqSMspOCecn6cZqhgu/AwcYI5wuAOmOeSMnknkEc4x6p8OvDF74i1/S9LsIXnur29t7SFFG9mklkCDaBzwW68lchipOGH1WS4GpjsbRowjzSnUpxSSu3KUopLRJ9utujejv8AW0KXtZxpx96UnGMV3lLkW26ktE4rV6Kx+uX/AATO+CX9ra9N491OyzaaSBHYs8Yw90wPmSJkENsAVMggknkjkV+m37YHxJtfhj8JtYuIZVj1LU7eSysUDgP5syMgaMckKgbIbBxgFeADWx+zj8OLL4S/CrQdLWNYLiOxjuL99oRnmZPMmZySB8rE7mc8AbfmOa/ID9vj45yfEDx8/hTSrxptL8Pu1uYonZo5bxyN+FHD4b5BjknK8EGv60zGpDgrg6lQptU8VOlGjFq8ZTxdeK53o1f2cZb9kfsuNlDhLhOLT5MVWpNfyyeIrRjfzfs4u912R8R6J4fl8X+ILzWNUE02nWUpv9TnGS1xJPKfsmno5JxcaldBIlxysAmnPywvXE/Gu5B1iKzCwrOIhLNFbqI4YAwH2e2iVOiQREJGrBDz0IBI+kbC1Twj4bhsJ/lksov7U1psLmbWrm3Dpbs2MldHsnjs44yziHUJr9gCJAK8I03wiPGmo+IfFut6jDpelaNGdReW4srm/XWNTLmXS/ClrHBHIq3WqxW9yPPuFNraWVtc3M4ysUU384Ty14lSgk51sRU561Szdnfmk3beyd73erbbVz+W6ODxOdZ1Wxcqz+q4WMuZy0jOrNpttu6k2raX6wVndoz/ABRoOjfCfwBog1F4T8QPFmixeL9Vkt73ddeCvBl6kttoegm2lt/Ji8W+NDN9quIpnkl0fTjp0hSKSbUo4/ju91W/12+kvb3AeXakMKA/ZrO1QbYLO1Q7QkFvGAi4IaR90spaWWV29U+MOsX+t+Jr23v7h7q+F2b7Xbg+WGn1eWILFbM0cUKhNHsjHZIqooS7a+eMAMufP9L0u4u7u2sbRQ1xdSiKPfgRruB3zSuNwihiUPLPKw2xxq8rHCmvDzSHPiKeX4SM/q9C1JxsmqtbROdlro+/W9rR0On+z61Ck1WrOtPmlNvltBOfLZU4a8sI3UYt68sVe8uZnXeBvAuu+LtTTTNFtI5pVia6vLu8urTTtK0mxiKi51LWtVvpbew0rTbYMvnXl7cwRKzRRIz3EsMMn6h/Ar9iBPFHg+5+Iyx+GdT8A6Pc/ZfEfx9+N/iG9+Df7LXhe8QO0lhoc0r2nxJ+NGtwiMvBpXhWz0i8vJUMVv4Z1m1dLiTP/Zq8C/Bj4e/Cu6/aN/aH0658S/Bbw54ll8N/DD4RWd7caJqf7Unxm0qzt768stX1K3dL+x+F3gSC+sNU8YavaF5dOt9S0jwpomzxT4l1PUNK5H4kfFH9pH9vvx3Jqev6loemeD/BFlDa6LoS3+mfDb9nf4CeD0eKy07RtEs7qe38L+E9Mtoxb2ipb/bfFPiK5VUc69rE4EuE8MqD9nThGUqfKqtd2lGNRpKUKMJRanyNJzqSTTatD3lc/IOKHmePnjIYfHUsnyXLmoZnnFeUo04VI8jeFw6hVpVMRiUmovlq06NCpanUWKm6lGHpfjTUP2D/AAfc2+kyap8Yf2sfEcEgsVu/Bthov7Kn7N+hzTtFE134f0K3sPEHxK8U2enSDzoL/V4PA91q0cEct+itNIUs+Pf2svjj4J8EXn7NfgjxHc/D/wCGNrc61FrUfg+0Xw54i+J8Opa7cu1/8RPFenyXeveK7fybe2t7C0udan0uK0S3SG0XYjy+f6Pq37EXwKDr4vXxR+194+toLd10PRJdV+FHwO0++DrJLZ32q3UH/C0PGdgHCxStBYeAYbiPcIHVGElX/hb+2P8AB7wq/jfVvH/7Jvws+LGs6nrM+sfDyz1zVPE2neHvA0Oqai9xqXh7UktdQk1zxVoVnapZ2+gW13q1q+mst+0lxcvqN0X68NWjSoTpYipSU5VY11NqNVxcU0o31s2mlH3vdvf3eVM/OKmNxWDyjM1kmScTZzSq1sNfFZtLD4FZglPlcsvwWLlhVhKFJS9tVqLCYSNaDvBVpWv/AE4f8G7H7WmnaJ8O/iF8GvF1/K974M8QzeJdI05BcXd63h/xwLFJZBb/ADTCLT/FelPbzyLG+248X6b5zxqJJK/cn45/8FJfg18G7Oebxh478IeBiIzJBZ67rMV14lucfdW08JaOupeIJS43bH+wCLoWdFwa/wA9rxB/wUR+OHiAQWXgyP4efAzw7ZG/GneH/gR4B0D4apZf2h9k89pvEekQHxnq0ifYrdo5tY8RXximjS5iEc8cbr8+X3xP1bVZZ73UtTur+8uX86e7vLia6u7h3O5pJrm4keeWVtwG+VmOMliCWI8jE8P8L5ljnmuYUp4nEyhCE6cm40GqfuwmlzJuc1y8/PGUb6JOykflNTFeLWBw2JyjJs8jwvkmMxlfHvDYClTxea0quN5J4qj9flSjCnB1XUqw9hFyjKpJc7SR/Xb8ff8AgvNoNy95Y/Cvwx4g8YTBpUh1vxjeJ4S8OlhwJodA0x77Xb+MY3xrc3uiTMpIeKJiVr8fPjP/AMFOv2j/AIqJeW+p/Ee78PaPch1Ph/wFH/wimnvAykCC5v7OV9f1KPDYxqGsXKyc5Umvx0uPHUjEh7lsPwWLkHPAYN8uAecjHIySM5K1zl54wdyXEjAqPvbuACBnBZs9SxwBzjkbtor6GhmWUZTTjSy/A4XC8ijyuFOLcX7tnzWsm2tXHl9LWPmKfhvicxxH1vOsXj84xVRqVXE5nia2MrTleLfO60ppO/8AJFJPTQ+n/Efxc1DUprmWW6eWaYySSzvO808rtkl5LiQmSRyTlnd3ZnyGwwrxzV/HF3MSTcNh2O5A5JI3DkkLk8HAI6qRuPIK+LXfih2cjecjJVixBZsqB8zDpkHOF68kBsGuYvfEswC5feX4+UnA+6eQpByQDk8Nk7iNikjgxXE1eu/erSvvZydrPlvZLbrtqvmj9KyPgLDYPk9nhaaultHyVnoraJet3bbf03VPFMxlhLznJ83DbsYG0HJG452jORx2OCDkcZe+JXG4mXcMscEkHB25JzjAHQnOeg6AV51eazLJLEVbaMyZ4GOYwdpC5xnqAWAQjCApxWJcag7MV3HbxjnjgqAckFcn/ZyDnjHBrwa2aVKjk5Tbaa0v25Ur+XVvrutz9Ryzh2nSjSSgopLbl0Wt/u300Vl1OzvNbdlA3HJZSSCMKhOG/hf+EhVLc5yACDkc9carNLHcHeSouoVXZ5bEg2/OGchmTICgbckkjPVhyst2XDbpHBVSVKs2SAF59ewBKjkAL8q8HKkvx5VyjSFyt3CSoeRSoFud3HJIGMjgbcHqMmuSWMb1k16pt323fTv66bPT7jA4BU4RtGN0102XNFLXe2/ml3Wq6GfUSGfBZ45HYbWBJ3Fsja28D7qg8929Q2Mx7zacLk8Eb9y8AgEEkY+6BhgDlc8YAOOee8lZyd2Y0Y5PVmOQewDqBgjuRzj5WK1VN0R91+GAOG4z93IC5ADc4OHOCDjnpzSxcrySk0rRW91dava9+qvfot+n0WGopWTWlldW0+zy6K97bXVu+qZsPelGBJGQQfu4XkqOQWAJIOeOCBnis03uWJySQSmWPAChdxCkjIPQcDb7scHJa7yMAIU6gjqGXGR8ueuQGySFblQoIJgNxuHzDaCM85DfLgAkfMflznAGcEEkkgjB4qTted20tU03tG1tdPJNa9NLnq04Wa7+6t7N/DbbVPpbrpbdI0Gkfc28EMPmUhtxZTtIZiSMZw33Que4U/KYGn3qQMKowc8HkBNw3OVCocctjqSB8w5zmuFPLc55OMg/KFADHGf4T6AnkdM1WklJUKxA4wrAHAGFKruYn5c4BAxuXHAPFT7Vpbu7Vk9buzXRRTdk9eq107+lSSUflZXUdNr3SSSsrc2ia35Ui5c3ewRsSHQkKMHLKpKEEHIZQME8ncCAdhPWtcXBkFuu1lIMqggoC4Ea9XJwCwAIG3LIf7/Sg82QxyylHVlbeBkA7FGW5xg8ZB3bRuOQA1aRiPsofBf98W2sQAvlI2doGeOhZCSQQcYXIh4huLu7JuKtd7qUNbtK297q2l/K3o0ZNwqNtS92Fr3XWNtbLZrotdWzREm52yJB99JCGOPmZdm0uc/KzEMwAKqQD0y2beSZRBgfJcW67iSyttbAODtAOCVOAQ20kMGGBFNcFCFO8hjtLlVKx56s+7J3EKSTnoCyJlTnOvHdrdcMSRJDtJ+beokT5d+eVbeMAEblByAScYTxDjzu+yctV1uurvvql0XXXa4uNnb8NXpZ7tbaX116PXfXeRgcgEMc4UZ28HOCuQpBbOMkliRzk4qu0hIRjtUrxliAoJKYQ8sMDGAcjIxn5Qar7xkgAbuTywkDYYg4G4HLEkE/3eOtBZCw3A8oD1Cxh8gArgjO09Bz1JDBiQcJ125b29Ha1nFprR6Lu7Wuk7XL5/NPmSWiumny9bW03tvsrXWloSMBsDByqg4wSFACEggDGzIwOhHzDIU8xW0kgubgAMWW1mXeVP3REqg7SwCkN8oIJVu/C812lXIJyzAKuCW+fO07izdT6khtoG48kqIrOVHubpGIJNpcfKoJKt5QAVgN4CMRg7gT1bcCTuxVZp00nb3lq7aNpLva99XZ7p+qakpSpq9m2ldPZ2Sdk9dVf8LJaW1g3BVTgRsVwMYyBgqmNzEHcwDZJwcAnqJ0LEgKGBIyVYk5BUAnjkBQO54ySCV4qirMo3lic4YgFhwcABemSoyoIA5+9zjFyLcrLtBLMPnU4wAcHBAYbQvHBKkH5hlaFO70vfd3e+iffslp+OyE207XTdra7Wulrr9m2+z2WxoRqoCjnblSACO5GTlckE4525wDlc4xWraKSBtVmA6gFuSAuCMj7vQ45yTuJzWTDuGCGL8qMLk4BK84UY47ZYYyM8NtrqNHgaaeAODhSsjZx9xCNnABHzOyrgcMWJHpXfQs2lfRyXXRX5VpG901dc1t7ffhiZxp0Jzd/dTe+v2VZJvS/qrtpu+jPpv9nn4V3vxi+Lnww+EViHEvj3xj4e8LXU6KWFlo9xdRXPibU+2ItN0SPUdRmckLHHaSNIV2lq/qA/4LE/FCD4NfsFfs+/s1+HUXRtf/AGhPEU3xT8QaRb4iex8B6MLX/hDNHlhUqUttN0t/COkWsbYAi8KpEoxCNv5lf8ERPgLc/FX9qO/8SSwsLLwr4et/A+m3SgMU8TfGGS50HVbiA4P+k6N8K7D4l6vFIgD20lvasSrMhr1r/gpL8QLL9q3/AIKp+IfCsVxE3ww+ASWfw2jSCVf7O07wz8NraTV/HNxEOII41u7TXrbPMcot7eIMZDGtfoOChVjleFwVOMVWzPFKqm4ty5U3hKd27JRUZYmon/NSTVtz8F4mjU4r484E4GpylLBYHEz41z2Oji5UXHCZPCpK9v3VWVbEOLT/AHdRy2PmL40X8Hwg/ZN0rwLHI1rrHiXw94N8BFVYiVrjxddW/wAX/iUQpHmpLaaVY/D3QLsBQduuXUcjk3BFfpH+xb8IbvSP2UNF+HGn27R+Kf2jvG3gv4WPsUrdNp097/wnnji47MbfTPD7eH9IkdgY0F9fAhHkYn8f/jfql38ZP2mfh78PLo4s9Ag/4TDxfbIHEFlrfjVl8e6/aSo5+SbRPCreGfChiYA2z6KtmAFjWv6xf2CfhhJrnxk8HLPZBdD+Avwsg1qWHy3EUPxN+Mog1+/iUsDi70Xw6+maOxz5sMdlDGRlcV9vkNWnSr8RZ5f/AGXh/L6eTYHmtZ4qKp1aqhdKN44nkpNxetNvl6NepxZxTDhvhjxC49T9nUng6+EyKTurVcfGnkmSxpN66YKEsTKK1i5ykna59Kf8FN/2gNP/AGN/2DPFUHha5TS/FvizQ9P+C/w1ggYQ3FvcapprWOq6jZqmWX+xvD0GoXKyoPkuhaDcpcE/xAfs7/BfV/jl8UvDfgmwWUDW7sz6xqOMx6V4asiJ9V1OZ3wsTSoDBbvIwV7iaJSVD4H61f8ABeL9p5PjJ+1fZfA3QNUE/gr9njSG0bUooJi1tN4/1xbfUfFUzAExNPp1sdO0H7uYbm1v4+GaRR8d2Opt+y7+zJc6jbH7D8af2mrB7DQFizFqHg74QWsht7zVF2BZrS48Tu8tpYkbZJUlNzBuktdw+Z4cwVHHY6vmmZpzy3KVLH45t/xazlzUcLFuyc69XkoqOrcVOS0QfRN8P6GXcOvirOqKjSxaWc46c0vaSwlO39nYRTesvrcrVYxlqniJtq0U1wX7WHxM0z4wfEnTvhz4CuYNL+CvwU0efw34clTcNJh0/RYox4n8XzqjBX+0vasli/zyXFtDp8CF7u8CS/CvxJ8cXOm2luNDtLi21zxHZp4d8AaJGmdR8PeFnuHgfUp4kzt1/wASXU7yvNGqyS6jdXUiMttbRRj1bX/7P8FeG7zQtTk8qDT4LPXviJOFxL9qOy48MeAY3DAyTQN5Oq69bLlZNVurHTpkLaVOzS/sx/Cf/hYeteMP2jvi3d3fhv4d+CNIvPEt/qcAAu9N0C2k/se0h8NLMrJN4q1/UJbfwL8NoiskU3i3UrnxFequi+HtZu4nm+YY3M8ZiczxcnHMcxnKVr6YLBUly8tK1lThQpXpUk+VRmpzf8KMl+ucSZ9HMsfmHEWcV3TwdCblCMYp3jeNPD4bC0lZzqVJOlhcJRgm5zdNK7lI9G+GFjYfsc/BiP4lSyRP8ZvHTatpfwpAWOWTT9Z037XofjL4qyBmZjo/w2+13vhT4ZyLADqPxXOv+LoLpW8AWkc/N/s8eGNJ8OaZrv7QvxNsH1Pw74UvLbT/AAb4cu2kkvfiH8R9RdzoHhqENmaeDzo5NU164G422m2tzLK5kZA/Ei48Wftc/G9WSz0/w5pBjttP0jRLORofC/w4+H3hizMel6JaSzuRa6D4T0C1+0alql1IJ9QvFu9Z1SeXUb+7uZYf2h/jlotjb6JbeCC1r4O8GWWo+F/gdpM6rE96zlbXxd8Z9btXGRqniC7gePQ/ORpbW0itYY8HTpnmMsrYbJcIuI8ZFKlhnUo5Dh5x0rYqMV7TGzjN+/SwbcJK6fPXdGEnZzanhylV4ay3G8dZ1h41+Js6msPkOVzSdHDzhTSwOEg1zR+pZNSn9YxtWN418dUq1bWqOMfPv2gPitr/AIh1XWPDl/q51TxP4g1qTX/ibrEbgxXuuyMHs/Dtq0H+q0XwzatFaraKv2aOWPykGy1gK+UfD/wrP4i12zs7aPzFEi8vnYcMd00rEgLFGCWdiAiqADxmvJ9CuL25uXVvMuLvUWJM7FprhhMxMjM5J3XF0+4vnLbCXLDGT+o/7Kn7P3iHx3rmi+EvDOi3HiDxR4m1LStEstGsIz9s1nWdUkV7LwtaSrtWOExf8THxPqDEQ6Zo0brM8TTFl+Qw1SvxJmUq9ebkqk6levObvyQUvaTlOd3eTbcpydm5Ntu97/mOa42OS0MXjMxxEquNxU6+PzPG1GueviKlqmIxFSUnpTjbkpxk7RpxhBPlimfpJ/wTR/YeuP2ovjBothfWVzb/AAd+HsFnr3jjVRE8AutMnlKw6bazYUxav47urR7Gywxm07wva6jqQVZZIGP9Lf8AwUQ/bP8AB37C37PDnw8ulWfxC13R28JfB7whaLDFBpgs7FbAa8bCMgQaF4VtPJaBCqw3F4LGwjBWSUps+EdH+Cv/AASx/Y7Nx461bThqOn2p17xpqNgI49S+IvxN1CyiVtJ0GGQrJcWdoYoNE0G3KrDp2i2Md3crETeO/wDEN+3F+154+/ay+MPiL4m+Mr1lW6mk0/w54ehmlfTfC/hu3lkOm6LpysQNkMbNJeTkCS9vZp7qXDSBU97MMdRpUOeH8Ki/Y4SKTTq25b1LdIbPmbs0oq2srfxnjoZn44eItGk5VI8I5HUhThBX9lKlCcJSp6+79Yx8lz1WrShR5U3GTjzfM3xB8d6z4w1rVtb1nUbnU9W1jULzU9S1G7mae7vb+/na5ur25mcs7zXE7s8rswLSOzZOa5vw/KFuUDsMkAgngBuAQ2eeCATxnrg7jzxxuDK+SzHPIJJPzEjtx8vJ64AJwuTgjS066KXEbbtqhgDlscEjk9iOTjGegxg5J8nK8Q/rNOtKfM3UTb6vmcVq9dObpora6WP9COCcsw2TYXB4ahShSpUI04U6cYxUYQgoRjGCSslFW0Vkno97H1Z4A16XSta07UI5G3W9xE5KsTgbgMgAlQCucHqOBknFf1LfsxfEWLx/8M9BvjMJr2xtYbG7ywMjNCmIpSSSf3sZUg8AkMCck4/km8P3oPlsshBBBLZ7DdjHI4HUcdyB8wyf2n/4J4fGZNO1o+DdSvStvqaiGBXkwomBcw4VmAByNhLAMUbAwV21/WPhvmcMXh6+WTmpSq01Ww6bb/e07OUd38dNyS63S6n9h+F2dLAZhTw9Sf7rFxjTa15VL3OR6vdSXK9b2b2vp+8lhIxOSDkkYXocZG4Y5HJxgjHTsM46iJRINmATjJ5xgAHDFe43DH9MYNef6fOSMltxBLLySMjDFScfKGBHGeRgDjFdnYzMSuCQuBhjz7g54OFLEFeFx8vJyB9PjaTpu6aTWvXdW2Ts337J9Wf1VhqqnDlveEuW99e3Td22a836nxj+2t8J1+Inwl1d4LbztW8OedqlkwTc5jjRmuIQQuQHj/hAIOAQBjNfz7+AvEl74B8bafqNszW8+m6jDcIwZkZHt5CSueucAqcZBUYYYzX9aGv6Zb6hZXVrPGslvdW8kMyMAwdGRkcYIxhgWGWOMHBOGr+Yz9q34XT/AAv+Lmv2EVuYrCS+bUdOfayo1neP5oCdCfLfchC45z1zXy/FeDjj8po46nG9fAv2dblSu8PUacW7a/u58yu+a3OlpY/lP6Q/BFHMMHWxEsOp4fMMNUwmLTgnFuVPlhdJbyj7qvr7quu37Z+O7LTP2iP2boda08RXV/Ho66nCQu90uYo83UJUE4TzkdSvKgSEN94Afkj+zr8Vda/Zs/aE8KeNLFpIf+Eb1+3N7b73Rb/RLiUxalYykbQy3FpPKnYB9xA3JivtP/gnD8Vo9U0rVfhpq9yHj8p7uxilPBtrhGju4gC2SEJjl2qNoKBimRmvl39sb4Wy/D34j391BbGK0luzcQFFP/HvPIZ49pAYbY2Mi7uPvAYCspH45O1HENNXhK11upU56Tg1s04t3TTsm9bWP8caHDcXDjfwoze6jD6zPK5TspPDVYqVGpSvdqUL0pqybjNSaa3P28/4KgfBHTPjt8FZfGfg6IXw8Y6Dp3j3wbdW6o4/4SjRNNF6qRkHCSeIvDDT2LRqrGW4jd+ZVAr+V7wZrctjdxI800N3DIoGFlSWKaF1AKPtBilhkXhvvrtBzkV/VT/wTx+I4/aS/Y1134Xajdrc+N/gzOr6GJH3XU2mKZ73StgJEhjwl7poJYL5b28bhVC7/wCb39qz4S3Pwg+PninTLBYbLQfEN3J4t8PxMdrQW2p3k66rpzK2fKfRtch1HTDbs7MiW0TfLv3t3YarOnhKcE5Sr5RXhg5yablPA1lGtltZ7aeym6Llf44OOji0fzBwLSr4DMeJeBs2XJKpPFY3C0pW5frNGf1PNaEVJ3cZSjTxdKCiv3FVz+0mf2Y/8EuP2nF+KHgbwRrl/e773xBpv/CNeKUZwxi8ceFIobK8nly2Y5Nb0z+z9ZQNjzDeNtzsNfqd8evBsPivwZdXUUAuLzToJLqCPYH81ShW4gYEZZZoWdCNpUllO3IOP4zv+CRnxrm8LfEHXPhdc6oq2/jO2tvE3hbEuDD4z8IRzTyQW4bGyTWfD8l3G8a5Mkmn2qEEha/tk+HPiS18feBdM1QMkgv9ORZ0znZMY/KmRs5yVkDKQecjPXFfiXifgamRcQ5Xxbl8XThVqUfbuF1H2sEmr2sl7SHNTacm2qbd/eSP1vwAp4PiDh3xQ+jlxHOM6EKONzXhd1btxynNG52w8ZvV5Zj3CrFpNKpUaSSgz/PO/b7+AyfB341+M/DNvG0OgX9w3ibwqyQyNFJ4e1x5Lq1tonxgjTrj7VpTYP8ArLHkkklfyP8AF2mQQyTDMpB3AkQu3AxnjBYAsCDngnAALBsf2lf8Fjv2ZhdeF7nxvpVko1L4cX80lw4QlrrwR4muU37yDuePQ9aMboW4htru/cDbiv5DfiN4f8i4nBljCksR1UZbI5IGTyzjnKjJySDmv0rF1aObZVg81oSU44uhTnKy0UnGDautE3o2umvqvifCfNMwwU8Xw1m7dLOOFsyxWQZnTnK0vrOXVVRjVTkk5LEUVTqxnZRlzu3RnxDr0FqwfDz5U5YiB8lQeRncHyMNuIxx1O4ivNr6G0VizGfByAfsrYyADjCvjJJfaGJIO5enA+h/EGgQqzH7bagHLfefIIIOCD8wU7tx6nccgEZJ8e1TTIR5inULQgcqCZRzx1Ijz8u4kE4BDAkqRg/mWPo8s5OUU1fRuLbsuXrffXfXzP7MyGtWqU6b5oJNR972kNb8iuveV209tb3t3PJbyK0DsolmVc5KfZWwegJADA44G5gPmAY8cCuRvFti+1muSNwG5LRsbSFBDbueSDng4XBIwxNem6hYpkhdQtdowXG6U+gxu8vLNyxzn7p5GeK5C606Asw/tG0UEbxnziNvBUgiMABdxKIxOOoDNhT85Xp3layWl9pN3uns3vrt9y3P1HLY13GL5k78unNDS3LZ36bu6vv0ucNOLNXOWvd2GwfsTAbuR03cAbR19SCckZx7qW1XAAvdwBzi0YHAyxUgA8ggnIzkc4P3q6+4s4QSP7StE2sEwBcsNpwAc+Vg5w4+YbVUfOwHFY8+nwB9p1ewJMfmEbpzjAUtgiN1BCglSrcDIXLACvJqKSbV4rdWad2m1vZ63V9LW/NfWYWlWST9pq9U+aNlzOOt2uvo3tta5yzzW4+YNeYbcpBsZtoySSwwcZADgkhiQOSRnNZjb5bMt0WYHCtZT4BzgqA3yMDg9iCTxnkV0ZsLWTef7YscqHwjNdDcAVzsITLFi4KjkgZGThgKrabbh2Rtb00sUV877kEq+3GMw8MHJ4A74G5sgcMlJ2d4r+X3WtbRV7qWr0v66nq04V9Ep66b8u3u9UtbK9tG73drPTALWaREl72Ta+P+PFhlgvYkgbcYJDjjK52EgmsZ7PPH20qQOtkcMd4AOM556L1AztOeM9D/AGfaeWW/tvTUO4oQ5uScDGTkQ8hs7gSpIAXcSqkVD/Ztn8o/4SDS9rAMNouB83QL8sKngkkhc4PC5bphKM3quXRpP3b3vZ782rtrprtsrW6o06z05+ia5uXm+w2ttdb2e9rs53zbUZyb/AyNv9nkjaDhWyHAb7jcDHIPAb5TG01pgP5uoYxuC/2cSAeOCC5xnkEcrg92+70DafZsdv8AbmmEdSoFwNyksp+Zk8wgY5ILEdCCQc1zp1pyG13TflOEOy7GcAbQzBCRknIDnYVYnG7FY8s+rb6Wa9PitLZpJqz0bex1Rp1Layd7r+Rp/Ck79baLpaytbQwmntSzNuvW4dSGsXVDyx3YWQDII4yNwzgrzUDy2u4Ai/fAD8WRG45zsxnO3OTgbgckbec1qXVtBboXi1GC8cbv3NutzuIKhsjzBGu1dpwSwdg3zKCc1myTOhULFJ/qi28q2T1B4WU5XqsYGQQuQSgG7B86duZJLdct7bNO99rt26arY2VOaafP5uNlt7vo29dHbz06VZJ7fcVKXYPobZ17gZwpUliSQCV4xyCME1l1Axl1a3uHxlM+UWOBtxklSFzgndsDKWHHLYuzTSOpwJk4Q7lALCQAhARkvhScPiQk4wDgioZLmRAgEU7o4UNsCEqzZyuMM25sEgltwXOC3CjNyld/veVxUbpU3Lm1W/V6O2l9etkzdQlGzcotb3+cenbzv13RX+3kgqYrk7lwx8njnOJAACCRgbTncOMAqBSfbVyFFtdFT8xbyuTg4wBtOASSoCnGW+Qg8VbW6lClmS5TDbFUrF8wBKgswx8zYbcfYhtpGTKtw23eTOBgEjaCqgBdwO1s7Q2R8xDnHIUAkZtVH/zENtWslTV5JKKvZ2/J/cVbZKSt0XLdLZbt2201beummhS/tAggta3aurAElDyQc9FX5mBXOTlx0IPOXjUzu3G0uz8ucbRjgAAn5NoYgf6zHfb2q2L5AVzHcEqjbhtwGbODjfuZTkkBgxGeBkkBWi/DHcYrk9AML6sN3AycjJyGG4Y/eZUUmpxb/wBo95KMW/Zx00irJ33vpZPr5lJPbnW+yW2y3sr9F1bemqRX/tMHOLa6IJJLCIDHHIIwBggkEcE5LYGaDqrDG21uiSCWynJUdTzkMMbgCMcH7uOati6jOVW1uywBOcbcLnIPBAJUMcYHbCEAGlF6QxYW92AuVPDEE5IzuOWyRn58fQE5FTeo7NYlO1rXprVe72fut21+S1cioqSso1FFWVk4u6sk9tbNbX9GUjqeDkWl0uExt8sjHIwWO1trHsxIVskcg1csbyK52gEo6n5oiVUhCUG/fGDuG4ZOGyDjPG0hraiilEMNxGCS5d1UBVwodwCcyAbhuUAkAc4HymnfafJHIL2x3h1PmyQx7t2fvGSMZG7PB2YxkgqM5qlKpFc8aqrKOkoWs1Gy1Xn1aW+tr9LV01KMuazV0vdaSs76Wsurt1u+uj0uIQ7r5m4uCEDMQAcqvD5ZSCCueihsjg4Bc9ysci7mCqeTJs3Eln4IKk5X5fv542jBJHMgtbeCSQhFQNyN5yv+sC4AdchSAoDArgdCMioDbRxzHiOSFm3ksMmFtxUBQ7AmNyBkADAOAwxleRqqkopRUuZLRPS9td72Xptdo+S/dyle8muXqt37uia6pWtvdX16FqF5DNIJArKyKwKkMdjbRtLqwILDJyAOc5IGRUI8ssVR3A89mQBwVxwCVAILKTgYHTGcKMtSbVnaV+cAGFQQA0fU7ioCtgjgBsYI4xipFh3Iowefn3DeMqP7q/MSCcs3zAlvmPUYpNyUdU4q/vJ33a0XkrpavpurWI9yF209oppWSVrPz37dx8UxWVklYlJGBWXeUVCAwMYLE5GQzIT1I5IGc2IRCJpCgk81/mzJkgRFioCScDYMJuwu1zwCw5LVjVg6mPOCwZSxCknbjCoc4wfvEnG75iSAQRqsM2ArlZVJVuiRoCMIqlzlM5JUKvVduUJq4ppwulJX66tX5VZJvu2uttE72V8m4tTSvF8u2kU7cu7eqaV2+j6asvRiNcxIQoySELEkCRcHIDYZWY4G3kNgcZGJoQqcfMpUAKC3AICrgZOAxOc4GOgBDZJrJgkEhmIG1SpIyH7tgqv8Xy8seSpA/hnjG9uS25SCz87m3YJC7lyCTgtu3DGAzfLvrsirWtGK5trNafC0+7astI6LtsnxT5ndXdtE2929Enbz2d9bfO91WY/MdzY2qcLk85OCBnJznrgjkknk1ZjRc+ZhlY7Q3zMc5YbAWO3BbcOOQQDzgCqtusnUsrMx6hNu3ITIB4LOCCSeGDexFaKBGxHkuhYZI29wpxkj0J3ANwMlcHaa1hpaTaTeyta23krPXstHfucFVqLaV1a12m3dadWtfTr2sW7ZFCGMBpIyjbjuPUgAqGZgGYnBQhcAnsQM7NnEF/dbi8aA7T91+SNqksWyUDDa3AIJAyxJqjboMgDJ5znAyCSP7vykMoHHHUE4ycdBaRkkZDbjxjK9DtbH3eSAAxYAZPzZOK7aMHJ2dnbRt3sou3bRtXTttpp0R4mLrK0o799d5e7Z9r66pfobFmhITgr03A43YJXknG49CDxkA/MOprs9MgTIZYyCwXOQeM7Q2Rn5jk5GSCAS3eufsISTg45CkMB83Vc98sCucEnvnnNd7pUGQigY+XpxjAUYwM4HQYI+bAK/T3cLSfNFdLWeze69771y9Led0fD5riPZwlfRa6NvX5bv7tG/M6jR7dX2DnLEZK4HRhkAA8knI4HYlWyM17J4b0/zPLAHzAgYK7iVwvOTz8wDYO3PIXOcE8HoNkJDGNpxnO73C9M4XPG3OOGwoBHIr6I8F6IZ5IiIyCSpGFILKRjIGME4XAyBgHHOOPuMowftJQVm23FaLS1lqlfqtvJpeZ+L8VZvHC0K0nK3utJ3s07Lbps9uumiZ7p8LvCt5q+paVpmm2Ut5qOpXtrp+n2kETNc3d9d3EdvaW8Kj53mmnkjiCqANzAAbsmv7/P+CZ37Mlj8IPhr4Q8Oy2sDSeD9PW5126VA0eq+OtcjW71+8D4BkSyZ49Os5G3n7Bb2aAnygF/mC/4JMfs3SfEL4wx/ETUtLN1oXwzazl02OWMGK98dar5sWgwxg8SvpNut5rRIw0F5DpjNxOK/uo+HPhuz+HngOxsXEcctvZtc30wGBLcyqZpnZjzjzCwGeAiqo4UAdniHmksl4eo5VhW1js2apcsNJxotJVLWezTULbtz0+F2/F/B7h+l4leMazXMlGXCvhrSWeZnOq74evnUlz5Vh6kpXj/s8Yzx07+7+5UZ6SV/Gv2sPiPD4X8HDw7BeR2d1r/mW81yZEiWx0m3jabVr6RmO1IraxWTfKxATcr544/z/v24Pj2/x1+Nvi7xdazSv4X0+YeGvBFmzHbD4Y0Nza2MixE5jfVZvP1a6UFm86+K5YcD+in/AIK7ftUPoHgHxNZ6TqTQa/8AEue88DeF1ilIlsvCdltPjDWISpyi6gZU0aGVRh0vZNjgwsa/nD/Y9+Ctz+0R+0V4T8MvYvqXhzQbqDxL4jiUM0F3a2N3BDo+iTMD8qeINdudP0ybZ+9SyuL28AK2r7Po+DMgXD/DuDwso8mMxyjisbOWjTlyy5ZNW0pwSi7tq8ZNWTaPz7jLj2PiX4mcYeJmIqOpw7kEa/D3Ci3pvLsunOOIxlBP3faZli1J0pQV5Kcabbsj9nf2K/CmmfsSfsW+K/j/AOMLRbbxtqtidasLW9VY57nx14o0+Wz8K6XtYB2/4RjwzcwzTRlSYbvXvE9u4je1Yr+AniXXdZ+Inje/1a/uJ9S1jxDrNxeXVxI5lluru+unnllkIJYtNNIzA85ODgDp+wP/AAVw+Ntpaar4T/Zp8K6iZ9H+GloL7xbNC6rFqfjjVYDdX09wke1fMs47l2aMZ8m6vp4FVTDsX4X/AGGvhA3xJ+JkGs6jbtLonhxxqVzI8Z8l7iPebaEE5Ayy4wWwADwcDPsTpTzDE0MFh4z58XOnK3ve5hoRXsbrsqbniJqytUrTv8J+0/Rt4Hxub4uWd42g/wC1OIsY3GXLd0cJ7SLk02tIKKUIW0eHo0Nbx0/WX9mf4a2nwj+FOl295GsOpX9r/a+tSNtV8SRtKUdmGUWKLamOSGIx0bPVfs/eEJ/jZ8cLjxNfRPJomj3a3ESyDdGlraSbLOIZAQb2RpnBPLgnAPWP43+IhofhZNEsH2X/AIimXTrdYziSOzRgtxKoByF2MsMYGB87HJYqB95fsXfDWLwd8OLbVbq32ajruLhiygSJAi7YgcgkjbzgYznnqM/d5xiaeUZZTwtH3YUKUYRT39rJRjTvtd/FUa1176N/f/TT49hw/kWS+GuUV/ZyqwjVzCFKdpcijGnCM7WavTcpyUtG5wktd/su3iihghgjVUSGNIY1TAVVRQBxwOOMAdc9OKuBgkWcjPPOOODjpx0A+mcDr1qhsMCMHB4HGCTjqWyM9QcDp6HFNuJwEJOQq8buAQMcnkrgHjB9h1JFfkbUpy1fvSlzNta3dnq3q++mivvd6f5qRqwpUm+ii0k1vZJb9b22dmvwMTWr8W9vLM7BQodjhlBUAd+5GCc4HTgkk4r+e/8A4KT/ALQhlu5/CmnX48m2WSKVEkBDSEYYuA2SAMADrkM2e9fsL+0Z8T7L4e+BtY1aWZI51tZkhUygEsY2XOBuJweuMY4GcNmv47f2nfifdeK/EusajPdNK93eXLkl8kAux9AowCAAclcY6cV9DTccsyypi5K1bEJ0qN9GoJLnlHS+zST1fTzPsvCfhifEvFEMdWg54HLpxm7xbhOu+Rw0ScZcivKW6Ta9T5F8feJZLq4uCJCWkdy2TnnLDPJOOxXnkdcHmvnDX9RKByzHcRgqSTlvUjJ4wM7sZOQSOSa7fxDqJkmkyxYlmPAzwQTgAfLtHTPPUYyDXiniG73M6CQnJ5GBnJ2kYH8I44yRyxx3FfmeY4mVSUm205y5pO7Tto77t79UtNOa5/pTwdlMYQofu7cqjFpxTvblSdu1n0bW+19eUvZzPLJIcMdwAwB8mGBHGc4xzliAASwyGUVRcICW29toHqPlJPToT0OCOTySMU9xyHOcZIxkZznJyVGeOuR83XHJpqoHkC7jkn0JyNyZ5yck/Q4PB5bjyI+8152vrrq1ezsnvt1+8/oXIcD/AA7x5bWbSjotvJPTTTd6u5LaRkZkdSRj5flPBIBwOM/KvBGeM9TnBuPJsUgtksGIIyeByoOD2wFOcYPBAAxSMoSPAGBjJBBx7DhuhIOBjAOP4uapmRpW2BcDpnJI29TknAIJ64GCMD+8D7OGhyxjCN3Jr3tN7qNr76p9r66O7SP03DU1RgkrN2ve9lfTbTV6JO2iWpq2ETTSKcMx42jGMsSdvTOeg4XqAxJxwP17/wCCcPwGbxf45Txjqdp5mleGijQlo8pNqEmRGFZuD5C/MMYYZQnJGK/LnwRoc2q6nZWsMTSSXNwkaqqktI8jBVAIwfmJwMYJ4A6V/WX+yF8J7T4TfB7QreW3S31G4shqeqyMBG7T3EbSBWYcjy1IBPOANq85x+/eEPD0cTmP9pYmHNRwKjUjzK0ZV3ZU7p9VJOV9tLu3X9F4EytY7M4Vqq5qGE5a021dSmnF04ya0dpXaSV+WN92hn7VPxTsvhH8LNWvVmjhu3s3s7JQQrtM8bxr5agg4U49TnLYAFfzX+Hb658TeOptdv1N60FzNrM8cgLrPcCbFlbvwwK3V/LbQsOCY3cg8A19xf8ABRP43Dxl44PgzSrwSaZocjLcRxvuikucKGzglQI8MrAnIAxn7tfL3wd8LLbaReeKNURo9Ms4J9bvZWAG6KxaW20m3XKhfMu9Sa5eNGPL2sLr8y5b2fELNp57nsMtwkpVMHlX7uVm1GeJk4+1la/LJQa5V2Sk00npxeKmf/WcVLA06jeHwMVSSi2+fFVuVNRtfmk21Ths+ba97G3463SW8Whxlpb2dhJfTfeeWeUs8jyNuBZp5s/MWVmjiiOACCLPxC8E3vw38G6ZHreiXmkwabokPinbqlrNZzeIdX16IPY3NqHULf6bbILK3guU3KI0vVEx81gntv7G3wg1D9oz9oLw94blieTSjdSav4huM/uLLR7RJLq8ldzkRpHbIYYQcrG0gKguUWvef+CwXxZ8Ma74u8HfCbwpDZJZ+FLGYFoIE8630ewkk07QrFplG9LExW0uoWdmCULXTXkxMtwuOrLMhw1DJ8XjK8asazw0sRQk2uSMFONGjzRcXzSxOJc1BKUHy4arL3rWXtcJ+GtCn4d5pxLmWKrYSp9cw9LAUuRNZjWnL9/Bu6lyRclqk1+7nd3Vl+B50i51C6kllaSa6u53kJwWmuJp5QzYySzO8jknrjPGMbW+iPBP7NfxM1HxJoHhA+FdVsde8aal4f0a6uzFJdxeAvDviW4topfEnjG302K8vvDOlmC4FxcX9+tskehx3s6pOlzDm18Jfh/qHizxdo2l6bZ3t7e310beCKwgMt9HG0Us2o3tsmRh9O06O7ulmBAiMXmbl2B1/XT4kaZrX7Ln7Jvg7w14PvJtB+Lv7UlnD8VvHOoaTrt5D4o0j9nzwTql1p3wb8C3t1CcvH4m1a11Lxn4lilnjm1Yx2i6g8sMUin5OpwyoUMLiFRqPGZliJ0cHH3t4w58RWejvKFNTlFWum9Wr3X5lxVHGZT/AGNQwOA+sYjOMypYGnKcasaNKKg6+JxFSrC6jHDYWlWrJOLc6vsaScfacy+I/iDa+F/jx4/Fr4Zubyf9mT9lux034ZeDdGiv/wCzNWuvA8V3qkdlrWn2iWssZ8dfHHxuuueONeljtZGW91y4tp5baw0m0jtfgbxr8SddW1TwFo2oTaT4Z8P6rqk8em6VdzjTodRvfKt79rSYLFJeSqlukDa1dK+pXaxq0UlrBKLZ/wBWfG3ifwPon7LHg6z8QDxJ4U8e+OrzTLb4gS+CdN0/T4/EPgXR73W7W18f39pfTyWN1qNpod1pOi6HpWnRaWLA2EeouLnUZ47zSvxb161sLfVtRTTJ7i60xL67i028ubZLO7u9PjlKW9zdWqzXIt55YlWSWJZpSrs+2aQZZvF4wyKlkWCy2hRaliKtOVXGSu4z5nK8LU9HGLTeuqe2jvfDiXhLLMuw2TYDD+wxtGhg4Y6tNrmvjsX++lKrCTkpVqab55T972s5ybuzMFz9mGxMKM7SFwPmOAuWJwSxbIycnuSRmr9tqpA2lsnaPopABKkEDPU4AByOSARXMyMvSTGQQQCWzxgBupyM4JX+JgSOFFRiUg4HRMgtyAxGAPvEHkDBICk9/m6/lOIqyj17X3VndbNdXolbru90fnmZ5dCpFx5enLbl0WkenWyf66to9DttcMeCGyDkA5I64bkAqeckAnoT0IGV0U8Ryqgy2cHGEBUgbgcHbgs2CdwYjBHAZeK8rS96YJ9wGOTkjBySAASBjrgcnk4DxqJyQHYKF24I3An5SDHkKuMk8nOOxBwB5ssTNNpN3bW+vVPzfmmumu6PgMXw5QnKUnC97XVrJK6+9Lfpby6ekPrzPKxMmdqj92rfJxs2ttByRjkEMSreoAFZ0uujDgtz9043HBYJkkMMD5SRgnKgZIOePP8A+08nADoy42ksrBwMcKGwexySCcLwQTuqI36EFl+YHaSMFVz8vI+bJJxwcYBAwR0PO8VKV/edna12k7Wjo9u101118jkhkFODu6d0ktFF2s7a3Xpt62R2MupyuceZgjkHaGwCVDDIOGJzk5AByQ20gmsa41Nx93JLcEZJVVJjBYgsSP8Aa53AgEAgVzj6gzNsJOQuSxyyfw7SCSoGSCqhRg9BtbJNOS9YZZnXCr8xOc8BRwduNwwM5UY5DHBFZyr3v73TXfdJPW93q7pdLt66Hq0MsjTlHRJWTTaWllHRLt+KdtFqbMmoOZIlBzGRKCGHOfLU52g4XAI77hkFSUJWqst2zH7xBO0gcAkDaAM5LDIHBAx2POGHNNeoJoM5wVuGILYYkRr8vlpuwFGNo6gYbBViajlvj5bsFaQDrsweCVOAdoDBcnftYBT2BFYvEtX10uu2ukdbW3aelvPR2Pap4PktZXlZO+i3srLrqtn0s+qinry35dtoV1IBAJIILYThN+zLE9OrEBgCGRiaM11II7hgVC/2giSFkJAU245BPlqoBJGTuZGbpjcKzJ7kOVTcwLNuQk4JwygkBFbCHO5sMMEE5JGartKfJuD5gAGpIeWVmBa2BXlgwBPbHy4IyW61l7fm0Um4qzsttLNLXve9nr1R30qSg0lo3Za7N3i15q13fW78ut97sAlT85xjaCcsAQwLKoO0EMBuOMcEdRmo85aMgbxhCV2YHyjGNu0NkAcKN33mUKMEk5ryhCzoH3vuZiC2flAYgj5QEwIyVIKghWxjdios4Rcs5Esy5wGG1GKxgxoQFUquQQuSGZlAO44rGWJs7O+rto7pWsr21vfTRLd20bTPTpU3Zcq1dre71aTdr9F/dvbfXVu95uxwQcbwWaPO4CQkYZXYlclSBtYFlAKqckYa0pX94TuOQG5KhSdoZj8wXHXcGBPQZ4GcqWZ12osfzrh2JwVARkDOy8BnOCyhGyOMqOBSC6jMjRZCuBwpyeqxgtkg7skjcqszEjbnJ+XP6xqo7XaV7afZVrPRXvd2SasrrodsINO7XvabLfSK2fV6ra76rVmh56oWBcYYHIfZgMBHhkCkKu7GASQQCdo5yYmmAVSTuXACnbyrZUbWPCYGQfuj727kgrWeHDBgWz+8BJ3sBwFIG3gqAOSOATjAHzKWSXBVCz+V5YA2sXPmtINihTlMckfICNzsRyDxT9ulZX1TtrZpfCtbvRpddLNrXW51RVrPW17PV3+za/S22qdlbdXLc0rYZTyWDBeOdpwDyq/MoONxABPPJ2krSMrQC1k81XUidHQ7sgmNSFOWwpRSFU8AkBiNhJEbTgKNqk7tm4El9udoLkghSeSQVJ555UHC7iTaEcII5y25UL5YRDcUVMfJkMG3AOQGUhCoEyq3SV2rW0S3s43bs1/K1a2mybukdtDWNa0knyLRrX46er1Sv0vr2t3GmQlvmCqEl3BgoYlSVBClGBxnLSoXwVIUqMiqN6cLaOxJL3MA3RybkYFeoCKFJ53SZAwx39F2mgk8rTypNvhuYpXduRFDJbBmySd0q7XYkSKqAkmN2yAzknR1EA81jI15bOEZWbap3YjXAWMxoCdjADJY5JWuCVZzTs3ZcqSastGtGnd9r63ezu1rMZtNJt62vpqruLVtE72s973fk0bDytnYyOPnEbM23GcjDxg/Mw7A8FnbaCGIFIx+VVyW2uittYnapVSVbdk44IIAyCTj5sCoSYjtCkuwO7JUZ3gjBKkZAySHODyOemaJcSBkVlGVVy+TgvuUhQT83LlgxGPvD5lYc7e0bu15b62dou2t1rbdJ9U9zT2kUviXTXzvHTe2ml3rZWv0JHlOR8uMAEEICCq7VY7hluWAC/J84A3deKZmkjk8+1AMyQyJLBIMNPbOgLjYFjywLqVkzgAEcBQATJ5qNncFDxsrA53OOQGY7HERzGrYYkgEDkHNoDzFkySrAu4lLurEFWK4Yg7oyH3KG2sSCmdzKWhNze60tytPVN22d9Xqt+zu1re3LTzumnrpe2qt0ba6O177u5atbtLuBZYRuYAkowy0ZQsQkgAfAxtBbgFCOcDcNW3aVokLLsY4LIuFwwbBXOWJOR8ykEAE9OTXLiKS0me6t9vlyBfPhMhbcGDMdqkLhQQSrNzG4AHyMRXRW0okEZQgo4zgNhg5bO07AfmUA5LNgYw2N2BUZNWel1q0utmveWmnVPTbpYUaqd07cyXf4knH3r6KKd36tLSxvW+5uUXOCqtnJBwVDEgncADwcnCgYBIAr0TwnarJKsjEfvZF+Y/KRDAC7FlGBhnwcjg7eGyCteeQL8oAJAz90ZBDfIcfIrYIHI+bIPzZBIA+hPhJ4D1T4h+M/BXw30IEa38QfFnhvwLpbDkRXHiTVbWxur1jkhYtPtbie+uJThI4beR5eFYn3ctjKrVhFJNt07N2unKUeuzS7a6bI8TPcZDD4ZqpKNOn71SpKT0jRppSk5N2Sikk7tL3U2rJWP61v+CQHh3T/wBk39hL4q/theK7GO3udE+H/jr4z2sl1H5bXPiDxPZzeCvhNpC+YCzyp4b0DUNQhjB+W3+JUBUuLlTX4j/s3q19onxd+NPj66llufiFrGpWHiPVp5At1L4agW8+KHxp1FJ3XeJ7jwlpS6FEUyZr7xRbW64klRW/br/grJ430r9nT/gmx8Df2avCgXSdR+Pev6P4hk0iMeXc2nws8C6bYW3hCwuIx8+2DQ9N8AW8iMSGu7K8JG5pGP4nfHi3i+Dn7KWieDbdzb654h8OeGPCd1EoCSLq/wARL20+KPj5yOJEmtPB/hzwB4cuMhWSDV5oJiVuHU/p2E5KGIxOOk+elk+XVvYqzlGVSzoUINXSTqVPrNWnJW/jRkvsn4d4YZhLNn4h+JM1Jf2ti6fDXD9aStyYdOnluFlh535kqdJ4qvNRSSeF57XWmJ+wX4cvvjV+0H4o+JPiiBvN8beNYm1GVlJjsdO1vUbjxV4vdZGwFt9J8K6dcWOWbC28tvExRWUH+vzwD8VdI/ZB/Yg+Mv7W/jaCK1v9d0vxT8W7eyudkMuoalr9xNpXwr8NFWIYNcwyaFaJbDcbcXTEKEhxX8+3/BMX4HXk/haz02K2Mer+MrfQ/AenuARMuu/Eu+D+Ib2NfLLPLpXw80zV1mAy0Ns1o+VILV9K/wDBw/8AtDx6bafAv9hPwBdLHbCw074ofEXT7GTiLTdNifRPhn4culjG0hVttT16W2bIDx6ROiEGKR/Zx6/sjgvJ8rac8zzerWzjGR+KU5Yqoo4ak46X9pKcW1q04aLv854u4avxPmvhn4SZapf8LOZ/60Z/Ck2/Z5JgYxwuAptLpXpUsTOkmmlXlS1vI/D34EaHd/Hr4t6/8R/i1q0zeH4rzXfjB8avE95I3zWLXs2r6lDJMWBa71rUblbC0t0O6S4vIokw64G740+JOtfGH4i+IPjbqun26Qz3cXhb4R+D5kUaZYx6NbCPQLE2zDyv7C8F6SkGs+IWVfJuNReG0Yf6YFeTxlpzfDfwD4Y/Zt0W8gsPFvjePTPiN8ddVdgq+H9Bt7RNW8K+E751LeXBomlO/izXrNzmS+utFsTC9zG6j5g+Jvjy/hj0vw14Lsrka14otoPCXgDRkC/2hpfhi5ufIbUJxkLHrXi2+klvbqZtp86ViZVs9PjLc+YThkuW4XIeZuWFnDMM9kneeJzapFewwS1d44CE4wUHzL61Wm5KUYNx/sXM4R4dyLKeBsrpwpV1GjiM5VKyUa/s1Tw2DUY25YYLD/u3HZV51b6wiXNF8Iaz+0N8VtI+FXhJNY8QeHNM1uBvEF9p6tc6p4x8U6xePCsMMiBvtOteI9Xkl0jQg8jeTC2o6i2LWyncfQ37U/jvTLfTtF/Zi+Fl1Y3fg3wRrSzeMdX8N7m0f4hfE+2hl0vdpPlE/bfAfw0spLnwj4BBLx6jI/iHxeEhn8XyQW3V6Lb2P7F/wBs7PT723/4Xj8Z/D1+ulajZ3G+58J+AdWNzpHiv4ixBQHtb7x/At14G+Fsk/lXlv4EtfEHi+3tbebxdod4vN/s9eDtO8EaDqf7SPjrRYNX0/Q9Si8MfCXwTdo7N8RPijfFV0XRobdQJZtB8Ps6ax4muIfmEUEVqZFuLuFa4cvwUsxrOhUqxpQqUnis2xDu4YPA01GXso30UnTXJCGrnUkoq7qST/PckyxcZ8SwnVqKjwjwpVrV6mKm7YXG5nhIWxuZTfwVcNlaVXC4CDUlVx8q9aKvHC1CDxto2nfsxfBS58B3s7WHj74geGLHxT8Zr+EoNT8G/DbUZEu/DPw0tp2P7nxZ8Tpzb3mtW4/eWXh23tFkH2S+vVr8hfFXivUPG2u3et34EHmrDa6bp1uuyz0vTrWNYtP0izG7EVnYWyRqQATIyMzkszk/Q/wC038UdX8deK9Q0e61yXxHfJrd7rnjfxJvVx4v8eXrN/a19vXKHR9CU/wBi6DbqiQW9natJaQxJcbB4/wCEPh3e69b6frOsRXWn+H5L2KxtJBGUuNblkliWW00jfGGmILN9oviBb25bYzrKRE/wXFmc1M6zKOBwEJ0stwEVhcFh43UKFCnNcs5yXu+9KTqVpvWdWU7+7ypexn2fYXMMVLNJR+r5fhaKwWRYKX8SlgIv3JqC96eLx0/9oxEkrylJJKPK0vZfgj4A1S+0jU/H1xZNJpOjXdnY3GouUEUWoajvOm2Vt5zBZ9QumhmkWEBoreGMyXG2IATf17f8E6dJ+C3/AAT5/Z4sv2zP2lby1sPHnj3QryH4IeAy0cvix/Dd5EBea7pOnXJ85dW8dyqZrjX7tIotK8Krbs0pfXTZV/OreeNPCXhHwj8PPAOmafaaj4O8JXFv4t1jSI8wQeJPE0lssmoyalJCI7iOydpbfwrawmYzR6TpepzRPFNfI48p+On7TXxL+OHi658VeP8AxLeaveGGDT7G2BFtpGiaTZosOnaHoOlQFbLR9F023SO3stPsYooIoI1IUvuZu6lisJkWElg03WxdWlTlXnB2g3O0pQbVpOmrRTWrnaV7bH4D4kcOZ/xhgcvynBYh5Xhs0ksdnte18TSy73Xg8qoRbcYVq8X7bGzl7tKyoKNROTX2/wDt8f8ABQf4jfthfEO88QeJdQfTvC+nPPb+EPBljcynR/D2m7yqKkbMFu9TnADahqcqme5lJwI4Vigj/LnU9Qa5lZiwILZAwehOeQCCcr8w9xnjBrjL7W5pWLNK7AbSSGPPAxnbgZA4HOOcKByKjj1AyqpJyP4txycHHJ6kkAkkFl28jGBXj18dPFz5qj7KMEopQSUfdjG90ktbWtor3Pd4G4GyzhHA4fB4CjGCpxjzTa5qlSenNUqz1lKpUd3Obbbv73l0InQc5J2jA5xwf4vUnoCc4HUYIzViO4JxkngNtPALAfdIJBJycEZ9uMmueSXLZbIyfX1wQAOQMnHI65z905q9FKM5OPTucAsOvfHGDyMEjBwBXVgq3LVppei2/up7aq1k9E126H7jlcFGMUlZJq11qm+VLysm9LWtvrZs9m8M6kZFRGZVZSoA6tnaQoOTyMEdOuWI5Jz9Y/B3xvdeEfFWk6taTtDLbXMLq4Y9UkDKwIxjDKOQSAeMgc18M6BdmCdTnCMwDBic5JwMHgABuuPXIBGBXvui34U28qEgxFSMEDpnBB7A9FPIHHBPNftnBOeVMHi8LWjLlnRqU3dNtNKSVna10/O19V3R+s8OY6dB0asZtTpThd6q3LyNNJPXS7639Ln9gfwZ8fWvj/wLoPiO2kVzd2cQuVDZKXcaKk6kBjtYOCfoV4ya95spiuwk8EgjHGOmRj0wMjgYxnjcGr8av+Cc3xeTUtPvvA1/dq0iqLyxV2+fzUGJowrEEFkVXYAYJAbIBOf2Cs5FIHzEgkMc4J3ZznavTGBt985bsf6axrpYqlRxdFJ0cTRjXp2TtFzS54JdXGfMraXXTt/avCuawzPKcJik05OKhVirpqceW/MrX1et3bR91Z97gSQMQN5UZ49AoIXnjDc/hkY4zX5Xf8FGvhINd8Jad470+1D3WiyvY6iyRZJsrg5heRlGSscuBk5+8eMEA/qVpsiEbGOQBtJByMHhSR75984DHAJFcN8TvBll428H+IPDV9EssGradc2xDANtd428hxuAwUlCHcuO3Ixmvn6Uac3XwVZfucVSlRne+inFRi7O2sJ8s49U0hcb5JTz3h7G4ZxjKfsXUp31calOKlC/ZuzWju07M/mi/Zx+It38Mfib4d1qKZ4orbUYobwBtu+1dysiklRnCs3QnkrlW21+1H7XngGw+K3wp0vx3paR3EiWMS3LxIGzDPDG0M4ABwFfypUBzsVyADtIH4PfELwxf/D/AMd6vot0jwXGl6pcQlGG0kRysAyk5GJEXcnXDHptxX7s/sU+P7L4u/BW88B61LFc3em2EthIjkPILWRD5MwVsEpGwKMSu5FZGBAJavxLOcHLB4ivQnFqrhqsotbXpqUYtefdNO2l11P8T/pH8N4jhTizh7j7BUnSjQxX9k5yorlToVJqNKVRafC3Ug293ONtLW+Of+Ca3x+n/Z3/AGoPD1jrV0bTwx4xuj4F8URTOUto4dSkaPTr6YYC7bG98uZiwJ8uMjkMSv2D/wAFlf2bhFazfEnw7Zh20C6bxrbSW8TGSfw3r1zDp/jLTlMWWdNI1pdP18RKNsNreahM+FaU1+VP7R/gnUvhp8TbqSOM281rfPtkjBRo7m3k820mjY5G6QLGwJPzSBgWHAr+k3wF4r0v9sr9g3wx4yv4Y9b8SeB9HutD8ZWGFmn1O0t9PGgeKbKZCfMP9r+Hp/7RXcCWuRyvmDNebhMRCnicPUm0sPiorKMY3tyVp8+X4hq+vsMYoxlOT+Golax/FvjjlFbhzinI/EHKIXw2PUMbNU7JVcTQp01jqHMk03j8r9ptd3wV1eVr/wAsHwU+IesfD3xj4X8Z+H7iS01fwzrGn67pspZx/pNhcJMIWyozHcIJLedNwWSKSSNgVYg/35/sL/GzRvHXhnRbzR7gNoPjnQdP8YeH0Zw32VdRiDalpbEEL5unX63FtKqgYlifIGDj/Pm8YeErz4U/Evxh8P8AUS7SeF/EF3Y2UzFcXmmNIJ9JvwwJVo77TJba4BGVBcKWDgV/Rj/wR/8A2ibiPQr74c3l851b4d6ivi/wxAZWL3PhPWrpU8R6bEpOWTTdSkjuzGq4VNVuHAOw15/FmQ/25w/mWV1EnicOp1KN0k1VpWSs3vacYJu9uSVS29387nWfy4I4w4C8Ysm5pYPA4vB4bPXR1WJ4Zznkp15z5b88cOq/tYraNSSnKzij+iz9sj4VaV478D6lJqdil7pl5p17oWvwbVb7ToetQvaXO8MDk2zOlwjNkx7HkQq3I/z8P2qfgzqfwr+IfjPwNqkT/avDWs3dhHMyMPtthu+06VqEYwcxahpktpdLtATEpHJXFf6WEiaX4+8F5wl5YazpfBByskVxb54I56NkH7w7YBNfx+/8Fif2dbnR9W0r4m21k263mk8BeLZEj27ng8688I6vMFBwLyza506SVyVQw6dCCzECvz/wpzd4vLcw4Yxjf1jASlUoRn8SimlOKu73hNS5tXvBJdvuPHbJ6fBnivw74iZS4y4X8T8Hh6OMq0P93WfYahGrgsTKUbxSzDAONONlepVpNtts/kx8WaeYmlDI2Q2QpPBwSM/MoBxjLepwT2z4LrduVLjaQ27pjGB8uSWwQVGd2W5z0xnFfYfxC0U2805C9C4UDI5zj5to9QCeh3dWx1+Z9asNjNxnghsjkHgADG0LxgA5JHGCeldGc4N06s001ZtJaq+2vdO+nns+x+0cHZrGpRoy5r+7B2Tv/K7O93azb0t1WuiPDdThIDYUgjqCuBuypyecYxgDBxkHGQAa4W9Ug7T8uRxu5IBC5wx47ngAZbnqOfVNVgYMygENzv3EEAhlGMKSCThl4wDtwf7o841SMJliMnIXCnBwdoPByCMc+xBGWUEV8TiaaWtrNO6WnK7JJq221+mq2P3vJcWpqkr3T5Vf4rXUUtdtWk9lbq0zhNRdFhdmiklDEKVQMzlCwy2504CEOcggkKc5JrEfapkCBQrHe7Jhg5k2EqrZVRubO1BlRsypDcHqblApIVflHGQQPvA7xlf9l88k5DZHWuclkjAmQsA8ZVmAUFgHVVXZ8gzw4DhBjcQxwxrwatlq+V3W3Xa7fva69L7a79f0DB1IuPu3vZb6JWSaf/gPbSy0SuY6eaSfNTDDdgLsC4j2xgkZJAOGIY/KxXDKGJY1JoiW3jIBO9yQxYgld4DclRwBnIK9MlSSL06PJMu1tvkpufJJMoDAOfkVSwVU3EkjzEAzkhaqIySeYVcgLuQgsQGICbmXABKqdwBOWXG1gMLXnTbdovycbp3ajy3Sd0tXdb/c2z2MPJWa3VlZrV2bjbW2rbv5X1WhAy+nKnI6Fu5wAo6cMR8ucEnbnGKqMgwwDc784y2VLAHb8o43AgYJIzjrziyAxLq25SNoUg8OqsoUqckqW5ORgLgLhTgGC4WONQ/IOxVkBDFnwUUtg8GTIA5QgcgYAzWLvrJpNJ7NKO7TXW7Wi5WrW1dm0d9J6xtZbX3TbdtGna6suvXVbFbDHbjcMY7HBUbcAdRuwyjLdegHzNShSScqQMHjAAGTwAdvHGGVcuVLZUk5zhQWTT3Dh/PwIrtmXe6ZkijkeNw24rt3uoRSoJKAZAAFOOnqrhEupXLaXFeYEsm6K4kuEjyw3yFvLAViAVPAxgNXGq9Wyaoqzbjfn1uuXW3KtX2v6910KajNXj2drK3RXWvndq99dejNnb03EfMAFJ43BmUFfmHzZBwcDnGTjGRSmkaKSKMJI5kJICINgAdVZ2LKFBJOSAQWQMeCOcy1tmS6spnlZmktZ7gh/MO3aXhQAEksNpUkknLKMk8Y2/mwCqhVKBNq53AjY2GIwVAJyFL5U5O4irjOVSLcoKDUrWT5rK1OSd7JJ2suXfXVPprTaa6rdXt6J9n0669OrszdtZlz8o6kkhWB6EBQcDP3VPA255xy72ZeD0w3JyAAOVznJORn0OAMNSHIOM56njPAIGcAE4OCASCT3GAThA2DxlsAfKeQB8vJAOAewB5PGPlyKd+7sr26rqtej5V1uv8AJ7NrTbp17OF3buunna67qSd3PJIG3BwOc9cgAfeIY87hjHUYU5wOScEbskkD7vA4B5wAMkEAdSOCg7hj6ZByNp+XaCoIJGCMD2z6EIGODuJJU9xtxtK9skjdnrjj5e+cyrdNNFf3W9Oltbq63Xa3VO1KzV1Jr3VZa63tZpW330T2Tad0Tk/d27sDnqcnkYwAMAeoyQPvADspfgk/xAjBOSASvC4AII5K55Axg46woWd8FAwAII3bWOAoDDIUHd26HPBBwac0gIG1gCWVQCCVGdhwwwQuByCSNoXd3BotrzO9tdUttFbRta7d9u9kbU3q5X1dm428le17Xdk7O8mm1dN3u5m+TIzjkHqDyV4PPYNyAefuryOGYwGAbAJzgs5B5TapbIweTtwCM/e24IKopQNyNoJwCcbT8owSOAAQcYwBtIAByKMgAEqCWwqnBJOAMA5O4EAZJIGRkNyRRpa+lm2t2r3cb7PbS68nva6NVZQ1bTdlZvf4Ut22vK3vNtvu2yeNZ0AlZkKEyI6Ft0UgUhGGWVGQ7wJI2x5iE8KdrDO0+7ktbgWtyNqFwMHJ8tWOMo4LM9q/VduXhO4EFcrWrnBBIX5lIwcFgONxb+HaR1ycFcFQBzVGWJbkLv8A3cqMHidSFlV12tlSOCpPBGTuJzjOAvPWjJ602oSWutrSulaLV7eenpotVzyupXi7Pqm73SjHWV/NXWi0a5tU0kd98qlNrlArKrKCfmKnkAglScD5tyglmbbkGo/M2YG1txyxjUljnIBLAqVVABwS+QSASQQaAEdlcthugbduARt2AwBGcAr8vU4LYwQKdImflVxFlTlvvOUB+6itu+ZzwdrKWGRnIxXBabu1o3qpJ82j5bW5lqtLbq9r66cvyScVJJ3sur010u+raV7paNt9Ex0apKjDcSjIxGwjJc9WPl9Rv+XyySSeEJBWto6S1hYJdXspS6uYlNnZYEszRlf3txdSMAYx5fMWdsjhtoAwWNuzsItDt4NVv41luZIs6fp8jfO5wSL26VkTMKE7kD4YttUnkkZc08t3O13O3mSzDMu7GQSqgBRuby0VW2IgGAqryV4rojT5I3mrVHFKMV9iLSfNJbXeyine1m1pZ8Uqrqz/AHcuWhGfvTsvfkmm4RuuVxW0ppK7XLFbtQoyFQVYfwlQcIQRs+XGGBzwF5bcc4BzmnNk7WWQKwZcYX5WQ7Q6seAR0+ViEOfm5AwpUZRwMdNpyTgFhlcrgDJxjBX7vUDNMAdEYtm4k3DgKFcLlOOpGFCncSpzwTg4NVa0WuW+zunslbotemm+rSbT0Lerumr3vq91LSP91LVX5r9LdS0m1Bg8DkrkbirbQBkAMeQQTxyASu2pLZdvlIzszorFizNuYsVUkEk+oUHaGCYAHVqbECHVQCckN/eIyVyAB3DDAAyMDKnjDXQpOCC3AK7svlQSuMYJAXOSMDOTkjcRW8FzNaO/uq2qVo2bT89Er76aXtd8lSXKnF2s3e/fotWvPZOzu3e9ryxFQN0e1hnGA5OCQmQoHKEZ69VLHAIGa04UQKFBCjAb5jvXJxzwcBj8uMAjAwgySBQjj5BxjcfmAJ25JBbco5IGBt6bcDHHFakSbvlYbhgdOvRTggjgYPKqRjAbjALbQi78umz32+yt3q9H31fToeViJ9V3V3pvo0kla+rstLbmnZBXGVwVyM5H3jgZO0KrdRnPIwM+w6S0GD83GcbeB/dQcYzggnkgn5gMYANc/bowKbVA6cKSqquFOcjcdu0Yyx98EMRXTWSAEggYO1Tg89F+6AcAjGcjggqcYJr1cKm7J2TWr36cvrZO+y06+b+excrJy1as99dHbW9t3ZPVu9zqNPjyY8cDsT918kY45XJ5zg89OvNeiaTDukBZeFChNo288HAz0AOPZc9NwBPGaXEp2kknGMDKrg8HHQsOoHJ6nGccj1Hw/aqzKSDkkDJ55+QgZbcfzzwNrYYCvpcHS5nFLW9lZJNbRta/y8l3dz86z7EqEaju9Fd631VvXb1TPTvDNh5jwgpjJTJC5OBww52gN8u4Ebl55r7B+GfhyW7u7OKC2ee4uJYYbeCJPNnuLiaVUhhjRWLySSyyKioMuzsEAywx4D4I0YyvBlSW3KFyGPYgkZ4I+XKknpljjG4/u3/wS0/Z4HxJ+NFj4t1XTWu/DHwsitPEM0bxCS3vfFVzKYvCGmOrDbI8V6k2tSxMp3JpRR1CzLn9V4dwkYx9tUSjTpR9pKTW0YqLd23dWta/3M/kjxh4sp5PleNrKTlOFKUKVK+tWvUcadGnCybbqVJQglrq1uf00f8ABLb9lq3+E/w+8KaFqFnH/aGhW0fiHxdcFARd+OPEEEU19E0oysiaFai10iAbnxHZQyghnxX6NftMePx4X8HHQtOmWPVPEDLp1uRIEMELL/pdy55KR29uGcykFUO0kEcHuPg94Nh+H3gC0iuYljv5oGv9TlO3c9zODNIGfjcEyIwePkRQOcCvwo/4KsftWL4D+G/jrV9J1AReIfE73fwy+HkaSFJYp7uDd4u1+3wWKDTNLeSCG4QjZd3FlkgsDX57gIvjnj+tjqi9plOTTXs73dNqhK1Jaq372rzVGtH7OMlryndn6xngZ9HDK+FMPNUvE3xlxFSePmly4ujPOIRqY+pJL34U8sy2VPBppuNKtJTSSbR/OF/wUH+PUfxm+Onia70i+M/gzwcT4L8HBZN0E+maPK8d/qca52l9b1RrzUGkA3vbyW6Mf3ahf05/4J0/D/Sf2Uf2YPHP7Uvj+0ig1aXR4/GMNreoFlvNU1Gyl0/4Z+GoxIPvJp+ry6/dpGyPG3i7T5GTfphaP8af2YvhBdftEfH/AMI+CJraa88N2V0PE/jTyRIzHwvokkNxcacgQ5Fz4hvWtdCsu8l5qkIQOOv6vf8ABWP40Q+CPDHgb9lrwzdW0TaHBD4w+IUdgY0tpfFOswNcWOnBIVUNbaLY3L/ZIsKsNtc2EICizjVP2ivUjJS5nanOLhrvHC0+RV2u3tU4YdS01rSkn7t1+HYDh32mJ4W8PsqipJPC4rNJUlZxo07ypuq1a0p1I1cZO6tKpRoxacamv4tfEjxf4h+LHxF1nXtVuZtU1zxVr99qd9cuS8lxfaldvcStxyq75jgKMKoAAIwB+9f7JfwktvhJ8KNMimto4tZ1yAanqUkihWUSIzRpKRtIWOPDOpOSWCq2Scfkl+xR8JJPiT8ULPU9QtfO0nRHW+uGZcxnymYqr4JUF3RVQHJb5ye1ftZ8aPGKeCPBFytm6x6lqippOkxKQGjVlKvMoxgLFEWc9AGKHPIr6LhHCQn9bz3FRUYtzp4e6SUacbOo4ppW1ShGyS0ata1/9YfB/hzLuCeFMbxNjYRoYXK8vlTwinyxUaWGoxc5RT05qjSpx11u0edeH7a5+N3x6g0+1V59G0e7isbfA3RiGCVWvJ+BtBkcOAQrAqAoICgj92/DumW+i6Rp+m2sarDZ2sMEaR/LgRoqEAADAHIbrznGckV+ZP7BPwxOl6RP401C3Jub0ZhklU7groMHJB5IO/dklTLjgZx+oVpLuwR1ABCZyOi5wQTjrjOeD06YPhcU4uVarCjfZ+3qx2tOfLywfZRjZX3Wq0u0f5BeMnHeK4+8Sc+zqvVlVpLGVqOH1vCEIzSap+81aFo01y3fLCNrK99InoMEA9D1+pGD3/Dgc478/rGoR28EruVVUR2OWxwgOSTjGQAcZ69D83Fa1xOI4mJIGRg9zjI4HXpgg5A79K+S/wBpT4p2/wAP/Aes6i06pcPazR24MgVy7B1yOMgIMZ29T7kV8zlmElisRTircvMnJu9lGPK3rokkt1bpo97/AJbi5yrzo4WhedevOFKEI7znNxitH5u2rum3a2h+QH/BR/8AaKa5u7rwtpV4Ps1mJUm8uUnfIqsvzgNllUgZyOM4xwAf5w/H/iKe/uLmR5txLOS2ThjubKjLHkliGBAyfXq31x+0j8SrjxV4j1a8luWkMs87bmYkks7jgnjnvjPYY7H88PFOpu5kbcCo3bgpIBY7gDxnnJz2xnHUGufifMY1av1ei0qGGj7KEV1UUk5Wv9pp3269bn91+D/BVPIMkwVCVJPFV1CviZ21dWfJKTbturuy6Jedjhta1MKJXaT+9gEY+6OG44+YLgHOR075byu+uGuZWO7GNyxngKMYBZsggZAUnAzyAMEca2s6h5rMoxjd0DDKjOcEjJ5UgZA65JA6Hl2LMpB+XnODxnAUfeJOcjIAzx2OSAPzqpKVSfvNLr2te3RdrLZ23vpqv7G4ay6MY01y6RjFNrR391ptpNtaadvvBmOeceg4JxnA3HGOOmD6+7czWiAMHIXIyQMDB+6Bz1OckcZxjkk4NVCGLKME8qFPoAFPzc5AA9u4Xgla0VRVjAC4b5S2TghsD0JJDfKRnG3OMbuRvQhdpv1312TS+Wm2q+Wn7Vk+EUaak4qySenX4bKz0st211ejbSutzMMEcZPII79sHHQlsE4PHfGDhljC0sinbli33QOefYZwRx6YzuOehhYiV8DJYEck4xzjODgj73sfU5Aru/CeiyX9/bQIGJkkRSCc53HACZ+6SSSTnJOAeenv5XhZYrFU4pNtzjZa2k7xtprd66O3lfW59JSg51Y6tptRSva9+WztZW3VtNbtn6FfsCfBKX4h/E3S76+tTJo+gvFqN4zRkRkxkGCJi2RlmXcQRgqCRg9P3h/aL+Kun/CL4VavdpKkN0bJrPTo1O1mnkjMUWwArnywV4GTwWwAc14X+w98KIPhl8JLXWLu0jt9V16P7bO7LskWEqRDFnbuH7vDMDwPmOecD4K/4KBfGiTxN4pj8Iabdl7DRmbz0RiY2uTtCqcEZwScgZI4B7Cv61wlOnwVwTGfuwxuJpRlZ25pYivFKCe6fsoavs77H7plFOHDHC9TGTtHEYmnzpOybnNJUYLT7MbNq71T87/n3qgv/Hvi+e5uJnlutU1CSe4nYs5VJJGkmlbk5EUauwAJDlNqgllr6J+KN3b+EvDukfDjSx5dzOIr3XIo9odbe0Jg0XT5io5ZFje9uQxKiSUzKRu3HzX4TxWuj3SeItUiMttasb2eNgXMsNjiWGAMRhTd3ogiQlSpAcMG5avcf2b/AIMeK/2rf2i/CPgmyilub3xl4jik1i7RHMelaFA/2vVLpuG8u3sdJtnjjJyoKxwAFnG34Hh3CRxOJ9riKihGoqmJxdWbXLTpxXta1acm21GFNTlJv3bXb02/G8oyjE8X8XYPCxcqlCliY1arcvdrYypNcntJNuPs8NBzrTdlySUJN2P1i/Yo8EaT+y7+xz4y/aD8bCHTfEfxhg1TR/DM9yfIubbwVolne3viHVoyQsiQahJbfZI5oQJNqW4twZZ41b+fT4j+ONV+L3xM8V+PtYklluPEut3t5AkhGbawkupDYWaqG2Rpb24jiEaZRFQBdwXn9rf+Cwfxv0vSj4d/Z2+HlxFZeF/DOmWfg2ysrF1SGDwv4VdItTnKRtsT/hIPEcJtZMIsk1t4faQuYbok/i78NPB+qeLPEmheHNJtHutT1/VbLSNOt1BJe5vriOCIt2SKMvvmlJAjiDyNiNN1fp1XDVcdTy7A0aUozzCdHH16KjHmoYeUYUcpwU7RVqlHBKFXExuv9rr15tK7Z/TvHU1CeQcC5VFyw+U0qHtaNON/a5jiuVRpSitfaQpuKnF3/f1KqVk0fsF/wSy/Zfv/AIleMtKv7fT2k1Lxlq6eAvCrmAt9l02R4Z/G/iBTtz5cNg1vocdwuxfJvNcVT5tvlf7H/wBq3/gmD+w38TfghdP8Svh3a+GdU8DeBo7OL4o+DHi8PeN47XRLQXEf9oXMUMml+JN00LNFbeItM1RI3mkWzNpJKZB8d/8ABF39mPTvC1hP8Q3tB/YngTRrXwL4HuJIMC/vfLe48S69EWB/fX91cy3TyLk79UngYt5Chfpf/grD+0ppvw6+Gp+H66p9ihutOu/FnjeWGRRJbeGNCzcQ2hJIxLqt7HHFaxlgJpoYoSGW4w34F4l5rnXFPjHwj4Z8FZpjMvo8MVacMzxuWYidHkxtZU8Rm9Wo6UlGpDCYKnDDxpVOeHt51aEotyscfEeTyxXGPCHhhleIVDD8O0v7T4ux9LkcIY2tSp4zOJ1ZNOFSll+XQhhaUanu+3nUpSjzO6/hB/4KNeE7PwJ8SYvBOi6xaanpEPg/RWitYrUW91o2ns4ax0nUbdDJaW9/Ktol7dNYOYLuGe3mlAaTaPyK1qN4ZHUZxnawAHX2APIwrBMHHZchuPuT9oP4g6j8RvHHivxrrEhbUfEur3OpSQlyVtLZ22WOnwk5zBptlHBZRBsfu4FJG4tn4n8QMDJISpyGYg5wc7iMgDPAPzgjgkjJAr7zxWw9Cnj1QjJVJYWhSoSbabcqdOEZtWSXvT55WST1b00v+S8e4fLKma5hUyuj9XwFTE1p4OjKblKnh1JKipuWutNJ2W1+VaJM84ucIT6Hb0ILZG3ggZxnGOeWOcdhWbJNtBI9SOBxxtz/AAqOpOBxzn5SeKvX75Y45ZehOQAMgEHbk4JBxxhgR2YY52VmLOSTggHCkBGOVwXGd3bcMFMAkAkqBX8349qm5rtLRaa6LZLWyWr231elz8WzDDLmasvTS19PK97Xvqm1dvfSw0xbKMTxkg55Y/LjOTxjBGcDOSchsNUD3RCruVuFzvByg2hecvggtjAyec8AHk5xulkY+W4Z0bY45D79oIUg4ZskZyOdo+YdKzpnmJLJKAGcAKUJVUXiXYykMSwODvzjHIGOfmatROzjd3XTpttdta2aV7pNXt1XzNfCtydrJN313Sdr6ptPXSyej6KxtC8DsWDqUwwwpHU4PB2jGM4YDpkKQWxSS3LMoXKgkEeZt3MrDaV2jkEEghjgEHsCeMUzeUFK/KjA4AAUrtIA5BK4ONy4BBbkAAgCn9smL5KMi72h2jAl3DYrS5UgKgAYlSM4IY5QgnmlVsndu97cq+V3e9k+nRO1lre/I8GnJuNrxeuqd7WuuVtvZ3vpZp2slZ7L3u11V2VQTtTcMEFiPkdyHTDLkgnuVzgkmqjXDk/NsIwzJsK5YEBcSBsEMW3Hphj8pUHmqBmO1huyv3QuRgnIUEbQDnk5AwPQng1C8jEEg7WzgZBcBeMq2SARkADsScdPmMOq3K6lvayW7Wjdr627ardNrdFxw6TScbd3bXS19OnX12aWxYknBuLd0nQZS5BCgbslIz8qkbwwwFcEnb2BHy00zKBkPwWYhC7EjO3PGM4IDYOCV4U4wQMlnh+1Wwi2bRHcnau5QpKIDuCsQXGfmPHXPXFOaY87c527A+4bf4eu8jg9OFIYYGc5BwlW+LRrbmtro1DRPbRq9r97Pv1rDW5Ve3u9dNeZOzvotHo7ebSLM1wYVaXE0yvIu6MASMrSbCFiG8qgBUgkoSQQQNp4YZiIrrLAML63KoZVRFDWpPGzPOMg8Zz8oLDOMhnkWZ5pV8xEXNt8qEjlMBxuUs48tmUlMx4Vs5yKk3zSQXplUBmv7cbiUJH7gj52A+YFAGfCqCjDAxgVjGo00npFxslp0j5u9mr9drta6rZ042g7J2avJu+rcXZt6rlWrvdNq99bjppWWRk3uyShnG9DiJFBVk3sxUKSFCHB+b5icqAK4YlRGjGWMiRt2QzopT5YQxcoSqkHaVCkMXQ5JUVQZY0jEryF3n2M+1+SWDEMQGjWMFVjLMgPlkk/OGqVnWMSM5VUQbH5+QRqU+VQBhgcBVHXd0OADQp3d202t9fSWuu34JrTfTtjC2kfJq3y1Svo3fW6W19dGlZBv3xsACqCXO5xKocyMT8yIspPyhsDrwRtOUM+4KVDMDsAwMAIzfNtCupXD7QWyeSWxtJAjWVtoDssrsVKssewbAEAVsnHyZYq4UByAQxNVbmQloogrNJIQQwUFUVChbKsAhLBTsBYbs5X5wDUuaS6pPl0va97WVk2lvulvdJ6JmsY263aWvkrrR208k7Xa2aRfZiDg5CENsycDqgAOBwVGCOCMnKnaQDXmAmjZRI6oOVaMsWR15Quy9Np2ghh1AJI4JrrMsighiuJFjIbchKgKNm05ZkwAAwbacBiVK7g5QobcqkHkZ3EhiQjKy5Zc4BARiW2kYyQdoHK6V3fb7Sa6Wb66patq/36aLS2tmtGkttE3bd6ddtNH1SmeXZET94qpGCVJmKD5sgsUZiqg9Mg5wACcMea3K2TlTua3uApZkwH3RqzSKrjKHDbc/LtYEZX5QhEgA2E7twcfMSEI2nHUhfkA3BshnwmNm4B0xkH2MqFLfZ7iNhhFYBJUIIQq/ygkiPJbYRhgSr75U0k1unyWvbR3Xd6b7X0udlCzp11ZXcI7vo5U9l1+5t31sMyWdo3JH7o7SdwRY2Y/KSgIV23KMh2VVBcByMVmzhYzGEP7k3sR+dwSoZCAo/efIqrgI4B53rjBJNsO0ThTkpM5dSQSiZIikj3ufLGflCgKFUbSDyWpkgS7i8p2YQMyqSu8OF25jZFCIwEbtuznYGzGFPSs5PmT5bOS0Xd6+V782l3Zrv1MVfa65bptbrRxUt3olfZ6W+LRpF3cGJG/DbsL2JbdwuCQdzFgCAcNnOd2SVEgUD5sEjy1BBGNuPvOSysu7JO4hscEYWsuKSSKZLW5BEgUtBOPkF1GA2I2OXYzAHlOA2Nx5GavNIAN5yQ2Ay4YnIJDDLEYCFDtDEsPvAkZyRm5XtvtZvXTlfrfVWteyd+qvTut3d7tJuzVk9X0VrdE7p9FqgVSxU7uGZ13FDhjjYqnlQDgnaAQ3ylSrVajco2WQhChKEhfm3Y4BYggEjKjYeCSxAwKhVyFKsSynILADPzYG5CpDLgbT94leNnLGpYc7QAckHEjBNpIGwFsMG+U/LjJGRyVPUXCXvWWjV/vulfXXdra2zd+jq/W3vNJN3tulbd3dtddO+xejGQykq4YkLgnkEFTG+FHIwu0tklvnztDCmIH0+RpIw0ls0nzo3zFCX5PzEAMBgBlPIyDksQXwDcrjaMq25SSGDPhcAF9rA4J4Iw2AuPlYHQjG9WWRRscgFcsMglcEsFX5QSQOrLkZA3AnRbq2qVnbbRJWV/O+rs97Pzly5oqV0mtnvJL3Vq5O9r2XZtX0udFoxjupYDGd6Nh2OR/q05AK42gkgAjIGfuk5r9uv+CL/wAuvjb+2L4buZYS2meAtOS3N0gJ+zeJPiILnRHnQqG23eh/D+18f+I7SRdpgudLtnIHysv4weDdJiR2lwSssykfMwCwREPIctgDJADkEgkKpKsSD/AF2f8EXfDunfszfsYfH39tDxbax20ln4L8b+PdNnuAUM17qsF14K+HVnE7DLTJpXh/xJcQqMuLTx3amPKXo2/acNYd1Ksa00n7GEqyTSa9p7sMO23pb28qLd0lyqW6R+DeOHElXKeEc0jhpSeNzH2WS4NU23UliMfL2U1TS15vq/t17v2uVI+c/+CnvxJsP2r/8AgqXb/DTT7mP/AIVd8AbTTvh+YbWVRYadovg2zfX/AIgXCov7hI7MWepWLZOCtjbxEkhAfzm/aT8QXXxe/aB+H3w/m2w29o3/AAmXiS2RiYrHUfHslp4turaZWHyHw/8AD628JaH5LBTajT5bYLjfXUfsyXc/iCw+OX7QHje8kF78RPEN/wCH7nV52LTppGpz6j49+LerxysQWNl4B0PUbWbGQ0uqLEmGCKeQ/Y50HWP2g/2gvFXj64tSl14u8Um3h80botOPi/U55pkaRiRFBonhy3ntVLDbDbrHuKoy1+gYDDfWaeT5XTf7ziDMYV8RzX5v7LwEoSipJ6JKnShUTd7ucvetc+ryHhhcPcLcB8HwS5sNgqWbZlb3W8wzGEMNQqVLqztCWPxDi17vtub4Wr/1Of8ABOvwR4c+HulWvxG8YMmieFPgz8OPEXxt8UajdiNINJv/ABroEttonmlhjzfD/gHRdevooyS1u+pRhAzOq1/NH4s+Mx/aL/aK/aD/AG8Pihbtc+G7PxPLqXhDw9f5ePVblZG0r4VfDy3Vz81ra6VYWM+spGB5WkWGp3chVWO79r/+Cjfxwk+CP7AunfB7weZLP4l/ty+LfsunaVaKU1TTfgf4bj0jQtMtvLiDXEP9saFpXhnSVjcL5k3iDW4YwqySg/gNrmmWe7w78IdD8jUPCPweUXXiZonRLLxZ8YNXhH9srcXLMY5tM0AWj6Ql2N0dpoujapcruN+pf28yxUsZn+Kx9ONOVPKuTC5ZQ+KmsXTUoYNyjazp4WKrY2p0lGFKOrmjg8IMLRz3jzjzxhr0vrOCwWKhwdwVGcXKlOhkijhJVsPdSVWhVzClVxE2k03h3HaomeS634hurDRvFnxA+I19NfeIPG96vijxvdS3CxahqUerXEl34d8HWbhd8Fz4mvkXU76IjZpnhnTUcqbeARydv+y98PdIlt/Gf7Wvx3gebwp4dsEm07Qo5JbG58RT61Fe6b4T8B+G2BD2OpeO5LK8sor9S0nhP4YaN448ZIk+qyeHFuPKPA3gfxD+138cdI8A+F0k1rwdo+tSpJezyLpuneIdavI5rnUdY1nUHMdvpektYaTfaheX88kcPhr4deHtS1BpYWinLez/ALS/xQ0vxfq/h34N/CKSa9+GXw5uL3S/DF3FaGCfx94s1IWtj4n+Kd7p0SgwN4hmsbLR/BOh+UW8PeB9J8NaIDNd2epXN78ZUqOtiVWvUxVRV5Qw8pqU1jsfUk1Os7u9RU6lTmj8Scm5aKorfo+cYzHYnMKOSYCpWrcQ586mIzDFxcnPKsqm1Tq4lTSvHGYyf+yZfG/N7T6xi4prCpS5jQ18a/tU/HDU9Z8T6rZ2suq3Fx4m8b+IpEjsPDHgjwn4f09BKtrBGEttF8KeC/DVlFp2kabbJHb6fZWOnaRYw5S3iC/tM/tD2N9Hph8DxyaB4P8ADnh+88BfADw5KVhvtJ8MO5tfFvxW1u1CoY/Fnje5SdoZJC09obqSGAqukWch6P4pSWH7Pfw31L4IwyCHxPewaTrn7RWs28sRu7e7DW+reFfgVY3UZLGe0l+ya98Q1UyD+3msfD80Yl8PanG/5deLfEmq+K9auNZ1IBJXEUFpbRNttdOsIFEdlY2secRwW0SIi7cMSNx+cu1HFGYvh3K45DQnN5jjZLFZ1iFJOcqt3yYWFldUsLe9TV+0xTk3pRgz384wdDI8qwvBeWqNGjSVGfEEqUkoynRcXh8mhNf8uaD5Z4xNtVa/NTlfljJ+ifCq28AJ4rstT+JkWqXXhm1jvbm6sdKgWS71G7gs3uNP00zSnbBb6nepDBfXcZM8Vq0giKSMHT9MfgP8J/AP7Sfw8+N/jnxF4yi8J/E3wlYaZ/wqj4e6Ra21n4St9BRby+l0+1tLu6DR2MLWkHh+2NvcrcJez21/epfPMJa/KvwrImradcaQVj+120T3lo4A3yMFVZoXYtuYFM5GDnIbqFr6d/Zm+JMngfxnbxXUxi067X7NcKCQPs08i+ej8IXRQ0hKHaUbbLGVdGr43KatODoU5qE8PWc3UuuWc5OKgvaTTbfsrucFeybb00PwvxBy3N6+V5njsgzDF4LO8vp4OWGjFxq044bCYqGLq0KVCrBwisfTg8PiKiTqTpqEIyiotGJqCajaXl7ZajZzafdJCifZ7mF4XiEOUMW2Qk/LnHDepONwY+c6irqzbgMnOTng5OMHg45weEOTwCWzX6A/tQeE7ea8svFulYkspbeN5JIjuBgu3Z0JkRAG2ys77ixIEsa/KAA3wdqcShpcAEMcggk5yRyQDnjODkL04HJFcmaU5Uq8k3KSfwyulo7W1atey1u9H5Np/QcJZzT4nyLBZooKnWqU/Z4mlvKliKfLGpBq11yyTcbv4Wu6txkxyCMkEAqDkcHAAGST1ySMcf3sHOEs5dhIJxkjk85JwoJbpkcDacdeuckzzxgEk5BC8HuX4x8zZI55xgDkKSCCazQu1lb+LIJxwxKnOD975l5zuxnkt1FcdNtWav7yW7ta1mtHdL0S0V12v9JGi4NSSuo8v4KLsrt73ad/O1tjpI2wccsOpGMrtIBzjH3ccHIAHHYkDQiJbgNnHIIBI+Xbn5cYz1yMDB7YrGhkLIjKRzg4XryApUkZIPTPOB7VoQyYcAE4wOcNg5CEjjaBk44HIz3ORXo4Wo4yjq+l1p5a6aXsumje6e7+qy6ekemi6bq0XfRu6ultbY6eyk2MrZIGBkk45J5z7A4I/wCA8bQce0+GtQWe3jG4Mwwp55yMlcgbiCwGRnORzjHTwa3mYkbQCAQG5yOCATyMHnj5Rj24JrvvDd9LFOI1baHZTuBJBcYxkgjJ6AjByOOGr9DyLGqnVpO+jcfxcWn1sl+tz7jKsR7OrC9+WfKpa6Jtx6+mm9lu+5+jv7L/AMS7j4efETw9rEU5SFL2FbhA5C+WX2yK3AyCjMpwOevVQa/qS8K67a65pGmaxYzLJa6jZ291Gy4YFJ4hIuSowSN2OSDkFTwDX8Z3hrVJbS4t5lJXayt8rHgjnKseBz04xnPRq/pR/YO+LK+OPhpFoF5cLJqXh3bGisxaR7SUEqQCxOI5Nycj5U25HOR/VvBOaLMcqqYGpJSrYRe2orRt0Z8qqxSu3aE2pJdE32R/TvhXnnLUq5XVmnGpFTpJtO0la+jbWqs7Wb0tqtv0p0yfIADD5sYHBx05I64z1JweQPet24VZ7UkZyqENnAJX5WwQBnA69zzj1J4mxmAYfMVV8EAdB224znGCeOTxzkZrtLWT93yQSwOQRnPQNnHzDGOMsPXkE57cZSdOopq91JNJadr9NLbvtZXXU/oWnFVKTpu1pxs1p1SvbZO2zV27ppH4X/8ABRT4RNpPii28d6baqlprkYW5kRAI1voQMhyF4EsaxsDjlgxGTkV4x+w98YJ/hr8UNLhuLkppOpTDTr9XciMJO7IjsMgMRu29hkcE8A/tF+1L8L7f4k/C7xDpIgEl/bW8uo6W3Bdbu2VpNqc5PmLuUDGDuzniv5qYnufCXiwbhJbS2t4UcL8rxyJKSyqPlxskCsFLNhACDhmz8Pxnl8Kv1fNIQusTBUcRore0goxbdv5ocrv1fM+1v4B+k14aUs2wGeZbOinQzXDVa2GfL/DxCtNSi1tOnWUZprVcy93c/aj/AIKB/CyPXNAh8eaTCJVkto2uZYgGUgRO8bll52MV3JJnzEJ+8ckGX/gjV+0JF4I+KuvfArxPOD4a+J9rnTre6Zfs8fiKAvbNbGNiE26la3E1vKigrI/2aVuYkA9t+FGt2f7Qf7NZsLsx3epWGly6XdhgHl3QQsEkI+ZsMCrOTn5WyCQOfxnmGu/BL4w2OtWHm2N/4Y8Rw39tIjNG+6yuSfkYKAS8aIM9GO1jliM/lLowVSrhKrfsq8Xh5S19znt7Or60pqNSOu8LX11/yhxmUV+LvDriDhHFwUuIuE6tWeCjVuqjxGXSc6KV/eUKyhKhN/apVJK2rPsf/grB+z3L8MPihb+OtPtpF0+W8HhjUZ1DAtZ7X1LwlezsFGXFib3Qp5RlPtOibc5Ybvlv9kz4133wX+LHgrx9ZyM9rpOopb65aKzBdQ8PalGtjrlm44DebZXEskQfIiuI4pc7kFf0O/theEtG/bI/ZH8OfEfRVtri88aeELXT7ieDbssfFVgraroNw7LkxiXVIfsau2fIsNSnR9zONv8AJroF1d6Pqlxp2oRPbXlhdS2V5bTArLDcW0xhniZG5DI6mN0J3KFDAnYTX0FKtKtSwmOrRSrT5sDmUL3ax2CccPiebZONdKFaMrWkqnMvdP5x4OhR4h4QzzgrMH7RYClWw2HhL3ajyjMKTq4NtO7jPCynUw0klejPDpWTVj/SW/ZI+Itj4l8ILokF/HfW1lBa3ujXIkDLeaDq0K3ul3EbgkMhgk8rKgKFRQeea8C/4KGfACx+K3w+8U6HLDH5XjXQrjSTcuuE0/xBZf8AEw8M6oWCgJ5Oo28YkkxkxYjHylgfzI/4JGftLHVfA3hrTNS1AvqXw5vYPBetiaYtJP4X1hpbrwpqDbjuMdnIt1pZc4CpZxjjec/0X/ELw9beOfBGoaeio7XVkZbSTtFcwqJrd8j+7KiMByCoIYEAg/z3xFQqcDeIeGzWjdZfmNWNWU0moSjVlFV1LZPlk1Wa0WqV7aH65wJQr+Mf0deJ/DLMJ83HXhXinQympNReJ58ovi+H8ZS5uaap4rDQlgVO2sFN2Z/mCfGrwXqGg6vq+k6tZvaanpd9e6bqNpIhWS2v7KeW3uoXjxlTFNC0bZxgggDAyPh7xJYbHddgUAOASAeONpJOM9mJAwTgjnkf0if8FYvgG3gn4vXPjW00422kfES3nvbgLEI47XxdpG2y8Q27HaEWW8j+x6sSWDTS3V2y/Kpx/Px410ryJpRtOBvXAAwCABgfe4XB7kdThiDX6pxDhKdWnTxlL3qWKpRrQlFJaTjGVrpa2bs9Xdp2OLwd4rec5Ll9apPlxCh7DGUmrToYvDzdDF0ZRfK1KnXp1I2aW17Ws38p6zbkNKNudpcL2ORxjJ5A754JAO7vXmGpRAEnHQYIOTnG0jrgA8DBweQV5wBXtfiG3KPJwDkt8wBUBgw+ZifvdCeWBwdwz0ryPV42bcpySO+WwAccHktlgSdynk5PynBP5PjaajKal0la7t5Pone97d156n9hcO4nnVN3upLd6Nr3deye9113t0fnF8md4OcHI3LkHBXqu3bgbtpBzxj7q5BrmJfMGEIyQhUPtIMqk7ULBmyARtJAY7ioyzMAzdjfRszFXUlQVYEfe3DZgZyTt6noCSAQT1rmLuJm3gqMLtGQTuyNrHO3cAORxn5lORnkH5XEXc5dltZrur9PPXr89/1PL6rfIr6WW9ulk9723176pbu/Pzs7SFCyqjRyGMYLsGGFJkIYSBQPm27fl+UHDDaKy7mRd3XaDkcZIAQAc5Ldc8DJH3iQKvyowZ32jcRtJ6sFxlQD8pwWbryMFiwDEYoHOctggj5eWHPyAYHQHPfOWJGe9cEotT2abV+m2ney2TeiT5delz6GhJJp3tGyV03rfl2V7d0o623Vr3KjOEy2BhQBg47fMWIA3DBICkHcBgMQBVSaUSOh2spVkkRgFwCcKd+CDubqSWKlRnGQTV2RQRluu4EjB28YOME5B5PuTknOSKpSDaScluRtAz8oOMdMAcAbgcquMnC5Fc7TtZpK/wBlLpo7u+l73e8tuuh61Nx01Seltr9HZ7NJ21evZ9Ui3EaXMbTTLbQ4kWSUo5WFZEI3MqEF0G9mYEN8i5wVGDixrGup3KLL5qRacke+NmdWWC5VQ47gHy2laM8oHMbkOGUbAC4AYE7yOBuUg4wwCgE4AJyDk4wwHOQ+CK1RbzzI1Q3FnNFBMkY3QyuwnUgM6qY5mXZLkN2bBVSBhUp80oW0UHJ6XbkrWVno27N3vZt9ToabjFNqyW70TtytXdlZN2tZqza8jCiBEth8pH/Etm4DH/npGCB83OByR2PqV3HQGB1zux8yZPX5SuOduMj5TkkD5ueRVKNCJbEH74sbxThwcEXbAqGXPRcAckMGLHjIOhtwGXGSMHrk44wcHIOAAccdSVwOBhC9m7X1itV/djo1drW3a90ulyqV1FO97NqyWurvbzst79t7NkYzgZO05ycjPDY7dACOep65OUFRhTvc5DcfcwSeAMYCnap9QRgfe4UHD2Lj5tu4qAuGOckYA5OASeVz24wQajOR1IwRtA3HGCM9FyBwDkEkYJ42ZFU7XvptfVq17JW/Hyu9NLG107Wtd9LrR3Tv/esl1fvJ26K6cruwdmVBO4D5zx2AAViASTgcYYZAGWt8pBH3lKsgA5K/KDvGSpAGDuz8oHyqeMh3DIwSOowSOcKWyAOx+bhhtHAJQ5qMuwA2n5gwUDkd0OMDcRgdP72CV4GAX0V7fhrZx33+fojRP3U73dlq0tPh83te9l/mnZVnDMGXBORu3qwkUbQDzwMHdxyWwQOVNSbgGHfg5xgqThcHP3gM+gxj5Qc5qEtwoOPmG056jgHIwCCA24r83B7gFhTtqMQCwyrDkEgEfLwp564BzkAdGUN1L2Wtn8vKNm7aWV9d+lrnRFvkS0k7315VouW1rLq9m+uqu7jwQwBAbjBJHAwSCS2RuwOgP55OFJsBBOVVQB3HOdhB5G3jgBVYg8EEsOFYc5BYALg8FSwYqA2QRkgDgscnG7rxQV4x3jxg88A4yCDnkkDnHILbsMc0c11qutlf5W010btot797X0V+W1km7LR6293pzP0035d0+UapRVIUhtmCfmwOiqVw3J4OeAVbIUEYqFo8yoycNuVQSCBt3DPQ8A55ON2SAchSRK2z5mIK4D8nIwAy8k7j8w4O084GDk52xplmjcjjIbJPOBtOVOOuOGzyTycnGYtF3TXu9dVd7LdJN6Lvd7p33xne6Vo2V9lftZp66vfdp77jI9MvJpCvkTeaYnn8rDpIirg7wCgBA24QAtJvDAAFSV3Lewg0y2TUtVTzJpSkml6ezDN1IMbp7pQgX7KCjblZg8mQpXlmrnHuLmWR7iSSSSWTcHkZ5N21yWdx84CtlmUDYpILFlLsxp24OuC3mDbhC5LlcnA6sCqnfjaowjLlSVGBxRlGEm4xaau4+0cXZtp8zSWrWrS16ad/jKkKk0lOoox05lCL5pfC3FT5tE7pSdr8vMrp2ZcnvZb25e5uJS80xUsXCgIgIKxxpuZY40yAiquEwyED5TShVxuBGB2yDyGDdCDjJxjGecAciqqrGzrtwCEUbgAo2AnnKnLseeRjKjax4FT5CbmYMVBCNtUjB6EAAdcjPJyCP4hwai73cmpS6y6206vVLS9v1REoxXLGMbKySSSSWySXKtbf5fORS4zyGG8BflAZlPyqpJJG4YznCgk8HOMPC4xjOSCCAAuA2M4zhRg5w2ckrjIAwI4zvyCcMCFIPUHKjOAckZBwuTnB7Yy9TxhsHhRu7cFVyQcEk+oyPxBrSnb5NJpPXto1fbq7dt7XMZ62emj1Wi009LdL+tyaEYK85w2AR1yfUKM9CT+HDDHF9DtYEjAAAAIOcEgDIJOe3I64O7nrUi5G4DJJOcA7io245HAA+UnAxnnGADVtAfl2D5SCcc9sflgDk9jjHIIG8Xqno3Jq7+6zsrb229fny1bWb97Raf4rra2261fXTpZ2YwM4LDIClQMADO3APTPBxwQG6ZHQacLBsKCOevOMglRkNkHPYckg89QKzlAO0YONwxlh82dp6txtz3Gc88jjGnADhck5TbtU5yxyuBkgjOQGwdoIADEHrtF6rrts3Lsnvdaapa7rQ8ytqlvvpZarazW2u/fW2z0Ny0jAwG4DFQQT16Yx90Z6nGT0yMdD1WnxHKjOOFyQc5ACk8bSuMfLjBznOMcjmLU52d2JUjrwcLkAZJI3ENzySQc4zXX6blwgY/wgbsZO7A4I7FsYHXGB14J9vCxi1FXttZfCr2Wrenf9NVqfM4+bhCbS00XK7XWivo3trfRX87JJdvpMbsEAQZ3Luyy5VRg5I2lix7dDgkk9M+1eGLB5HVduHIUcg4+8oGMZA6Zx/EoBY5BA8p0aEsU2kY4yMnkEKAVHHOTjaRjpu4JA+h/BNh500A2EkbNzc5OCQSARkYAxuxnoBnAr7HKMOqlWCX92ytbbazu7r3r/AC6Lb8Z4txjo4etN8qcYvra+ie93or/PRI+l/hr4f86e2Cx72YomxVLM7FgAqKMfMzbRtBL4IAyCMf3V/wDBKD9lNPht8O/Bek6vpoi1qdYfHvj+SSPbIPEOrwIdH0WVhgj/AIR/To7W2MbEhL6K/bA84k/zGf8ABMf9nj/hbnxx0DUdW0/7T4O+HSQeMfEStGHtru6s58+G9FlBAST+0tZWGaeBsmXTrHUT90Ma/vx+AfgpfBPgeC6vI/K1PVVbUtRaQfOskiho42IC48qIIhHGXDOFG7FfU8b5suHuFpYehLkxuZr2FFJrnUJRUak0t/di20/szcHpofy/wJw4/FrxzyrKcTFVuF+CHT4n4l5lzYepXoTjLKcvqy1herXUa9SlO6nQhUaXuoy/2k/Hx8EeAbiz05wNb1kppOjxBlDm6uSIVIALACJGaTuMpgkAg1/Bt/wUp+PkfxV+Nuo6Do+pNdeDPhbBceDdDljkLwahqkU/m+L9cjIJV31LWUkgiuQWEljp9m2TlN39JX/BVH9q2P4c+CfHHibTdRC6rp8Mngb4ewq43yeM9fimhvNVgGeT4d0lbnUfMwwju0tFYgSYb+Pb4TfDnVPj98avA/wws5bjy/EWtibxFqMIMsmn+GNLVtY8Uaq+TmR4tNtrx4mcAXF99mgVt8sYPocA5E8i4bwyqRccfmnLicRdWklVUPZU32UINatJxlOotNTwvErjOl4n+MPE/GHtV/qhwDSxXDXD0r3oP6inLN8xpX91urVi6UJwv7SlGEU7pW/bT/glz8NdF+An7P8A48/as+I1rHbG806TxrG90Akx8N6E95Y+BdEgaQrIr+JPEiXeueWudy6f4Zm5iuY2r8Rfjb8TPEfxx+LPinxtrtzLeav4v8Q3uozFmYqn2u7Lx20IOTHb20RSGJVHyRRRxJ8qYr9pv+Cp3xa0/wCEHwh+H37K/g8R6RJc2mn+LvG2l2LiJNM0yC1isvB3hORV+ZYtL061tUdHxuTTtPnIDSE1+R37JPwvufit8T9KilgeSwtryOW6k24VI4yZJW6AFViRlRW+4XG7BK4+hxHtMXXo4LDe9PFOnShayaw8WlCd09PaSlUryf8AJOGnuo/Tvo08EY3iTM8TxdjcPP63nuNeHwFOcdaGCjUpw0drpKnTp0b66UFUWlR3/YT9ij4SRfDv4U22r31sINV8TKLmTcoWUWCRyfZkJPKLIoMrNwoDlgQzCsvxpPcfFv4w6d4csS1zpGk3QtEWPLJIyyL9skCr8v7yUrAmcgIoULkE19I/E/xHZ/D34f3IsfLhmis49H0eGMhWaVozEGjXjCQo3RQRkFzkgEZ/7Dvwum1XULrxxqsLSCKUSQySrnzJGJaPk8n5xLOfXMZJ+Ra/RcRUo5bgaGXU2lToUo1K2z5lBr3bp71aj1XrtY/pb6X3H9Lw78OcNwXk9WFPG4vCwWIhTlFTcbclOLs+Ze0qc1SSavaEdbS1/Tr4Z+GLfwh4S0bR4o0hMFtG06rgZlZQSD8o+4QEGdwwAMhjz61aH5WbcQCuAewwqDOeeOCTz79ea5OGTayxdGYqqgEDKrkYycnHUYA78nIrba4Ftb7eAwA5yCDwMZyTuB5BPQgBeoFfmOPnUxVecpKUp1p3W9+VtXtt00vq166n+MkMRyc06kpTnaVSUm1eVSTje+75m9W73WvTUqa5qqwRSOzbUjUnJx8owWY9c5O0A9Qq4OAMtX8+f/BR39oDz7y58Lafep9ntFmSXZKCDIVIbKqSeDxnOc7mRTgY/XD9oj4pWnw/8E63q09zHHMlpcJDudcmV1IGA3Q59AcEbQT1H8gX7Tnxcn8U+I9VvJbpphcXVw7lpDkbmfBAUYIC4A3NkYxk8lvRk4ZPlNTESXLXxKdKha11H3VOad72dlFO7vbq9D9P8HOFavE/FEcxr0pVMFlsozcpRbjKu5R5Y32ahFNvs7XbVz5O+IHiae9ubhjIWLSO28tuySW5LMxJznIbAJJO7Jr5o8SaqX3jcwOGx8xJYAMCDnudxJAHO4DBYV1nijWg7Stuzwdo6kHkDJyQW2j1weGJ5zXiWo3zTyt8xJY5DE8liQcE8kcYOMHOAcnNflOYYh1JSbk5Nu+9lrZ+V10eqvZ3P9KuFsn5Y0fcTS5UlZLRKNm10/FW62KEzmSVmbIA69cABuCOc/dIwOx9hmoW2jaMD7vyno38J6ZPoB1IIXPBwKMELyOueOG5J/iC8985J9/Sm8nK8cc4AB2ggE5xngD6jjoRXkR957vysnrs73WrvF/C0l+J+/ZJgVTUYWV2obvouXTZatNa62aeo+FAZQQSQSB+HBxzxwR1Xuc+uLFy4QDgZIK5yCcA8AgjJwM9wC3JY54WBBEpfsE5zjLEHIzg5APQDPQ4BIwTmSO0spI4AYgjkADgnp8pz2yMgkHA7elTjyxhGK1lo27XteOvW1lda6Npu19/0uhFUKMIJrmmou2+9l0/l6Nbat62NKziMkqLt3FiMnHU9QpP4dchsdsnNfdf7Jfwon8eePtAtTbPLaLdwz3JCFsQxuWcE/NjIUDkA7mHBUAj458N6eLq5giC7y7KucfdLE5453e+epJORjn+g/8AYF+F9t4W8KXfjnUoVheWPyrV5V2HYm9ndSwJyWI5UnuRzhR+xeGPD/8Aaeb4edSN8Ph2sRVvbl5IODjF6JK+kbbu90mfY8MYJ43H4eLXuwcZ1E1dckHHV2vvZJW9d3Y+v/jN490v4PfCm6dJIrc6fpAt7dA4H7wQ7FVVJ5w/UoMg84wTX82fifxJe+OPFOoavezPLLf30s8jEk8ySM4BAOQACoVcEEYJPIA+9P2/PjZceIdZh8Habc5s4ZXe4SKUsjCNyFUhWxhmLEDJyq5Lcg1+d2jR+UWuG+6gLtkEDcMAAdcZAAOMbRgAruNfZeIHEMs1zmhk+Eb+rYF2nyXtLENRUlotqatFaNJ3v5+3x7n0q1SjlOGl+7w6j7RQtZ1ZcqUVy9Iq1r7Xatc9HOpSJZRaTCqrbh4zK4BDyRoNyRM2VDIsgaYkKMvIGBV/mr+kT/gmB8NLD9mz9mP4i/tb+LoYLDxZ4z0u98MfDqe+RFmsLa9g8261KNpMPHHa6XCusXU0YIe0uUt9yyQTivwJ/Zs+E+rfHP4v+Cvh5pttNetr+s2keoxwhmddNSdftaBhlhLckpYW28hBdXEQOfmr90v+Csfxn0v4U/CTwd+zN4Bu4bWz8P6TH4LRNOZI4ZLyWCG/8eakkafMiN51toUGWBSO8vYgVVGD/QZDlKqYTCYOtG1HHyniMweiccly1062Lpr3lJPMsV9Uy+Kt+8oVsZy3dNn6X4QcO0MnyrMuK8ypxWHwtOpKnzK3tpQhGVWCbfM5YitLD4Npb0q9eyXJzL8C/jn48ufjN8XPFvjmV5pLLUtTmtNDimYyfZtBsnNrpqEFiFaWFFuJySzSXE8rku7k1+in/BNz9nXV/HHjJfFVrp73V9NfxeB/BKeW26bxBrSRRa3qcJxgHSdFu47FJsgQ3GuQyhla24/NrwD4V1HxNruk6Lpdo93qOrahZ6bp1rCpMk93fTpb20aKOpklkUbmGcNwMDNf3T/8Ed/2StO8J29j4quLSCbR/hrpceiaJcNADFqvivUke58Q64jlRvaS5mnnhkYMwtZ9KTKtZrs+q4i4ow3A3Cufcc4/2bxGGoVf7Mw85K1fMMQvY4GhBbuMKsqbkkrwppy+yfS8JYyjg6/EPiTnsY1qPD8KuY0YVtY43P8AHSlHKsKr3vy4mSrT35IU1J6XZ+zfwr8G+Gf2b/gbonh4SW9npfgvw211qd9tWIT3Uds11qd6/H/La5MsmOcBxGuVAA/iT/4K9ftaah8RfFesaNHfut341v21rU4BIN1l4O0i6a28L6Syk4jXUbu2lv54gNssGn2U+D9oZm/qr/4KefHSy+G3wkfwUmqxadJ4ltrzU/EN2JfLOleENAQ6hqt1IQQY0mEQiUEfvI454xvY7T/nS/tEfFW7+J3xA8WeMrnfGutalK9haSMT/Z2j2yi00fTkBzt+x6bDbxyBfvXAkk+85z+P/Rr4fqYXKuJfFniDmq5vxBicVTwGIr+9UlSlXdXF4lSbv/tOL50nZ2WGg4+7O55HD0sVgOF834szGpKfEHiBjMXFYio/30clp4hVcdWcr80VmGPbpbWdLDtr3ZHzL4w1Z7iWZi2csx746sOPu+gAA5OSDzkV4DrN0WLYbIyQRuySwG7IAIySAMk54PIIwB3/AIiv8l/nBJbO4kDAJXAzkg8kkH+L+L28g1S4QmTL4OCFAyVOQmF5K9z0ycr3LYU8HGmaTx2OxVacubnqSk3fVNuLskltd7rXqfkGf4hVKklp5bWs7JO+m1r6+t7I5i/nYSKMjYVYuxI3AjphcjOcMwXk4Oe+Dz80oVRvK4B6jJJLFQo3YyWUk4OD8q+1al3IGJJxgFeDkA8g8kj5TySuRkE4+VuawJZDvcMCVwVyw+XqG3deMYBTaMg9cEjP4tmM5c0nfVyun/d0VtNO3psfneMgr9m7aJ9rW0u3u7PV63Wi3p3E6hZHklWNdufMDHC5JwN6KRu/eZAIJfaGXAXFZ73SR+XKGBRwkQ3SAhmbBVwSR5ZZXI3FHDDqBkGluWJXIVZCGU+WwVjsyCA+SMYZslsnGAflC7RmSkqozucKd6clh+6bKsCsmAxzgsG2FMR4xtA+VxEpX05Ulrd3u27J73Wj6O3d7yT+fqUItq+ivrfTS8WrXT3dno30WmqNIzuCy/eOAyyqV25yFZCCT0IIVQMudpJwaph3VvNMrFVU5tygMe9cDeP4lK7fmJbJyTyCRVQTFUikkibfIwR1ABKuWK4c8gISHJJbcFBYqOtI0jLkmJpSWO51MZwpMalyScNGu85YbT93dkjJ4ZVFda8tnbRejeq36Jp6aJdmc8qLTVrPRLa3a66X8t30W1i3LIxbdnL8NnBGcFd+VH94bcsW2seWO3JqJ5RwAfmCgk7mBJAXKEjJGOB14BC9yVpvcJGUy5RiBtD8rkFdrYUMBHlwuCccgrkdIReI6+YDtDEqFbAOVEfG3llLEnyyQC6jG0jpmqi6vW6unbfR3tazu+737CVJ6abW1fnbayeq6d9LD5Ji1zb/AClV8u5JHGSQsYIJJVgMHgc9s/eBE3mlg+UO1QAqkfMDhRgctjngByADhyCSDWXJKwvbLKsVaG6x8x+VdkeN21BuPqrZ2cHAXirqllferJs2kFNnybgcFwwZSxzhckEnPzcE1Ck3zLV2aVlbtF6NWWm6snuzVw0TVk+VOzWl4tO97tp203s0+rSQrmUyRsHXy/vSR+UN3tiXf97CYPIO5mwNtReYF+27XJVb62UbeAB9n6lMhcDvubAXqSoKgMiOJAHBZSd8aYBQBRwBgkMc4Ug4AxlgOteHBXVGU4Av7QhWbkf6NIcBSu3I3EcjC/dGWORF0mle6blvd2ajd2vot76WS7X3UYJJNJJJxSXrOO71v522d73bu7BIAPlucyFWfJHU7SWUgja2ApVACDyfLZGNZrJAsskqF0cPvJWVjHJJ9zJVjg7t2ADujJX5ipClXSyja8shJUfPj5wAoKkgbUAyWwMY4KgFipJEHmGUqyllwisC/ljdnaQjA/dGF5DZLDBBY4FS5LydmnoldWsr2b06r0v1TR1KPL33tpp1jfr06X7J3bbQ6WZUaJQGM06+QFKEMwG0tgkhIwFwUfsQVIypdo134GVG3LSIznf5QVhiAKJWzgDKFVUKSZAvUVA8k0QLqLdAdrOpMkko+4XbcgXG3DDZggsxVg+41LvUIWUeax2hgiLuZhtzIBghQp3ZDEFQx7cl+0hLm1uo2aTSu7Wejbbbum+ZRu3IpKyWm+rtvun0u7aeX3k4c7mjYFQqjGW+/GyoiFAC5wMAMwOGxnPIBmXYpQdMx7VG7dtJ2jO4kqFOAQpznHynIbGdNMLaMSsrysTHGQhGCWKnc+1CgQIWU5c7QNp28mpopAyKQGCqoY5AVgzBG2uq5ZOCCVY5BIJ4NQ6vvuC1knfltrFNqz7dno+bRPXQpxtZ7q+3neO2unS34t3ZLM8giKwukThlUNNucEAhnbBGCQFbY5IyQR8rAGpC7yLbgCSaWEMsnlqwUwmICV0w+FAZXG7GwICdoZ5SYncsobk7gmBgEnBGFOQ7N0zyAeFDZB2kM7wjzIgQ68gp8pVn4yG3IWUjIIySVOSuMkPS3vNpWV0mtFFraN11s/k1ayua0aig3zRvGaUZabJuDdk97WTSfbTzk3llZ1ziQEdiWBBxkgY65U4YbOScDADkMhAMhXeqqxChQoKou3JJYnIzgknIwDuYBixmDI10EUlCFlhRgFUl2CzwK0jHy9u7dkBUYEn5AoRI2DqOdoEYOxSSD0OVKqRkZ652jgkrkMKUkm9PetF82nK/hd1eOnW7/m7tpqqlPkknFqUJRvGV978ujdkk029O+j1sLceXcRMj7kB2GJlEhlWQLtEsRIDIUYrgAjA4I2kA1ra6kMwtrgg3gjzFJgLHdwjdiaPj5ZRz5iEZZskcbhVmRZAhkCpJKqB9rAsHVQjEHJA24X74bc3QE4zVaW2W8AjZijJGlxHcJgNbzYXcUCE4jyAJBv2q33SG4TOSs+eLam0nJNuzUlF7u/vbtdUt31EmnGKsrNpRd1dX5fnaz132s/eVy8obect90k5bIVwGQbNrDBIyc844wOoIupJu+UoAuCoO1hkkIAp3Mp28gL1JB3ZG1Qce0uJWkNrd4W8jj+RVwqXcZGRLGwyS5wC424ODwCCq6cZ2FgTlwvAIYsq/KuAWyCBtPBI5BYEBcC4S5um9kkrpp6brVu9+9t3bVkPft107aX/PvfvqXYcHB4G3BZQCMKMZwwDEhQeGB+YfeyvzDctVDhQFLE4BG1cg4UAEZLFfukkZOSTkAADEhLbI22qMMN5Kg7T8gAOCWBxjdwp5x8ykFep0aJprmEAOsQYSOowCqoAxA2qMZKjhyMEkZOQR00rylBWb5ml20Vt+q36+j8sKs/ZwnN/Cotrfy1s9reeiurLqe1eCPCup+KNU8OeC9EieTW/F2taN4S0mOMlpmv8AxBfQWKSLgBj5ZuizMEwI1YtlVLV/V5/wVG17Tf2Uf+CW/wADP2X/AAiy6drfxy1uz1Ce0hHlXC/DrwNplnomgLMoJcx3UFjoF8+TsNzLdMmQOfxr/wCCRvwQn+NX7aHw9i+z+bY+AIv7eaV18yCHxNrNxD4c8KvLvTAay1XVItUUcyKums4GxH2/ef8AwVL8UWv7Uv8AwU88O/AzQrtn+HvwJs/Cnwcs443EtnptnoEcN74yv258tRp4F+tzIzAFdLKSv+4Yj9TyTCVHl9KjSh+/zGvDD0otOV0msPF2in7rnWqVVJ2V8MmldJr+cOIsFU428XuBeDqa9rh8tqviTMYWulONejSwXPf3Xy1VSlZrWnVm3fU/O744TRfA79knwl8PocWuva34W0fTboAhZf7f+Li23jXxndEZO1tM+GmgeFvDEuMN5Pje8WY4mYN+hX/BG39n678Q2thEYDaSa9ZWsVzfuGieyl8TTy6hrerCdiiQf8I/8PtCvZGkZj5Vxe2seM3KsPyb/a+8RXXxn/aF8PeC7VhHpMN7NrlzbwFjBZf8JbPBrLosa58tND8Aad4V0mOHGbf+zGt48odp/du98Z337HH/AATb8b+JPDcbR/GD9pbUI/2dvgjp9sTbava6rrcLr8Tde0uQFvJOj6frWpeEYdSRFltL/R9KWaZUjbH0+CrUsFm+dZjG8qeRZdHIMuik5N4qVJRruklZJ02ppNayTsm20fpvHeb4rDYHN8Vl15ZvnWJXD3DMYXk6eMx/JlGAq03rangsEq+ZVJaqmqUp2TVz8+v20/2lE/aF/a0+Jnx38NASeA/hLcWPwE/Ze0eFA1hPe6OJ7C21/TLZkMYigl/tXxx5qhlilu/CMcrbWiB/Of4l+IrzR9L0n4PeBJxe+LfFcckOrajFOUf7HqpeTXdVubttohXX40a2hu52X7J4O02a8d0j1nc/ca7rPh7wF4VhvIZrfUtF8C6ddeFvC/lSLDD4n8Uak7f8Jb4khKfMIvE2uQT2WmXEal7LwJ4eG5ob2209m7/9kv4aaZ4R8P8Ajr9sv49WEes6B4ZuLeDQPDeqgwJ8TfiJqsUt34T+HVpCoWVdGUW8Pin4i/Zo1h0n4e6Rb+H/AD7W98TWYbjnXqYfDU8GmoY3G0a2KxlRyd8Jh6jTrSva6qVYRjSg2rwowTTUmfbYPD5R4a8D5RldKHJguH8Bh8HhcLT5frOa5riJU4clPS9bHZljKijCXTmqV6jUIzkej61/Zn7Gn7Omn/DDw4iR/GL44eFVv/FmqrB5GteEfhFr4t7m2sm3hbjTfE3x1aC31ed/LivtI+C9h4W0aOXyvHviSCTi/gb4fu/hjoEPxw1HT7K98catf6lo3wX0nVoI5tP/AOEp0yza61v4iapazq0Z8JfCjT3TWruWRTbX3iH+x9Lk82A3qL5p4Ej8SftL/F/xT8QviV4ll+xefrPxB+JvjnVAXt9L0a1YXGsa1JGoEayhSmk+GdHtyqvO+m6NpsPmSwRLo/tWfF3+y9AtNOsrJ/D2t+PvDWn6b4Y8IswE3wr/AGe7S5e88J6DdfL+78W/FG9Z/HXjO52ia5hudOjSQW95Lbp35NTw2AwNbijGRdOhhKVSOT0pqPM4L3Z4zld7VZ1XGnh3raq3NJ06E0fR8F5Vi+H8sxXFOcKNXijPKrxKSfNSwlqVOlB0VO8lhcspuGEwCaiquIjLESUpqu38WfFj4gweJ9YurSC9u9Q02HU7y7m1S+ke4vfEus3ty8+qeKdXneRp7nUNVu5Li5MkxMsQmIctyR4hdLC6OBIp5OzkhnYgMcZHAJxgdyOMZ2jq/DHhy68ZeJ9D8N2LLHea7qlppsLurypBJdSxRiVo0UvIsKFnZYi0hAKqCQQLPjTwVeeEtSuNFvnguPKggvbHUrTcLTVdMulBtNUsxKqziKUxyRyRTRxTW86TQTRRzwSrX49mlXF5tWxGY1lKTqVZLmabUHK0lByk3ZJWWvVLVXV/Br4vCrHrB1MRF4+vCeLdOcm6lSHPHnqczvzvmfvfaerstWN+F2haj4j8Xadbafquk6KEvdNjvNS1y8e00mwhv7+z09J9QmjikkjszcTpHdSBWjgjIlmyoG30vxlpE3g3xpqFsuwCx1OdG8hxPbh1kIkFrdIWjvLGZVeawvYWaC8tJYLiM4lNeNeCb220zxNaSak7Jpl48mk64qsAo07UE8ie5wBtLWbPHeQ7lbE1sjgMAAvs/i+51AmPQddaOTVfCRPh83BUCW90qGZpNPYuZCZPsDbYbZ/LD/2ZNp0e54liYY4dShl/toOTcMQoVL6KE+VSg01olUipcvM3eVOS1e3l47LcQ8dRx6rRlgqlGWDxOHdNKUZytKlXlO/vxaUoODWnOmrLmR9sfCbxYPid4aPgDV7mObUF0+/g00zPl5YUsfttsisWyshltoxkhw+1o2yWjNfIuuWEtnfXdrPuWW2mlgKurIweJwCGUnqpXkckZI4yFrP8FeKNR8Ga54f8R6fMyTaRfW8u1SRvSKQMyE/3JYTJFzlQrkADAFe0fGKxs7zxC3iXSlQ6V4kgh1i12YCp9rjSSaIYJ5imMiFTkqQvTcMa166xVKEnZzprkltZxSUovRXve/M113TsfFZNlsuG+I8bgqShDKc4g8bg4rSNHHUpJYykr7KtCdOpTSs2o1L2sj5wu0KklgDzuwMgY+UYOOcZz15zkMBgGsSdNpJG7PTbjp0OdvPIHJyR2A4Bx119b4XBxjJyB6cZDYJzjjPOM5BHOF5ueMjIxkYxjA5zjGcbRnBPQgZ6cEiuaClbs1tfe19Gt+trbaM/Q/ZqUX70pX967ttaO636LVO3buJYyMcRNjI4XOQDwM87iMdQQB3B68HWRu5wDuBzgbmPyjHOenAwRzyT055lX8uXcoIKtg8HGcgHpkn/AGsjqArAYFdDH8+1lBO8ZyP4cYz64GCGOcevKg10wk04vRLSz0Vvh0lF/wBab337MBJ058i5pJuNtN9YtJX7dO1/RGtA/THXjg/ewNpxknkZzjGDyOa6SwuWikilU4YYx1xxjGSSDwQD328AnPA5eItx2OQCRxn5unHfsQNxxjIHWtiDcdp4OOCRncCdpPynLHJB6kkHJJb+L6zK679z7LUl1TW8WtX3211tZ72Z9jgarurdHfzumn8nda9b36n0DoF6J44mD9QCTgFs85z1BBIJ9sZOeK/T/wDYQ+Lj+B/iPp9nd3OzT9UdbK7DHCbJ22FsnAPlkpKpPzfu3J5bB/IfwvqLwMkExAUcq5IxkjAySScHpgAEZxkHg/T/AMONdfStb03UYZHRYZojlX5xuO7BAGcbdyk5AOCGORX7z4e57HB5ng5zn+7nKNGtFu3NTq8sJJpvXRvXa9m9T9T4UzeeCx+DxMJpSpVKcpK6XNZwel9ddmne+yd2z+xjS7uKVIpY5VdHRZFfO4OCuQcgkc5XOeSCDnAruNOugQvOA21hgkqc4GARjk4J6cfQ4r40/Zm+Iq+P/hj4f1Rp1nvLSBNNvhv3O0toAisfm4MkW1stjG9u4wfqzT7oZQZ5XaM9hk5I45HAA6HBIwSxzX75mmEjGU+V80Gk4SS+KEuVxnte0o22XXTsf2rlGLjjMLhcZSkpQrUoTT335W0+0rtp8rWt3o7s6zVLWO4t3UqHWRT8pwQwYEOABkDIOemD8wYEHn+b79t74TTfDz4qareWVuY9K1yQ6tZMEKxp5zf6TF0wNkxJI7Bl3DGWr+kuLM9tjgugDAk54GTgZ7Y43YGcA8EE18C/ty/CKHx18NLnW7e1D6n4baS8SREDyNZuWFwnTcdmRIc5UhDnglR81UwqzDL8bls/4jhKeHvbSvSjzQstX78VKC6ttXv1+F8WOHI51kFSvCmpV8IlWhZXfJaPtI3fRxu2u/Tc+Pv+CcHxfj0jxU/grU7krZa9A0KJMw2LeRo4QlSwALo20gbdwc4wy4rqv2/Pg5/YfiEeK9OtQlpqaG8EiDgTAK8i7kXH7xAJRjIzGwwSSK/ML4YeKr7wD4+03UbeV4JtO1KKXKHacwyhiN3B6A4OMKDtOf4f6JvH9lp/7QP7PdprNmsd1fx6Ul/Ew2lo7iOIiaPIB+R2VvXYGCNuXaB+EZnQlSqqTTi4P2VRPfmTik77p3b97ol00R/iT4tZJPw+8UMDnlGPssp4rUsLmEEuWEMXFRi3KzUffi1o1ryPzI/+CRvxXtfiX8MPif8Asu+JrtWmbTLvXfCBnkO632xC2uWtSxLK1pLJpl0hUAx7ZshVTj8V/wBvv4Qar8Iv2hNY1GKwNjpvjG4u7uaKOM+VB4o0e6On+KLQLhtrTXkcOrgEhjFqceAAAK7H9nb4r6t+y5+0t4U8XoZIrTRvElvFq1qXCC70O+Emn6vp8pwV/fWF06kOCmArrkxKa/W3/gr98FrLx94Ctvix4NRL+y1nRbf4h+Hrq1Qslxq+k2MI8QwQ7GUtLrPhV11Qw7TJJfaU7yjfyerBN16lfDx2zPDPFUFe6jmuV04+1hGK2li8Auaz1qVaL1dj+OOL8sj4eeK1DGKCp5Jn9X2c5RilTWAzrEc3OruMbZfnDU5yXw0seorTlS/M3/gnB8dR8OPjloOj63eGz8OfEGBfA+syzyGGCCfUpUPh3UpC2xB/Z2vJaB5CAUtbm5IcBju/vJ/Zw8Zt4x+Htnb3779W0cPpOqIzgyLcWjeSGkGeroqs24AliRjAJP8Ame+BvE0kj2q3O1JovLktLyEeXdQSqUaKSOTAKmN1VgR8wwHyrAE/2/8A/BMX9peP4ieF/BHiHUL0G68V6WnhzxahYEW/jrwzDDY30kwyRG+s2wtdagUn5xqLlSfLIHw3iPks8+4SqV6dO+MylvFUmleTp00nVjGzTinTdST0d3TppNn0HD+Yw8IvHjhTiR1rcJ+I0IcIcQNp06dDMq65spxeIV3Bv20YUI1W0o0p1NVdIwP+CtH7Mx+I3wv8axaPp4fWbK2bx34U2RhpJNY0OF11fTYSAx36rpMlzAsa4827e3LZCEj+FD4n+GdRtbi4LQxqpbcpyGyCxO07lJX5gyjncOOTnA/1If2gvBkXinwXd3MEQmvdNQajbIF3mRYlYXEOOQftEDSxAYIy6ttbbX+f7/wUZ+BI+E3xi8W2NhaeX4e115PFfht0TEEem6vNNJd2EfQAaVqy3lkIkH7uFLYZG8A8XAOcriDhFYSrLmxeU2pSv8UqUVBQurdIpJSe8+dtWZXE3Dj8LvHfP8hhD2OQcb8/FnD04aUoYutUjDN8FSuuVN1/9phSh8FOTlZXTPwc8T6ddQmcvHDtXl9hyVJZcHjn7xA3KuAeu3pXiOrQzBnXEffB24yAFHB43E4HPPPJ5PP1P4zje1knK7lbbLCdwb5oyCjIcKoYMOecjhWAyCR8166VV3ABYbmwwyGzk43dexXjIJBwCACa+azmioVZtq3a9ly9Xa9ne+1k9F1P6w4TcalCm1Ko5JRTTnok3G3K0ldvV2a0st3ovJ7+KVeFkTnOSY92OmF+YjOABjGcnlcEkDk7mOcHieJFzgfuS2AMAEfNwOu3JPXGS3A7i/AywPGCfTGVwTglugyCAB9B90ni7wnd1zjlAc+qt19zggYwSM/eAx8RiormdubW99ZJvRdLPW3Xtvv7v6/l9OMow96atZ6ye/urtbW977Wv1Zz863G5QbiIOeVAg3b8FCc85xnJOccgFsvxWbIlxtIW5iOSWP8Ao+cZP8XORjAzkjJ+8CCK0pSzFiMYCng53AnacBiRhSRwRngndgjnOkmwMnG09OGb5iQMYUgjg5OWyByQVzjyakUm25S0tZqTT2jZXb+K97bXW19W/q8PhovlfNJrR35m7Ws3q0uay1aV/TqU5EmIKtcr0xuWAKqkFcD5XJAwQTtGMYKknpXM6NuQqqTRBi8fJV1X/l4hJ3FhlTvXAZSRksDuFzfu47/fxkcA49OD6DBIYAbTt60rqAuAyNslRiYnUfMrkdeNvysSQ4Jw4JB6YPLNNe8m21q1J810raJt6bafn29KNBxSlTc+aKvZylJNXTaa66K2za6bD2J3HG1gEGQFyGO4DI5GckZJ+9uJJOABTN5XHy4wccrk4Ow85ByM8kgDPBxiq1vKrZDLtkU4mQFiI23E70BOTE4HyMRlDhGIGQbDfLg46ggryQegOMBRxwQ3VWJx8pyM4z53prraz73jo2lpbe3XZ3Wi7KNTnjZu0otKUWr2babV9NHq07vT1sQMIwUcLzGkkcb7mJVZW3vt9jIynoVIDAcHNKzMqqAvDMBgfMVxs5I49M4JJ6djikbPyqOvXGTtz8vUAED5SCR0PUA4JIxJJzhdozg/N3GACcYOcH2HAJJNRK6aUbWeuyaekdfJ6WvpbRJnTBpLVJ2fa/8AL89+3pe1hj9gT/dIyADzjAyM43EdB07YKnEasApVRn7oKgkgk4HUtnngEkg5xkZwoHIPThsYIBPTaPmAORx0/EA8cM1vmYAAAYB3ZBZxnAHJ4PU5wCRxSSWmmm/RtbPV+er72ey2NY8rd7XdrNNLT4etl003aS17jMnJPO4ngZ44CnJXoflyQeCcE5ABBiUYO4puUjLAZAyCoIXHC9AwJx1AAA3AvAJHORh8FScsQu3DBmGQvpwGB+UgHOWbC0gBIAADnOQGJKZWTJVACASTjbgjPJAqW0utk/15d00t/LR9EtUOybSTvorJ3bVpQe1/S9rLSxIpJBHzbhsII4yvyjjduLDByCw5IKso4IlQbSwJIyCdpPDD5QxAYgDnjkD2OcUxgroMZUh0bCcMMbRhQCPlIIIBfbtHckinJ0PI+diFB+bcoKgBiwIAUMCTwT1wCQaNU1ay2vs1tFu3Vv0+XU0atZp/k3e8W072XvXV9Lq/fe1lRgcg8N1+YYAzgHPG/ABAXJ5IGOGMzdR1yFP94rkYJJYnIUHPPGAGOeSjSrGEWRiCxULuU7nbg59vXJyuOMZyGDncCAoVhk5JOCMcYHXgkbid2fQACoi07X6q71Wmkb2XS++itolZ6m6kmmk7PRSStfXl00d1bum7apdwywIwBgDLFgpG47flA3cEgKNxBIzwWJwIUKiRQ42ncGXkKWRiuCfmdiQNvC8nljg7aezbQAQdwwQQee4BOQFAOcAgnkEgAqDUPliWVC/mbkYBdjFDkFeThl3liTyAGLbd4wEFDbUU9HdLsuivr690nbfdmU2r6JN6aq1/him/vSvr1etkyirorMGdVLqAAzE7h8o2qWwpGcBW6YGThhzIg4GAc7gw+8QQAvB4GeCMDoQM/WNUGSZFWQ4C7nQAkdSOmQFIDA7iy7hkHg1YjPA2kHqvTJQcAZ2luQmAR6855y3DGz1tbbSz1+FvfS/e17JPufJSaWzd9Lt7N2W2u1t7t300IxMJXZFaRNjqGcbVIOQSq7sMQcDrwcEMo6tbiU/MxUquMfvCWDFQvznLMQMgdOQeCWHzGJgRkxgZOFyQCjZIznbgZG45J+6BgkEingsFwBlvL3MoHyscAZ6j5QvTgNxgEDq43Tu7tpLXtezj8Tb0v25rrZ6ET1j0je1ryvro3Jvzt00ve2xbXBVSCpBXjB3DPQdBwfu5Bwc9xkYePugqfmwxPPLcAncSCVJ5G49R1bIBEK5wrBygwNyfLkDHCNhugGfmBPXAIyQZFz8y7Rzljuxz9NwPJOQT0GMEZIJ6I633XbV2V7X809Fp2Vn3OSUdG3ZpO9n9pqy11s9H006q9iS3ZgAsrASLyy+YHZFwoySBtCgnlTzlScgEE3oztySx3bhtHA4+X7uWABJ64xk4OQSKpq6qyktlnOM4OXIx1bGRt6Z44GcEZxaQ8gggYCnJJycgHg7c4PXAABx3PJ1pLlsm03ptbvF7X623fVvzMKrUrSjFpNWtqr2sulno/Traz1NFTuwGyGLLtOMdMAHGMn2OAPoxJOhCSSqnlwMiQYAzweVJzg4IxwWYkHqayFOBlQWkG3o212ztL4JycAdRkMM/NkZJ1IcjowACgkjAzkKMgAnae/OQegJzx0xvzX1W3brbXy3tvbr6+XWi1orO/wBl7JNRv2ute1t7X69BaHlCrKijaDuw2WAGQnyjkjJGGGBkBWHFdjp2Mrg8YBByBk5UkAg454zk4OMEjFcRaluAR12nOOhIVVHAByCCzEDPGDg8jsdPdvkA4APIPAO4jJJBye25hweF6DI9fCNqz8+t2nstkuz/AB1tqz5rMYPladkrP1asrX62e/8ASPW9BKlo8jjIG0dScL8zYALEMpJYbcDnHyk19XfC+GOW9tFY5dnUKMDJJIIHTkgsQSMjJATJ+78i+H3HmRHd8oYBsnkk4LLz8oAAOSScDPIGVr9+v+CTv7Onibxt8QNB8Z28NpBDrF1NpWmTa1odnrOjjQNLA1Lxfqd3Hf2OoQ2sH2SzXTINSt7cy27SXaRzRsyyj9M4UpRr4ulGclTpxtOrUkvdp04pc0mk+btotW35M/AfEjA5jPh7P8dgMLPFSyrKMfmlSl7T2UVRwtBVZKdVwqKDm1CnC8Zc9SUIJXaP6gf+CQ37KP8Awgfw08GQ6vp7QeIfGElr8RfGrTQss8EU1sp8K6FMXXcFsNMkgnkgcDyb3UNSiPzA4/df46eO4fh58Pr6e3dV1G4g+waXCMbpbqWMxxqgHJxyzADJC92IB/Ir9k7/AIKVfs06Zq2qeEdX8R+G/DevPr95o9wbrUorW3u7mxu5bVbzTb24naylsLkAPbWbXNpeW6KY1sijRmov+CmP7YFl8Ofh3r3juwklubLStChi+H15Av2vTNX8Y+IxNa6O7TQiSDyrFUk1UM8imSOzcxHy2bzDOeH804i47wCx+FnSyDL6UatGs5wqYevToKFWpacJOHPUqckZQ0nGnFtxT3/lngTxIyTw5+j/AMV/2PmFTEeNHiTnbwOLy2rgsXgc2yqvnMpYPLoxpYqjTqzwOXZeqtbD4qmp4Z4ioqcamvu/zcf8FQv2gpPiJ8aJPh5peo/a/DPwpF3pdw8M2+LUvHWqzJc+Kr5mBKO1pOltoUchzsTTJ2DHzWJ+kf8Agkf8HdH8J+FviD+1j8Rrf7Jomn6Xqd3ZX12ihYPAvhBxeaxPbrKGjZ/EviSztdLtYwFNzb6BqdtECJhX4faVp3iX4z/Evw/4N0WabUvEvxA8V2WkpcOzzySXmtahEt9qV0/3vLiMs93dzv8AKsEc0hwoZm/oA/4KA+PND/Zc/ZM+HP7LngaU2eo+M9G0u61uJD5V5F8OvDUi2/hq1vVjIdZ/FGrJJr+oB9rm+OqBgY7gZ/TZ14TVSalaC/cUnr7lNxXtpxts4UVJRttVqU1azV/i6XCVfA4LhDw1yxOWNzqrQlmsoRvUeFpShWxeIrXXNfFYpupLnuqlKnXgnfR/ij+1H8Zdf/aB+NnjHx7q0skl74r8Q3VzbW25njsbAusGlaXCpJJg0zT44LSNPmJCg4znH64fsK/B9fh14DPiTULXy9T1VNkLMuJShBacoxGULylIQQfkSL5sN938mv2W/hjefFr4s6TbNC01rb3a3Vw+0tGqqxeWVyMqAgUmMEqd+zkqDX9BPjjVtM+GHgOdoAlvBo9glpZQghTLe+U6oFUfeCmUu54JYlsMw4+g4Ky+nWxGLzuvTtSpc1LDKS9yEYxipzhfRKMYqK1srWVnq/8AXnwJ4JwPCvDrzfEUo0cFkuBVLDucbRSoUV7aq21rJJaN63u+p89fF7xG/j/4gWHg/TpGltNNuBA6QklWupWV7g4UnIhjxbqMlgSqHLOWr9ffgj4TtfA3gbS9LihWK4aFJboIMfvGH3GwAQsalUOCDg4xt3kfkN+yH4Wm8XeOL3xlqoaa1tZzO0kq7hJPKzzBgQMAiUeZjkKiLjkkj9kbLW7O0tkMtxFAY0IHmSIoUZI3HGAu7PC8gAEH3eayli4VKkYtvE1eeOl7UoNKlFrSyaV+9vuP8kfpW+JlfjXxIzOhCvKphsJWlywUnKENUqVKKTatTpKKa/mk21ff1eyYSS+a3KR4HUdTyfQ5x1wMLxzuIC43ibX7ewt5HlkCbVYrhsAcM3JyAFCgnOT8q7ic8V4149/aI+F3wo0K4v8AxX4u0mwZYmkNut3HJcy/LwkMMbFiSTjjocqCMlq/Dj9qn/gq3YXi6hofw1jMMDCaL+1rqQCd1CsMxRjIQN1VirEk56A5+WhDDYer7fHVY0aNO1k378rKN+SO/e1kkttE9PwXIOCOJuLK1HD5Tl1ecJyjGpiJxlToU+ZR1dSSSlpryLmduiuma3/BRv8AadjmnuPCemXwW3tBLHOVmGJZCCuAm5Nw4+UkA+gJwtfzf+P/ABrJfXdzM0pYs0hILkgksxBzn0OM4PfJ5Odr4u/HLW/HesX2p6pqM13NPLLMzSOZCzOW6ZPdjyoXaCM8Fq+YdR1K61CViXAQk5cnAAPH8Wc7QScgcHJAyTXxXE3EccwxCp0G44elH2dGLklaKs7uLur6XdtddL2SP9FfB/wt/wBVclwmDlSjLFPlqYqvypc9Wai5rba90k72S620dqeqPdsyxscMc7sgjHcZAA9eSO3ynuedNvltzdc5IHO3BJz/AL2PpjAzwQRK88MJwpMjADcSTjI29j2PPzA+mDnNUW1F+SIwvAxnnJ+XaxzjJ7A4K88HIUV8c5yqXknaT6uyu3Zaq0rp6a3T8kt/6cynB4bBqnByjzQs9NbbX0V+2qV/N9RHXJ79cdwOo7cAYbccnkjnrjLoIi5GQTkgAEdTkHI7EE8/d7c81nvezOcqOAfmyMZx0wcAnJ6kDuehphvbk42jj5cKBngY5z98Y5I7jgtzg0X2bae19bPXl3SSd9Lq1lbWz0b+6y3MMPCUHJuSVr2W21mv6srrZGvev5MaxKSGwMk7ueG6Y2jBIHJ6j7vBzVK1hO5SASc8Kcg4wAMgcZzjkdsKxyA1VRO91ICwYOduSMk9Oi5ZuT0HcgYxjFdTo1sZpY49uSSARyQQwwcZAIOeDgZyQBnOT7GDSrVqaSupOMeVdrrTW+/daNpvdtH3ODxFPFTumnBcqgtmpe6np89UtHayaPov4BeBLnxd4s0nT4oS4nuYw4x0XJ3hSCcfL/EQQpbndzj9/vFniKw+E3woi0axaO0Wy0tlcR/KN/lsXYDjJLEhW+9uwp6EL8BfsPfDqC1Eviq/gVEtIv8ARzKCF80hxnOMLtO7ByCMnAYg4s/tpfFV0sx4csrn99fu0UiLJkRwITuJIyNpXcC2FABAycZP9Q8P06PCPBeJzeranjMXT/dJu02mkqUVdaKTtJ9O2zP1/IIU8nynFZrXajL2UpRjLqrRUYrr70tNUrrVXsfn7458Q3PjPxdqerzu8n2i5kWEkcLFuIAXpgcdRuGeSW6mlMvkrDZpgOxDPkMCGbAA6BiMYLFVOcBh8wIrP0lQ0gmfBEf7xmKkjCggsTggYC5HHy5zjkivZfgp8MvEHxr+Kng/4f8Ahm1mutY8Xa/ZaTaLHG7iGO5nVZ7uQKGIgsrYSzyMmWCRSFAWC5/PuFsHWzjNPb1bOdavOpOc3olJqdSUpXSSjG7k3olurI+J4ewWK4m4hhGKlUq4nFQUI20lVrTSSVk17vM/K2rVkfub/wAEkfhJZ/Cb4Y/Ez9sfxlYRqNFhm8K/DOO+QD+0vEl1DJaLPbB1y0VpLeB5JQG2zvC2UayJX8kf2ovixdfGv40eJNce/k1DTdPvbnStLneQyJcqt7NNqF+pBwf7R1J7m53IPmiaJckRg1+13/BS74n6D+zH8APAn7LHw4njsovBGi2egSfY2jVr7xlrtg154i1SdouJbjSNOvJpPMUsEv8AWLXLK0MYr+dfwdptzqupWdraxS3V1c3MVtaW8SGSa4uLmQQwRRIoLPJLK4jRFw7tgD5W5/dctoynRw8qcGp5w6EsPTSbnSyLCynDLKbXSWOnPEZpVX8+LhGStTil/TvGlaOUZXknBeXO79lh8TjlSv8AvJSk/qlKSSu5VpTq4yUJWlB4mEJJumrfp1/wTo+C1/4y+JEHieLTZb2XSLi10Lw1CI/MkuvF2u77eGS3UqyO+kWEk9xG/wArW99daTLuwQa/0OvgT8MtH+BHwY8N+FAYIDomjC+1y9AWNJtSltxdalcOwAxHHIHij3HMdvDFGCAnH8+P/BFL9kyLS9TsNf1Swim0r4XWcdzeTlA9vqfxA1wF72RZCCtxHpPkeRbyZJW307TJBxIM/sr+338a7f4Y/CW48PWV/Dp+reMYrq1lu5JVjXTPDthbtca9qM7sQIraKyHkzTOyCNJpHDb0r+dfpA5ri+MuOeFfCHIZc8MFWw1XN5UXKUf7RxcI1G63KmnHLcvlOtJJP+M07ygeNxngcRWxfB/hJlsvZ4j2lLO+KakH7tLH4ylGpGGI7QynKuapJO8W6ttJxSP5YP8AgtZ+1nceLdU1jQ9Ov2SXx7ezWFrCkhDaf8OfDd2qH5Vy0S+I9YSGJgcedFZ6xDgq7Gv5WvFWpBpZTvyxJ5J+6C3AI5PAGO27LEccN9h/tc/GyX4xfFjxd4xjnkOkXF3/AGZ4XtpWbNp4X0ppLfSVZGOUmvFMmq3oJ+a/v7pmyGyPz+8RajlpAGDKcnrxk8noPl6/ewSMnaAQVr+heKY4PhDhjJ+EsuUaNDK8BQoSpw5U1OFKnGSny6Oa+GU95Si5u7k2cvGWb4erWjRwS9llmW4ejleV0o2tDA4KEaVJq2jlWalWm7Xc6ju2cFrd6HaUK23bnjIwSD8uDyQRkHJ6qQD1Brza/uWJKpgk8/e6L8pO0MCxOMccZIHGCWHQ6rdlyxbHHB2sSwBxwGXAOeSM8Lzu2kccJeTYYEciTBx8wAIKgjAwMgN784A4Ga/l/O8W6k5tytdvmu+6TVuqatpfW33r8SzKspym7+adv8Nr9LLW2q/BXoXco+YNgcbASSuWOOTw2doB3E8rkN2ycCYhjyCcLncGB3DggMVzgMoHIJzxk5GRZmnVi4w20kBt2CScBmcqBu5OArHgn5SAMg4iTPIrO77yS6p+78lsKFHIHzMSQxwCCRnklttfnmNrpya731aVrJq7etlfZ2vd9rXPlq9nK/u3avdWdrWaV07Xvo7et3ZjJZVOSDtAIUnIY/MFJIDAsV7KSOM8EnBOa0mPlbkleGC4O0heHDDaCeSNgO84APANLNIJ1cwyNG6vt3AbSCgBKhSoZt2wqrFhlTu7ArRSNo1CvKzbSATJnP8ADuUElsJu4CEk4yu7Iy3z1eSck07x0s1qru1979dP+GPLqwu+ZWVmvv8Adu0veVu2tr3VtCcSsAxUlgVCEg/MWwjNjZkKVGMgsXUYLfKRg3EkblzxuDHG1W+XPdg3OGDcknDdAc00RYppWQkCQq4AJYE9GKBnUIGwOACu0D7+Dhu9w0jMoj2NtXaQVkGwHJyMIuAQRjaS3QY3Hhk7JXeqetkmlqrPS3Rb62dkcjhZ7tOybtbW7Wl7/J9u2410aFZDApwzB3SRm2MDy4DlxsXaAdoUbgCR1NQsd4VJ5BkBGABCASEL5eH2gts2rkZKvwyE4K0922DGWkVvkwVA2FhgkkgL5aspxn7247TwoqlOXIRYZXAEvlyZjEm1WKnaxOCSWXYFQEIpULwSK5nK3vNeVl0u0u9rdXe66smK1W1+u2ySdndvpfrvdvo29pALuyYlVG26wrbnY/u1XcWbBAYJ8rDAboxBHOiJQw3MAgA28gADIAIJUlQ4PzYbGCBkAnnHLt9qtosbmtw0krruYRI0eyMM7Dh2BKgFypAZlRjuNXNwMhUrncpZgdu0sWGfLCMoO1l+VeejcsVCqQmnz2aSbSTWnvJQuk1e1tdLWV2mtBtX5dLdU2tXdrVt7JLW2/buSylChcybcKTIwOFcBkfbwFy7dAwYMAFVduDmvG5e31ImQlWvbUgpvRCptmIO9yMoVI+7828OyjGKe2HzGSWUBSeWfkAYJ2nL5JwwP3vuuVOagiM7LqSlrcRfaLNFIwJDIYHWYscO7FUC+YxBcM2AwYu9E5NShurJ73vdxvrqtEnunbV7K9nK1umjg9W21edNWW2jXbTdd7NeMBgytIHDEthm+cKwLblPybiBgOMLhTtCgk0hB2nr8ysOCQScLjYMEhk3lQCQFJyAVINP2JHlUBHDFmwTkk4fcBg4bG7Zypxx33ZhdPtRdPMLxeXFuDBRzxuiUFSNrBkdyGCq2zgcjOUlHTdydneTadtEkrcydtr6JvtdGi1vbZK7212S21tZvS2j0tpYuxMsSYJbcSXd3ZnbcQu5nBAZtoO4AqMoR1AU1Cb1IR5rK6ozmNW2puYvsHyoVVtjDedxGcqQFyApkKkBtoDEgAHLZVjtDKqjkAjbtRSw4DZPy1hyrIjy26vJ5e8tGrM4O1QrKPvkCMDIQoAQ2SGUlc5yqOCTgt200vSNr6rot1a2lndMqCTb6bOSW9tG101/LV3Vmy+jyzyRuzRN5LsRtQuFjHykSY2oXG3dh1+fcGG05VdBSBM2Gyu04UgqAFYEHJYg5CEjaMo2Q4wxFU7aJY4RnMcjqGYFiTnaioGBxvDbRk5OcAZ6VMtwHVdr4KfKYhjcuChwQu4q2Wyu4gYOXBLEl0+jl8UrNtp73imk77LR2s/S1htJu17pX2ulukm9dtLvT87RteWBhgXRk2uHHzAJxlSvy9cA4UMGxg8E4QZ27kBUFWwoAB3bR94HcQCCfvHGcqxA25h5BwwJIYMg+Y4AwAQ5J+XkkYGGOMYYKKjkJGAYyyOxSRlYjbwrEbXPzKQGO4cjnZlwudFJLdayS3b1bsktFdPzVr+SBLZeiVrarR6dOqT2s9NB+NjJOhYTOyBmVn/eZDg70woEeG+cKNu1R8uOTaZIUbz0yBKX8yIlcwzMpbdGhdh5BRVLKAcEtjgMBTLsAPm2/NhCB5mMuuBlQxIJIYDgOgIHOSGxThdw+ZXVlVAy7IywX5DGCCWVhu3oOgILjacAU0207eSWtnZebeqvo1d7XbVjohKUU4yUZQvdvTRPlaktVff+W/RXastAKOzEBsNkMxC5wF27FA2kBgSAMDOAMYqZSjjIcHYSCVc8DALKdo3DnIPVUG0AYxiM7RiRBiAhg+WBNtM2R5eGY7YnEbGHIyDuGBsyZUOSCmADhmOwgcnknadrblORhQGC5BGAa115tXeyW+jfwv4n0ttdNLtcirCdKaTbknaUXfRxfLZ2b3tbTyS00GXdmLgKd5inRswSDefKwCQT90eWWbOQR2IU4O6a0lL7oZwi3sOTIo2gyKCW+0RE7g8chwzkcBSBkBiRNCAAQWGcdW+YMMIQMnAXLYIwB8oGfmxkmtfPKyxyFLqEH7PIu7B2oxaGQ5VTEdwxkcEHK/NtqlG75kndct72s17tvRrTW1tbScU7GN9k9X87OyWj0dl6bd+i0IV2lckbnCuvUphinCkjZ5akHnlTzjBXbXc+GEAeSdg3y7FJIwp2hfN5ODsXA3OSRgfOeTng7K5MqssyrDdxgrLGV+dtxwXjwGzG0jBSMBcLksMgn13wnol7rF1o/h/T4jNqmuahp+l2cCKS897qt3BbQR5++GLTRoTtPllizqwCtXfgYSqYiCgru6sne/M5RjFadb6W2Wvmefj6iVBx+Hmav2UY2cr3vZLbWyV76ux/VH/wQy8L6R8CfgH+0H+2b40tFjsPCfhrxR41sZ7hABcx+E7C+0Dwlp8TSL8x1PxHfeITaoCwN7pFlIhYAZ/Nv4B6/q2rRftQftR+LLlv+Ej8SWur6FpWqXD7mbxv8aNW1Kx1HUI9x3n+yvBp8c6y7JkwwWiuTGZIzX6cftsalB+x7/wSQ+CP7Pmjyiw8VftBanoE2pRL+6uZvAXhO0kvWedVIPl6vrE8GszZIDS63dooVVDV+PPxw1uP4Tfso/DL4eQSeRrvizRbz4i69ECY5V1Lx8o0bwlDcbWH7zTfh/pV/qUQZfkj8ZPKp4IX95yeMMtxFStNw9nw/lNXESd+enLFTXsaMWtnNVp4ipB3bas7ppI/K/BChDH594oeKU17SEsVV4a4frTjzL2eXuOWUKuHfVVcTUxNaTjZOWDTXwpnO/sg+CNX+Pn7Ruu6/ptnJqGra9rKaL4VtGjMzXGs+KrtdE8O2UakEN5NpsSMIWaDy49o8shX+y/+Ci/xitviX8eLL4ZfDzUYpfhd+yz4buP2fPhde2syx6bqHxKezjk/aG+LMLRTMFMFzFqVlBqqyPHJJNpOoiUzKK5j9iu+uP2Xv2b/ABz+0BYqi/E2/sbH4efA+1bYl4/x1+JNvrlhofiK2MoMPlfC/wCHyeIfH01ySp03X7bwkLgouoqG/OrxxqV5dW+m+BPBDT3+o+JI5NAtbq3imudQudGk1GRvEevROrvcS3/xC8USXcYiRTdy6fZJppZ1urXb40MRGhlqrV1NqVapjcQruEsRi6lTmpRja/NJTkk2+WUPcbXLJn1GWZYs04ojmuLtHJuD6FSGDlUtGnPOsXRi8biU9V/sWDdLD0ajVlLFYqOkoI7n4H/CPVP2s/jboXgLww1rY/DvwglzI+t6oWtPDuj6DotkdU8QeMfElwyKltoui6NZyazqZYtMumxWGmKsl7q/77079q/4r6T8WfE/hT4P/Bmzv7X4MfDSKfwn8NdNeHZqHiI392D4k+IWt2kIO/xb8StaRtRdW8+403RU0jw9bSta6bCF94+LVppv7DPwDT9lDQZIh8ePiXp2iat+0zqtnJEbzwdodw0OveGPgNaXcLO0WpNNNbeI/inIkqrJqaaZ4flRRo10s3jvwm8Ny/CbwZD8a9WOmW/jzxlLfaZ8HU1srHp+grautn4n+M2qRyq/l6H4JUjTvCjyQtDqHiovPAs8fh28tpdMDgMRmuKqUJzcZ4mEMTnWJXL/ALNhockoYaHvckZzXLTUNLycIO3K2etwpQq+I3E8eJMY6sOFMgqVlkkJQ5KeMrQtRxOdqM2lP21ngcn5tHSnUxEHbFrk1NUsPCPwJ+GuuaFrsVtf+Hfhxqmg6v8AGNY7hUi+JPxmeG5vvh58AtNmiKveaD4LkS41/wCIbRMYI7y31ZJZBcaboouvyP8AHPjbxD8RfFmu+NvFWovqPiHxHqdzqmp3cjKA01ySyW9vGcLBZ2qbbW0t4UWGCCKO3iWKOKFB7J+0N8Xrbx3faP4O8J3F8Php4BF9b+H/ALaW+3eKfEGpzrceKfiJ4hHmM8mveKr+NJts0ss2m6La6To/nSfYWnk+aXTo7ZPIbqRlQo54DEEBhliB1BPzfMfneO+JKWNq0smy6cFluX/u26cv3detTtBRg07OhhoXpUnoqs3VxDUZVZI/V86zCGNrQo4a0aFJRjaDbgnBclKjTf8Az5w0HyQentqrr4hpTqyS9T+Dt08HxG8JzqJFaK+neF0wZI5k0y7aORCc/PHIFdWZAQwUnJJK+yfFPQre+fxdFc6nc3fibw1a2fjbR1JaSx1Twf4gijvfFWiwxkNLBeaHJcp4hskd0i+xW3ilW3OtqteD/C6Zrb4ieC5xIu+TXbOAo+SWa6Bt1jYZ53mTyw3BJYsc4Gfuvx5eeDfEWp/D3RtHs7S68d2Xwr1G81ax0+zmg1DWbnw5r3ii51jw9qM5lMOpnxN8LrnU5dLWFY5YJdC0nTgs73wjj8nh2j9fweOoe0pKSUlTozvzV5zjTUYwvLWpGSVSmle84RTbTaPzqeWLM+JK1KlVp08dh8ljjMIptKrVqYfF60qVnbmrU5VKUlaTcZ2hq0z82L1FicSxkMGU7TkFGjk3GME7doG4qN4yVYqQSAwr2zVLh/GHgDRfGMLyPq+jGPwv4mcnlpra3C+HbqY7t5/tPRrOe0LSFmGo6FKysN5DeNapZHTb3UNLMglTTLpobWfKn7bpcg8+wu0GXBS4s3jkQg7QWBJB6ekfBXUbU+IrnwTrNyttoPj6JNBuLqZsQWOpXExl8MatO2QFi03xALF7iXhxplzqcKkC4da8jLJxq4qplVdxhSzCLw3NJ2VHGxlfDTlbSNq6VOpLTlp1Kl3rY9/Bxjil9WnL3MXTUYSekY1dJUpPaycrRb2UZPrtoeHpo9SspYJAPMC8bsklsA5yRhck5OAMtyMbcV7toWqf234Hl8PXrl7zQXlk04sQzC0kdnkt0P3gscocgKCVDKo6fN8/Q2N34X8TXuk6hDLZ3Npez2F7a3A2vBd287W91A6Zyrwzq8eCQCAcAjGfUdMuW03VI7iPiK5XbJgcOsg5xggc8NjJG7IADEmuOLnQr1KFWDhUhKdKpGSd1JSV4tWdrSSTXTr0PkcwwSq8tOcLYjCV1XoytZqdN8s4PW/vRcovupbvZZV1EShUqOMEhudwVhg5+XkjBwBxg4XOa5S8h2k84XBIBPcYwSf6AcjqcjI9C1CFBLIEIMZckY4GGyRwGJwucY9snnFclewcElTySQM5yMAZ7k4wMnGSOT1JO1FTuk27J6ptap2Vl0tZK2n2U7tWO+lKTir2SaTaWmrUb3Vm1orrZt3vdp342RT8r4+YkDCgAnaRhvmPO0YOCB0J+c9NrTGZxsfnA6YIABCADOecjHPQj071poCpbjJJBA4baTzj0IwQOAR9ByEt5jCVBVhg7jt3YIOMDocnknqQV68EY6o03Jrl91PZLouVLpZtNbJ6Po7WOyC5JQknbVSWuiT5VZ9Xurbd20tTrbSEnBCZwPm74PGOwwenT+Lgnaa0UBiYDG454yUzk4BBHJA4wTzkLkdsYdvqZVAscLZ45JGeAMr1753HOc4HHSpf7QmDMShJHBODxnHK5wpB2t1DA/dUYAr28Bz00k07aX19Evzad10t6e/hMZThy79rq/8AdbXfyd7vd+Z2ljIEZBg5BOCAMjdjOcHknPGBzgnjIz6z4U1x7WeOKV8LuUqzHIXgsMkncVOMHaOvXaSM+C22qShgHU4yAHwflOQM8KAOemBySAM9T12n6vtcEg9SN2cnpzjILEcHpg4K85G6vr8szGWGqU6sJWcOWS6P3XFu/S99dLK34fQZfm0KNSMlKzVlduzesW03pfXXq10vqf0Mf8E8/i/HZ6pdeCr+8K2urxJPZLJINiXsKudqsSMmeHcoPRiq9CCT+1Wm30bBfQgYOQucDjdgnOMdRzjJzk7q/jK+E/xb1jwXrGn31hfz21xZ3Ec1rcRviSJ0OQBhg23ACkZ5GQRyK/ou/Zc/a60X4r6dZaJrlzb2Hi6CFFEfmrHBq6qhVpbPcRsudoJkt8ljktGcYA/rbg7ifL+Jssw+EddLM8NSVOVGbtOtCCjyyg2/elFe60leyXe6/rLwu46wOJwlHJ8ViVTxFOX+yuo3yzUnFukm3ZS7XdpLRao/VLSL1HAwx5AXBxkjqAeSfvY5yRjGGY5BqeKtFtta0m/026jWW21CzntZUZAyGO4jdWBHHTcCDgjOD94CuB0PW8sjB8DaMfNyOmQBluuCuN3IOCccj0+G7S7tmAIYlTt5yee5zkjJyTjJ7eldWKwtTB4qFaKaSau9NNV3v2fS/kj9wxCpY3BVKE1GSqQcdbWakkmtdLNNPTprfU/lm/aD8C3Pw6+J2v6VLE0K22pT/Z3I2hoi7vC4bBIDxshVjgE7s5TJr9af+CdXxWTX/DOo+AdWuQ4WAy20Ttk/Z5d6TgDP3EZ1MqqoXbhyFMPPkX/BSD4VNv0n4i2FuAk5OmaqyrnbcRfNbSylezoXjy+SxAXPKgfEf7JfxTl+HPxO0O4Nw0dsb+K3ugX2Kbe5fypAwyCRltwJ4YlgvzEV+WcZZWqWYV6kIqNDGReJou6UYubTav0UailDXXTbVH+WX0s/DeeY8N57Tw1CTx+S1nm2XNRvKSov2loWV37Simmt730vdHv37cvwubwV43uNXt4GitLqaWNioICRysXgfcVwzIGOG+UnYBnbjH65/sR/EBv2rP2FfEHw21Vo9S+InwUlEOkRTkS3F5b6XZfaNAgkVwZJo9X0i01bQJQCEmWzUyElnD+I/tk+BLf4g/DZfEdnCtw8mmLP5qqXyBGJIpkA/wBpRuG7cqOwBVdoPxh/wS7+N8/wP/af0HQNTvjZ+G/iUsfgnWFndltItQuLp38P38hcouINWht7aQuyuLae8iZ0Mp3fBYSrWpVIxpK2Kw1SnjsK9dMXhKkZqLVtVVh7SlKKXvKqk9Ls/wAvvEfCQ4+8JaHEFNe0zXhNN43ki3VlgOVU8ZCS3vShGGNp962FpS6WPzq+Kvg+X4U/F3xV4Sgjkh0q31M6r4cMmA8vhvWP9P0rAOAZLa2kNhcrkmO7tbiJ/nVgP2I/4JWfHdvDfjbUfhvPf+VF4uW113wwHlCrb+NfDMUlzbxRZIVX1vRvtti4XJmuIbOMbisa15n/AMFgP2fl8DePLnx1oVk0NpZ3EesRiOMY/wCER8W37me3PluyiHwn40a/sWYApHDrkILpCkYH5afCP4qav4H8SaB4m0S+ey1fw7q1hrOm3CO2Y73TriK5hIwAQpkiVXQE+ZHuRuGwPfrPDTrSjFf8J+ZYeOJoJxT5aWIgpOnNX1dCrz0pp396ElrfX5nHZXV8UPCOm6c4zzrDYWKpV4O8qGe5TyTw1dTTvGdSpSpVZctpKFVxWup/p+/DnxbZ/EP4faPrMTJMt9psfnoBu8uXy/LmibJJysgdCPmIYZ6cj+ar/gst+zMb7wNr/irSdO8zUPh5dSeJrbyod0lx4P1y4Sz8S2YC7dyaTdtZauFZisNpBfSEANk/e37Ff7ZXhtPhd/wmupw3tv4E8VaRYeLNI1W6jXTNC0e8u8Qa9ol5rerT2ekWi6ZqgeCOaS6WCWJfMSV2YIeM/aC/bG+BP7Suj+L/AAJ8K73TfiJ8StN0DXbH+zfDGr2l34aitta0TUdPNvr3iWWFLK9tru4f7EkOirqVpLdvBbpqcM1xCzfifC3D2d8MccY/B4bBVq+TY6o6aq03GVKNKtarSnK8lFfV1OUKsmko2lJ6I+lxeb4r6R3h/wCGUOF4TxXjnwhmFGNTIPq9enia+KyycsvzzC4jEOl7HD4fMsPQniacqlVJxceW2rP8+P4nwC2vLmHyohghkXaD8rkSAkBgOmCPmOCSc4UgfJXiFE8x2UqvYhETbkcYOd5yTtzkknBAODx+jn7YvgrS/CviDQvFPhiPUD4M+Ivh6PxBpa388N/Lomv6fdz6H438HzX9vGltI/h3xLp1y9hEQbyPwzqPh2e8Zrq6llk/NfXJg0j5Yuc/fbDA9CCcDsRzwRnuGro4qoRw+OxNCStKlVlGzXZp6aPRrW+7WvY/qLgjDY6hhaOHx9JUcXRhGjjKKlGcaOJpNRrU1UheM+SanG6fRuNrM851EbWYj5m+f5THEw27lHIYYxymV9Gbg5rkL0lmYnYBgoSsMIK46nCrkYJC4yWHIBIBz1WpyLlyR/FwTyTggAHPIPGTwDyOMtzx11JktnhT0br6EYA243dFbnjAGWOK/OMVZS207Xs/XTtq773tpun+3Zbh5RjG99k/i6aPS+u2zs+ttdTFnPQZIIXOQkQ3Z5XICtk9Mk53HIHOKoYAJJK9SBmK1K4/d9zESMk445wcEbjVi4ZsnJYHcCB1JHy44Ix8+T7E43FTzWfI7P8ALjGMEfe3Nkphc4yxPBBB59MgZ8aolfVOzs9G+0VqlZbJO268z6jDUlZP3nqm0nJp6RS8t9bXd7XXQrXbTIqyRlZEj+eWPyoEd4xw4SSNY2V12AoQ33gONoqNJ45FUqfMDoWRiFG6MMFO5QWxNGwCyKAMHacBXUtNKx2kBTgBQzAEnbjGQWDMSeRyCegJ3MKoGNWkUq+FacMUXKxh/JIBXLqu58bWUZLAdNwGeGTlGXNduOis7bO3K1q9Lfrtaz9FXjyuL0dk433i7Wtrd7vp31diveJIrCeAATRKwIbO2aPad8Lg7AVcfdzyCcDB5NlPuQldoWWFJtuVMkauciORQXbcpHyklSykOByar3bMYXIzwpJOTg5U8hTzjOR16AKB/EG2yhYoGUEGSzsz1c7tquhwhJwBgKpBOCTn5Tzz6qquWTSkrta20sr6a3tv023td20o1ouNl7SL5nsk0k192t76rppZkxwWTcWCgn5QFKtypUSZCswADEbSOoxgfKWHCgZzjgA57H5QAwJ4OCB0528g4JTjB6HpwCCRjbkYONuMcjPH3hkmmE8k8jjqcngYwMn+Hnqec7s54zad31tfa2zut+zve6XTVre/TFPR9ey76NaK1mtNtQfPyZAbdhW6Z/hJJPzHj7xzgjBJDAEhrZ6YY8DBA5wNp6/xcZPDAnIwADw3dh2wcZUNyW27Rt6AAYXdjknOf7yDhoEjZCsu0gEsASFPH3RuwowDnnjJwcYJV9rb289fhvvbX77rfRmkXtzW+y2tOjimlfultdfeI3JJGVbAIP3BjCkYyNwLeucEdxjlsR+UDleMYHUEhRtLEZ24OVPc8gYGC8KPLRicMTtBPc4G7P3jk7QTzyCMg5OKwjIfazswJDLnAYBdmxTliRjGAOFwQwGSCY1i9b2av81y9H16fkraFq+mvRK12rNWvddVe3zd0n1urtYKw6LgZBYqSu0k4A6+pIG05AGCaFUjIHR+pDYKnIwvy5U4XPyt94nch4JFdZCsgCRzKsrsGlODGrFgB8rEHBCsemVwwwTjM6upK5YbUDMF3EghQq4A4VioOR2+7u54Ipc91H7LS81stLq/npa+q1bRSafyte3RPlve6v5xXbR3eqkEaqCMjhWKswJckHPyZAYMMAYX5iAVG48VEf3m+JtwXONyMFLY6OrDL4BADcn5nGBnmmiTPPzAk7fug/MSoIbkkkchmGMc7gMZKsXGOkZ2qxbAOQSnyliSSWUknAAbOFBLfLOjvdJtu13ur2Wr7W672WumjfMvdST7SW6k/dWl2lK/fqrrq0ngsTypY4CAvuDA4X5QpYhgcrnkBgpz/EpZtUum58t8gBBCrjch5JGwNkH5Ru3AHPzIABXdgd21VKkoyqwwhTO4sMFVUqMK+QCVJOQRTViVVhQOfkZQGfcXU/uyyFwxwScsFBBLDJPQlSStZu9laybTtpqtbJLVLr0fVCaulfW199NuXp2b666LaxXGQdoJO8gHOSqlQAAFJIPQlQBnI+XAAABhCZMMQ23cOuSQgBAbAAx24Izxwaaw5BY7mXADE9BkfN8mOAQpAJ47HNOjCKSoJJ25BZieML8qFuSNx6YLf3ipOK4VvG2q0Saa62eq3a6Xb9Op8rZ8uzb2krP3kmuuj006b/O71RZNpHVdrfI2BtIUlABgHO0HjHIxwMAWUK5CjDNjcVGRgZGd3GORjgE9wMcVAjKVX+FRgEEHnBGcfxMcjvg8gMDwBKnQEYwRuwu4AqwABY7uuNrYOQccHDYOkU/m1d36r3VdtP5K/wB+tljPs9krLqr6Wel935Wd/S9lSoypBGflxwSoYLncNuAfmyABjng5C1NgYHXIwM5yWCheD1wcdvUDPzKWqooDAoCy4OWcElmZQg4zyfl4z1Xp8pIJkDASAAnLLu2YOA2V5Yn5d5YN1GM8g5HNqbi1t0XTXZp6WfZv5PVamDipX301s7rotbJrS17dF6snLMRwVPzBRgdFAByxYjLEqcAdW7jjbKrcKq4JIX5eSQo25bdg9BkE5BH3TkECq6kkfMMMCAOh5BHOSBnLZwQAGPB29RZRtpOT1GAcHdnC9cMBkYBGGIAwc54G8JS0t30vd3Wl9rXs+tnrZJ6K2UkoqytzLovhez9E7romno9NC/E5AGF6Y6A4HzJjjJGRwQMkjjqGrSjIbC5w2AwB9BgADIAB2g4IPQZGCFrFRiq59SCQckHOOmOFyW5OQecADrWlFLtCcYOMEZztJ2nnpg4xkk8Z+7wcdMZRum+sk7eemi0d7aX0fmefWik04301d7W+zre139ltLRX0e6OhtZCCoIywAyPmx/C2cHBOR0yRyTyQCa6exlwU3DbgKWIwBxtwM7jgknOckYJGATiuOt5F4VRwBjuQQQvoRg9+pwxAABya6CyfOMhiAdxHfcCuGOOMAbgSM85I2gYPpUKm1m9NXrb+Wzi1ve3fV/cvDxlH2kW3bRW13eiutO+ttdWmm+h6tod4VZCNwHyr1IDZKcqcYweSDgEchsY5/oS+AX7Un7TX7PH7KmkatZfD/wAGHwj4o+H+seE/DvxA0mGfTvGfgbw54m1m70my1G+W1vrewkv/ABHf6T4j/s57u2upNSsbKG4vPs8FlbXF1/PF4LtbjWNc0XRbQF7vVdTsdNtVUAs1xf3MNrCmMgktJMmM5wCCFJAB/cH9tr4pWOgfD34efAzwzc7NB8PB7mYRlYxPp3gGxh+GfhiF/LC74JbvRfFviQ5yHl8SSTfNI7s/33D6X1TMcVOtWoxwtFezVNr97XnOnGnTldPmhq+ZdV3u0eNjMqiuHs0UqKxMc9xmD4clhJtqhiKGLjVxmMnXja86dLDYKdoKydapSv5/Ndr468Rqh1eztdRTQtQ1WHSjr13E9ro9tq1womSxl1aa3OmQ3wRnuDEboyBA8uHH3ur+KH7V3jXxB4X0r4Vnxj4j1jwtos7X81jreqy32mza1/pEX2rTbJZZLOCyjMl3c6cIP3Kpct5MksTI5zfE3iL4v/s2eDbCS58VT654UgtdJsdM8A6kl7aaL4N+K/j7wXY+Mdc1vS9JvbK702/8Q+EvDut6RZXGp6kJltNYvruws7MxRrMfz51XxhqmvavqOv6tcrdalq11cahdyxRRQI91cSeZIY4IFjghhVmJjhiijiiQqkUaKoU+5WzPGZbCnSeIxMMViEniKFSPLGFGfJOEleUm/aXTUXFSsk27No/Hsz8Mssr51Up43JcsnDKJU5YbE2jWxNLHJe/TcHSTpPDJqMZqrJ8z5UouLZ+tf7Fnxaj+FfxGs/i3/wAIxbeK9e0hX07wtpF9dXlrHNquqRiDVdRsnt4nEs2l+H3vjOryxJbx3K3Er7oVSTtf2qP2jte/aj+NPiv4i6nGbQaxdQ2ekaOtzJewaF4f0uNLDR9Jt7qRI2uFigj3NJ5cbS3EssxjBkOPhjw1rOt6X4Es76SCWz0u0SDRtOntwbZpvEHiCya5v7t54vNN08OjqivBJJDJb74ColSf939afsbfDCf4x/F3wh4TVfMtbm/iudSlYM5i062PmXEjdSBsRlY9GlfGCcGvq5YieIo5TllONquJhzyqOEVK1ecFdtNtq8Ury+zGLSs7P3+DfCfKXxNhc6+oU6nEOOVPAYeu5VpezwbqRVKMaUpOlTs3KfPCClac7yak2/2r/wCCeHwGfwF8O/8AhPdbsxHrHidRLYrLGQ0enL5hiYEjIEx2uW67MA8ECuV/bR+KFlb3tt4XtNQidYZ2e9Eb5UTM0oBlYdCAm44BKb9oyc7fvP4s/FX4XfAnwNLDqXiHRtLTStJSy03S0u7eO6doYljhjtbZWEkjnaoYrHsBIUZGTX8un7Qv7REHi/xNqN/pl08kT3VxO87SEmaSWR2BUkklAMKmflKKp6Pg/oGd5thOHMgjl+FnTVedKNLlUrVJRdvaTcV7zc5N3bei6ao/rjxS+pcM8C0+E8sxNKGIxGGVPE+znH21pcntZyS1TqTct94pqzVrfpN4P/bg0z4N+Gf7G0nTrW7m3PLLdGUKzuEZQrj77ICBjoxXKhuSW+cPip/wUx+JevNdRWOtyaXbyF1SCzfyliHJHzkqWOAMD5toXBL5r8i/EPxG1G+kZI55WODgByQCPm5OMHI564AySCc485uL7UdQYeY8gDEjklh6EY3cgZIGT3PQYA/G8XxjmM48tKvKmopKNvdbjaKsnfZWS372XV/510vAvgt5niM2xmW0sbjsRXlXr1cSvbOVSbjKTtJtbtWXK0k7XufWHxF/ab8Y+Orma41fXtQvpXLKGubyWVQCWwVVnC4AyAApGzsDnHzZqniXUtTaR3nkbJO5ssQQSc5AycDPJO7JA9jWRBpzEgytJIWIIAB5JPQE5+mRyeuDgV3OkeE5L4Z8hguM/LGxYjrkFgNoHckHjHG7lvnqmOxmPk+adWrKSs3rK3w73d1fZeVn2Z+g4PIOHuHqEFSoYfDUqdlGMIQhFWS2St8O3z03R5ZOsshLkFmJLAnJORgEEYbIPbdjOO4ArMltbk5JZlUjBA3AH5QflwQBg47Zye3Ar6HPgOcLtW0k3feYlCBt5PRlC88Ag9vlXBxnLn8C3wbK2cpBJ5K8Egn5QSByO/UHp0FYfUcQ/e9lOUtJapu6fLsnout2lve9j1qPEuXQhyUq9GEVZJKpGN2uW7bVk7W6t79VqfPjWc6nnIUHJz1TLYG7Odp4HGSQeM5YZhNnID9zB+Xk9MkDk53Hr/EAN3GeTz7yfAGpMNwsphkchYyVUDtgKAV5GMncGJOTUL/D3UQMCznzwQTGVwPmHQL6DnGfbk5D+qYm9vYT0td8jtry9Ul1ez+dtDpp8T5e3f61R3V71abbd1vr+PW3Wyt4Z9jc4IAHTCkcq2RjPyk5GeQeg4OCu4TJp0nJ4I67c5x0wTtIBJ6ks3U8fKa9kPgHUDn/AESX5cE5Q8nd1GCDyQAT/DkDB6GeDwLqKjH2SdhxnMTnnIAGANoB4I5AGVPBqFhMQ1pSlZWWkdlZWtZX8ttLPzPWw/FOXwkl9cpXslrVgrax7uz/ADto7aHjQ0hiysFAPykcAAbtvIwe/APGd3AwwxXc+ENPJ1a0SX7pnjwW4HqckgAgkEA5HJPIJJr1Sx+Gup3uxBY3BzwjLDI2Bn+8FJKrgdFGOgA4J9o8Gfsn/FTx3II/A/hXXNf1C0h+0Na6Tp891KsQAIZwmCowGC7j1X7u8gH3MrwuKpVadRYepU5JQbgou8kmm1t2s+/6/S4HxN4eyh06uYZrg6FCDg6lStiKVKlH4U5SlKfLG+17rrfex9x+A/HWg+BPhlb2VnJElwbctcMCEYERnLP0bhgcDqOEYtya/Nv4qeLrnxv4tvtWdy8CytDaozZAhQ8MuD1YDpxnI+ldf4x0z4l+Cornwt4v0nV9DvbZRBNZ6vZXNhexKOWR4541k2ncOQGxncezV5BbwYYyyDEcY3tnkcMSBjAALbhkDaMnAzg1+hcTcY4nPMPgcrp0J4fDYaMFOk/dvOEYx1W1o6yd9036H7RjvELA5/lGCo5PXhVwVSEKjqUakKlOtLRQUJwlKM4e9zJpu7aVrakXmC1gEYJV5lwwP3gNuWGB1JK7SGzkKRyoxX9HP/BGb4D2HgTwX8Qv2z/HOnQ3Fv4TsrzR/AMF0pRbnWZA1msFqSrZutQv5FhmlgD/AGCxsmgkMkmrzC1/nBtYbjUdUghgWSV5pkihiiieeQvI4GFhi3u5RC0jKisVVSwXgEfol4k/b0+IXg79mHRP2dvDWo21n4csL/XNN8L3ljbJpuoz6VdxPFrOr62gtomudS/tC81hNNvEmD2r3ks4eWRIpF+04Njgv7PxNKvi6eD9tClSr1ZqTqSy+Uoyx9LDcsW1icTRj9UhJuCgsRKopc8Ip/q/hDnnDnDuKxOPzypOOIjhaksDThT53VxD5PaUU18FWtRU6FObt7F1Paptwijzr9s/4133x1+O/inWf7ROp6XpeqanY2N1u3w6hqE97Jca3qyAAKY7u+3w2excLptrp8SghFz9AfsAfBO+8Z/EGLxU9i11b+FJrKLRU8nzhc+M9VEw0uWOInEq+HbKC/8AETqRiO607S0fm7jVvzb8E21xrmpWdpbQyXV1c3EVtbQQqZZ7i5kkWKGOONQWkmlkdVRVBZmMaJguK/uH/wCCM37GNvpyaNrev6dHJpXgGGHUdTkaINb6v431Vre5v3Eh+S4jsZ7Kx0+CRcJ/Zvh6wkCFdXm3/quN4py7hfhvPOPMxjCOGy3Dv6jhnaKqYhxVHL8DQirJXqezhHlSjC3NZK7X7BwfjcPjs1zzxE4iSqZZw9GecVqc2uXEY6c+TKcspJ3T9piPZRjGyioU25Wjdn7yfsj/AAasvgF8CPDHhqaCO11eTT11vxNISAx1O8t45ZIZZTjzBp9skNirsRuFqZCQWJP8uX/Bbv8AbFbVI/EGgaFqZSbxrNe+B9BSGc77XwPo7ofFeqxlCNn9v3ckGkRyAfvrO9vY1Ym3OP6Z/wBtz4yx/CT4O6ja6fcpD4l8Y/8AFN6EnnCN4vtalNQvcgqyR2lmz5l6RyyREnB5/wA3v9tz46/8Lg+M/irXLC+a68NaKw8KeEzuYxSaJosk0b6ki5Codc1J7/WHIxhL6FHJ8pBX4D9HDI8Rm+b8S+L/ABJH2uJxeLxccvq1kmqmJrVVWxdaldNRjGfJQpONlGNGvSWmh4XD2JxlTA8R+IGayvnPF2NxmCy+dT4qeFqVFVzXFUbr3afvU8BRlC3KlWgtFY+JfFWrF5pgDwxcc9AMfKo54XgAlezY5OBXgeu3yuXGc8HHQDPruJGQegwOO4BwT2XiXUAzurPzjnkgjJBC7sHAzwcHOQCBkc+Parek5yQR2JJBxkYweXI68nnJwwOQa+o46z6ePxuIqTqObdSTd2mruSXktL2Vum66nwOc4znfs4tuKX3STi9bXV7pprXTe2lsHUrkEsCQSDjjJ4BBYNkjJzu5bgDkqTwONuZfMZsMwZBuUgAh1UxcOudxRgrDK4Hy7flwBWpeXDMXbqTjIHOM4O0jJwQMYxywzgkDFcpeXCDcjN5bbwysN2MZTaxwASP7yZUkZYd6/DczxLfPdp72k3botNW9bcuitsfDYurdtt2b1d21/Kndu1n1StbS+m7p3Ezvt8qPLLL8wkXYvlKVBOwspkBXaVO8FQRgOQA2ddSPtZVKqShwWG5duDkkDIzgYBxkEq2QvIleSVydygLtZAAcksGQLkOSUQncRtBHBxlhkZ87ZR3XLOB8q9ckAnkNheDxkHgHbycV8ZiaqfO297Xb0Wy26p6LVW2smjxKr1b1u0ndJPSys0tb/ftp5lZXfexdhJGw2ptjEZjl5RlIyN7NtHUdTkMTkVBIA8qsCQVycZYBsEEq3Kg5+UZOQThT0FIZcFSqkYRDlVUhXPy7GOcYUkthixAO/OC1MJYk9pFOG4UhR8oYjBZmG4jowDDJPXI8qc01a6tq9W7p6NX62u9NnZa7HJUaa6aJN36N8rS3d03ZW00172Qs6ht27qCmzBZgTGvIz8wIKlmA6ja2AN9RecmQQw3Y2kHIO44IRkIBVyHwwJGOVJwvDgxjdG3sCG2ofuqScAMzFSoAIyUyQeBjgZgAkxsZmkc7nZyDzJkqzEjcrgklVUpnoMlgCeObd2lslq9e0f1fbay6nHLrfW2l/L3Xrrrv0tr5Njyx2EBcSKPmU7DgnaSRjcSgGMHkgAYG1iaz5ZJrieGwsEE19cL8qk5+z42M08rGMFfLXknI2YO7d8oKzTO00Vnbxyz3s5MMUKfOcvtQO4kHG07iSCB5YO8jatbyW0GgWr2qMtxqlxn7bfgSHAZSwsraQkHykZQWICrMwDOExGF5pSc5ezTtFaTnu+nux1Vptdelr72REpezUbrnqTbdOnZ2fTnl2gtP8TSUbXdqTW0Omp9it5ftBJD3V0MO1xOfkO3kMYF5McTISFy3DMTVZmYEruKkOoLKuRgFcBiqZDNgEMCRnnCsMhhQSuksu2QoQ65LEIyKSwRAAR8pGdxYggZBAGYp5vs6giCabzJAkaJud2lYKY48EMeTtB27jyNgPKmbpatckIqK0bb1tba929XfW783ccYPRNtylaUna122tU+mm3TbRacqySTGSG2gjklu7lkjto0wWZyVxjjKk4IZ/uqMBiHyVsrDLYRy2xfzJHKzXkivvi8+NPLEMR/dhltyTtlVpFcsWDOoDmnKktiCm5H1Fk/fzwsSLZNob7BEyMgVkIJmkDfM4CANGD5iwTOYEJUhyoJU5IUsAMvyTh2O75lwAwXJX5glLmlra6StpZJe6tUlq2nrrsnvqHK2ovT2d0ndK8pJx95LblT1V1q/e6CO8iIQrtIgIG4D5lDBSclmIPyqQQOFzkdqjzI6M0TgFgTGzYYMSFLfKBkZGAy5wWGVYryRlOR5eTmQOQS64BzuZMKVK5IwAnXhQ2Th43xlnCo5UYZ2Gw4DKCQGUJtwWK4Dc5PAOWm/XVaJKz1+yrq12/XXu3HW9Xs0la7tbtst9Xt0s3um7Ju8aIu5XZiCq9y3lk78/OjHI6jO35ANqDOCTRfypLlVfAiU7ncAHCKAMDJAC7lAAyCc4ABPM1zOqny4m3Z+XgAhS2MqjDALbgc4yMnK+0MUbHLsQArAsNwDOxMbbACGIU5I3Y2+meCM3NNqNkr8rd9Xe3Xe2i12/Gxok2ua2miatZ9Fq9O9+l9XvYuF8NgEhgQABztA3ckAleDt6EYHIAbkNUR5eRVUO7YMoBLuvyghm+UkkhSoP1YAEYSbzDhY1+TAYgqCWIKAIMbW5ONxBY8k5UcVHEytIxC/dQfNlijHChmjLDkquV2jICudxIO2tea8oqy0au21qkumv8rad9HZfPRKT5bt3T3u27KS6df+3bX0tZ2LSMzLkZG5dih0RipAB5OclS24oTkkbj1BNRtJIIlLqCQY0ZUKH5WKkMu4k7/vZUnCtnjPIijZ8Ok6pGPNAi8sgmXBCIzDJYEBTuVR8+eACMGyqgSYUEEoRuDNwzHLBQAFJ+bO3jAwB1xTu5W1aVlfyel2007Xd7PrfZjtGLStf4dW73fLC2921q3ZWvfVWQyUeY20liVVZFKvs2NjCkbVUuuccbjvbOMDmpF3lcbty4DMQm3LEYy/U7mDAu6AEHkDO7bFnfIdyneGAIJTHlkDaVBYkBud4A24JJGcYnVCwIYALu3ZyGQkYwoLHbtP3ioyOFAyw5m922ra2V73eyXbR7WT11a23UruKu09HK7vZfDdW80rPXSWqaV2J9pltzGWjZ4XZUkChJPMB2ho5Fwrom1pCZCS6jBOWJxpExoVlU5s3JEbEqXt5QATazbnfBUIcEE5UFlJw1Uh86hkLY+7wdxGQcsRjd1JALZAI5APS7Gw/egqXhkGJo33YlQgkbclFWQFgVZQGUkHA5raDvdOVrtNaXSd0m73Saa3vq90+xGrFr2U0+RtLnd3yN8utu1l7yS7K2xZhOQhK43FQNuOAdpGSowwABON3T5hnitGEk5JUhyAOcYYEIOdwUFScndwSSRkcE5ibEZYlLyQiQeVK5yCNxAt5suwEqAMSxGTkFck5XUgXeM7jsAHJJ5b5eo27iDyAA2DwR0NdFPVq60i9d9G7WvpZ37X301WhlOMqbUW1orpu7TT5fS67NfilrrWdilze27kFmjbLFcDManJQquQV+7sLDGOfQN+o3/BMX4D6h8dP2t/h5oMVsZbTw9cwaxNJ5TSRQ6re3ttoWgu+Q0e6z1HUk1VS5DrHpUrYIjYD82fC9v5szTfNtBSI538hcM5Gdo6ALnOVxggZxX9Xf8AwQt+G2kfCz4c/Gf9rfxjbxQaT4N8G+NPHkc8+FQ6X4K0zUNJ0fDHBUXupXfip7Qqcfa9Os5UDFcH7bhLAQxOPhXq/wALDRliql1a7pcvso7rSdWUU115rJp2a/NfE3Oq2S8H8T5nhuZ4jBZRXjhVBXnLHY108FgYQT+Kc8ViaMYq13Juy0PD/wDgrn4vj/aL/wCCh3g39nXwfdoPBvwU0nwl8IdPijbdYaXJCsVz4ku5iilI10qzVzdSsWUR6YFlwsT7fyh/aP8AE1t8Yf2idP8ADenxyJ4dgu7ZbWwhRppdP8MaRawaZ4a0qOBTueS08J6Zo1hawZLi8uzAjkzsF+kPhD4g1Xxb4o/aW/ao8WTO2p6vFrdraahM37xPFXxg1S/tNQmjZiCkmm+DE8YXMbDJgRIGzgqa+LfghHrHiT4jeK/iBYw6hNqzz6ivh2TTrGXU76zuLdH1S8120sEYfaJfCWjWS39jHI8VouuS6Gl9c2lmZZY/uMbWqUMnw+Hgn7bijM5V6kuV80cpyxwhSsrK0ZzhKWr5Xd36H1nCXDn+pfhhwZwyrQxWJwlLMMfPX95X0pOtJys+apjamOxEpXu+e9tEn9b/ALQnxEis/D3hP4f6fqUWn6T4C0zXbBprGVZ4rbxTrz2cHxy8c2xQPFdXVlb2Hh74F+DriMst7Z+FLm500rcXspPtf7IXgi1/Zy+GOqf8FCPjD4ftD4t1C6ufD37IngLX7eOS0vfFegWsFjH4/wBQ024+abwP8HLJrWeyEsJt/EXj5LKMNcxaNfgRfsK/sXX/AO198UvF3jv4rP8A8IB+yh+z3FF4g+L/AIxhuln0oaX4ahlfRPh54Q1uQ/Z9bv7ayhnin1bT2uILvxFqGq+JVOoNNo9ze8h+178dfEf7Zvx503wv8MvDR0nwFo76T8M/gr8NNAhddP8ADngvTJU03wt4b062TKpLcKRqmuX0g8y+1O7vLy7mKgEcqnPE1Y11SdSEJQoZbh373tsW1GKrci+JU+bnTs3/AA072TXxGd4r/WLPMJ4VcLSqulD2WM4xx2GveGGxFT2ry9VY2axuc1nUVVK8qOE9reUJ1KUl4d8NfDd38bfHPjT4s/FPW9Yl8G+Hbi98bfE3xhezCfWdVk1bUDJDZWtxdYS88Z+O9WkGlaHbNvWBprnU7uNdL0rUpofmz9qL9onVfiZ4rv4LYW2j6ZDaWWjaZ4e0mSRNJ8M+FdFi+zaF4P0hCBIdP0u2Cm6nl/e6nqMt9quoF9RupJW92/am+J2gfC/wjpn7PPw41Oz1PTvDGoS6j408SaWQbXxx8RRC1jqWtRTpl7rw14Uiafw14LVm2SxHWvEKpHNr8iR/ljqUlzPJJeCRmuxI8zMzMTcFgS+csM7gDtAJL4+YBsVw8SZ5/YeBnw9gqjnjsRP2+d4yE789eTt9VjJauFJScZK75pub1XIl+5VYYXJsvw/DuVezp4bCRpxxjwySpVMTTioxw9PksnQwkW6cbe7Kpzz1TVtUTDLbiMnC7Q2TwynheNyhQNpOMDJZSKaspUfKGJBGQCw7rjgZGN2R8pzk4xjK1j2t4k6SEHEqqRNGcHy2G0EbAdzKSDg4BwACQTVyGdmIBGMDnI6upGQRldrMeABjI5XIwR+Yxlzu7d+bV3XMr2Supb+b3avrbrxYeSi4p3a3ukr/AGbWW+ttktHppfToNI1w6Brnh7W0hinbR9c0nU3glJEEwtL22uGim8s7xBIkZSRVcHyyxU4JB+s/itfeJPhr8V/g58SovC0vhRdU8H/Dr4j+FNPurltQs9QsLO4fFzbXDkifRtbltLlVs5GZLWC5l0ySNFhIf4sm/eRsuPvDG4kMDggBwDtBA5BI3ccYxkV9F/EL4o3nxS+H/wAHLS9hma9+FvguLwILqW6kuc2+n397PDBbhwwsrZbWS0uI7VHeL7a97dDD3bqndgMbWwNaFWlNxlSr0MRBR/mpVISkm1uuW7VrLRddV4GPo4/BcX8L53gKcXQpVMZhczqyq8sqWHnhvrGHnCN+WbWMoUadmpOKquzSTT7X9rn4U2Hw8+JmqXPhFHfwHr2naL46+H8w3SpP8LfiDZQ+IfCUQmJXz5PC6Xt14QvpMEpfeHruF8SRPj5EeSSCeOVXKLv2I8ZIKo7bkkDLjGGwVYOxVtojOeK/WSDTovj5+w3ZeLo4xeeMv2UtXTwh4ngTEl3e/An4qavPfaTqDgHzXt/AfxHk1KzBwVt7bxuA0kcEAUfllqmkS6feXulz/NJZysscnQS2u1mhmBBO4bSpLAbckZwTkfQcY5Z/Z2YUcwwOmCzajRzPByj8NNV1GcqKktOahUU6e9+am+bdn1/EWXrLc3c8LFQy/MqNLNcrkrtQw2MfPKgmrXeDxKrYeT6unskfQ3xFuv8AhMdF8JfFa32vd+JbSTT/ABZswHi8b+HUt7HWZZlTASTX7FtJ8TKzYMlxql4Bh45BUWjXI1DTLeXI82JQJAG9ME7jjIyNp+bAAIBAY843wauv7etPEXwuvJEz4pji1Dw4JDjyfG2hxXU2lwp0w3iLT3v/AA4EGBcX17pbSNi3TDPDUradcz2bhgrEACQ7WJ4UAgnIKbXBU/MCMHnp5+b/AO1fU87hFWx9PlxXL9jMKChTxCbVlespQxK0a/fOP2dPnM8p886GYU0msUuapa1o4mCjGum1d/vE1WVtLz5Y6xud66bkTd87Y65OcAKCCC3OD6qMAkkMoqjcWLOpwgJ6MB2I2gZwegPOeefmwVrZtEMqlU+Yg5YDJHOOcAYAwDjaSSeBnv7x8Kfg94n+I2s2uh6BoV9rN7dukUdvZWs1zI5cgZCRoxAUsuWwQqkkg4IqsFh6uLnGnQhKc5tW5YtuzS3W2jeunfWyPkM1z/AZJhauNx2Jo4bDUISnWq1ZqEYRhZybcmoqKTdntotbnyz/AGQ7YDR88lsjqSVwMEjGMcYyT2I5FOXw9MybhFjOAMqTxlfocsAeTkjIHzEgV+nnjf8AYF+NXw/hN94j8Dapp9nBB9oluZYfNgVMIViaSDzFWdiGxE37wbGOzndXzVqXw01azd4ZdOnj2nPzIwOcKdoITJHtnr1yxXPvPJcfhuX2+HnTelrxeqtHXW176tW0vp3PHyPxE4bz+j7bKs4wONpJ25qOIpVEtnZuMmk7J6PZebs/mCHRJ48AD5QTgbenbORggcZyN2Bk4zVlNGmYEMgIyMArkkcYBJwBnucYyR0Ne+HwJqYCkWU/KkDMTk8MeoxuHB/ukjaBgEZqB/BWpDraOoG0HMZXjjgNhiwYDKgqN2SXK10Qw9eP/LtrZ6QaV9Nkr6btevU+mo55hZ25cTQ6NWqQ6cq0s1Ztu1nqru2h4mNGnIQFQjBd24rwQcEZIOTuyQDhT0BwRxoQ6Tcja2CRwMBCewG75iCPfjgg5O7Kt7DH4Qv42Ja3LZ+8rIVyTyAPlBII4zkZ/vHGToJ4Uu8oWt8YGD8pHpgc5wRjcSVIx6A1206dZr4ZpJLaLV9uq+/dfNpnZHN6N1avDvdVEtGktbN2fd7delzyK3s723IZA7N3I4x0PzAYPQrz1G3IGMV7T8PfiJrvhHULO7trq4tJ7aeOaKWORopFaNg6yRyIV2MCQSwwpYZbBUsJIvDc6hVa3IKksSIwCwHQjPT6jG7kYPQbdp4TS7XbLbPnlQwBGDuGQpQE8cde2SSrE593Kcxx2V4mjiMHVqUa1OcZRlFtP3WtFbTtbd7abnt5dxXPLa1OtSxXLyOMly1Endcuqa2s9n02VmrH78fsj/tg6d8RtMsfDviu+ht/FEEKQwXkrLGmspGu0hzlQl6AhWRSSJshlG4sD+m+i+JYJEXZKOV+9kEYIAxxyD1JB6YyC2MH+PPSD4m+H19b6ppMlwEgkWYGIujRtGR5ZDAq6MvDKwKndgHAVcfrx+zV+2rpfiqPT/DHi7VotI8SII7a2ur2dLez1Z1BWOGSaU7Le9c4RFkZVmY5VizAH+ouEuOMu4qpU8vzipTwGcWjThUquNOjjJWSThUlZRqybV4tpSeqerR/Xfhr415fm9OhlebY2jTxaUadDFVKkVCvpFKEpt2jU6JtpS0XxM/VX46+DrP4m/DnxL4YljSSS8sZpLHOGMWoQq0tq67sDDSIEOOeecCv5ldUgvvBvjK6tbkPbT2d9JbTqQVkingl8s784KsjLkZJBwGB+XC/0iaV8RYZUSC+8yNiBsZg+TuztYEgEoyj74+VhyMAgn8a/wBu3wFpWk+P5vFXh9rc2XiNTfTJHIgNrqUexb2KSMANGJXMc65UfPI2MnOO/jnIaqyVYhQ/eZdNSVSNv3lCbSlC9ukuWcbb3bTadz0fFzJsNnWVLMKcI1F7OWFxS3VSjVj7sm17soJtxTvqpLWyuv2G/Zk8W23xw/Z9ttOupY7i+06yk0u4DkPJ50ETJGWO8krJFtDDnOODX4z/ALQHg7WPhD8SdU+zG4sbvTNU/tzSLiNXSVFSbzd8DrlkeJxHPG8ald8eSEY7q90/4Jn/AB2/4RXx63gXWboLpfieM2YWX5kh1CIO1tIVY+X+9DbCAAT8xDKeR9lf8FDfgymv+G/+E70i18y70dGnuBEoZn0+dSHXIGJEjy4RjnCbUcFtpr+csXOVHFU61NOD5lOMt93G6vslo3Z3Vlqj/EOnlcfDrxX4n4CzqnF8PcTVK88vp1lahOhjuZxpcr93lUpzoSSt7qj31+b/ANo7/goNo37Rfhn4T6T4/wDBcllPZ+Dm0fxnql3crbnxn4b8SWiaB4vuNIVdNtxLY6fqNkviPSIjqVzJp/iC21W3Mk+2GK2/Dzxwmo/DTxp4k8I3k6S3XhzWLnT/ALRCAsWoW0bBtP1CALuzbapYSW9/CVf54LiNt7Bsn2+y/tTxN4Z8W+Dy8MifDm0vfHWi3T2T3eo/2HcajZ2Hifw4l1HL5sGmTG9tPEdqpgltrS7h1mQm3k1W6M/yx8aNcTVtY8M6izu2pv4M0vStYdnaQzXnhu81Dw9ZztK5JuC+h6bpAaQ4LNG3Gcs05lmM45dR9jClGFH95h5wTioRqVZLEUHu3y1GqkdlZyaS5rH7hwz4O8PcJ5R9XyShKjl1dU68adapOq5zcuWtedSUm5RqT01TdOUItPlTX1c/x88T+Kfgp4a0K48Z+JP7N8B61J4b/wCERfWbuXQI/DXiW7bWbGd7IXghtriPXl1K0tpGthBiZIdxmlAl9i/Y+/aNi+CXxy8LeIvEeoHw74dg1zTLXxPeX0NzLZyeH5NR066aa3WBAuoSW7QxX9rBbvIZ7eCYoHVct+Vngj4h3nw/8T2PiFNO0XxFa2dxbT33hrxRp66v4a1mK0uIrqO01bSppYoL2JJ40lTzATDIoeMcsG9b+Peq/Ee58Y2eufEXV49fu/EXhTwvrGi6/ZyKdIvvDN14X0V/DlppEMNrZW1nZ6Lo09ppIsbaygSya3Nv8wUyPxYTPZxhDNY+2lWwdahSxtKNO9BUZyUFUqVFJpRqq8La2d0370b/AH3C/CGA4bzLLOKMgwlLAYnKcxwmKxrwmHhSjKt7VS+sVJwSTeJcXCpzK8puXNfmufZv/BRfxRfXEHivwx4c8D3vh/4b+F/2j/iLKb3xCLA+I9E8S+ING0e9tfDMNnZAQaD4b1zQLWDxHpcWZ5ddlt5tQu5VubaSBPxb1W63FySfvYUYx8uRzg5zjjkE9cnIwa/bz4o3X/C1P2YptduXF9e/Ez9l/UfEdzNJl5T8XP2OfGdjFeasHAJ/tLUvgdrd1bXsxDTXMT3Dys3lrj8I765DlmVRtIBbGMkHoQuBkNnOfXIwRkV8x4h0/quezkqs6tHF4ehjMPUkkn7DEQjUopKPelKEm3d3lZvVs9rOuHqOU8YcRYejTXsK+NpZxhJ8vJ7bBZ1Qo5nhasoq6i+XESpOMbRi6TStZ25++mI4B3FuQOB2GflycHAHIyOf7pJrlbmV1ycYHAyQQdvHQEnOOozgAk5OCANy8lHOFPIz155KtzjOMk8NkkHGem08vPKoDFjx1ORwNwQkEDIBHBHXJxggDFflWJldtXut/PTlV9Ourvqrve+p6+GpKKjdW2sna/2eqXk+10lprYo3DMSoOGJBBHIA+6ewYdB0Pcggnk1mtlScMzFg2AxBXAC4WOOM/eOApIB453EHAuszMGK8YXGOevHVcKQuNoHJB4xt6GhMGYMoYrkPz8u4DAbCrt+XAxuOSw5wASSPGqycXprrpbf7KV7adWm/W1z2aMbLZdNd1ZqNk3+G+71tpenLex5hRMb5WCgvsCEhkAQ5dWBYEMhPqGHOKrvyqZBXFwgUElSFKHI+6MgY6cAg5OHBBnnhjki2OSVypBBZSGj4VgQS2c7Q5Y5IbORjiCU8grgkzwFiW5DMkiEY3OcYULwAdwLZywrgk3Zptpvl0v0vFR20fSyT3fdHXZqzXVxvfV3927T1/lT0bVtNLBOw8qTcpI2MEBBBICg7gTnOSuckAgfeG7Ga9vK5jtwUC7LK1XeVADKd4B3ZP+6p+VSNpOMck0mBJHIpBOQrgADBUgFcsSWJ3nP3SARtBAJbZn93bsrEhbS34JOWO5yWAwDgHgSHIBJUg7cGOa9SDT3j7z81yq3TfRadbdbFPWpDt7yve3Ra/ds9lazu7kzKfmVeMjPO51JJyAq7gPmAwACMEY6VEjLkHcRgbdxAUOxKlgACHyOBycepPZz7VBYlipY5OCSC23KjcQpGcbsgDALKADhot7bBn5icdApBK7cYIDBgBy27HA3fLxjTz2vbt5PfR63b1Xy79PL02+HfRKzur3069tb2I2MwJGNyhgMbWUsCAQS24YO3rtyACGIb7ococ7SflIUfIdpGCFK5YnkEYAUYyMEepgj8wJ87IzGTOEA2qnyssa4wS2OTwCPXAwZFkUEZB5G0glQVZtuC/wA2c5O/Iw23HHpCltbrvdpWslt1j2vu11vs00tXr0101TXVbX8tfJX0cCzAjkHBUqCdpU+Xu24+ZuTjJ+5jOPRRFhQ+TtJyMMeGG0cgDII4BJABJyDwNod2QQ+DgEkDPyrgAb+cuc9c9MBuADUbMzKyqWQjLFsE5ZdhI4YlQcbWDZORznglO6avbTp9zW7e2223Vo0TUUrrWytfdvS+m19eqV09FYsCRGXnKEBUGWG/GBtw3LEt0UHGQOWyAaVF3L86gZA3E5YlCB75JyT0AJbdkDAJq4lb+8Fb5hgksdpGF+ZTtBy3yE7QCFJBw1WF8w7SzALtBwvQH5Tt3HDg/LhsgsmcYClcpPaze+2js1Z669Orsna9k9hxd+7W6v1elrtdLWbdr7W7pw2As/LKSC5bJYE4J5IwufvHOfTO4VWk8tgg8szMGVlCsQFQsgyGDDCls4LRneRgBdpJV4yFkClmiZi6r83yg7iw3EkhWYLtbGVCoe5w7ZGypkuFXY3EhV1UEHaAMLtJwMKVbjJIBwM5NtdnorNre636PTZbt+V7tuVtN9L2VlZ8uuzdvVW663EM6Rb8/eIEmFBwVPLKGZigXkEkna2JCo3FckOZXBGFViMyM4VUZvLJjUA9MZLAdMgqxGVDig7qpYh0UBOTFyVVicjLY4kJAJOdxJUFUZl2hcKq7VYyCPDEGPckcajJK8gnK5AOGySBE7xvzNctnyq/XSz1eqW2ltNXYn3nZPRat921bW9+9/k9LaEJzygGGO0qD907tpySwxyMjggHGcA0oQbFQHkFSWAxkYXIyoJ4IAX5scEHIzUKs7DeEKvkB0PykDg8MSTjvu28fxZBBEq5DO24kOCzKQxCso42ndnaQBkjLYYkcBa54qOiaVtopdF7mtnbVWWl79ElqfLtNeqSvZN7ctl56aq+lvvHxsVfa+QOoYjO7aBgYYnPA5YDDAAMDjmYADA6kkMpycAYBA5wDk4HZcDoves7biAoGFxkgHodhIAwCGxgcEHJyc44lDhCN7EdCOC5524PTklie5BI+7kYrSMtWk00mtdbb36u9+ZaPV3+Vsmtmr3e8b67rXdav56X3RaUsfmCtkkH5hjcQFzxnPQgEZzzxuycuViGwwwGyQPYhcEhQx28AsAwJxkcmq6lQCNxAY88FlUHB3r0VWHzfMdy7m4AHFOTaOBnGP4n3Zzt+8SNpDEr2APRCp4BHm6p27pre0ddtb9bO/3Iz5V56bLle+mt0/LX52tdMtAqOpGQMspyHwQPUEjOThucDCttOSHphSq5OAARnHTIwFckgjtyMAbfQmqsZXO9Ywv3ctzk9AWyGzjnGTg4wrDJq0pJDYXGDgg4ztJUbs9SuARnnGCCAQK3pt7tdOVPbS6avfW+n37rq8pxVmrba9Frp66vpvr5llJEG1mbYBzuAzluCM5IJIwQBwCAAcnrbiYk5YrjG4DGORggknPGFJIwAD9ABkmQ+bCm3dG7lTICpKtwVXkjhiM9SccgHGK0I8jpkgfKATnkYbtzkkAAgEgHux4tO8ml0aXXS6Wvn57emxyVafKk2vi2e70dlr8Sd+97Lsm09uCRvkJZQflzwAOVVRknOWH8S9eTnJJretZS2ACAygKCQCOMdMsOhAzycgdjzXKRO+/aoBA+YDkgDK4HJH8WOuBnpk8HZtmYODuOSvG3puOMDjoc8cM3H3Tkc9+HqONk3qtk0kuVWSv0eyu3d669GeTWp3upLzSte3w2e2jto93q9O/0x+zbNAfjr8HUvPL+zL8SfBksyvt8t0h12ymZWBAyCYsYOeTjO5ia+mPFHie4+JPxQ8JQatP5ttd6poHh2Yh94Fte+IFFzkkqCXkv5ppT1Z5XJJUivg3wJ4jfw5408K6/yp0TxFoupgkkErZahbXD4bcOqI20j5hjaAW+WvoiPU5NK8WG/gJaXR/EUWoQbcH5LPULe5gwQAMfuojuBAccr8mK+synMOSnSwkmlSqZhh5142+KCdO65nb3V71187dV62Gp0ZYXKKFaMXSoZ48VUTtqqlLD0U9ukFWjbT3W9NWfVX7ffie6k8XeKfDi3bmz0f4+fGF1spI4kmiWa60WzsCzIfMa2t9NsIrO3V0WMJA6xKgU7vzzt55HKiPdlWXJx15TB3A5UbuhxtOcAljg/ql/wUC+ENzqviu8+Jmg28dzpnxE0bQvjRosql1XUNB8Q6ZBYeIBp4L7b240vWrW7utQESKbW2mjlkYjKj8p7aIo6nlguDwAAwwmMnaeAQMpkKpJBIPT7DjfDYrB8S42FdN01VisPNP3amHpRjCjJNbc1OMXaOlve0TufPcWZfHKeKeKctkv3lDPczmrv46WIxU8Rhq0erpVqFWnOnKzTi1y3SZ9i+IvFyQeB/A2gxDy7dJta8TTTGCONZ7i+vLfRYw03350soNGZI0fiH7SyKSDtTqvht+034u+Ec11e+AdYn0PWbuxNg+q2iD7bDbMw8wWksnzQNLtUFgNxAyWUgGvGPDWs+GvFXhuz8M+LdSbSptMlC6Hq0bZeyjuXVtStWhuJorG9tb3ZBciG4uLCeG/t5zDegahKh7LSfgR4lvNGHizw/JoPiPw+dRTTYrm01SOW/a4lmuoYzd6Igl1WwObUib7RbGztDKhkvgrRu2lSvmdfF0MblTde2Fo2+qvmq4dUadOEoSgm6icXd81ne6cW+nz2Oz7D5LGhmSzKllzUaOHp1p1VQnRrKmqSjGcpK0pS+BxabTVuWWhq+JPi94+8eX82o63rOueI9QuCWlvNXv7q7ZmPLMFkkZFUYPyjAVSAFUGuaTRde1Zw108gjJ/1Uaui7Tzhm29F9Op46cBfefhj+z98X/HniTRvCvhDwSNe1fWtVg0bS7Gx1XRWknvZSAQ4e8jMFtACXubiZora0iUzXM0aAtX6Gt/wSn/AG5LC0WVPg3aXeFYMuk+OPAN3JuUHc2w+I45C4bcFIyC2Rtc4FZvL8+zGTq4ihipycveqVadS8nJRb1lq9HfVv4rdj8V4x8YeF8mxcMPnXFeV0sXiYutTji8zw8a1WF1F1Hz1FLk59OaT0e2rPyXtvBFwVx5Spkr80hHJJx8wdQQScYUcDAUktXpng/4B+L/ABnfW9lpNkGa4kRfPmkitoFVz9557gxRqnzZZt2CoKg9a+6Lz/gnN+2vYSMbj9nzx9KytkGxj0zUUXbyCrafqtyrHjOFcAgHC8DNSb9in9s/TE2n4BfF+EIetv4Z1OVQc7RgW7SKMhVU4JBCg7QSGrehw/XUoyxOFxM6cWrwpwlGTs43V3CXS1m09D8xx/jXw/WpzhlXFfDNOvOLVOdXM8HWjGXuqMnTp4mDmk7O3NG6XxI+l/2dv+CSuieIxY6r8TfiNoNnbMBJJouhahYX1+33WMclzJKIImPTKIwXJyvAr9ffh/8A8E/f2TfAlhFBY+BdG1y4iQK+oa/qCalcSsNqs+DL5CEsC2EiALZztGK/noH7O37bOjsPI+EPx0s/LbgQeF/EyKoGQFAjgf5RhS2Sc8kHph0/gH9tjTI2F34D+PkEYHVvDfjVRgZYc/Y5RgYBwMEg4XnmvsMFWwWAhCFHh+rHlUbznT9pUfw3vOpTbT0eisrvTRa/z5xRT4l4xxE6mI8ZMAqUpPkwWBrUcLQgm4tR5MPjU526OpKb76H9L0v7IP7NNwm5vhh4H24ziO2t12tgbgSjgc5zlgMnqM1TT9jT9mhSxX4YeDSM7vmt4WIAxjB3jPbAJ4xkkgHH8yjx/tW2oKXOgfGm3ZMg+bpHjCHBB5yGswwPAAHQYO45zUQ1L9p5TgWHxjGAAVGn+LgPl5PAtPlwBgDBxjoxPPorOoaWyiqtF9indfCv5Vo9e29uuvytPw4ziUbLxRW2tsXVvdpWbtj7fJ3737/08r+x9+zjHlf+FX+CiOQc2VqduckkZbuCDyAcbeSKgl/Yv/ZnuCTL8LvCPzkksltGu4kd9jheSAc5J3A4GeT/ADMRav8AtShQI7H4ysu7OF0/xjlh1ABFmOcYx1xjkd6sLcftc3GRBpXxwdTgbY9K8bHdzkZK2XLdBx1PzHng085T0eU1Gr2fuQa3i1dctvzb2bb1EvDXN1t4p046q7eMrrVqN9frr1vdpfef0sr+xL+zAjbv+FZeEgRkgPGMLgd1eTA65BAO0/N1IFW4v2RP2adPKvH8PPAkG04xNBZlk49Z2Y5yBxyB3OcZ/mph8Nftm6odsHhL9oC6yTtEeh+OHAP8Ix9j+YAgYyV4A9ed+z/Z7/bq8RbVtvhV8f7zfwDc6H4kgjOORl717SMDO37zcKSTyckhmsnZxymSVtuSCu7q7T9n29Hb1E+AsTT0xni/RpptX5sfJKytd+/mMdLaXejvdO+q/pEPwX/Z10IL5nh74X2CICP30ehRAAnLHMhGSM+uACDjFX7Px1+zh8MIrk2vjb4VeFY3VjdGy1zw9ZSSLHu+WUWsolkAP3QQxHAQZxj+d2x/4J+ft6+IW3S/CLxjaiQff8QeJ/C2kAbuS0g1XxHHKFXurR9AeSSa73Tf+CUP7ZerKDqtt8O/DSlRuOt/ETTbh0HOWkTw/Za2/HLMF6ndgEAA6LNcbNclPKpq2ibtFNJxW/s0nf11bdlteYcGcF35M38Y8DXp3jz06eKp1ptafZ/tCvq1ovclbpd2Pqn/AIKE/tEfsYfEn4e3mmWup2njr4kWZjj8O6x4WtCq2BWdXnXVdakhtIbzT3iDKYUa4ZZNjBVXcT/N94j1HTnuJo9PjENsrbsFzIzheCWcAM+VwAdu6QpuCKBivqf44/syfEf4V+JPEHhLxNqOiS3ugakmnX15pjasLC9ciLzL3S7rWtK0WK90uISqq6i0ltavMDErpvRj8meJbrwv8OJdMvdRvPDXi/U7ywOoWelafrFvr89i9xbPHbprmmaen9kaXfxXBM8VrqWraobdoo/7Q0e6jlMB+VzPFVqmJhVxFCOGULRnJRabV1u5aybtZa7aLW9/9CPAfIuH+FsjweDyniXGZ3hcU44rDyxWIVdR9pCE19XoxhGNGk1aduVJybcpOTu+h8M6vN4Csbzxncw2EN1c6Xd2Wjwa1ZNdLJa6pBd2F7rlnBLEYDc2yR3NtpMrkeZfEiFZRbu8fz5da7PrerSX8sYtYWC29jYIzGGxsofktrWLcQSUjA8yXaGkfdJ99gFoeL/iL4o+IeovqXiO7knk3l0iZw0au0cFuZZGCxedMYbeCBdiRwQwQxW1nb2lpHHbpm6ZNKLiNYojLMJVECbS5eQ/d2KGJfd8oEY2s2MKQdufSy/OIyqUacG1Qpzilo1Jp8rUmkr7N6bXd37x/WeW4xTr0aj5o0qMFCCk4qW6lOc7O3PJt6vaKUVZJt/o3+x5rPhjw7468H3Gp+C/EHi/xfqfjDRLTw9baZPHGdG0+ZZVn1nT7OSCRNU8SyTyouk2NwVt4TaS6o4Btmkh/wBF/wD4Jq/Hf9mXx38CfD/h34OeN9I1LW9HsruTxZpN1EdH19dTsZFtdRu/7NumWW80y2kSO1s7+zmvbNbVbSKW5FwXjr/PL+AvxU8FfA/wvqvxK8N/D/4gWnxSuPA178P/AAH431O4jk8E2fj7xPBf6R8RfFS3YtI7d77wt4NvJNG8FeHLFpL3TdR1aXXtWu1nhtopOw/ZX+J/xF8P6xqMPhfxFruieFdE0vUPFHjXVNLN7HD4d8GaeVn1O7k1K1t7ltDudYkih0HTrxUhNxqmo21uGZzEo+44uwuX+I/ClPhXHZpiclwmVVYY/BYvCQo1qFfHKEqc4ZjhHKnUxMXGSVKUcRQlSqSXxRiov9VyXjelmGQ5xw/nlXE5bwxRx9DG4bHYWOGq18TmNHDypONXD89N4qinUhRpU3iKc44hyaV46/0df8FvP20PKg8W2XhzWDEyPf8Awq8CmOdoy17e2+/x74gtl3I+7TNFeSwhuIlKpdavpUomEkZWv4v/ABNreXcLIu3lFDfeAAA+XDDbjpySTzxtDAfSP7TH7VnxB+LOqX0PibxVrviDSLm81DVNG03xNdx61NoY1i4Wa9On391axXVtLeJb2kV5cwNbi5FrEHjkVWZvgPVtd8zLFw2crw5IA4LHq4IReTwD3xtPH0X9sZVwxwtlHC2TPkw+WZfSw8naKdWta9WvKzbc605OrUva1WpNrRn32c8U4TMcJleGwGGqYDLMtyvCYDL8HVlGVWEKcYzr1sRyWj9YxWIlVr1nG/vTSvLkuUtd1Le8iq4Oclx90ZzkKCCP9gDOMjgAAgV5pqd6zkMgRQPl+ZsnaNhLHGXbGMA8FNy5BXLDS1O+DFizF2MmRk8gkg5XbyUGFJO08gdciuIubhnldQzBkQOTlGWQZQbXBIdggU/UEgkODj8SznNHWqSnzO7lbq0r2u7NaK2urUuZ73SPzbH4rnm27yTWq662SsrO1rN93+cVzLjcCThuMj1OMEhSwBxkAAYHGPbmZ3KuoAzHzvPLqhVkXOWYAMMBsAdDlCcFRauppBtHmKUJJkIQg7gQQsZGAoIjYsxJALAEMp4zGmUOQvOQSo4yCAgYAAkDqAdzbScEZUFa+BxuJU24p7a7Jfy3u00l8tXdW2PArTTcr2VrdV2i1d3101u9NVqrJEE7B9wPzn5sKCF5OCMsCcK2MMoOSOBhsk0JGLoUZGj3oeGdSyhcBlUlWLkE/NuHy5BJHDVLJLuQ4AXIO6NmUMDtz8+E+65xz15YKApJNNcsm55AZRwGXCAABVKAKRnyyNpLcsF/P52vVTm09E0lpZb8tr3W+qffrvv51STvo7XXlbS1t/S+2rsklolWIbzFPmNsC4MLJkFgQq5wzSbsICSWJVwVyUDESKxXJypBUkYAJ6rkBV4BPpkBexI4qNwFKnaGDMCTltoKmM7tq5Tb3UgnBGRvQMhiJVI2LhgvmBg24Z52gBVTI6cMBkHhhhSCeBzS5r3037LbTono1tou1zkcvsu1nq3d2WsV100vdbO1m9WrvVnV9pABwcHs68BSPnfDMyE4AORnB3Liq11N5ChFUyXM2Ps8QJZnkbYqAfLuIUk7txUklQuCrGiacQxSzbfMWONnIDJkFQJBhsEAsc5JYEZ+UEGpLKH7OgurplbUJYQqAMgisoGXIjiBOBckKTIyg7MFFPMpPNOo21CN7tXlLT3b2T1tq3tFeuyujFppc177WXWUrR6dIq6evvLsm0leso4tBspprt4JdWugTcTqweS0iZSfskWAApVuZZF+UsVG7YsYbL8+Wd5JWQCNixjUjEnzBG3M24MpOcgE5DHAbZlapyzPNdCCMu/lkPNPId6KSyHYgk2qzsQSzDpyABkoLUhCLukk2BCMncVAKnIBycEkYO3OHxggDGcItWdnaMXa2m+l25K925btW7czuhRpOLcpvmqTabbT0d1yxileyTVlG9l3u20TTLbxea6sFEZAXdkk5UqgGMF3yQANpHYbMgzyW72PlzXwEepCNZbW3Rip06GSM/vLhBiQ3xyP3fItmyrBpC3l1rd3tvI1S6R9+Haxsmj+ZFEbKupyoyhDtdCbRGDcr5gUosTNDdSyTy/aiWkkfG4u7sd0rEszMH+UFdylQPlICn5dwOUpXTlZu1uWNlrompPz/lWnVu70FyuUox0jBJuU01e9orkVrtJW1e7a5b6SIVJkZpC2Yyy/6wFmaQfPtCs5YRgscBcs2MqzHhSRDIGR2wF+YBAImZTtKOCccZx8gb5jg/KQSVXAQ7ZHQDCjCszDaygbUwEB2gnbt2qpLKwAyY0IBGJS+FEhfqxBUZBdS3GAdqkZVc4PoK20t2nqnZ6Wvpdvu9n3b6rRvltbpa2l1f3VZ3etn8rPW5MucuNwC5AWYF+NxQg8bwxAHzOr/KfnJVutOZmeRgkxkKpjCEogOFUqCTkng7mXiQEehBaw2qY0JO98iPe5EW4ZzlcbW4ClgDuRR5Z5JDoYBjMikLg7PmyCpKnPQZUc8cLhQ2eppKUm0kklZPfta3WzV9r6u27tqJaX83o1Z2vFvVcyupNK736O1k329upAkYZHC7X6N0be2eQpxuHBPTPUU99qsJEjG75VYqArAE9XO7hcKACQVwDwynBlY7Spx8u1Tg/KI3BUYHJAPGVHrggBSwMOQSOCAFB3FFPQLhWyBgAnnClSWIB6ADVlbrqnbdba311+bt63Kh0a1s7u1k/s2fV2vbVvXfQo3UajymL+WBLGXbdkxszZdgFcfu8bBwuVdPSrit5ZMZyWAIVgpBKkKiqWxltpPEifKTkMwYmlPzL83OF27Gw5JPA3ALk4LAKeSrfeG4DMMiASwNKzxmMlonViuwbzujkLP86sCrZQEhFzgqxYwna8lre2mzTfKtHdvbXVvWyvuatx2bVlqpJJP7NrpX9O+t12U7BG3LuwQcllLYVwSFO1VUkDd8w4HyqB8xfdJExKAFju4yeQ29dgJOS0gDEhsg5U53YbBqsVkfiMIXD/AChgCu1CMxsWk+UPhSoycg5J6YmLgSLhSoYLhiEVCzbQVPO4AAb9xy+AucHrUZpPmWmna19Y6J7aW3f8z1Fa6tp0017rva+j12182TnOTuIK7NoCoVAGNxU8ZYjL4AJCg7gcUIgTbt2xxD5hyQAN3AjJO4DAXAAC/KBkNmo1/dhQpICglkyzZXIDtn7uepXqTypDcq0pYFQ2QybwEXO3KNt3cKRyOhO7HIYZBzSjq299bt7K146adVo9L7Ky0bSf+SX923K09u+rbW6S0uWE3MM7tpUjqi4bbtzuLAEsRgAHG4cfeK1aUvuBKjpkKvX5toLBgXIKgDcD8yjkgjOKabSN3KlWBK4UMWwqk8nOxRkHkgthSCWyLMQPGzADBQQcHKhs7tuRnkAAEcBd2cEA9EXZR+Vtr20bvu0m9NHZWaW6vk+kla6Sv0VrR5Xqr2du2uiZft5FjDiUF4pVJnTjltrFZYirKqTIXBjkyQVGDwzKL0RERRD++jkDfZ5gQNwViFjfO5hMgTDAKCG5JHBOfGrAHaSSHBDEEHB25YfKMZypK7QS2CcEkjb05DNc29uw3o80ZaM/MMKDIzL/AAxv83LFSrDpkECuqhUb5YRTu2tW1ZXa93fqn0vulfW7pySp2qRXuq8ZX96NknJat3jb5K/nr6x4Q0m7vf7P03T7c3Go6pdWlhYwRpukuL7UJ47e1gRRhi8ks0Mar5ZLM67QxVSf66/2j7ux/Y7/AOCO1h8N9JkFp4q+PviTw/8ACGxljYR3F54O8BWjah4zv4tpy9rqPiGLUlmkHy3A8QxMSUZFr+fD/gnV8Lrn4p/tUfDrSorI3tr4Qlm8bz2gQOLjVNKngtPCVi0Zzua+8aaj4ctBF1feyjIRgP1t/wCCxviy6+IH7W3wE/Y38DznUNI+AHgDwX8PTaWchkhu/ib43ew1XxRdOFyrTiK48P2MpO4o1rOXYksq/rPDuEqrKJU6FNvF5piqGBw7irtxjJRdnZ6OvUp6aX9m79U/zHirCS4jzzgHgWjH21biHiSGf5jRguaUsn4bdL2FOpFXbpYnOcZg0lZqcsO0m+VpfCvjDSIvh5+xr4V8PSXAsdS+Itnr/wAR7sgkSyLqV0/gXwakoBDlYdH0nxxqsYCNm2u2kAxIhrJ/ZU+HXx8+JSeAf2SvgJ8IdNg8XftB6Vc3Gt/ETXNMuH1/SfBsuo6vY6rrUWtRbpPB3ge40ZYdS1ya3EE2rppmm2ljdS3V5Cg+1P2oPgLf+LPDujaV4ck0iO68UfGHwp+zJ8Dkv7XU7m81DQPgtothpvxJ8X6Bb2qG1bSrPVdTJ1LUjHeNzqtnDH5q3nlfqb8SfiB4X/4JN/sk6h4t0+DTR+2d+094Yh0zw3JFbQw6n8MfhXptpDpPhiZogCbAaZocFldWlksEMk3im7QXxvZNFCn7DjHLY5fjsPRjX9lDLcpoZbQlHlbapzlLG1asrN043hJTcYe0lKSglzzij6Hx64uo8MZthsgyqgswzuMsLw/w/l1PWdXHYajRprFzpxcX9Uo151sVUqStGKpqTau5R+Af+Cmvx4+Hn7LnwW8D/wDBML9lrUon8K/DX7O/x18X6cI7ef4gfEzy7e41KyvTbPJm00vUi8+p2Ane3sbi10zw9GDFoMckn5aJrMf7Lnwa/wCEuu7gWvxd+Lfh+8OhAkrqvgj4Zaqk9hea8hwJbHxR8Tk+26V4flyl1p3gqPWdZgVf7a0m6Xlfhf4fsPE+peMfjr8Y5LjUPAPga4i1TxFFc3U0d7438WaxLdXPhj4e6fdO5ne/8UX9vcXev3qs1xpnhiy1/WZm8+G1juvg349fGPxH8YfH2v8AifXr1bme91J7qYQRmCwSSMRWlrZ2FqoWKx0rSLGG20rSbGJUgsNNtLe2iRVUV8nUzSnkmB/tap7uLxEamHyTDte9Sovmp1Mwmnf35ybVPSyblKFlCJ3+HHBi8PeGo4jF13jeLeIJVcfmWZ1I3r1sVi0li8e3LWMYWeFy+Kb9lTpuSanGMpea+I9cu9d1K61O8kDvcSf6vG1IYd2I4o048uNUUIqKMIBgADOeVlYqSudpfO1QuNvHJzg4PJJGR8xyu0nNPllJAY5TBUgkEFmzuxgsQCd/UghgAeMZFFyC6hsbXQ46AZ+UHaCT1wCrDn72SDg1+T1q9SvWqV6s3OpVnKcpzbcnKdrtvu29tXdKz7/UU4K2t5S2b6zd73d9W7vq/XqUrslWintgVugWEilWEc0JVyfOO5UaUEbdoOG28LkCrVndLNErqGT5wJlYqpicHLIQPmALBVQnJPK+uIS7MdojzkcNx6BQdzAsxy21MAA/dwrEM1S5DKwuoDulj27k24E6cszOGcb2UkksR0JJO7aawVRxk3G+m62Vly3s9Wm7X2jzbp21LtJbWavdrVcuq1TTWm+l+tr7W6YTndgjIBwmdpPBVcAljk/KvbkBW28DHU+ErhFu7nSpSPs+oIJIjklRcxqwdcDGGlhUgADJZEBCsDXn1reLNtYDcxY7lOCyEAEqwGQSACysXDNwOnzHatLh4p43h3LLDIJEb7oDps2OecnlSr4cqSSo6EjrpzTtPqmr9mrLpZ+rv1013KqyVWjyPWWns209ZJxab3/K22yaR+ln7BHxY0L4W/GpvCvxBdpvhP8AFnQ9X+E/xQsdw2S+DPHVvJpV5qSK4aJrnw/fy2HibTLgrutrzT45Bhy2fG/2tfgP4j+A/wAVvGvw71wLNq3w91+Xw9cahGm2217w/dxJfeFPElmxwXsdb0ie1v7GTJX7NdWieYzmTHj9vcNNb6frtgQJx8zIvBV0DCa3O0NtcOHaMcAhioGdgP60/FGyj/bC/Y58LftCaco1P4n/ALNmjaV8Iv2grGNPtGp6x8IryeRPhj8UJ4YgLi6j8I3Dy+FdcvGLywW40u9kkit7CQH9QydR4n4VxeSSalmeRuWYZbzW9pWwFRweJw8NLt0qihVhHm+GVTlSbPq8GnxNwpVwcXzZzwtUq5jgoWTnicqrKnHM8JTa96UsLKMMbShe0YLEuOrtL8WbO6uNM1C01XTriS0nheK6guoTsmtp4JVnt7mFwFKzwSiOVCrBsozDIFfQ/iwQeK7WH4neHoI4YdRnjTxjplomyPw34rmINyDEPktdF8TTRzax4cZQIIjJf6JkXGlKJvBtQ0m40y9utOvU2tbO38WUaLhobiGTJE0FwrJMsqKocNu4B46Twn4h1fwxeSXWmzKsFzAbLUbG5hS60zV9OaRJH07VbB8QX1i8iRzIkmJLe5ihu7d4LiKGeP47BSjGjiMsxsZww9WpGXPGDdTCYqnpGrCMnHn0bhWh7rnTkrPmjFnyVOiquHlRnd0qnLVjNJXp1IqyqRVmmnFuM0laz01St7v4Muo7mSAyYJBUurZbk7QMgAgrwqlk5OQMEEEf0H/8E3P2iv2cfgrp9+vj7TLvRvF2pTrDB4wks49TtLXTBDzaRRxqb23LyKrTT28LyOCobABU/gZ8PI/APiXVUjfW7XwBNNKhe212e7vNHjV2cu2j6nG3mgwxwb47fxDNaRTSyLDca6nNxXung7RtS8S6zpfh/wANarFqNxqmuWfhqwK6Xqyvd32pagunWFykMMF2xtJJHj3XELzKu8pGZ1UO/wBxw5lmaZW6eIwtLD4+nXfsqU6dSnLmu4K3s+ZVqUnzLScISu7Wtq/wzxO8I5eI+Xy4fxk8yo4XFVqSjXyytKjKrNShGnBycZRnGTaU6NSDWt5x6n9mWm/Hn9nf4hWaDTfij4D1W3uY8NZ6jq9naPtYMMSW2rLBLu52srKSSOSQDirJ8LP2bddn+3S6b8Jr1pTv84T+GpWJYg5G2QlsnaBlSygKASMV+Fk3/BK79svRE8zS4vBGvKmWU6X4uSwL9SSsGu6bpGCwzwZF25yjN81cRqv7D37dPh8uv/CqfEWoqgxu0fxF4Y1VCByCq2uuGZuSdu1Sw2kAEnJ/WVQzSNNRxGU1lOPxRpShXs3y7Rg5pO993dbao/K3+zm8SsmqS/sjMeLcDTkkv3eUVsRaLULOVXA14Qlsneyb16n9EUPwA/Zyvo1jTwp8KbrjaI44vD7szEheDG5bf0AP3idzMOMipc/sc/s6367v+FbeBmDkHdDa2YG48gnyWAxuAbBOd3Cg5AP80OofAT9s7QmLXPwe+L8DKShFtoWpXKhc/eRrEXS9SM7WYk8ljxWd/wAIn+2Jp6rGfh/8dLcIpAMfhvxfGDkdCUtHyQOMK2CBkAZG6/qmMlZ/2Vj9+uCm76R291XVvQ8+p9BvxkwMrUuLeJaMlbWrk2cU9FZO/wDtaXztv87/ANK0n7D37O7sCPhn4TDKGb93BCAcjjGPutuPJbkjhuary/sH/s6yr8/w00EA7WzEoVxwCOQ6l8/LgbiTjK5BIH82RX9ru1Tc3hn46xcsCDonjdSfQkCx+UqMFVGRnOc55jbXv2t7Yc6f8dYQDj/kFeOUwD3DCxB4wMA8Z68YBSwWLur5PiWlZStgZO+se8dNtVfS7ehl/wASd+N1JpR46zyMk7e9gM5jb4e+JstttU9Glc/o2n/4J+fs1sxL/DmxQccRzzgAkqclRMAc53Ek7xyAAeDYsv2Dv2a7CTzI/h1pxwBjzppGQgcEtumHOeAjbgDktnIFfzeP4y/azCgSf8L3GAQd1n41GCOuVNtkMBg+XtZSD98YxVOTxT+1U+Cw+Nx5x/x5+Nt3uOLZ8klgNoZVJHHbGkcJiY2tkuLvZXawUuluri9VqtN7W66kvok+O0706viDncY+6mvq2ctOyira4lJX626bNu6P6XNS/Yn/AGYtRtjaXnwz8N+XIpRnE8sEgBAGRNFdI4bC/eDHDZByoJPyT8Tv+CQPwC8aLPe/DrxVr3w51eRS0AivLfxFo4l6qJbC7mh1Axg44t9RjYAngsDj8Ujqv7UVyQWs/jdcNjkDSvGb7jnqd1lkcA5XJGBwxPIu2el/tWXzKbXw38eJ3wcfZtA8ZBSOcAE2jEEHODvbrgjLZrb6jiqvu/2Ni09GpfVZRUXpd83KpK2tmpaO2trtepkn0VPpCZJiqWKynxJz/D1Yyg4xll2aYzDytyu9TDYmtUoVLu11OnJdErvT7n8YfAn9vL9i7SzqMCWPx6+EWly4eW3t9Q8UQaTZLj/j907Nt4z8M2wjYb7mxnu9FtvlaW5DdfgT48fHy7+Meowa3Lph8GzWthFZP4atLi71jSXuI5G824huJzZ3dq0wAzBcWd0Ywu1rxlGE7+28E/tw3IBsfCf7SJUqURYtN8cQAqwG5cgrgMDyoIByDk5ArMl/Zf8A2vdekae5+BnxWvp5neR7jUvDEyTSM/zM8s+o/ZnYuSzkvOSWJckljXqyxPGbwE8rjUx9XL5xjFYbERq1lHkaUYQqVL1IRi9oqdlZvW5/a/AGX/SNyvIo5HxVTrcT4eKgoYjCZPmeEnKMOXlU6FSniIRqLe9CpQg9E6KW/wAseAvi1qvw58W6b4jgs5PtOlXkFzG9pcLGX8iTeuHTzBG2QpV0ZgDlGUrI6r+6+g/8FPP2ffiV8PX8O+P49b8NarcaRNY3cd3YG9tXdgYpGimtzKzRupLujqvlkKsTLgFPzNk/YH/am8RQIrfA3UrG4klVFn1DVfCejShmbYMreeKLcuAWJkyq4G5pMAAn5V+IH7PPxL+GfirUfCPjXQ5/Der6W1n/AGjabLjxIsCX0ME1s8U3hGHXrC73w3ET+Xb3c0iRnFwsXU/J47IOJKUI1ZZVXqYdSu6s6ckoP3VrLRQje1pSXLr8Vt/iPFX6PuN45r5ZnvE/CvEeS5jl84rC5nSw9bByteE1CcqlF05xi1dOUOaKu1KzbPSvBfiPw/f/ABn8YWmlX7XOhat4Q+KVnp7Lcxac95ZxeGdV1azgnkuZIIVtpW0xEvYpH3tC8kUKyXEscDfF3xWubWHxRJp+nzebYWNu8dm7qFf7Nd395qNsrqATva1vIZHVyxDPtYjAA9MuNf8ABXw607WbS6tH1fXb23IttRvZdN/taQZtHXS7Lw/YXmrWnhLSNQIurXxBqut6ne+I9U0l20zTdA8OTSz3p+VLnULjULma6uGZ5biZpXbLBUZtpCqu44SMHCAHhFVQQAAPlc1rLCZTRy2pODxbxVWvVhG0lQpycZKm372rlq901FdN/bllDy7KMJl1Soq1ag5KbTTnCLjSio1JRXLKo3BSdtL33di1dT+YAoPTAZtqkEMcDBwSRuGCe57jhq+ofiFq48RfBT4ErNLJd6ro3hnV4Xdw7yxaTa3g8NWNplk2qkUXhywmhCTb5PtkshGQa+TBuZiCN2AcEgn5cAkjll5IyePun72Cwr9PfEHwr0bwx+yKnjzxBYG18RW4+Efw20NpUmMj61eaP4q+K3jCOHzCsUVxpmha34Ns9RiERuLaS+iEj7SS/m5VKdTLc/hF2hWwlHDrmvyyrfWKdeDVr804qjNq2lm3tocVXM6PDuRZlKvGUnmuIybJsPh4KLqVsVjc0wihKEXZtUYwq16jSbhSp1J6pWff/Ai4Gt/sufDS2ui7Cw+K/wC054Jkzg/8SXx7+yp4ul1aHJBBhll0SxkkQEJujMhUkivwbN4ZIIiSSzRo7E/LhmCYJzkHcWGSNwyNow/J/dTwfAfhr+yL4L1a+JtzJZ/tgfGdVJ27dP0f4RQ/BHwrckHlYtQ8c+N20+ybIM08PlpzzX4KTExxRp0ZVVRjJ3ABVz0yM7ecnnAGASMeX4kTVDFZHhpu+Io5Dlft4t2dNvL8Dyxa01jyv3X1tfbX6Himhz8UU04J1aHB3BeGxLkkuXEfUKuIVOSWnPTw9bDc0dXFcvaN2XVxuV33fNyWzztC9wWGScckMoGMb8gZrDk3lY38wcjeuBhVDKCFYnpxy24dfQErVx5Ac9uvB2kcAAYZuvBwvpkk5yMZUxZ+CWwQcIc8HCkFiWX5eASFLYzjOC1flVWo2+nwpW2ttb3m3oraPqvJacFOilsrN2ei0v7vnrbTS9tLWIHYEY6/MpB5+YAjuTnggkBcLtAzhsCqjHlwhUFuGYZBOAoHXnAwecZLctk5NTMXChtpDHC4OGOPlG/PJOScZJBHy5BALVWbcTyAQRkEHkkbcc4zwACQc4bOOcZ82rOLTT1tsur0ir2630bslo3vfTppxelo6a/Et7cuut736aq1m1dxV4SpIAVgCcPncB83yq2AAcgg8KwII+5huKpy7jjJIzNb4GMKflmznABzkLgk4VTgkD5hLIdyhEYoyuMM2DypTIBBDe6np1BANQSAjaNwB863BAAY7gkwYE4Od33ipOTuOMg4blm3be97a2V72j13u7Jtea7O3QlZLbWyurdGvNa667dbq7sNuP8AVOSQECMOSVUuQSASoY7wCd3O4Z4YKC1MTBS1GwqY7C3Aw2NzkZXcGBYnkEfdDrhducmorwnlTvIEbk4JCK+whTkFePlYqwBwxP8AEAlSKci2V8/8eFgNuc4LW+Q2QADtGfl3FV9iSKyveopaNpR2as+tk3dWunfv1CyU6L0ta9r7Ncqvqr7tpefbZudmyVRsEuFHI3bdy/MAQSSpGOcYBwOMYhJCHG4glACrE5zhQMg/IhJJABzxwoyMF8hUuqtk7kK4BAAyF6gYwW3EpyeeVxkmo40CgoGLIrEBmDbtuRwWZmKooHLL/F8oxzutt81tOz62va2lrWv130V+x0X1V72W6XrG+i0vbfW9tVrqqyFTM7eYOpTBYhPMBH3FKgcKFKcngDJ4Aq1k4ZVYEffOACCVbIXAUAFgeCCAMnYcGqQR1ACjzkSXKAuY2RCxJOGJDsuzdyCM7RwDgywyKy79u2Mx7EzhsBdrZAjIGCGICY4JZuAayi9k42b3tsno79nZ6Xv1W3R62vfy0Wrty9bJLq3a97J6OxZU5JIOVChcDGeCpIGMkgkjBZiDnDc1EY2MhkEpG0geWBtTA2nMmNpdSBgYOQ2VIwQKiieR/mkQxhGAZS6khNincuB1O30IO0gAgHErlQ6DbhWcKTwVK7VYKS5ICt3ABGPmCtuZS+ZSV76XSur9XbdJN2/R+aGnJxvfa2mt72X3tW6u+mvcbnMhAIMm7GFA2kBowN3zhVJLDLFQpxsOWAzIsToWZgQWkB2ZIB3BWYQ7AGwzA43A5UHA2k4lXYSzYO8fu3DADjIzjAZgC5GScbiVByc1GdgVo3LCRXPzMxBBK4XyzyS2AAV4JXHQk5LbNu2tlt7vwu/m9NX91tGaRStd913/ALrbv1V767X1d0kLI+5hGrp5jkSKcDay5ClCjEHdkZHygMfvYJDCDzZty7lIA/dgc85KgNnYcY525O6MnJOWamspkMgLFREMtkudxjPGSV3ANGx3MHUFwMuGZTSxgSoDHKwAYLvwSx27WfzFAbIH3lzgEHoetZuS5mratpbq7s1d990uy1Wt07pu+2j8rK+sb9bu3VrTz72FV0QBWZ/mTAy2eQDIQyqyhUONy4ZfmJB2nlRA7SLibYd4GCpRWyyjG9QgCspVQCMfLvyxHA8cjNgFt/lsqhAyrjkAsS+FYr833yGI75NNgiuVmXJRogwy8wUuwUpwSzkhwcueigFtoJAzFRJq3LJrleq1tot9mtEtG3qr9hp2S0b0as772V13e++trpbMjVipbcxwCAMZwckDHAGeOhJPXac9m7cO0nyhf4VGcYA29B0OO5ORwRx8tNwcMCVbIxuyM/wgbmbIIKnuvXqcljUCu5ZAVKphg2QpMjAqFXAIYAAhiScgEnB6VzSqONnb4tLK3dX5ne62urvW11qk18zGF3LWKsne7tfSKsu3kvx1J1Vo0YBXlydwxn5VZgQcsRkKQzY2gc54UndZLqiA4B2oCcBSSOowFBAHy9TyNvHyjiupwMYOANp9ACM8bcYycAZzk5I+9inEMeQSScgg84BAzzkAhd3PXn7w7CoqVnZr4Uk7Xta1raPvffo+q1iWrXM13v8AzJqKu2ttvKzet73LEMhZW3LsOOMgZKMARnHBOD/dww4ByASnmRhzEWzIvzFQSMj5cEnb3HDAYzjsWyAZHy44455IJIwORkDJP4joMn5o0A86RgqtlUDNtywCgEgtwSMEF+pAwD0yLvJcqutbKbd79NrPfZ3V+r8nCjG8nZpKKaSdtfds3e+m2i9NS2h3fOVIzwFY7txBUc5w2MYAySW4JOTkyoV67fmwNucbWJ2hSS7evygkAYwpw+CIN+OACckAgcjPGG5B6cgYOBzipQTzlhwVIHQEcDAOCWIPfjPfPFbRukldSvJPS+/urt3d9k16XRi79U9el+ita71763t6rrOvOCQy42suc5BznhjtJySRwB8uVJVgTVqJ8ABhucAYYcA8Ljk4GcDnocj+E8mojtuJweQACQ24nAIwDyWAwOuMYycYImWTDYJyGyVHGQcKMtliNwPXuy4x0xVxceZWu3ddXJ9Hr+Ctfyb3OepFtWaVlZpJrZWTV97/AHXvZu9jRibJxtZSODknhSF9QSccAYxnpjcK0o3KBd2SRk5OSf4SMt94kDO0jHBwcAEjIjkZgAeGY/eyQckKvLcZPPyjPIGOmKuo5+XvjA+bdySqk8DAyRnqQQdpGV4PVTaTTd72Wur7aO/Ty+486rBpp3um9nZrRRv33VrNP7uu5HK2EfIJB4CqCRwhHQbiRzkkjH3hkZNfQ+ha7DqsNjqMr+Y7W6WWpKSSyTxIsayuMkDzIlR13/eKLk7smvmuJjnOPlbBySSCCFPAGQMdMH7pyR8prtPDmsTaXcOcb7ScBbiIcEpksHBONskZ5VxyfmBAHB9KhVaknbVNWfXmTTT2Vle+1+ltJGPtXCDprROUWtdU1b7Ls7atXSfm9Wfs9pfx+0r4m/s1eDfhNrNwNK+KnwW1W8n+F/im4aI6d4k8CatKk/ib4ba1cTlHs/KSC01Xw69xcLYX9wl1pV1JbC7jlf428YfBu51SXWdZ8E6NfW91pEf2zxV4FljlGvaCk/lyJqWl2br5t94enjlimTYslxpizLHcKYAs0fkWga20So8cpmsZAFE4wwQMARFOmGUMu7aCCDglVYco32R8G/2gm8GanpsXijRbDx34RV/Kn0zU2eHxBp9tNELd5vCXjGAJq/h+/tYgJLGJpZtNjuI0kksXYBh+n4fPsHntPCYbPqk6U6NCnhY4+EPae7TXLQnVhdSjOEeWEqkNJ04xUoc8VM8njHH1+IamFx0qtPDZ5g8HQwU8bUi3hsww2DhClho5hGCc/a0qMY0ViYKUlCFPnhK03P4WNlOJGg2vFIhKyIwdSOu7zYwmVwcqc8Zx6gV6Z4THiK3CtpesapaLKqQyNYaneQCVArbYpGt5EEiKJH2xyNgBum3LV+4Hgf8AZo/Zu/ax8afDrUfhX4+17+3tdvLrxd8RPDOv/DQeJPEfgvQdCv7nWPEs2o6loS2GkeK9H0zR9Mto7kXCG/1t9Svba3eBwjCP4w/stfEXRv2k7/wXfL4PufFnxF8TaXe+DdM8G+EfCOiaFJpmuLaJ4X06Twf4dIg8M3trpb/6Zoz2X2pJoHluxcNKZ5/Qp8H4mjiHLDZjhcXRapyp1sDiYz5o1JcsZzg5xrU9VZ3hy3aabTi3/OXiF4j4PhKUcuznDRo16mX4jMHUqQrVcBWpYZxVR4bFug8NX5Ic1WUPaRq04Jc1JO6X5+/Cn4kfG74fa03iXwT8TPHXhvXZrCTT5NW0jX9Qtr57GZlM1r9rVvN+zy7Y1eJHEZVERgVUCvtfwz+3T+25osSpb/tBfESbaAR/aV9a6qCADnf/AGnZXRYsMnLZByBvJJNfphrf/BJzWNS0zSP7KvNE8Ky6dPqctzLdaD4j1DV9WlvmtWkTVtbH2a1nttNuLa7TRbfTdH06C0sL0xztezf6SeNuv+CWXxGswBb+LPBVxtBVfOXXLQnjqd+mzdc9Sx55wOa+1wXDec4f3YYz2kUl8OPpzi0rOyj7aTdm3e6WvqfwtxD48+DnE1dYjMsHl8q0vcvmPDVWVSEIzUEvb1cvcHF2vHkqOLi4621PlGx/4KYft1aeML8Zrq4GBj7b4P8ABd2cA/xF/Du/cAOu7kbjzwR1Fn/wVg/bnshiXx94cvgQc/bPh34Rc8dGcw6VAcEZB/4FgY5HsV7/AMEyvjHAD9nvPBF2nUeXq91EeOBtNxp0WDnJ4IGSAegxzM//AATe+OybjFpHhe5GD80fiXS0xxwc3L2+SvcscBc5U4xXf/ZGc2u5uTS0XtKcmvhur8zvZW3eu1+h4tDjfwIruP7jhqF3ZuWBo0Wr2+y6MeXT0+XXGtv+Cwf7asGDLqnw7u2x/wAt/h7py7gTgZ+zSwY+97ZPTvjdg/4LPfth24Baw+FU+MFi3gu9hyB1JEGvRKDgjPA2lQcAZrnrj/gnJ8fuVXwZpcw5AMHinw0V6cfMdWjOeeSFBwei5zVJ/wDgnL+0CASvgBHHIITxF4WwGJ7A60O5G09wMMWzis3lWcr7F2+vLTbtZJX0VlqvLr3S7nxP4Ez15+G4RWqUatGDTdtPdnF632+6x3af8Fr/ANrqMBm8O/CWY5GWPhjXF3A88hPEWRwM8MW2jI4GanT/AILafta8B/CPwjcEjI/4R3xCD1U7iR4kHfnqAK84/wCHcf7RGAq/Dmd/pr3hjHIAxn+28Hkj5u5yvC8U5f8AgnF+0USMfDabjPLa/wCFwB64B1wDOTwc7WPJG04ExyvOHq4K9kk+Sku393T5Wb0a2sJcQeA8tHWyJp2+HMeWy93ZLE7/AH6baNnox/4LXftacBPCvwjG4HGfDevsMEE7hnxIRk988H270Lj/AILUftfuD5Wh/Ci3OP4fCervhQRkgy+IXGVzj5iBklehOeK/4dw/tF/Kf+FcS4ycZ8ReFgqjOen9tuMk4wRzxjbgipI/+Cb37RTkn/hXqrv27jJ4l8KIME4PXWgGPXJJ5GQRgjDWWZzq/Zx1s37lP3r27xs9n83ZM1hxB4DQkl7TInH+9jua+qbXLKu/XZ6WRqXn/BZn9tW4ysE/w4s852tD4FjkxnAJUXeoXAYnJ/hOeODXDar/AMFbv26tRSRYfHfhvTd2V/0D4eeEQVHbButNuiMZ5JyefU12kP8AwTQ/aEfaH8IaTD/F/pHi7wsuO5zs1eU8ZPzKCQSSqjitq1/4JdfHedsy6f4Qsgx58/xdp8gUfS0W7JGTgOu49yDlcCyvNm781Onfldv3S7Puu/RdbaGr4y8AqK96PDlVRS91qnXu9Hdpud9FZq9k9VfY+Wtb/wCCj/7deubxP8ePEFiJFJ26RovhjRwAeyNYaDA6nrtKOG5+Ug5J8U8TftY/tZ+KEl/tv4+/Fe9SRSJIE8X6xaxOCoLYispYYwOOgQAAnqcCv0ytv+CUfxelANzrngC0BY9NR1a7KjuQLXR2VjgdAQemCCQT0Np/wSV8XsyjU/HWgwAgb/7N0DV9QfsOPPfT94+p6YJAGa2hlWbSunjYx2914unFL4XqvaK1r2+V356UfFnwHy9wnhsryOU4aQnheHHXnzLl/wCXlDAVZdLpqV1/Mfz++NL3xh4oklufEuua9r08xZnutX1XUdTlZmZiSZLueV3LE5bcSGbrnbuHgWueGp0WWQW0jiJA8rpE5jiRpY4lllYR5RWeWONWY43yogKmSMP/AELftJ/8E97v4I+HPCupaNpviT4n6r4k1PUrSa1j8O3NhY2EelwWlyBbabo7aprGp/aree5kuZvMsrLTltY3vZ1iul3/ADR8MvhL4j0aH4oRa94B8XeFtI8SfDbUNQv7e3s/C5S6tPBvifw34pvtB1fwvqbXF7Jocul2N3c3usXMq6jay29skErNc3dlqnmvhmWNx8MJVxHPKrfkqU2qsefl5oqM7qLbknG3NdvTS+n9qfR946yjxDxGUYPhyHsKWaSxOGwFOeHeFqyxGFpz5KTwc4wxFOFapS9nFypfDJVI+403+Nvh34feLPFc0n9iaLcT2Vv899q9zJbaZoGnRkZ83Vdf1OS00nTogAWQ3V5Dv4SAyORG337+xv8AsM+MP2k/HtvoHhS9tYvCvh8rqfxU+NOp202m/DH4XeFbaA3Wr6mmo6otg2t6zaWcU0mnoUtYLqZf9EilsI59cs/rFvCv/BO34d6Xoer/AB6+O3xi/aR17Q7RJ7T4PfCzwhrPg3wjp2pW4DNo2p+IfFE2i22nR27MtndzeG7O0mDxzyI8rHYfIvjT+3B8Y/2mtP0X9l39mv4SRfB74OahdxadofwJ+D1rdapr/jiczAQf8Jtq1hBHqXiOQssc17CYNO0cSK11qEV1cI15XzMo4fLJtRm6le7jG9pTUrqLlGCvTppPTWU5O2qi9vv48c8ZZ5XxOAyzLKmRYTDznSx2fZzTeAy7LaVKbhXq0Y4x0sdmeJhGLlRUMNg8FFpOrXqwtGVv9tr9oX4dfEfxJ4G+A37Oelmw/Zs/Z6tZ/CfwuP2POr/EHxBczW8fi74t680aW0t94g8dalZ28emNcFZ4tGtNNhRYAZooPnT4qftd/FLw/wCH774IaV4liuPBS2Hh/T/FOknw94XsL7ULjQWmubfw1qviTQLGHWNb0PQri4WI2V/rF5aahqllHql4kt4iSJzvxr8EaJ+y9Z2/hXxP4j0rxN+0JJFO/ifwz4dvbfVPDfwae4iiFrputa9Y3NzY658RokMovtK03dp3hGUJb3N9e6m0tvZfAF5qzzs8skzSSSPkszCRpC5BJdmJJeRjli3I4xzjGizGGGpRpRadXmU5Lm5nGWjbk72c2/eknfl622X9AcDPK63D2W4TB01jsrw9SGIoYzGUnUnjsVGbqSzGE6sU5yxFeU68a8Y8tRy9pSfs+SUuy13xVd6xe3eoXbq0tzIZHEQWKKMHGyKOJG2xRRgqiqgwoGPmHTibzVssTk4IJLYZgw4xyu3BJGc9OpBGTnCu70hchim5lTqxYM23kFcAA4xwcrnhcViXV55YUnlT8u3ByGyuGALFQowSecALkcjJ4MVnVSrzc1R3f2r9Xy3108tXtr5M/UvrspRtzPstb223elttd73W1tLNxdSkt5rALlh5cZXG35QJC4KksQC2AMDCjODtGDJKGC/N8p4UAsud3JB2ggjDEY5Y8Hacg1Vu7uNtkTuCzsCnU5O5GHIUqEJAXjkkgKQQKy5bx5GTy/ukfvSdhIiBUB4ySpKnG3cygluCRya+WxWPTck23a11vK8ra6LRN2/HbRHFUxG+0mmly6N7R5vK17fNvayvZaVi8gAYFCFLbs+Z90M5DANtyvzEKQSSPvEiswlgztliZDuYMGZeNmUXYRxnodqg/d5AwHK/XPIywBA4UZzg53DlgThcbsEjDVVmkLMqFSoCFt25SFCkZQAkEltpK9GXII5zXh16zlrvJJ73tb0tZ+fbrbQ4Jzck7c3fzu7a2Vlo9FfdWuRLcNIHZI5YssACSgLYCZCryRhmOMhtwyozjiNpGZgRksV3MoHzEHblthGRv6LgDaSwOSwBbJJ86rn5ztyA2ANuMBz93nG1SOTgLuHSo5H/AHbserR7A4DFyEAK4YYEiq3OONuTkggA+ZN2tdtySvq9ZWStst/R7ebOaV+ur0ve26t1WnRbbbetR5TH5qs+d0pISTCgAlFjQYYADoucKVZQygBsUHzNimLAZfL3CUnDABS/UqNzBTtxnIPp1r3URmRAxYHAwyk/MX3hi6p8pYZXcCTkcA/KKnU7V2EthUxk9VAVQWJIYkkYLAgHIA478S5ouSsktLSb+LRSd731+/ba2hi4+7zXu4uyV763g2tU25WWjslazSuypesv2a6XP/Lu6nlkKYbKlQgdWQg8KC2NpPCDAtO4kDojll2lWbdtOAuCRkM+4lhljhWZQD8wGKF9KptplKM4WM78FsupKj7q4ZuCSz52gfMTgZqcqpKlWbK4KqzFTjB4KIDwG4AyRtJGcEMcb+/N3uuWOjtf7Wzd3u3f0dnZoUvh5re8nZc2tn7ikmvJN3dmlbTfSwCsSBxtKCMhjtIOVOFLyZY788MJAW3YC+hWwNrIU1a+jaS0gYfZrCROb+ZUBFxcKyor2ETKqsu5TO3yZCozDNudjmFZWOw3Vujou87lMiZVlJBdW5VupVMAhmPyWrq8W5uJJXRYSitHDGqgRxRREokSR7zsEcfyLGM4iwpywGMnO8rWjyxta1mm9G0+6XTo3bZIicJOOiSvdSlpzKKlG6jdaN31afu2tq3oy6vnke6vrvl5ZiXQgHahcBFRZHyiABgqDHlINpBUIBG6t8pzlwVfGcq0bDO3EYCkNub+IqQcEqSdrRIGJXoWjXhwpLFsqCFK7jjdkAgMSASS23D8Op2K29QuZAVYksr5wpJG0bQqnbjb8qgYyRHdJ3TspX7tpt/K+q120sPSKUUrNWVtkopRS362afnqKWBOY1DNtJICrgAYIHJBKnaq5AwpDKSCBVGdhbrvll2owbYgVg+SgfYi7SG5A2uSyK33QQQxsXd5DZoskx3MVxAi4DTMANoZXQ7UAIyxbsu0M2BUNnZBCmqasQ9wcSWWnsnyBWTMU86sTGkalkMMLFmlYB5eCA8TqOUuSGs7rmdvdhHT3pNX1avaO7s7aLSorlinJtfZit5TatZLbRPRye1r7opQ/bBJG0ipDCxBSKXaZPKOGX5QgEZIUD58EggBVjJA0mkdQSihs8MCNg2jG9vlYD5ArA4O0cjG0mmZJkMhCBnBYkbVZjuDYABfIyeVyNpJJO0g0jMc5KDccKAAABkL84ILdFK53Pz1Q7ScTG8U3dttJu+vSP3K726dHoNvm5XaKvFaLRqyi+t29Ho76tqy1s1JZSQrFl6ucfITkFjhCcEYJAL568lSTTFJPJbccht2AAAcHG8ZAA42lcZIOSDuIcW25y/mDacAgbCxKnKkEKAeFO45/utydzVYDcrIMqGXjByiqM7uSpUnOCpBweRu63tbXs76dbX676u9tNdL6DSdtr7Xtpf4N97XTflq97XHSOGVfnMZUhgzAYK5GEZm2khxkccNgfxEmoFkQ8gEKSVcnAj8xihCbjl1PKgbs7QDk7QppzxxHA2qzGRSGztBUY2fOrfLwwHlkDkg/eByIUVJUPKr8uMsBgKACMLlpEDKCwDepKkmovK732T19V2/HyvfUaatta63tZK/Jo/e1Xre9n5AQN0aybvMYo3mYAx0wpLKiglmJUr8zsm0/MuRMDumJHCKgWRS7OQu9GIxuw3OASGIRgEbOM1SDxec6vuUJyJmaNlYmTKl2bedq5ITGVZ1OADHmpyXkKbt+Dz/ABJlcR4DsiBmcHDbjwRngluUndu93rrbqkvVX/G1r90U76b3tu35xs72d7313u093taVnOSiNwDtY4GV28Oc5IchWCjnJJBGAQZVLggBSWdAQduACPl2lBnhTwoB+bqcHkVxIVG1ipcsoDBsAqccncWwDzhsBn6Hbg5mVmwAoL7cK+QScEjEhYso5H3SCCQRwQcDVOzu73Wt3pJqy0u9L7K789NyVFNRS0Vk+tk7R6a9O931LMZJCn5V+UBGGAHdQoU7m5yDySFAJHBLDIuIBIoGTuDLtZepPGBn5SQQD0+8BkncQRThKEjg4VsEDAOAwyDsDMNuSp+bbgliSCcXoRwARg/IcnkqCFzggHK9TweWwcAEgawetvLTs9Vpsk+ra2XnduWbtZarS2v2tk3d+vfXtoXLfaz/AHtvuylc4PCjeTnhlG1cEAEE52muy8M2ay3Mlyyny4EAUkkAuQTJjcFwFQYb+JQ+3G3APKJGMjIc8DG0AH5cc5GT6ZDYyeQzKGI9Q8PabdPZWlpZQPc6jqVzHb2dtGC81zeXjLb2dtEoXez3ErwwogDu0jgKpBAr1MDSlUrQSTlbllbVpSbiopPV7uySdm9VtryYqUlTVOmvfrSjCC3d243Ud+9tPx3f9J//AAQZ+GFh4e8ReI/2gPFUEcGg6Gut+NL6+uFCpF4N+ENol+JFkkygt9Q8e6vYXEZ6SXHga5SMMYJQvgf7JfxB0r47f8FIZPjL8SNQtYJfE3jr4ifFAXOp3cMECaisOq6roVss1zNBEBaXH2SOCMzR7ILBIISH8tT96+M7G2/Yt/4JUeJbDTrmKHxX8VrnS/2f/D93bMFkuNL8HC8h+J2q2koO6S31rxxN4+uUuRgS2up6c7sVVQv82tpqM9rIkltPLBOmwI0UjRNgFDwVAz3UgEqVJ3ZwDX7XPNKHDOM4XgqDqrKHSxGMoqShOpWjV9pNczUuWUajqyi5Rt8Ol1c+G8KM6j/xG/ijjqtRjmWWcFYvJODMnouShGdTI1DM+IpUqiU0lWzjFzw7nZ3+pRbTskf1DfskfH74Va38b/ib+0Z8drrRdJ/Zw/Yi+FfjzwV8FtKS4msL7xt4n8Y6xqE1zrWk6bKYv7c8bfEOXxH4i1vWZ43mWxXXfDsN2RbWK3Fr+Pv7QHxx+LH/AAUT/am1PxXc20l1qfjbxAbbwz4eE5j0nw14etRJ/Ztg89xItvp+i+GtFikvdY1O6ZLeytLe7vrp8RvLXxnqnjvxHr/h/R/Bz3aQaBpF3cX1rpNnDHBA+pXkVpFd6ndCMA3V5Mtlbgea7BWjXYFVnz9DeLdWj/ZS+Cc+kyutn8ZPjL4WhuvErZKat8PvhFriC40zwtHI372y8U/FqDytT18RpFdaf8OltNP3qfGd/FFjmGbLiLM8wzOvB0Mrpzq4zGTnJJSjOrOvSwtNxjyuVWrPlm3eVSSdaa912+qw3BeHzXxL4j8UOIqzxXta7/snC1V+6yrBNRaweF3jLF4+um6lWMF7OnPliuSEpS8K/bK+Mvhqy0vRfgx8Lbzzfh54A+3QabqUaLBL428S3vkx+LfibqkYAdX12a0g0zwvDKN+keENO0i0J+1zahcXH5qRyibbIrMyZUbi3zEhdzpIsa4Zt3IIOOcc8NXUa7rFzrWoXd/dyM8lzIzMHJeNEOQkQTgeWAoUYKnA24x14eeN7SVp4gWgDESREn5S3z5CmQnC4Uo5AKjIIIyF/J8/zarm2PliW+WhT/c4Wik1GlQhZQp04ptRjFaPfz1dz6rGYurjsVVxVXlvUcVCEPdp0aUFy0qVNN+7TpQSjBJ7LbdvRkl2jIPBOCvCsqkICDnP3VByCQQORuUkEUpjGzcSG5Ykc4APCrjZ04B5A3Bs5YUPMaRFddpDtlBjJKKDg4TChvlIKkktnIULlWlWVYEUljgsBna7Eu3l5BVcjgdQpIBwfavE503q7r3ei1ldWd7pW5rJdO/UmCXWz1S6PqtVe2m2vwpejYkpUSBSQQyhhkHB+YBAzFipOMDIOH4C8gAPidsMcgHeFXkHO5U4ZyGLNjIIxyBtbBAZqzSpI5EfKx5BYhCQxZFHy/eAj4DYI+fGCDtFSrIoXLqQSQCccHheRgEtnILEgccsOBgTu21bl3S0e3Lo23fpbS63tfRqkk7629Nto2bk3a3TTmu1puiu0c1vdh7dWdZ2USJwFBMmcDkKpBGVJJwGJBZcrW7buRIUkBXaWQEBeq7VwSF2nDDAGfmznhwQcmdstEC5K7w/7tiSCSPlBXYSAWPfdkhsYIxoPOWnumdQrLO4VcIWKZXJJLP14cuRyB8+0gZ2pu17PS692+ivGLdlsu6V+vVE8jTe1tdraNpLa2t30vbTr09K8G6tHDO2lXr+Xaag+IpCSfJuzny5FLFSqy/LGcEfOV3BduD9ufskftH+Jv2UvjDb+J49NtvEPhHXLLUPCXxH8C6wiXHh3x14J8RQmz8ReGtZs5g0E1jq9lJLLaySo6WmoKjhVUyE/nRFMV2tlWORyQoO7CgZwCfukb+QcfMCCEI+3v2ePDOi/tEX9p8KtS8T+H/CHxJukWz8Aan4r1C30bw34s1AsgtPB2seILuWLT/Dt/fgFND13WJ7fR5NQENhql9pf2hNRj+o4bzDFZfmWGxeBqKniqMualzySp1oOyqYebuk41Ytx5W7PmSOOpxHW4LxFPiSnOpRwuCkp4urSpyq+wp+6qlavSgpOphFGUo4lcrUaTlUkvZxnb6k/a0/ZM8NeHtM0744/A641bxp+yl45ulPgvxlaRtqXiX4Na1fu9zc/B74pWgfz1m0qeR4fD99dyQv4i02NL7SLu71VNY0+5+BH8Ca3BbyXkNsNV0uJ9h1fRSdQ06IgoNtysa/bNOlydrwajb2kofI8ldpr7t8AfFX9or9hjxv4t+HPijRdV0OK6RtA+IXwt+IOgQ6joHiPSZVBOl+K/CWswTaZ4i0W6idLixvUjkWSNob7Sr1Flhnan4l134H+Ob648SeDNFu/g/qs0c8txpXh7ULvxB4biu5Ufy00gahcQeLtG0/LSO1rd6zrkESmSIYgjiiX9WllfDvEdT+0cFicLlmOnyyxWUYyVWjUpV2oRqvD1nTlQr0nPmlCEpUpKLceZqKUfspVeHeIsNDiHhXMcBTpY2msTWyqde+GjUnyznVyvFwU6VTCzcnUhRqyhOjpCHtGlI+K7PSpFAQnyxxvV2xgnBClWQbSQQcHGF++cV6r4Yj1jTpoLzSrzUNNu7Yq8EtheXllPE4bcskM9q8TxOjZZDCyMjA7WzuNfcHi39n74oeEPgj8JfHmo6FdeIPB3xo8X+MfEnh3XhH4fnsfGC+BHttG8uTQ9Xig8RaZGt7faobi8ub5IdSs4op7bbMsQvvZf2b/wBkx/j94c8XXUfhjTPBd1oZ0RINe0+XXJkg1TUZr+7u9N1bwobq9gdZNMt41sp7fULG0tIoywW9nmCV9zwBwh/a+LVLCYz2MqN5e1nenR5oOLTVaDlTje0Yxc5R5paJ6pK/DmjX8QMdDBcM0FmVeWOzDAwlhasJU/rOVVZ0cZF1XyQjKjWoVacveVpxte+i+Y/Cn7Sn7THhNFj8PfHv4w6Mka5RLX4i+L1hBHAXyJNTeEjHHMZBICgc17TpX/BQn9tnSlCw/tD+PbuNSBs1Z9H105zgh21nSL0tjjJYsOoYNya+mLj/AIJp/ELONO8UeErhQDsFxaa/p7HGTni0vQpzngMcYAJJwaxbn/gm18Z4cvFN4IuwOQU1rUIGZu3Fzo8QXIwScjJz/F1/eHwNmsFTf9p4epJJLmljqU5/ZeqlUbte9vNX63P6Mo+H3izl9vY4XiSioWi3hcfVlqnBPTD4hq97r5dXY4fTv+Cp37cengJ/wtWyvlQEg6j8Pfh9cFlHGTIPC0chHTJDjPzccZrpIf8Agrp+2xAp8zxT4NnGQSZvhj4QO7ORlvI02ABTnAIXOc5VRgipdf8ABPT47Qfc0Lw3cAEENB4o05dzDGdpuPIIJI4ztPfAc5rBuv2Cvj1Blm8FWUuMk/Z/EugOT0BILamnOSyhuTxgrnGbXBmbOzcsNVaa1SoVeb4f7r00avr2vqzreTeMVLljN8apKySbzOorXiv5pXfXrte92d5H/wAFiv20Lc7TqXw4mICk+b8NdFGU5yP3DxcH5TkEA44TAq6n/BZX9sFT++h+FFwvQrN8OYQAcdGEeqRgDBHAyeSCMMMeNT/sP/HeE7f+Fe3RKjrFrGgPuONx2hNWGcHcN4AznATcRjNf9in45KW/4tzqRAO0qdQ0VlDEbj01Mn+9tbdkDKnOM1ouCs3tGUaGHk2tf9mwrbfutf8ALp6N6Wa8m+go4HxbjvLi262UsPj221bdyptu++qvu9dT6AT/AILLftXqcv4d+CkpA5kk+GxJ5ySP+Q0WXjj5T8wz8uSch/4LM/tYc48P/BTaRgA/DZzjlum3XU4HB4298gEbh88H9iv43hQD8OtRG5mwft2jAgkjnH9pHnlju4b+6vOBF/wxV8bicf8ACu9RUgfKPt2jbfqQdSGCehOPlGRggDdsuCc4lb/ZMPd7S+p4a2nL19irt+S07mqwni5vfi28nZtYTG2drLS9FJWtvo9d7tn0IP8Agsd+1uzfutK+DUBAHKfDY5A57ya24CkHpnPQbDkVXuP+Cwf7ZEw/cX/wwsh2Nr8NNKyvGMD7RczgHJODhsc5BHTwmP8AYq+ODfd+Ht8oI7aloaDrt4zqYGeuXJzyflOc1oQ/sPfHSUgDwNJHk7v3mtaCmMkEsQdSPOCcnKkjkAEcWuCM3um8PhU7W97C4VX92Ku70unRPZq1m9RfU/F2eqfF/T/lxjlrpu1TT1vv06dL+n3H/BWz9ty4DKvjvwrZ53YFr8NfB/A7FPtOm3DAc4zkn6cmuZ1D/gp/+2pqSMk3xWtYd4Ib7J4D8B27emSR4bbaOMAsSQBux3qra/sGfHacqv8AwiNnGMdZvEWhKenBJF8+WPchR34ZjuO/b/8ABPr45yEb9C0GHgAmXxJpxGeM7vKaXoMkH5h2KHrWX+pmbQ1hPDUndP3PYUmrWad0o3t26vZPpLybxfrpx5+NFp0nmVNL4bappaO6VrbeZ45r37c37WmvrKl98aPFEfnKV22FrommR4zkAx6do9qhUHlRtYA4IANfKXxO+KXxY+I9tBbeOfHHirxRaWM0s1lbapqM8ttbPNGsMz20EaxxxtNCkSOEVDII0WQHYMfpXF/wTl+NkyjzIfCVvnOfM1mV2U45bMVnJg56jAI5II4Damn/APBM34jyDUZ/EDeGb61OkX0NjHp2reJnuNM1tozJperSWOh+Hr261ezhuoYra/07/Rd9ndzzrdx3FrCsniZpwXxJjcNUwrzmLoz0lRnmtOFKSurJ01XfM3ZRSUW72SWiPBzXgLxXzfD1I4zDcR4zD6ynHHYnEVKaUVdyca9ZrRXbdk9dm3Y/DmfSZCHkEJ2KQjMVZV8xmCxoW24LsWACZ3FiABkgVjTWrJL5EYLPIy7AoMhcyFQioAMtkkBduWdiAMsSF/YD9mb4cWPg74tXfh/xtrH7P/gXRptI14a547+Pnha68Z+EPD2s+EIzqumXfh7w015Hd3XiUahara6Zp0wsrHUvNkgnuIPPeN86/wDhB+z18EdWv/iL8RL/AMS+Mprz4meNNJsvhzoVve+AdF07QJNOs9d8IeIdW8Y6vLe+O08P+LbK/tdY0CHwjptnfiwDRyarp4ke4r+f8/4HxuGpTrKrDmoVJxxUZKcVRhDnXN7WcVCrJum/dhKUleDmkpw5v5zznKs5weX5hmVHLvrtLA1pUJ4bD1af1t1Uoayp1pUoQjKUvZxlKok5RneS5Txr9jT9jXxT8ZPHVlPqGhQ6hJosFtrzeEtVnOmaHptis0KW3jL41eId0Vv8OfhXYyyRz3kd66eMvHbwr4X8G6KbnVF1i297/a88YaF8U/iV8MP2TfgVqVz448KfDbVtf0/U/GYgFs/xa+N3j7VLSb4m/EhrVC0Nppc19bad4R8H2aNLFp3hzRbZIZH09IHXxb4r/tweKdc8L/8ACtPhhZ6b8Kfhrazy3a+FvAFnP4e0K4vGyp1nU1e41DXPFfiR1IC+K/HWt+ItehZt9jcafKQU+c9F+I1r8IPBWt65pzXKfELxXpl9o0OtHzIovB/hzUoYor06BdhlkvfFfiKxnvtOutSiIi8N6bNdrbyPr19HNp3zeArYHBzjSxFaMMBQnHF42NNylOuqHLUVGL0U61eaVNTdo04tyVlzOX53wtw7mOa8U5bxFx9iKOAyfJ5yx2XcOYWqq83iI05U4zrTUVTrY+rRqVMJQhTjKlhvrNavVr1YwhOl65+3F8dPCtroWt/CL4falBf6FpWgeCvgnod7ZSK9vP4E+HWs3Hjbx7r8QRmQQ/E34vXNrf2Lhn87RfCEEzs0GpWzN+QV5KMqgK7jgjhCXGUO1QCAcqSAx2hgCcZwF6fxHrs+r3ks8rna2I0jAASOFBtiiRF2hIo41VFRAFVVCqAoAribiT5lLEs2RgZI646kDO7cQfvYBUDAxz+Z8UZxVzvNMXmNZtyr1JcqbuoUnJuFKEk/gpxaik1a2i00PuMfUnj8zzPNa8f9pzPGzxdWEXeFGPLCjQoU9Xalh8NSo0KcVeygtNWV5JmDDK/MDj5TkHG0HacFm5J+VscKM4xxRModnUxsjAZTO0hw23Dhhweu0AY3AZ4IzUkjfMzFidxzggkqfl+6ScHORznrndhgM0Z5VRTuyR8qnG4FCQoJAAzgh8gjPXJ+YAn42rOWtmkk9FdWdrLfbre19Gn2sYRhpdqz0XLZPdxs/RaprRu707xzOwUbVZlyvmYI3spIwUdnUk/LjO0knaCDg1XZThiuQpJcr8zADjG0jAAOBuXkjcB2zT5JDtEoXcFQEqpH3QFbcGf755wRjDEgEYyxolnZXlLFPMGxYyNwjLBQJTsCgOcsSzDIHIXBAHHNq7bu23211S6r4XfS1+u+7eyjZ2flZLa9otJvTvrrfXVbErnn5sYzzlSOTtIGTnkkjjJIz6jIpzyKHhgxxJNGzNvxsCLIVUBtuWb5wu0lwBwVcbWsldqgM5kIUlnJG9scZ3A8jGQM4J45DjJpyZZVUny8TwkMRuJOxuSwy5OMHaMhgUOdzAjGu2op2SatbrbWLdnd3batfm/yTsmldaXd9N72d+2l9LtLr5DrlVaFgSoBjJUFV7ocDdtIOCMqMkbsMCCuS9ASLc53FrDTw2QTnMXLclVbGFIwM7VYkt0qq74t5GO4swcBdxBXCH5QpLHaMkncQ4wG6YBsrIjR26gAuNPsVLBVygMTZ3lj8xLcgjAyFOGBzUKSdRaNXhHRt2s3Gydmk9L9etiJL97T9JLpt7nRad7Ntvvohs0uwbFRpHDqqKu0hmYrwx2lQGUEEAnO0AYqHcQB8uwsqngquWwOBtO35RgEMcHAxnmphuZ1AUhQckjK7CCvy5Uk885yTk/PyBw2QyeYwxhCp2kKA/Rcg5Y/3XY8cYABOQDUk9Wrb2d7tKXu6rVaXukno362N73SvbWz/FW69G/O/wCBUWR2ICxPgK3mbX5QpyTkjAYktnaDgnG1RyHmPAaYoyFFPQyHOQXIKjadwdhkBvl7gqDmKISZ3PnAbaoIO07QNrEFslTjlsbm+UlelDysokfdvVgYxEVJQfcVjgEKVU7jvLbkJGThgKzTtD3ndtX26JrXRp9b6a6q13azT08klfqr6aJbp7tpK9rLZEMDsu8RK0ow0kkg+VdxCKUjUhQHVW2gk4UZx8o3LewI0j3nAKxqcffMjAEFSWxkkMVUkYK/I2QAWRphIgBsz1VVBcLhAVBQHLOAM5PzuQT8uKWOVC7o6OoVtqhypEhUxrlT1yWHA6AFtrKwzSXNGNm7NpNNxfLum9NH2ervdpPqzSNmru+u3n8Nlbe2iXRdN2PcgyCRncNGp2BGGwEE84O0SkjC43kBucgDNVxLLJII3RR8xZUVAWIDbUYnzGBjA5fb028dMVZR3ZgBGxZGIJJVsbAuFG9QCzFgd23DdACxyIWdjIoMO2MBWmkCrlt7KAEYhHKl1KjKnnOcDFEklazaTtdcz11V78y7b6O3mNK1rNtaK+urTjd39GvyHojs6qyYZBvJACJIAyDbhmAkZiuAWJDgHK7hvBtjilch/vbt6Iu0YLpuCMGBJLEFQdxXgEkZWppZEWNkwCcMVC7QdoAzh9u3aAeSO4GVUqTVJ8GMMgLbChClsMoDKzsyjeCE3Ic44bDY2llqJ2XnKzklbRNNa7dtktFe3W6Tumk91d9L3000XxPorO9+tm1ZikkWI+XC4DgsgZuDjbg5dR8shIKqCCDkfIMAyQXQDqHO11kCSBcKYyGjBB+8AoIbaMlyVbhuaYrvlSdyrtD7iBlmbAUMxc7FYg4I7njaRiponjimQOVQPMrkE8sWKNhpADgrkYkVTs5UkMxBzlor8yS1vda7Rs+nnprtd6Dte0k7WTvp1XrbT52VrLTbN37i24EYxgkqFOCAT8w6Z4ClcE5UgkZpy9CxwHIxgAAKAABycNk4+ZTzu4yCRiEEPySCRhgCw5J524ywyd3HQkAkjABEoRT8x+925xgDBB6Egg9WODwoPOa5YX5lJOL3eya+zFXWmllp+PRHz8oqLtZLy00Vlpq77N6b7WY9cMFIIyMDJPIIwN2COn908HkkgHmpUYs54LADBXBBctwSPmBIB9zg8EckCMAgDI5IONoK5XKgHA4xxkZPU468BFLAZP3QwBwwLFTgbmBzjGVHHJDc9ATtdK3qr6tpX5enT56Pu9DJq601fS663W19b6Ls1d7asmUBsqWIIO44wp6Jg9Sc+uMqBns2akGYyGQKRt+bCnrlRnJfgjDZIycnDA4yIwccDGCvI9uO6gnJzjngdDwSaaXJwCjBtp5O3Z0HQFRndj5QcEnjqPmptJdOaytu+X4dFe679dNbLtGrf9zRN2WuiWi07aW+RZR95YL1X5SBgAMNp24xzjHUEAYBOABUm8DDFgGwV5LdcgHIII75LYAIGOeaoqXQhgWYBTuX5gCM7tzFiFBJwpIGVzwCuCbKlyMMqjGDkFW6AEDONuTkAkAhzjBDAMahUeqlv0svdeqet291o1pro29jOcEndWa03snfS6el3v5dOjura4ySDgA7ucnnjAKg7RgE8+2FqYMWBypwCQRkDCkj5gMHOCR9T8p9aoo48wKpwRyMHgjCgfO3y5BABOecAdeVnRgfusDyAxGcnIAJORyAcAbiTkgAcVpTs5LW2qerv/KtGpbpaO3vLfs1jOLS6t2Tva3WNlfVJ9fRaaXLkT8BdxbgAswwR93O4YOcY9ucEZySb0TcYwW4BByMY46swORkA8c8gYG7NZicE4JIGc8jBOFxjGCBzwSTgjA4JU2UkKj5SSMHqOu4AZGfTHBH1IPFdcXZKPRW8tbQVr91s118rs5KlO909bqLb85JO9lbVW0Vku61NqJwxXIwVBKnPBzgcNlevUDAyAueRWvbzKGUlTkZOeTwwA4BB5IJGSD0OQOtc6jhsjIKjbtK4HPB5wMqP7w4wPmPYVcWcqVQP83GCDnIGzhugYnqMnDLwRuzjenUcXrZJ7a2te2mrV9FpfXZW008urS5tLO6VnurJWd90lvrrddNtPSfD/iG90edWtJNyMSHhk3NFMvJKSIV2YIbGMDGScALk+3eHNb8N62RFJev4Z1FyOZo2uNKnbPXCsZLUMeAyBkXqI88D5itHCsjqMZABGcZbjkrkcFhnbnjGMgcV2OlzK5jDgjaVILY6cDgYJAOWA67hleCFZvWw1V+7qtFHS7STfK9b91rbWzW71Pnsyo+7JxbTturO+idmtU1b100vd6fpp8I/HvjT4RWHjOPwz4ihsNX8b+H7Lwqnifw1qVqtwvhmbVrTUfEFlFMYhfWk161rpcTXVm9pfWcEk0ay+XeTxv+rH/BL6XVPiN+2N8KNT8Ta/qWvXtjrGseKb261nULvUrq8Tw94Y1nUrWeae5llluGtrsW7RtKzGNdpCKE4/no8BeKL3QNQsdSsLlra9spo57Z1Ify5l2qjiObdDIpYgvFJE6PgBkYAqP08/Z4/bm+I3wg8TWPjDRdF+Gt7rMcV/ZyXV54D0WxnmsdURIb21e68PQ6NdRebArwG4tpoLlYp7mNZwkrKf0vhjFYSEofWMRXpSckm6cFKLilG3M+eDfLfSPK9NW9WfyZ47YDifOeH8fgMmwWFxlWWAxWGwsMTip4eNOeIXvKC9jWjCnUupTnzx5rJOLSUj/T08Jf8IVH4c0mxeXR5ZYrK2WUNJbSMWMKFmLPl2y2TubLE8kemzL4X+H9+GabT9DmyeSyWT5JB9Y/YfXPIGa/go8Bf8Fe/ivY+eb7wX4CvY7m9ub947U+IdLEBuX3i1tBDrE8cNrartitYlhYpGPnLkEn6J0b/gsf4iiwbz4cBduA40zx9qtoMgkOwWfTLgrjBCk8A4AJwcQ/DzDYipOvheMcTSdWpKpaphK0ZXk1LT2eJafbzSu7O6PxpePvHGS4LBZXm/0bcgzajl+FoYKnVwnEuVuM4YejClCShjcqU9YwTasrNtJtWZ/ZxL8LPhZd/f8ADnh6TOch7SxYHnI58vPTsM8k9M81G+CXwinB3+E/DrEkZ/0Oy59uIhk8j2HI6gV/I5pn/BZpQF+1+CPGtsc4LWPxHSQcn5WXz9KTjgjBJGQD2YV3On/8FndB/wCW2kfFm3IBJEPizSroqScgqXNuTweN2MgY5pPw+zuGmH41qOz097F0m/h2/fSVtlpro15HOvpD5BVXNm30UqLk/jVKfC+MSba6zw1G/dXsr697/wBUL/AP4OsDjwjoA6/dt7cHkHn5Y+MHGPTPOO0J/Z5+DbAZ8KaMCefljjA556BR/n2zn+ZK3/4LO+E0C+a3xkgB6hZ/D8+Ae436xGT0OM4Jwc9cHag/4LQ+BwTnUPjKgG3hrLw2/wD7nTzgZzkH0yM4X+ovF8dIcZyto1/tuMXZvaWl7dfRdSJ+O/hNJXxP0U6zlb3uTI+Fa1vhutZLX5J+nT+k5/2c/g0cg+FtK4yCFyueCOqkemPp26YYf2bvg0Rj/hGNPxnoXkP05Leh9wDk+9fziD/gtN4FQAtq3xgCnkbtI8NsAS20Hd/bwzyDgg4GCMZwDIP+C1HgRc51r4uYAwMaH4eOMcYyNfA7N1Iz6nOKlcE8bdOM3ZW/5mGLWnu6b303slf5K5i/HTwTdub6KGOe2v8Aqxwu2tm2mqmqva7tZ7rqf0bD9nD4NfdHhjTsD1aTGeeh3j1J49fY0v8Awzp8Gx/zKumNnrkOwA9FDE+gJx0ySetfziv/AMFqfAHOdX+L7dfuaJ4eAyuOOfEHHA5xjHHTms2f/gtT4E/eL9u+MT4wQRYeH4gdwGQf+KhOzAByTjoSACQDUeCONXZPjKUdf+g/Fvs+bfW/Syv6aWcfHDwZt+6+iji125uHeF6eulle7tbzvp100/pST9n74PQ/d8K6MP8Aejib353KeTxgnnPGc1cX4I/CSHGPC2ggDByba1POfVkwT1PpnPfIr+X66/4LS+DvnESfGGYjqWutBtcgkjgDWJACeSMZAIHc/LyOof8ABaLQSGNt4e+KN6Vz/wAffjDS7MEjru8tLsrjDDK5wOCCc4FwHxNN2rcZz10aVfFza0VrJ1Y6addi347eHtLXLvopRc7Lk9thOFsKtOV+9L2FRr0S87n9XCfC34XWjAx+H/DqbTgYtLIEAYwAxUEYYdQPQDp82jH4f+HunD93Y6FDtB4WOyTHPBBVc9QMcdhnuD/H5qP/AAWhfDC2+HfiKYnJB1D4l7QeFAJWLw65znJwDyTgDtXmmuf8FmPEjrI1l8N9GjbBx/aXjPXr8A/NyyWlpppYZBGNy8HDEAFhUvDuu/8AeuMqkrLW1KvNte71dd333enkdOH+kJmSaWR/RgyrCNNKHts2yKglrH4lRy1SSVto6+btY/dD/gtL4sPg39mDSfGPw71hdJ1nQvGq6Td3eiNi6i0jxX4V8U6FeRyNZ4uIop557SNiXWPcIywd1QV/EP8ACn4p6jpnxb0TUvE17qmqaPrcXiLwn4jF2bnWANC8W6DqHh29v7q2upVjuotHfUYdZiaR8RyWMLAK6h1+4/jv/wAFTPHPxV8K6n4K8T+CvhzdeFdVudKvL/SJrLXLsXcuh6hFqmmb7mXW0uVSG8gRpBDLH5kTPFIDGzA/IPjf/gqR8crTRNb8M/Drwt8CvhHoOu2GoaNq9j8Ofgx4R0mXUNJ1W1Njqmn3F7qMGr3jQ39qzwXW2ffIHMjMH2yD6HLq9LhTD4HDUM3qYxYGu8VTqug/aSnOrGs6UlKVnHm5mm5v4nouv6R4WcY+IM+M4ceYfw4yrIc8qZtlWK+q/wBswjgsHQyunhqVGcKtHA1pznUp0Xz0I0IU5XblN3ZW0LQf2MdeOtfE74+fG/xB4ZkfU7dX+EHw38BTa58RvE96NE0+e/8AFdhr2o3o8B6Fo/irUpb2/gluLy5u7B5JIhpyJFEH8r+I/wC33pfgTw7rfw6/Yw+Gln+zd4P1m1l0zxD48j1WTxP8f/G+nSKsU8Gv/E24hhu/D+n3qljcaD4Li0XTwJXhkluYic/nV4i8R3Wo3tzfXEiyXF4wM8ipFCjOxyxjhiWOK3jQDZBbxxiOFAqQrsQA+aajqDOSm4YGSMYG5gAThsqc8EBgoJAKjJ6fM5jnlTF1sTOKhTVWrUquSSU7VZqTTk7tWba0smnt1P6mpcF4TP8AP8Vn+fYrHZjTxWNlj6OS160VkmCqTmqvJTwNCFCjio0qknKE8bHEyhK0qbi1pPrGtXV/PPNPNLcSzSPNLLLIZZJJXfe8kssh3yTSElnmdjIWOcknjlmvMZJyS3UBmJAOBwAMjHQDGeSSSCTVS5n35C54cEFuVIGFICnb8iscPuU4BwRuxWRLNIpZ2kPEX+rBxhgEKklSBvJOYw24qTgsK8FYxxtdt+9dvm1i7rq0tH3Ta9VofuGBcaNKnTpwjCFOKioQSiko8qSStZJXVktFfZ2NS4uXJ2uofqoDcncwAAJ3YDEgMHUZ69+Djm4+eQDcGDkEsw2kAAx7RlVxghT0C5CnDc1UadWIBYvkAnlshgARkKDkkcEZ+ckADOCtNpS4H31YqT85BO7CgEsQCC5AJB5AGCm5a56mLu7Keid+Za81nGyWyetlv6Ws2e1Cs3bdXS22esNU1o7eeq0vZkzXDyJlkKSE7ACN7DBUqy4/eEMxGXyCSccAAHNml3KJA53IChCDywFOA7MC67trEDqQ3OVJcCkkaZ1yfLUnYRGjM4ZAoJ8xxllYBQuFcA5VGBPBiTaQVRgoI3Y69QBtRT8wyB0AJKrlSSAR51XESlfV3stftN7J2utr+l++4SqWdu6/xK2lnpy31bvJrRtddRyXMQzCrqzxhfMXJypbYAWZ1wjdcqT1GMg8Bksp2llR5NudxXauEwCWBAwwUA5yxAOAcZJqIAeZIiosZwzsUyGd2UHHKhXIypXcu1emCFIqvcGVGAjXzY1bLF9qyoGySyszEPhQPnYFctgKNwI4J1ZKD2bbvdJ6a2b1/lulfvd9WZOV93ppo+uqav1v933snfcGA4CjOdy527WU4+UEEnktGxwDhiPlyc9ZI/NlDSfvHMavEZFdcskQjWMgqFZlVz90HcCdxGRUqMWGFHGCyqSOY2IOW+UbVY7gpAy38WOhhlVXDL3YDe/zbt8bZRiwdd2wkHhcYwOANtYVJSl8NnqvufL7ujXVqz2S6MV033TaT5WrL4bN66q1nbXTsrBINyuOQTnJGfkyQQSy4UbWK7sbid2eO9HfIrxsCzwbCjM3DbgAwlJaQ5DLGN5OVYkfKABUzhSF3MWxsbJeRXLg8HAyxVsqEB3EAYZuDgMqIhLsQGxGoCHdkgKFBRWLINx2nJAAyCSrbcJe9fVRsou97fy6S195aa6t3dnroRGye7VtEm0n9lPfru907rpqylcmVbKV9jbtp2KCMKmVzv29RtJx82GLYwRuC25WeJJCkZcrtYRAbNq5BbOV+UIBuIU5AwDlSwFW6x9klV3ZlaE/dJduWUBdsZ2ADO3kgF8MCwyHsz480qjOBHlOS+CQMB3G4EnnnG5Dg85xWN3zzlfRwgt9fPstl7qTaVrLYcmvdWmsrt6JONqe8Vpa+r3V012Qwtl7bMRINzalQQrEZlGVbapy45JHRRlu4wssTEylZPLIleQHAYAK7nDEBCdxVc5ICEMDngVEOJoHJLBbm3wrBiu3zFGcu4OcglGwGGMAhiC1gyB3LP8AfMj8DIBUMeDvzzk8MRkjbnaQtZtRm7aqyim36LpFW76JO1nZ3avDTjKLS+y7ddLxt/iTS7u2t7NXIXYHcjsfvDYSxBUk7Qy4LMQGbO1jnIwcAYoklkihdo+XijeRRIEOXQA5dwQScIM5PI4JBIapyAxJ2sdq4jBbGCG3K/YjrweOytzjFeUZt5+cAwynA3cr5bc4yDxnAx2ypwtTK8ebWzSsmt76K9/J2892rCjvBWb20lfVPkWvqmtb6atWVm6el7XjOrXkZuLgS7LGJgBAkkKgtPIrZRo4WZQsAwN+GYNjBtyM80jTyElpAS0hycuSOhJLclgBGRjcQx+ZgRn2Kwrplq7Fg3m3KsNpKqTh1wXYxgfdJYfOMZIOADZIwIy0mZCVZ8gEGMxpgboxkqCdwJILHIZcLvOOHVqcNU+aMZOT3lKUYybfVtN6dlu+1ySdSejSUnFN2UYqDSsusVe22rvez0u4AqSfLczZVi2ecgqMAgqQoKkNxyWPACncm0KAFOxnAchsDczKBhcbAQGwV3AbcnHHBazBt6jOVLHnbuLLtZuM79rbc4yckBTyBTRhgpBZACD1O9R8vGFUnAI4bJGACQd1aNpbLV6p/ctE9babeb6MOVtppae7dXXN8MNU/Po767K17N+0ngK3JEisGwxIIAU7Mr0IVhj3G0ZzIgCAnB3MNzkg7SwClsAgYVABtJIIPXI6RhVDBzgbwvzZBMbfJwFC5LMowwcdNxHBK1A2UKsrySOxCsXbIAwp24VsYypwOGZcEZXFPn1v5fJ7X316uzstt3sNWel9U72dld6aO6jLm9fk9ywSmwk90ORkKzN2DKnO5eODnHIzio1mjQrErYJAACj5FXCAeYz5G4twcEKz4DbSFyMoXbtBIBQgITklMMrAKcDhslckDHAIzlsgAIJDY37V2sAVBIZiwLlJEzlicEMSCCzAVm23e2+jTflvtr6/L1FDleis+q1T2Su7rS/dXb11bvdybVkUxEM6lSWQk8Lu3K/7v5WJYjB5GOMZABsBsfKcE7DkgMFCqFUYx/dIxnjDfeyTVaMRrkgkAHaCN5Lc9VKqqlsspxllOASV5JkDDMf3CpjUD5TliSBtJZgxDYBYMgLZJRjkAVFtO63Vtt9PNWf3q3V67tJWS0so6Xu1slsrN6O23XSzteRcNtEZPUMMhVLMAvBG084PIBKsBhTk4FiJiOVGCCCec7XypbGVJ2ZAwSFPAC4HNVv3hBxhh0BGcso2AZYkbQTkAgAE8OMklXq2FB+YkEZC54LBWIGMjgAkIxXqFUmqjbf5Nvv7vl83fr16ukuluZpq2miUXC2rWt9JX878z0a0I2ycBCpYYYliepXaNmRgZ+fbkN05KEqdC2DBsAgnJwBnocEEbSAR1I5wB0AUbay0OWRcsy4+ZtuBkYAwBgbycBQGIHCg5GDsWgLEA9uC208425yDzk9OAA2NuA3Fb07XXn5N3WnW/l+l9jGaaTT1vbrrZxW6Wr6X16aa77lnbebJHEi7vNeOMnI+TJQklVGMhRkBh8mcqu3JH6X/APBP34R3PxQ/aZ8BW1vYf2ja/D1f+FiSWZjEkN3rWhahYad8P9NnT51MWrfEzW/BWmyoC262nuyx+Qhfzx8M2onvEk+fbApdhuJUuVCpjgL0AUdCh6kjKn+qT/ggB8CItS8V6l8XNftY4NHk8Q3+tXWoXSARweDPgzpY1Kdt7kD7NqfxI8X+GL+Ig7ZLj4c3ZQFrSTy/u+EcL7bMaNaUb0sOpYuo5NJWw0faRT7qdVU4NXafNpGx8nxTn1HhrJs74lxEk6XD2UY7M1Gb92piqdK2BoNJ3br4yeHopKzbqJNps4v/AILg+MbLwj4q+A/7J3h28E+jfAH4W6RFroR8/a/GXiSOPU9V1C6CkIb26iaC9uXYDdNeSSNgu4H4GLIVy2TnPQcleFJB2kY+XnbzjtyCK+x/22vjJL8ff2lvjP8AFeeV5YvFnjrXrzSgzCQx6NFeva6Pbxg5CrFplvbRqAxUBG25Xbn57+FHwu1v4vePdK8GaLLa2Ec4vNT8Q6/qLiDQ/CPhTRbaXUPEvizXLg/La6ToGk29zfXkh3M5hjtLZJr25t4X9PMHic2zyp7OLqVcTiPZ00nfnatGU9tLycpuSeicm30XjeCfDeKy3gnI8LiFUnmmaqpnGZyqX9rUzDOK8sfipVW3zScKteUZSbaUYK7sj3v9nfw14b8KaDr37SPxV0+2v/A3w8vItP8ACHhfUi6RfE/4ozWz3vh/wkEDK8vhvRYUHif4gXUDKlp4etYdMaeC+8QaaJPzy+N/xg8RfFzx14j8VeI9Zudb1PW9Xv8AWtV1K6wr6lqt9OZLi98uNfLit/mSG0togtvZ2UEFpbrHBbwovtX7WXxz0/xjqml/Dv4cx3ek/CX4c2E/hvwDps26O8n0k3Am1fxbrsSMFfxb8QdTi/t/xBITvs7Y6X4etnSx0e2jT4ndxNCIpGCNEQLdzlRnq9vMzON0TlcoRyrsTjJcHy+JM1hCEMhy+opYXCzbxNWGjxmMVo1J83WnC7hRT05VeylN2/Zcxq0Junl2Fkvq2E0lON0sXiko89Vyuvd3jQS2ST0cruV7lyRtUttc7htIUnqGJLA5ByQ2CVGNxY1nOfMd8ZGcsc7QVyq5UhVPyspPPCqMc7eaaS6M4YGGSNdssZZUeJ8sSdyl3dHKkhlyFBBOVKksZnwxJK5IOwZwFc52jaELdCvPCZ6YNfGSk0raX1bvo7pLe6S0a1WuivpdteWoWbS0trZqV1azte6vtfV36a7Ga5eykaSIPJaOyCVGyfJLk5eIM3ABzhgNrcBz0xYMqSDKJvyhZchHDryA+xenGN2WXksSfmIKOAyjbJkBQrrjgg8+U4XqChPcgAHHcDNy1q6puDWs5Jizh3j2uEKBdxZXTBJUElgVZQWJFYc/K1ZJp2srpJNtdW3ZXvdW6LTVlJSje1rdtGtUldrbZtPt01uaEcYaVnZyXUEggsMnIZeMYOMhQM/NhQMY5vq5VQCu4soB2qRk8Z3DaewJJDEg4wQMCs+J1BwAFG4hcnAAAH3lZW/dgDGCWy3Gc4qUPmAu0oDKQAyKUK7CqhNquNwbbtY9SWyoIBFCmlpZ6+9r2XKml3td26adSo3srrdLVvX3bN2urPa1nfl30aTcshJkRFyJAQSWEbKQCgAAYL1HKgAFkBXgklbks/8ApEyRofNWd2fC7FEe4K0rl1bkjPOSccsADuGdIjERFShdyvyocli0kR+UjLMp4OQThlB4jO1rjlo7i4RldXNzICxdmwCVJLj5N/yqWTZ8pUbs/PmtobyV2m5Rb0b+ynu09Wkt+nvdS4qak20kr6721jF2t3fW779lfRic/wCsLbDuVyxAEew4GCAxQAnlRtJI/ix93obG5kgdLiNiu3DR7CCUOAyFSAMjOS4Xu2VI2iuUjXONwc7SAcsx3AYCjAJyg3AswAGSMgFV261q5TKKGOCjBXZtmBtypywJLL/FwHBweSTXpYVybgrvTlbaXVarZLWyTVn8jdUqdSMqdSMZwnHllGUVKLUlG8WndOLTa3s1ve9l+r/wl/4KBPrHg3SfhB+2D8OtO/aa+GOkWsWl+GdY1fVrjQfjV8NdNRlVIvAPxXtra51hdMtomQW3hjxVF4i8LIVVU022EZZ+x+IHwo/Yx17wBrfxJ/Z2/aV8Str1ld+H0s/2ePi18OtRsPiVcJrF1Fa6jBofjLwlc6v4O8RPpBeS5muH0vRDeWlvIE0+O4uIYH/JTT5UWeE8hWSQs3yEFjGMLjBBXOC68kAnYTkgdhoGq3NrLDPFK6SQsklvKjFJ4miKlGV4isqmMnd8rIQTlWGMJ9xluJqOdB1pqooyV3O3PyR5HyuorS1Wi5m1GKtFJnxFDwxy7BZjDMuGM1zXhrnxKxGOyrLq1KWR5iuaM61OrluLo4nD4R4i8vbYjLY4PEycnOVVytI/Sz4hfHH4qeNj8P8Aw9q9zq9h4Q+EvgLS/hP4A0Dzphp+keG9O8s6jdQRRW1kl9da/q1xdahf6hdQnUJ5J7W0umCWUEaf2b/8G1mleFtP/Z2+O3inxTPo63OvfE7QdCtRrrWkc0tn4c8LW92xto78hpIRc+IZY1dAB+62SBZEIr+QX4Cf8FRf2iPhX4Y0XwJqFv8ACr4r+DNCKf2T4f8Ai/8AC/wx45i09F+zII4tSvLOHWAnlW8UQMmoO3klwGDMzH3fQf8AgpT8QLbU9VvdF+Hfwg8L6drWsXeuz+G/CPh7VPDOg6ZfansN6mj2Gn64qWFvOY4iwjZiAqxo5jSKNP3PJcpocZ8OZvwliswnw3g8y+q1YZrQpPFVIyweOw2MVBYanLDzSqukk6ntPct8LVk/1rwjoY6liMZwnxLlGD4K4Zo0qry3PuHcdPOZ160sXTxLliMBPCZZiaVbGuVSpiZutX/eSnzVKkm5P/TaPg34ReIEzc+GfAmpq45MumaFdhwecEPA4HBxySNzZwM4OPd/s5/s8aqGe8+FPw6uN3Ujw7oock4XrHZqenGQ2Djg9Mf533h3/gql4700K7+GFhEWAZtD8ba9ph3hS2cTw6iU5BC/PkkjYWAzXtejf8FkvHdgqcfFCzC7eNP+KtwwXPAMaTabCTgjgZ6Z54OPIn9F/O1yzyPxblZ2dONfC5lgpKzj7rlHH1NW9NtHqtz99p8CZO2p5V4yY/B31jHEZXnWGnFaNJzw+MmlpfaPZpW2/u1uP2Pv2Xrsnzfg/wCCASP+WGnwW2SeuDB5eAD3B6AjNZM/7EH7Ktx8p+FHh9RycQ3eoQgZ9BHegDnoVAI4Ppj+LDTP+C2XjKFQZPEXxxttoziLxjp18vfPEt9aEgdsqdwK8Yya7Gz/AOC4/jFOnjr44w4bA33Hh655xk8vroLEEA4xyOO5xrT+jp4wUFbB+LkYxW1s9z6kldRSvGFSaWnZN7Xe1++HCfFFNR+qeO9RRS0U8y4ow6VnFL3bys3133Vj+wiX9gv9lKYH/i2NimTyI9a1xBjk8FdSXPtkfKTwOTmm/wDwT6/ZQkyP+FcIo6EDxF4izn8NVGOeDz6njNfyQ2//AAXP8YIMt8TPjTFjnDaV4auCCOuSddYZGMnoR3PGDqR/8F2PGMWHPxS+MIBVWXd4b8MSBgcjPOssDjoN3LYAGcmt14CePFO3J4vK10l/xk/EUb7f3Jaqy7232No8O8eKzp+PFJ8vWef8SK2sV9qi3fa+nqmtv6xP+Hen7J2SG+HXOOMeJfEi4Pqf+Jrnd15znjt1py/8E9P2TlY/8W4DE4xu8ReIyOfrqp59CCM5+tfyhr/wXh8X4JPxX+LijHX/AIRHwoxIxjH/ACGFPXjB9OwNQyf8F4/F2Mr8VPi/14I8J+FFwD1z/wATokFfrwe/Iyf8QN8fFKz8X4rS/wDyVPEfRLtS201W6s7pg8i8Qk+V+PGHvZXtxHxDfXleyoX7XWmru1pr/WQv/BPr9kpTz8MrZuOd/iDxCe3cHVRnoPvevGMYq1H+wN+yXFwPhZpTdP8AWatrb56f3tTPPsOvHtj+RyX/AILueMZNwf4ofGV+TkR6B4Uiz2AG3XMjn7vQ8DoSax7j/guj4wckn4gfG2YZZSY4PDMOCSegXXwFPHAByMEHjFQ/Afxzlf2njGlbV24n4hatZf3Y667Wvp5mbyDjmTtU8eIPa8oZ9xJO7XL0VOLd/Pz1P7D4P2If2VbVsJ8JvDj7QB+9mvJh82O01/J69xz2xit62/ZF/ZhtCuz4Q+CGZcY83T7acc88+e0h6gDOCT0wQRX8V95/wXC8YSqx/wCEu+Ok+Mg41rQ7TBBPB8vWZcDHOdp+XBAzxXD6r/wWu8e3QcRa18aZ8kg+d8Q7azBDHgkWsVztxzkbucKOeawn9HjxZrNLGeL/ADR2blnWfV10ulCVaPNftZXul11wqcLcR1LfXPHbETi7J8uN4nrrTlvaPPDm9NNXp0P7rrH9n34A6SB9i+GPw+tQnIA8PaPuGDnPz2bHKk5JznryTWf4y8M/Czw1oVxNZ6D4R0t4kDI1rY6Valc8bUMUEbB2yAoVlOdo3Kea/gQ1n/gsV8QrwSjHxFuPvD/iYfFnWGVs4OGjt9NzyQcjcOCPmPfwTxr/AMFTPiZrtvLCujRHLLIrav4x8Xawcqd3zImo6cjhyCpLKwO7jLAUYf6NWZYatSxeeeLbq06dSFSpTo4HMsVKaUo3SlWx9NNuzTvGTfZ6HJHhDJcFiKOMzHxczDM/ZVIVKmHo5Zm0pVWpQbgqmJxvLd2s5OLtfVPrxv8AwUT0HSPBv7TXx08LaWYv7MtviN4oudOZSwgOmandvqtsisxKhIob9FRs8YCk5GD8+6rrngb466V4Q8Aa1458N/B3UE8B+Gbvxn4++LGsapZeC38RfDEa3otjf21l4f0bXte1PUdf8GX9np2n/ZdPur27udMFhERC22uU+IX7bnjvXfFVx45/4RX4RxeLrjSLLRZ9Yvvhn4d8WPNaaVFbW+nzpp/ji28TaNHqcMFrtl1eHTV1C8eaZ57hyxNfC/xi+Mfj/wCL/iW78Y/EfxbqvjDxJc21lp82q6tLFJLFp+nW8dtYafZwQR29np+mafAiW1jp9hbWtjaQosNvbxxIor1eNs3ngquMwlCssXRr4anhateaa+sqnCClXaVpQnKopNxavaW6sfhnFGIzmpnPE+ByiOFwuQ5vDEUsPmU6vtsxU3WjVw9aOXVMI6EJUruXPPEz6xlScW2vWviJq/7OXw2+3ab4L8Q678ffFTQRrb+KG0XUfh18MtC1HeGmutJ0m9uJ/Gnjb7ORtsrrX4fCFg3yvdaFexkQj408YeNdc8U3YuNVvZblYR5MCE4ht4t5dYo4kCpGiFjjaoAJJCADccq/uidxD53cknHyrxkYVQMAHqCME7umCOYurhV+8AAxIyxClmwm1cliCTk9RyO4r+f8diJtNc0VHRKCbiuVWd3dylJL+89O9kj4vAZHTy2Pta2MxWZ41258Zj6kZ1G9E/Z0aMKeHw8Xso4ehSUnZyjKV5OK4my6Hb+IPuCWIzjPHABznLLkEKMuaTGRjOcZxxgtjqcjHJDHB5wMjIxSzShhkgnJztGTsHBB+6o455zjLYLFTzSlnToCDwF2nAySFJzjJUng/eIPODjivlsRU5r2d0+zTs9NE1bpvZ3TV1u79k1dyVlft9z6dG7222d0tCKWVQxJPG4YH3Acjhd2Svp1OSTgHGBVJ2fkIQVJyQxIcMAuQjFsDBDFVIxng5OFokkCkB9u52O3aBsZQQoOQSAx+YHCjJ4xg5MMkgRclvu4XIJDDgEMMryckAnADA5JIAryptX1123eqellZu32btuzutL6ERspLTX3eq3XLvrZa3evklcqTXHK5G0KwDHEbBTjBGRngMuGyG6DvwXCQgAsC6uoDMBkKzYU9eqDJYYAPrk7qrSxFpCRuACl9+Q3mMGO0A4c5IyNwJVuMBWGDC2LdWmMkzbmGIsnarsUyq5ZCGBDYbjA4IxXI5STbeq6O/Sy6W11sr2durY0n0vey++y2s1r5r79LF6SQoiklgCFCk7S+WwSVGORhWYk5wzAAAnFVZsF49iuA0sGDyBkh9u0AgAEckMqkA7jjG0DPvZMMdojVmACsx+62GABAOASpzhScqMbgYnaMSKgdyTJAzBiMIMSbd2cbdxGDtGMj1JrOq7pN91bvd8vrdv0bV7ttO7L9bttafLRaX3to1a7fd3CXzfLm3tGFEbEdTuOMAs7AAEgFkJ67gxIyQJULL9nIKbDZ2TPmPBBKbVIxhVAGANx5PAwCagmUi3mDFnDAsMhuFChggIODkqAwA7gA5warEPLDE4lZXjt4Qq5fO0KcITjqWA2ttI2ZVlJXnJ3T0u/dUlrq7SV1pdWtKy6O+jREov2kGo6e9FpK+/LprorOzez97RGuhAYovO4bnGTgEMAdxBGCVClQCTzuU8YMcuWWRM/MQSoXgk8YYkqSRjA4JzkgEDBqlBMQFBy21CckEHcDtI3PgFeFCjHQAjJOSSO3lllfbIBkAoDuwEJhIAwdwyQAckZHByRop3jrvZv8I3V72b1d77J+jeis1rpbXz2Sd3dO9n3Tt95E3mKuIykXyjcxYFiwdFwu5MoyBcsSeNygscNiSPCORnkqHLAjG7CJzl3wrMuUQ8ZBJ65LQGI3OWyybpANyZJHRAWOzbjoCCHyuApzTF3RRuDnaoYhuA20qgALYZssMb1PKkhiwBK1CVrN30SerbulFK9r3V16+V1dqo7J3100dvLV2Wlna+19SwkhWMBmO6Q7N7BUTewU7guBnHzBcruA46jJcULD5dw8tQQxDsQwAJDAHAD5GByHGCQflqujCSIEMTtby9jACRCqnlgASMc7W2oCM9hkujWVGbzJd8Q3eWZFxIHAU7mzt3E4Y8H7wO0g/evmTWi5laLva6WkWpNXVrd3ro9LFq7tu7rXp21b3b077NPyLOwojKzru3KwDDLEnaDGm9hlCSfTuuQxy0TXKKxbam5QyBAoO/YBu2EPlCpBYFiCAQCSVBMSh5wjqxVkkWFgxkTCgru6k5fcMqQQVztOBja2ZVQMq4eVlYNuCmTbsVt0ilexBQrn5s846DGc5RTmtErWb1utLPXd+nldvo5NpXTe91r3s9b6vd+Vt9UW42EoDqcnCq+QqMCTkoFCkcKckDAHIOQTRtaMSEbWEhLMdqgCMKGKZwoV14VQAQm5tpUMVFOGRxBE0QPMiowHLEgIchVclQUGS5JdS/UqtXWEQjAlO0FVKKAuFJAULuO7c/JBBZVIwzE45iEueCbVtI+89Ff3W2rtaxWm29300SfMuzSu220rq1rtXu7f8BrdRvIHDJHgBwMHaECxhhuIyDu2jcmAcDqhU4AdFCrypHHGzFSuJPMG8AOgJXDrhWYNvZCC2c7Swbc9ZRwSArEgEEKBsbnJ2l1KruHICA9cZOBft1BkhIKsu5DkIc4DxlXDAIArDIwS45bjO6lOmpqXSybi/JJaWlqk1Z3vdOy22dlL7V7K70tfbdO0n0vv5NHPFFQKEwqu4VSAeuRtOBwTgZ2jjLEqQCQLSjAG08heQSWxjaAevJIB9B2/vZrFGBHzF1LLvU55ZSMKMN8owDgj7ucAdQsiuQejOxzzk5x8oBGQV3AdcAjOcDcRnkpKz06LRLRaW6X7uyutXprZN+BU1W+vm9WtLN9t2uqXrqTKccZyFHLbiV9c9gMYOecDGCADxBuUskgckLuUFScbiVP3MDpnHPKjkAg8O3twpXK/wB4YJIJAwP4WXIJDbcN8wPIUlAmzhUUAOCQAwUjCsdqlhjB/iBG3jggGrcm5K12k9UrdLarbq1qtElr3ajFJfFrK3a6Tte61a1tbvrtceEyxL5DK23HQH5kAJUlTnGQMEE9OoFWEK4+bIPQH8Bn5WyVyOCOp654BEAVW7HttIIO4A4UKSW459lJC5YHq/nO7kqFUFQSQzEqo3sMHOcHO7IbBA24JpPW7d3opNadFfS+l/LWz8zKUb2V1bZJaWTs1pvZ9btWW7ukyZfughSD3yegwpyCPnJKjkfTI25qNgSiqNw3uGJJI24G7OVBIXkA89sg4OA0naCN3GRkbcggAngckHpgFs5Y9FOaFbbhgCCQQw5GTuUkADJ6bT685XK1V72Wl9LWslFaNtO/p21drolR676p+tlZdb7vTv3bJot54ALMBgLxk98E84UlsnAO/ABBYLVyMtjGew64GDgELuwCDu6jGOg4IzVJTuDlVIZQyAk+vzDOCGOWHyrgDrkggEW0ZtqZ5ICnqcZ4wx6sc8kHA5AzkAk602lLVX63TVldrq1d6NO/p2ZlUWi6JtKSt6dNVZp9NVfdOyLUZI2/MoOCMnoOM4J4PvyMZCrx1qQMCQS205yOxPIH8W48Yxj0IOe9QK2MjaCSVAxkAE44AHbPBzk/KDhhkF5PY8hhkKBgEDAzgZxzkZyD3AJNdUXqracyWu+krP0utn/wzOVx5unN0Vt00o9dktGrP+89HdF2EkZQZJGMkswA+7hgQAPlz3HzHAIHJq5FxgAjgKRvOc9Ackhjgn7vA9CuSKz0dlBxjsSecbTjIyeSSowWBwR3IIq5Hg8gkgALjkbgcckA7geOeRj/AICMXFpPV3dr66rdN3urb29dX6cFWDfo3d/3npprdK+tvPvubcEuCgGMEAu+MkcoQSOpOMHkEgfdY4zXS2VxsK/XAxhflBHXAPqCDxk9c43VyFsuADknBG0cfLyuMhT155ySCcEdhW5ayMrAgcnngZXgKc4O0Dbk85JJO1c9vRw85Req0suvTTfs372yv3e6PFxlKM1JcqfKru/la+2/n3d+zPUdK1HG3JO/HPbkfdIByTncMc5xwRnIPq+heIngAxKc427g38I4+8R0BZjkqdwUhiW5Hz1Z3ZQcDPIGBkHouWwOOASOORnjKMa6+x1FgVKsMDg9ACcLnkE/MM4xnocZzxXu4TGSptLmfTz1TTe2zdnppfS67/BZzktLFKScL8yd9E3e2ttW/X+r/VuleOZ4Aqicgjvv5/iJJOSc5YE87jwcGu/sfiPcKPmnLcYGGJxuyOCfrjIJP3SCGxXx9aaw4xg4OcEbzwABx94YHGApHHUNniugttcdVX5gMcE7uccYPJGVO0nIPT0IFfR4fN6sEkptNJLSVtbxdns9b737Ox+WZjwNg60m5YdO7u2oJXaa67pvW9reVtT7Ag+JEoAIlOBzkMDzgkDH3s5YgkhQ3B4JNacXxFkIGJiR2wxUgn88Yzgg5A46jK18iRa++STJ/COrHBBwcg8EZGMEgbeSR0VtGHXm4BlIJOc5xjle/Oc9yBhiOgxtPpU89rdaju0luntZvr+d72fz+ZqeHuDT0w8bt6txi1umtFp30tv+P11L8R5gIwtywUhsDfjG7Dbflz93LMRn5Tu28AEKvxFnKtm5ZTnBzJnk7eDjJyMkkhgCOGABDV8ov4gJCFZSAeDnJzt8vAIYDOc5IGSCSN2RtKJ4jkDMu8lMYB38EkLuI+YAbuhYg+gbIwdFntW9ueSSta76ade76dV63OWv4cYJTX+zQWkZfw7KzULq9ur1Ttru79PrF/iNcMP+Pkg4TB3cDqq4bk4ZTnIGMEqTuzTP+Fi3G8L9qO8BuWbjngY3Ajo2OMA5x2wflBvEb7Dtk/iiBDb89QWIbO4DI6gkk/ewWGYz4kkORuOBt43DdtO3r82R8vUY756nh/25VUtKkraJ3d7pcu+v3XTdk9+uH/EN8E2rYala/wDJFtq0O6Wq193bdO+h9Yf8LHnOFFxwNxYh84B+UEFmCkgE4wB1wRuHzVj8Rbgs4+1NgbhnzCcBsnB2kFQpOMDAU7QeMmvlf/hJ23sBL8wAOd/AyU6k4OSSD1ySDznJEY8RyOzbZF4ABJZsgkhcAEAEZHBbO0g9S3JLPqyUX7STWqbvFJbd9flb1asaw8OMGkr4WCva75Fdp8vr0T1S0XS2p9Tv8RLkEf6RjOArFjkNksQccng5JOScj6VUk+Ilxvy05yeqhypGdvRgDk/MduQM4PGCQPl9/EUoxmXHIHLBlAG1jwFzyWyMDlSoDZOKqS+IpvlCybQoILfe3ZC87cglgMgkcDgcng5yz2rs6kk2tfeu9ku+miena22510vDzB3VsPT6Waim1ta7tZ69E+jenT6WuviFOVIM5I+Y8Ej1JO0AnhSMdTnn2POX3jy4cjdOT2GJGUAdAvXO4E5IYfKcE8cn5/k8QOX8reThAW3HEe0gEKQSEydxA+YgkYHTAzZtaZxjzvLfKkZYrhRtyMZIH8JyRtbGMgEE8VXOaslJe0eltOZ9bLZO3Te/6nu4LgLC05xfsIJtp8yp3XR30Wl/+Cktj1LVvFkjswFwxBBOxmYAZ5JzkgKC4I9SBxt4ryvV9WefcFbO8MwfJIHQZDMuASePQkAKvCmsW81Zi3yufTBJOMFRuKgnceec4IyeCucczc3rElmkJBwPm5IO0DKonAVQOgAIz3GCPJxOOnUs2783Vtvsn3tZrSyV1tbp+j5Jw/RwSg6dOKs1sr6ppap9ez69el26heM28FtoJwAzL8+AuM7yOM5OAActkbW68dfXuxWdyzKjAKUVi2SVGAW3AggcAsuTnOWzVu9ujk8g/OBu3dTwMsclghGOgzyfmxjHPXErtwoCEqcSZ+ZuEwF3sBkjGGxzkEAMMnzJ15NNJq9tHv2Vrq21v8tbs/VcspqnCDcXq1rqrbJarVNfasrr8SOW73kHgFlyyhUJAIXa+4EkgBgN2Rk5DDKDGPc3OZYowSNwDp5hUIVyqKg3jcq5YMSwwRgNg4onuIlIaThiUDbcvhiwKqwOFjygJ3ZwFABDVQuLpQR5h2qG8tNoBUhvLYruVWQNjBYglPl3HDIAvHPEb+8tGr6rb3b2bd079tbXWux9Xh1aN/PV6Wjt0bvurO33tIeZCquGmkYjON0ZyoAQtsZeqkgBi3UABSr4NIpfA80qwCAFhkq27CjgnCk4IDBcHd8+5lyaAjw2fNkLjeocb2Zl+TavJ2lWA2luC3yr1QEMExLBipBCD5RgE/MAcE7+SAQ+7BQnaTsORz+2dk2uW2iV76aadbJO7d0u/md8Zctr6PT16d29LNrbVaXJ2coyhmWRZWEbsFV/L3Bcq25wCrYfayjJZi4yRtLXlfDj5lKgqCMACNQuBuUN86kA5BCgHPVjmn5xRAJHCRvIAuDgrvUYUCMNvMS8YKhs52sOStS5eIxsiyr++UoAhMjySMqYxt2kKzHLgfeAyDkYHPKu0ruXvXTacrXdla2t9dlrq3ou9c6kuurWuq/ltqmn15b7eT2VsNvaNopz5IAeRHKSKSz5dlfmRVbG1nUBU2kDLM1NuCjRzRtG0m7Cxxp8jEMUAYHhQifKWywGcYAUNVGMs8cLMkSyoUUiSMjcFUNEo2u255CQzAnLLncpO2rZLDb8yIzRgklXULgjcd6nLheMdMgFAFU4rKNTnjqmlLstL6bXur2eltm3uxNyV1e6TWq1vbSzTSSTTau7u69RxKsVYylAEV9o5jK4XCNiQklRkHDFZMndycmB2EqMAQVIDHkl1b5MB+CyqMgcnpjGcVHbzEK6XBVpoXzvAQB4+EjkJDMN2QcpjhEXIPymo33gHAwXdXAUlQN207BgAHJfJGWBUDBTYaTqPlulq4tO9m7aJX1fbvpZ21LbWlte91du6jZ9Fa3wqz+HVNN2bcyFWhcFyVZV2hugckBmBKllOGUBQSAR8vJysYfBDKXjb94Ny5O5drBMluCjJyUIAOWVTkgtllKo7hC5VUdUAySw5VQSrEjILAkAZHIUgCmRTzBFWaJWdiqkpt2oGUGMEMcBxgCRQAwXcfmYAVhzxU7vXmSaVtFZq2qe71/4HS37yWz2Wsn72sW7NN6pK0nZaO+mqSXrtHZzM6YBRRiQbi5JUDBXaFIHCsWI2r8gHO2xchpLmYNJ5PlTEbPlDjYQoWRTgqp4AXdnIbHLKDUvi7xuQE8lAhUHY5ciSMbnJ24QlXKdPmJBCsTi7dkNd3Mg5Q3DlChwHXcMFQu5QQcdTnYeeBWXPec9NGoauy+a0u02/wA+hk3ZwV1f3pK6ure5snpbVyu1rve+pDKjyGBFYIXuISpYhWbYRkA4JGR0AHdRJ85yZ5MiRh8vDsSxV8tsfkkHqSCQXyQdpB7VSlWZprQpvXNxGrcAAlpUC7iCrBNqvtON4ABbJ+SpCJPOfcFXynkKsWJY7ZBgFn+Y8E5YKVc5UAHmkpPmlo1r5tO8VbRO11bW76PrYGpNrXRJq2qe6u5JLe+jV2133ZKzLKBJG+5cEEElH3KA4VgAHGBgZYkMMH1BrvMxhk+UkukgG0bST5e3aQSSGYkEDAwPmYEgUmJA0rM+QxUgKrYjIQFt2MbiShyWUMwKsRwVAiAyBiVACl8NnBJYHAVjhht46YA5UkdC6s+a19ElfXXVa6/LvbW/Q92LUl7yVmmrXa5oPq21otbWd7pXV0VbZZ4tOjt3iDSLLJNsUL5iRyIGBBypVsBivLk7dvAwDNGoMUbxuQuzAyRJuzghHCggMCcMQTxjkAipSGwQ2GUgnajOCpIPykYJLgNlhnsCMrgmvITCm1IdxBClUyke3CljlnGSQhb0XOduM4SiopResVFJWlZ2io6XVk/Xd2W6305rp9HOXNd2Su+Xvo7abXfkk9HMTgYIUDAUlf7pUqoXG7g5yCSRxgMcYcm9h8pDOuSoIBBCqvVFUEocAgDIUffxkAVxIRIAxB+RuwB37l7jKhWYnacAnqmM1ZUhwM5XGDn5ipZQpZdrFc7gCdwGWHB5OSnK75fJPs/hX9NWTulpswlZJK6XwpvslZPr3Ta3ta+vutNZ1BySwCkFSQwUsCoC7SQMv0wzYIK5IXoAowOdpBG8gAqQCEYKVAyCCSFIJAwWyOMB2E4BKjDL8obJyRyoKn+InjIIP+9SRqVGGUD+LeHHICqST8wBcjsrAbhjhgRSbd4766yte6aSs07dbt3drb9ibcy0Uk9ElKV3FLlatbz0af4JoUMM5PCqFGD83Py4IxgemCDkEZ6nlrSIjIzjBchUYhcqSQQMhduH5IOSR1AAU0AgL8/HA+7tAKkKEBJYneTjczdSMNg5LRMG/dGErkEAh1Y7kIQOWIXA2cAkEEB8g7QSG27cyi3ZLundcvorpdLr77BGKbtfS6v73RJWe2yvZa79NkWASow5UsvRwA2duFCEEqpyCTgAB8ncFPKhBwoGE3DPJG5nUJ+7XKsy8ABudowB/CDTGLKeV3ZK4zkcHack5YDG1ieuCQenFOVD/rcbjjaAgOANqnKhXAxlRuJBIz0xgGkrJO19rrqr8vV9V5Sv1W7uWitPtXdmuXWyimm7XTfNve943i+8iiR8HZyQG3OwYsQFBXYxUquQCdrBivJGTmrEQJU4Xaeu0kNkrtIOW42q2CPlUg9c966FsAuqCRgCVULjBwEBOWOWGDkZDAnGScm1gld2cABSVyeAuABnA7DAydq9GIzkUnezsknbydvdtp1t57babMu4vXVpattabWtb3mmravVWSa6FqNi23nHTa2AA3CqRzgqeM9AG6tg9NixAOWOckgZyRuI2ZwSxI6EcghurDOGrGjHzkjGSAcBuAxCZGQSwUdWBOeQRgDjfs0yyDJwwCbADnJKgAgAtkE5ODkDg5Cmtqd7pXXM7LVLXVab676rW19E7nPVlaD+Unt0tzWs9e+j17NanqXhaJo7XzY4/MmuJVSJFVmkkIH7uNAMMzbgAgBZmJCqAdtf2weBLSL9hf/gkt8a/Ejsmm+Lbj4eeF/2ffD8pVUuW8beJbW41P4ltayj7l3aeL/HXxEhlkQl1Tw/Y/Ni1XH8rn7CfwxtPiZ+038JvDup2ovPDPha/l+JPjG2dS0c/hb4d2k/i3UrKYHj/AInL6bbaHCjgJNdapBCCZJUz+9X/AAWl+Kdz8Pvgx+yx+yE2o+Zr9roGo/Hb4rxRyMXl8XeOLy9mslu4+GM0Vxf+JJolc7hFd27FQFUn9X4dw0cDkePzGVlUrSo4Shpd8kbVKrje7tKoqUX1ceaLufini06ubZdwlwRh4ydfj7imisbCP/ROcM+xzTNHVtqqdXESwFKM2kpT93d6fzsXc897PDEqvNPcygIkSyO800rAAKEDM7sxSONFBfJUKGBUD6D+NviS1/ZZ+E178D9LlRPi58QLHStS+POoQMpuvD+nExaz4X+B9vNES8L2bfYvFXxORXGdcTQ/CsypL4f1LztL4OLpvwb8H6n+074wsrO61PTry98OfAbw9q0MU9pq/wAQLK2il1Px7f2Uyst34Y+FFteWWpBZYza6x40utA0omW3stZgh/MX4heMtS8Y69qWt6pe3eo3Oo3l5dzXt/cSXN7e3V5cSXV9qV9NIfMnvr+5kkuLmZiXeSQkgjFc2Pxi4fy32iklm+aU3GkuaPPhMDNcsq1m/cq4lXUXo40JOTX7xNf0FhIxybLaFClH2eMxFCMI20lhsI4KCutOWdeKVk9fZar4mcpqV3JPKbif5prjbPKx2AmSQ7iCNxCHG1SpJGMEYBBrDllJBYHJPIA6nC9CdhGRnJIJ+YAgnHNy6kIMWCpYQW4QHcNo2ABfvMp+993cRgZ3EDnKeVlywVXz94BSCrcZyMgdBkYywzkAgNn80c3JylK8nJtufVt2bcrO+u/S9raNHHT0tLq0tv+3dXZO192921rtYsSO04STzR9qjR1USNIouoiJCE3NIFE8aALHkBZAVU7tpV6XmBmXcqwsG2mNlOQd65QqHJJLEgpLtO0Kq5I3UF5B8u0ZYnacgAjgAhl3beMEEHGR/CSSCWSedo5ZVCyGElpNg3ygO6rI7Ny8jYyJNp38owEhxWUqnNHm0c1bme6mk0tX0d2vVbq52u1SCk01OCi3pbmUnFaq929VfVX007PAMm5dpXIbhtgAICnYvy5JViBjaOCRwCCassUT3Fr5pJj+V3UncGkMijhX2qEIUKW4OM45YZcAuVxlchZHG5hn5tpOduAN3QZJUKQSRnDw/mXMG0nAlijyQc/fUsdz5JIG2POxVY4HU8jacVp/LZ3/vJrTTTvdPoQ1anLo7LZWVuWOi0V7Npvps9W0yS4QfabgooAFxKSEO3I3YCgKz5B2gcZVjhWIIDFzcpggkmIhlyeCdhJGATkYAAJLKc5IDFgy4aNZ5n3nC3EoQKzHBDknBAUkuBkx8r8o55BEEUrFmd2BbJjEQHlAY2jJXKlmk28Fg3UhvlAobV9VZu6ltdXa0T0vva+tu6Vxw92Ebq94romlflvutXqvVJehNJx5PJDGSMKrMwaQkqWAAyuQVQjacKcYOxia0JrmS4lleWJ45PMkDEyhht3gAjIG9mXcQ3DEAsQFUE5EqqhgIOGeSPPzMGUgf3F+XbtI4JJ3hSpxjOuzOstyBhl86bcCDktyMbWDMDggK+QcglscCt6LfvRcrtyTtHlV/dXaz00WjenfdawT5pR72btre6jpG9t9E9LdWTQhV2jeABGpCDIYgEZGFOQcc5LEHLYb5zVyJlj3LuVQ3zhdwIBYIFRGGMEE5C7QrMAw+bAXNWfyyqBGkY7RtX7+NyncGxgZLcqW2FcjBUMKvBpGRdgTCYk/1attOMlFCnCkqAp65PbpXo0JN6tq94tprZKz0lt5aNLyTV30U/TXRO922tL3d3azv5O6dram9YTz+aqDZ5RglJIKiUnYRsJyhRzjKsB0JJYEkjoNOuHiZSFyMLkEsME7TgggZAA+Q7iwD9wStcpYyuJ2KINpgl+ZgC2Nm0uu+QkL+72orDq535BwNe2nCqIyMABW3YyxwEwCPmDEeq4JBDBuQa+jy+qo8l27qT5m3dX927WztqlZLvu9Duw7aeuqXK91a91Zpd2undW7M9P0nUjC33mOcHkqFOGRl4+UDLEruXKE5C7WJA9E0/wATNGsbrI3H3VVnCjJGGJGAFByCcNggjBIArwu3uRIihwwPGAwC4GFxyTwTxwNuVwwIZcVvQ6jsjA3Y2hQSMY+UKuQSVcDHcY78ZAA/TslzyrhFHknZRa0Ut7cqbdtk9dLP5WPpMHinTSd9FazW+8dLLV3Wu1ltrqfR1n4slEMn7wsBNDyrMNvEynK9M4O0988kAYxsQ+LnA5kDMRwMhc7iBtJ5GCzAD7u/GTwa+e7XV08i4KSdHhV1YfKpxJuIxwy5UgOx+UYDfMRV+PWVX7shweQM85JU4zjj73IJIIICsQCG/RMJxpioRgo15KNr2c7aWSunfW1r9m9ezf0dPMZqMJKfxRTV7K60T9G3db2sldn0NF4rkYhlm6rg5ZcAscnHJAIORxk5GBjJWrS+LJVIxMCMYIByNoIxjIIG3O1QOuNoySa+fotbkULvOQAXBzn7uAx3YPIycFRjkk4PzCwNckZeMY4CncTlSB8o6cDOeAQQMcnFe/R48xUUovESVrWtNtX9123/ABv/AMHqhnFRaczs1prbXS6StfrsvLyPoBfFr5YCUHAC/eDY29V+6pUEkbjnC8bckYDW8YyNHEryq3yMF2vkgLK6ZAxuGAD8uchcg8BseBprbE8tgADJD5A5zks2OCTgjHzHAyG5EqauWjiKnqsgJ3Mc4nkzgDqp6hsHON2cA11f6/4t2SxErNaXltrG73evn961E81qNxfO9b63slZKV9N+jfZ26ux7mfFshAXzjk4xyOhPQ5zyCcdcnqOMNSDxWzFv3u4ZcNv464wTjJAGSCORnoT1Pho1XGBvIJ5CkjK4AJJUDggepI9AVxhBq4YkhiOMABiBuwp4PykgnAxgkZI+/molx3i93iJX005nrey3Urvp+lr2H/as0o3k3ompXet2ttdb3S0u731PcD4qkIH7zPQMSQRg8AY4KglgF256kJgkAh8WMMgSEAg8ZGDxkBSSMDlgAA3HHDg58MOt9SW5BC7Tnbjg5DNk88jPUdDhjlo21nKht/UBQoyWGTgEkjBwCe4wOpJBrmlx3imre2lo3tN90rWutOq6rXYTzaejc2nZN2elnb8L7v8ABao9vbxaxU4lZR82SWyQ2SAFHBwCQcjgdhnJqnJ4schiszAqTj5ienHIHJHPqD6nvXiTa5zhWyQCxcDOQSpx83Iz0bYCDgEAYzVWTXGK4BYljzk464BJJA65wQemMDOMjircdYvlaVeT7OU7O2l9pW0XW261vo3m82qW0lZaO123a93s9PnZ2t2PYZ/Fz/NiUK21hjc3BycgBc7c7gCSQpOeK5i+8VSSZXz8huWIbheudvHfrnJ+bgkZ+Xy651hmYqGIB5GOFBGDgDGBnPOOMKQp3Vi3WpyEbRkk5G8knGdpHdWHUksBk4wF4y3zWY8Z4qpTl++lZ7Pm2Wy09Gt3bTs7Hn18ylK/NJpbfE7NaOys2/xVm9HfVdXquuvOXVZNwyQeQMHAwpDdMZJI6csDkkGuDv73eWGdrN93cRkjhixyMjcOCdxBBOAACTSub1jnggEZBPIJIGD/ALK5OcdDhcNuArClmYsS7FnPU8424AAyPvZPBwACVB7GvzHNs3qYuUnN3eu70+zZ3V2r3Stvr33+cxNeUpOTs+930TVm+r1tdPV62stUy5mYlmzjOcckcBgQOQAR07dyDxWDdOwyTh0DgKnEbBfkJ2tgqxXkBTgMTuBIAAszStg4+Z1wCoJB2kj5eTjH1IPc7hjGVM/JIODjJOAcZHQAZIGCNpGePu5G018PjqvPezt0durbjq29G3rZba+SPHqtSTe3a1r9L2S0ei9Hu3ZaRmUNhs7QqYCnBIOUYGXGNwIXlMk7lONwI21iYgCqBCuAxZRwQTkcgdwAQBkbuh3dGtIyjGeqkMMNnkBmJA3MNu7oeh7YOTDIzEAIuF2jDAAEZxgqp2jB6H5eGJIOcCvAqSsum7aVrvZX2Xa38vS3nxO+qX2mt31SS6q/m1pfQqzyO5IRGZsrGAdp5yhLLuwWwW2kKV6hWYE5ESkkJtf+EbiQWO4Bc5OWJIBG3BLbanfDqAQBlRkZbadgBXLZKnJIUnaSQcEEjcKzy/u8RoNzLtWMKzYICgkE7R3AXuMlTzyfNnJqTd20knZvR2abTunpuvVJdNIs1JN6pJWu77W9bq60d97/ACjkmGdgX5lUMT8uAAU2jLMvLZIODgkEEK2BVQSLOCd2GDZAYBGQjBAAORgbjtyxYgDeQFpxkGeFkX5BHgvGivKQq5yvzkA8q5+YgAYIUFlLqgGBGGyoKouC7fICwI6gqw+bhTwCMkZ5nJvorb20drcqTT/Xv66na+juk7L0v03skrvzfe8BV0O4fMELvIxYjzFVkYZRmUgoMnHIBwqgHc1KHEkQZBgfaoC2cI+8K5YLsyFKbvmKgLkhguTtFoMGI+XaoRTtJUEgcDKgcAcAnGRwCQcVA4zIuFIRniZjkr5jbZsH72CMkkKFAOSByecp3tZNe89Y+dlqmldd2tW9PUSeqvbX130d0+66XsutnbVt0oEErA4DI38RyCFzsGC3BJGR3K5+624WZI7dFtvlTLafYuAr4+eSAZLElSXYvliAA38OHIrOuVh8syKpEm18Bd6jLLIXJztUj5gpIKjgR5JwToS7SLUBWANlYjLN0HkDc2CWyCRkcA5KggqFcypP2jvs4wS1b0eq3tazS7/eZyuqtLTS076uzXLFq/d9Nd7bkbKVGVGdz8gADBzk8jkqCAdo+bDYxkndSug28b1whIBfABQg4AIwRyrZ3BQ3IJGRitCQBUBBCk4ALHcAQVBIYgEtyArZyRxnGMVS65WIjzFYDLGTCkgpkE/KCxb5QcHOCeGyRrJJ6PS70b7vTtr59UrdkzbVNeT6+Wr799t76WBpkjjDtwFVQMAfMByADtIYkD5TkbhuOCaoLI00krMfJYMCuSFURZCOv3tgckKMMoDAEKAcATSnMwiMW4MpVQ7EhcsQcquSUUHkYXyyQx+UhQ0ReUNkcf7zBO8rGcoNqORtKkggMqjIGNxJ+bNYznOVS32INc1/tXsld2vZrzST1vdWVJ6t7tNLS+7srbab9bJfgWY2iBPliMq+7cqZBbcR/ASTuIGepKZ2jgth7tlSRggKQAFBwcb8soJICj74LDbktxgA1UZ/MIMYigjyThSGkA2EICpLKQo9QEG7cWB4jOxQ6qSRJK0bdSYw2CAEGAHJ6jeTtGSRlQR1Wkla2nVWUmlF7W25nfXe2zSY+aNnol0W+94210au1u9u25ZNwiRhHXDuMMUVGRd2whiMlt5Ulxg7nwwUBgQKzKqyj5i2CASSWUFmBXzGyAFIbawG7oM56G/HEqRiMDaU2uoJV/mAUtJ8ynBO0/Ioxzjg4qOAC4JchkKsWx3/AIWwAwfIzhZDkkNtGEIXbM4yfLFv3m1ZWeluXqrJN72st10sJ9lu7OK6dLvTS9t9Lbali3t4onJVSG577vlG3lCTsUEqcDGFU4UL8wp7kSnLD5EYoEyowWXaWJA3cElhjOCBngE1GZFikWFSckFmCuWwSVUDazKTuIxtQgbjj72QHIHlUnfuK8glCWZfk67l24JyqlQNxyPvAZ2UYpKCttZrZX92zd2la9mrW1v21tbJXvbppv7ve23/AA+qGobaIsFYCQkBvmO987MIXYDDEAEhtxLbiSSCamhn8l1jeQDfKpCKGaVQTHjaCM7FBP3VOSCQp71rhB+5VQAZJEywDA5HDyN8pBIHyElRkgFdu0Yu2kCLLGSrKwKKzHfvJUrtYkHflvmIIHKAn6895tySjGKWivpq4p3tre2/m3dNO6J1TaVtOnk+V3te97PtqklfXTKY719wFIBwCwG0gELkkAksehzlsjJw5SMdBjG3OAM9PcAdQNxAOMZwQCY9oAD4wx67SRnow28gDKjHUr77TkIhLBSOSSVKg88bRk9TgnHOcgjnKAVyKTUm2vktFbSy20+Wyt8/Dkrrs72dumz07Xs/LTyJg4AOeQp2ABSSGcqcgryxO7JBJHBOSARSJJuIQKAxTJyq/On3AVAbIdlBOAM5J2kZpRlTkEDnjdjoNny9eOO+PoADgBDZACbwT8rFs7RkcqDtHzNgjPTLbeel3bV7rdaWe/utd7aPeySfdk+78Nne1k230UXtZLVbp32THKcYDEALgZI2g7tuV5ySwyOMAMRkjJwTBbHBHdRk4A2pg59eDwCcAjJXu14lcYY7jvyMcHdj5du3OeeoPXG5iOakYlsZ4A278A7iMhc/eKgcgAfeySOVOVpNppSVuZq1rK/wtu2l9Xslrpda652slZu+t72W3K7+rd9tdLW0AFSyk7t0mM5+4cEFmKlkCswGxSMkcgAHoEhD7EgL8uCAcdeuBjqRlgVAA4XIQyh2GFIJKgYKgngcYJK9Nwy27hhzkh7EBfm643kgAZPytngkbc4+bqM4AzTi7X3vpbqk9NL3Td2u2qas1cmTva1na65b3ldWs9l911rd77rkHG5GPygrkoA33QrMw656beuCQQD0sJKNwQ53AZPUcYXkgglThsZIK9gSRk0wxPIJBOCASr4UhSOTt6/Lhc9zuOTilQqrhjk5JHTIyQCu5uApAznJPQdT0pNq1uW/dtXt7t1v6ad27WuTKCad3rukusly/JLfZu9lfpbQWbzFIAfI+Vgw2jjBxgHnI6ZO75eg5qxG2SGGeThi2SGIHUIRtBHUHPBHynBOaxcqArMPmI25LDkbR945HGPvEZBA5BHM67gucqWBAIG/DYwTkjjA6kEDC9cgkHWMmvid7K7SdpK6jdaNa/N9Labcs0le3up6Jat9NbvfW/kttyzDlduW3EEfMdwB5HJLc5APykAcZBAJFW1KlQytnBAYYbAGQOp2nnr/ALIb6AZ7sFVXZThWAKowVpNxG0scEAYDZPTAOB2qzG0jhAwVdoG5QflIAVlXeT8zYILDJBIKncQQNqc0mordW1ve6bV027JabX+96HHWpvl53or3bsu68ry6Welm73768bhSQQdpGAN2Mg7cg4wAff8AhySe+dWJxtC4IZQvUjIAIyDkkliCMgH5uuO7c8jngAHqAWzkDGCDjngsMKeCMAdFq6knAAJUE9hyTweQuT82Suc8DIXPSvRpVErapPdaKz1VrJ/iuui01PMq0b6Xuu7s1ey0a117rfq9LJ9Rb3BHAyQR3IK5O3PIAGCNpHB25wCO23bXYBG5s9AO24Db97Kg5J5BAGTw21sCuIgukLFBIGK8MoYkjIQEgY5AA5UcAde9atvP84ZZGOAOCQNwHC5Lc8gevIUAHIBrrp1b7Sty207bXTte/wB3a+m/l4jCJ7qzaW6te6jZ6a3avfuul3dd7BffIoY4HBGevBU/MTzzzk854BHWtaDUR8oyygLlewyT3LFcqWIOACQeWJY15/DdHYMkHpjrkD+9u75Hy4OCMjjPI0UvHGAq9MHJxuA+Xg9zgnJJAweSccDqhXdrJ6p6Jrslorp62t1enpY8OtgItuLirX6XSey0a7dHpd3t3O/j1T7u5iCegDZ46gkt2DBcllOOC3PW3HqZXHzE5GSQScYxz8oxx1wOSCSDgnHAretxllAHysCQuCCCQQMZx2PPCgKCOliO+Y5TJUggh9ykN8qY2k4wCfwPIyO/THEuK1lo2vhd7bK1nZ3t2vvdq7PNlllPV8u+r2v02T7Xvpv101foMmrH/R93BG4BiQAxAUgqWfBwwJJx8xGBllAMX9rndlnJDZ5yTnhedxGVORjnGdpJ+YfLxEl2pERGB9/kscPtVAQpYAnd1+X+IY+8MqLfqE2LkSZZmbcSrAAeXgZ6DA+YgBtvTPAv60+Z3dtvtJ21V9umutrpPS+zKr5TTbjJRWtOF1azdowS6b2srd9H2O2fWDgDByksW7PORyO+3gnjod/UAHmnDVCGLFiQR90EDIwuTn72M5yGPA+VsjgcOb4sFJb5/NhCE4AOFOM5ySRzxwSOOCoAe18oLHdnJIKnIA3Hbkc5UYwQSQ+CeMYpxxL6yb2V3e+vLZ2d7Weiunpe900c7ymHLH3I/aumtb2jtdvVr+lqjsDqroQAQd/zBBldhOMglThQFGdpzlQNuSVwi6ufMdXfYyopwW+8QR8rHhTkAkgcnKDI/i4k34BKhmLrtDDaeFymMoSBnJAyoJz1HPzRfbG3SlRniML0EuMktuB3MMEFpOhHX/emWJd9H7q3d20+rX3a79lve1wyqO0oRu0l235UpNX0utdFrfbc7v8Atjcock4AC7d5B/hXILYOBu6gZU5yOuab6oxwFlAUDG8tG33dmVJz8obhQBliRlA2RnkheSKeSWyCD6gZUFTzk8g4IIOOScNzA86uynYoGTt5YAElDg/fJwcBkzwMEcYyniW1FJ3T3s35W1tbp5LVW0NKeWU023C2yTSTWlrbbO+2tzqn1BiCcsQGz8pccZXkhskhuOg67d3JOa7X5IKk4JyAzdlITaG+ZmIXIGDkEnKnnJ5U353MQcMrgZbkMQF4+cHJJA44yo5yQM1XugZdxJ3BWXcHfDZK4ynGVXcUwBsQ7QQCCaz9vLXV2eiV07bdNElvpsnfoehRyxaJw397ZX6a3XltfZ/I6Z9QUksjbgDt5J5IAJyuc5AwSxOFONpIyaypr0/M/UHaQFyACAo2kLk7iePmY44YYGQ2LJdFQ24qq4BjAALbsA/PvKhRhSwU4PKkHg1Ra6R5EDszFUbAyNoLEHcygA5BYDO4lSoPzD5RlKs21du+m7847O3qrLvfTVr2cPgYxTdtdNVr/Lpqlbt22Lc9wJArqGTAwUZgrKflJztIY7sfKxGQxGV71nSzZ3EhlHQ7js4yMEjawyMZ34xuHOBwWSuDkbnGF4PzEHbkqSADwRgDDAjPTjjLmkZyPlb+H52AyxHl8AOejZySThsAjLDJxnU5Vayvo7NuyVo9ves3vtZW6N39vDUY6abW00291qz6p6eemm1gdowoTdlSWIxlizHGUbOcgbgMlQeS6qCRipnCYdwuV2gtjYPugDkH5gHyx5OCFyTilB3M7EFsL8+HKqM4JK52nggBSCdpLfwkKIyQ7MmAdoyRnK9EPy4Odw4OMZA79TXP7XR6q60966X2X3Td1d2s9L31tf2qUnG3vN6atu2nLHTXTTW9vWz2VZpxHldrEYwGGw7l3YXcWO9iD8zHCYQZYKxAMBd2IUgGQMQSq7WKJgb1bc29CcZIAJO3IySwsCdWkaMMNycshJG1jtAJ3KDySA4HClCCTnAq3LqwBdmV0YLldxKsf7oXaNpLAklgFA3cgNjnlUbSlzJ9lfzjta2ttGtUtGr3OuM1s07tKzvf+Xu0ru60fVrW71ilJYtLFveRXYBWI2MrDcUILxHH7sKMJwSVBKkkV44i0rM/ymMIkgO0O6ZVlYAZeNFVtpYtlduMHOKeCylldVKBzkdQEQouWcF9yrng4BJ2kZwN0RbcZcebGIDtU54lPyEMOEdlG3BVcgBk3YrJyvrfS6ur2s1bs2+l7vr9ytaa6NWV5Peza0Teyd/NtX1to1iijQyIGlKBmkQEsDFw2duWXcpyMHaAPkGEPWdXYBcKFJUMN2ckcAhjnczFfmI2lgxIJYE7qkjFVEmWkLFJG2naoBxvJDZAKkBt2AME7wQQS8FTtYE52DKcHK/K2G2qwLEEg8kkDCbV5EqVpOK0sl62VvX56/gN6662vq9+iWl2r6a6NdugsUofJhO5PmDOFBG5ip2bdgJKlsMcsq9Y+CArZzEw8uRPMdV3qinBAUY3krtXBLKSGxjA75wk8IkiCeZJCoIbdCdgKquWT7wVVYY3ngZ25zyKbE0a5jjXEaIBFJwAwCpgZLMHySTuxgsCSwAxU8z+FuN3q9b3va+m+r1V3a3zZa5eVvmellyu9rtRTvrbd6W2VrtaWFf5wGdSZP3y5JLqu7BGSzEFchRg5YkqASQVeQCxJfKLuRRufjO0Luk2gAKW5BBZRg4XjKSxuAjDAlWRdz7ckDfuLnaRGAuCFcfdVvl+8SY5I1YbGBkAIYqJArHZgHcygYLZX+LJAGORU/C3blaVuXbqlrf7777pvqClrZvqubVN392z1kr/AOGzbkr2dndbo7rSXcwIWLKEHCnDpjkglixb5WxgjJO1jkSYkWVjnzQzBmYhQYmLEsQzHDKCpIAXuT97rTuhItrMqglRGwQEsNqZTpyV2gDGcbjguvLGrMe/auCJHMQZyysTjYFB3nAPzZ8sgBTjLdQDCbcnfdKDvdfr32Taemr3uiTfJF6PXV3V7Wg7XWjT16NdbJCTKkklqjnGbmIrsdQ6qCpDElv4yeqkc/dVSWyrELIwGQRK6gjKj72fceoJBwQCRuYEU1z+8g3cr9piYkyFGBYjIUnAJ68ICFycAFlFOlbPmSspjQNIV3FT8ysWAwyFgMtwhUFRtZtoALO7cm7K6aV1braytayW9ne3loK9uR3Vrb2i9XKLdknZejdul7q6ZyrZT5z0OW4zkA5IwgUnHclTkcc4RWORvTaVIIxtXJCpj+8QFwpJOFH3gpBIpoPILMCJQPlCBsDKA7mAGScctgkhiuOACBcOShbDKd/cF1I+ZQGO0E7cHZgZIzsovs0ttLu3Szskttdel1dt30Z0Wl+ztZaOF0tL6x69W9el5FIU4KswZD8ueGGQdud+1ducA45YrtGCVEbyZCnAUMoXaQBgEgFGGCA3QrkjO0MD8wASbdHF5qGIMQpbepZXUEbgMfQYzljuI4HNQiQSS+WQjIVDxuFCHcrKrCUEllZmXCdGG7+EsQZnNLybtq3o7tLvor/jaytZJpNpOTtZXu2laK5bX323srq/YUorYYfK+Vbd83XKgqSoA+bf91hgkcbTVhSI4w2QByu48tnKngkbmGFPIUFQBt5AzDIpYhg2GUrtOTwAVIz8pLBgckgD5VO4gEsrykhxg4IGd7AvkjbtyCowDtILjO5CTwTRu21q0vuVl0010Xror30Q3OVrNNKytq39m70e/W2llba7QMHOPl3bWVcgc9VXcW3Fj1yGVQGxk84qJg4OHB3B1CMoHzLx0yThcMWZgQxPzFRT0cGMSuFhZcqyjC7Su0DozOrOBnqNxJRlI2EBdBMucqXQHBOEL5XGd4wAexGWwMcgfNN0rSvZuySavZy5bKzStey0ej0fdBHmSd49bXTXu6LS90tdJaLl+07XcRDkleXV9u5SNhQqdpIwSeB0LAZdcLncThqrmZWDk/IQwO9Q20gZVegUgKM5G0c8rwUYhcbiQxkQDsRuAJCFkCDB+ZSMKcnIzgq0OS27HyY3Kr/fDPsb5jkEKWwVAyQcAgEYNaaK2yv1cr2jK9rO3XVqS13abZpFNq78ktd0+V6NNtq21rtX0asWF+U4AJLsOASGVgoJVgCVPAJUAEjGQQrFRJHsy2ATk9ywOCoIG0bc7QMk5BVgCBgNmooHzIru0eTIAQ52HOBHuDA7XABIABJC4wTzYQSnaN4xty6n7+MqOC4BOAuDjlQGGGJDU1K9l3Wva1o8t7PSyvv1XUT0UbyXvW6JO3uWkt3fXrfTXl3JlUoVBOY87QeO20jbhSOB235wGbvgWEJJTb8oBDAjHK/LtJJ6knHIHJGCPmyY4lIOCRgk4U884GCNxA3Z4AAGeoO7irO1gMkrwVDFSuGGUxyPnY43EsF6cldwqobtvS9ktlu1fZW0008ut9JlKKvZ2ul0Sb+HRa8utuiV+zSV7kXLKWIyQPkIHzEYBA5XJzyNxJB+XJbr02iQGe+twUbYrGQgDCgIBwVPbd0LYyOhzwObiDM2WUEkAKzbidvy4LHIYBcn7oOTjg4NdtoEDxW13dlN7eWYosAlmkcbQsa7VZpCxC7QSzMMAcc9uFg516cUr6rr35VZac17q2zWt9zhru8VFayqNRgrtu8rJW66620sr2S0P6G/+CJHwps9S8ReMvir4gRLbTNd8T+HfhvBqF2EFrb+C/BzwfGT4v3zSSEKLSKw8N+BdBvGywMfiKSBly2G+Z/2kfijqf7dv7Z3xa+Kl3qp0fwRea3quonXr+NprHwV8H/BsS2NjqE0TbA8lr4ftLYWVgSJNU1zULbTYVe71KJD96+Nf+MF/wDgn5a+ALaZbH4n+L/h7pPwvjig+S+tPiF8bba2+JHxtnYRkzC88P8AgN/CHgV3RfPja4sE8xWZIa/Er4reO4PhL8OI/hTo0yp4l16S01b4kXcLAzXGoW7G78P+DWmQ4/szwrHMNW123DGG78VXMKziQ6DZOv7XmP1LJstyrB4lJUstwjxmY037s6+OxE5SoYLZPWfPKTbbVFcyd7RfzmVZPSxniXnvEWYxU8v4GyjA8FZPSdrVs3rRhnXEc4LduWOxWFy2tVunGOVVYO7ST4X9pz44/wDCxPEUGhaHbSaH4F8JaZb+F/B3hlJA6eHfCenTTT2WmzugKT6zqd1c3fiPxdflVbU/Eup387jCwxw/HdxcMN5C7lKnI5woI/i8vcCeDsLMdud3KjImurySV2kdi7yOzyMTucs3zSFgSeQSDhiWBIOTkgZLuWDZkIwrksAy5OF+X5dqjAJA2ZJTGwls1+O5pmVbM8ZWxdefv1ptqN3aMdFGnGN1GMIx5YwgkrJLTv8Aa1KtTEV6mIry5qtWTcnooqzSUYq9oxiuWMElGKSsttL92dnkqucG1g7gEYA6hBgE8Erklv4SAxrMeQMVAPACtydwOCOcEHAO8KpIBB5wRwbV0zfuckYa2t2ADsScAhQCFyo/upjG58MVZsiiW25DMMqxwrFwwj2qSv8AwHHXGFyQflwa85y12erVr/LXW19Xro9dNEFNNpe8m1ou7bdtNO27t/mKcOjYfaZM4IJBDKFKqQh7EqNvQllIOGNDSRn7Mm/96toN2d0fzvJIWG52wDGDwCGQbcqwYMQzJAyoPLYUHgYHGFVctjkZJwOjcg4WWbzPMgbYodrSMPhQpAEhxhs8gbcBiSSx2sWXkZrac1vzJbJqzbfommteuyOyDXJO6u9PS3MrL16vR+W1hC0jMrMx+QqBwcE7VUHjB3rtBZm+8mcjndTeFnhbPJkQsQTtJLRkMGC5A25wN7AnoflApufKI5DBtqsBgZYhDj5W2hwMhQMnGCpAyKUli8ag4/eIqFtvALJySS2SxweAQ2ACAy7inKztsvdtfRt6b7J99XrrYjZS6W00drLRa9no1o7Wto1ZqWZ/9Iu9oB3XE6rk7gSJThSWwuOMgj5m6g8kVGZCqjdzjAboAqEookKknf8AdBPRugbGeWTjEtwhYKRc3BPJcFhIQMMwwMk4JxsONoOeA5HVFUqpc8I2AQmSFDElzls8udwDEbSWwwxUWnrdv0slo42Wi2s2+7btqtDSK0i9vdjZqztpG9r3vfs9FpdaavJZWtgqFh50WEYK25soQ2FIBGQACWyAWVFYE7dG5lJvro+VtiFzKAwQKVKsCC+9yGCqDIQCXDEZJPyDJWNWlhVtwVpojvjKFlYlOhOVQYZuABg4VG5Y1enVEubpUDbBcSuVYlwsnmdABI2A24tuwQD8oO7c9b03q2rJXit3dtJWb0vZ90221dWLj/Esr25W7NpaXitNNNktPJ33JoniVm8tVTzCshUM7F84IIKtwMlOoKgjBAJyNBGDD51PTc2fl2yArheSzAfKWwFwyjfgZ5xyCwDoSJRjY21mOOWaNs7QFO0YHTv3wZY7h1KKI8MzBWXlUVl2ZaQlsAEk4O9iq4zkqBXRCsotRtaNk01azbUdney10drq2vc3Ts1e1naz01eltdGn5rR767HSWpIuFZjjFvIQWbsEY5JGCWAwThsY2lgfm3SW1yEbDOSFUPySQzMVIO7hFyuBkfKck5Y7lrPtpT5jvkAC0fk7cqVAIAXkjDEbQ3G05+cAAMjkO7AOCGZg2QQY0K5UbztZcAYKKQSCWEboK9nD13FQs2rylorJbx1sr6PVtK2i0VrG9Ko001Za63b0vbS173tqkt7tea6iO44VWbk/PwAMYK7lO3JAxyQM5xkY5rTF3+6IYHkxgcANjKhsn5izd+PvADIyCa5MXZ++oyqYQgMGbHOSCMgkAEFmBAJ2tkZIstLIF80Ovkkxboto3xkGMlmKv8xAJBGMDhh97A9/D4+UY6N3S97XRWS956+WvLotN3oelSrtJrRq7ulrtbr73bS3/AO+gvGS1uc7iglt2Ygl2YASAqpVgFKnJLH+HJw4PD01HKqyEsnYBlAAIBAAXoMEkDJXIONw5HJQXBa1u2ZlCh7cFT82BukJyu1QAQG2s2cY2kHKgkV433FYFASAzLhsArhW29AFxksN65UheTXtwzWS9krtqUOrtazWu+1tdEne/ZJeksTNwo+89YLa6WjXZp27u19+53CagVOVcjOAT83BG07QAeoAH8RGM7S4JxIuoMQMNhSQwPXK5GBnceegGMZ77GII4wXZCncdo4I3YAVRsOc/MM55UFSOODySLKXTgKdwPQHAyMYUkjagBOG5KkH5sFSucd0M2k7JVL7a8ze9urSV7Ky7ffbRYi1rNvRdW7ppWvs7ed+2p2I1Fd2WY54VQCdwxjqCCW2j/dIxg8EEPGpN9mt3BypWYMFw+QLiQZCjcwGcgk5UHggs+4cf9pkBKrjaSCxJJ+YFTtI3bQ+OnzdCCoKgJThdMba3AIwBOGyCQWFwfkGMKQeBg43HCkKM1os1qOSXPayturbwSbutOm3W1txPES5opvR6PXeyVk9k9NtL2Sd9Xbrv7TbJCuSAwAXJDdAc4BxnBJ4YDjqFFNbUcjLPyRkHABGCvXG4jkAHPytwTgYY8h9rYYGOM4Ck7QAdrHdtJJCgfxNndjbkYFM+0uGLFsFuAMbVAIXjAYKCBnJbOBnAw2ar+1Kul3fZL3tL6dk3fXdetncf1iSur6PVq3Vcr0d7tX630dlboda+pngBgTgHd1bGQNwJbkgfKW6nJwGIFQf2kyk+ay5GOcnkAKcoCWYtnHzcA5yQDgHlBcMnG5uGByc46gEYwT64UE7mAYdeVa6IHynn1K92wOM8AnjBAcAEhc84ylmlRSj79r7Xlp9nt29LJfMf1iSaTve9ndtN7PZXa87bLX06h9SYkKBk8tkqOOFU8kgBsr/DnOcY34BrNfFgGB+X7wJbIG37vzEjb1wDg4wCMNmuZe534JbgAAnIG7O0jcxwCD2Iy3PIDYyz7SccscD5SQTkjKkEsckgHGSEJIxzuArmqZlLrLdrb5bJvZ9d9dL2uROs7p3STskrpr7LUumu12r3e2hvPfJhstnbwM8E8LjluoJI2jr0BCsFqhJeB1LZBHAILKJAhK5cZGcAHC59drAnmswTs2QwwTgLyFGflAOSSCeMhl2k8B8suTWlnKqGI4wAwVsHggu5xkkYJ3kjJ9MgY86tmEpJ+87Ps7W+F3aafnZWeunc5pV3a17J8q6LV8rad9tr237J63tyyBsbl3KFDAgrlvunaD1bcPlABC5I74NZ09xsAOVHQgnLcsF+XcxBzzjrj+EHPFRvcvkgKCpwSS33chc8AMcAZI2kAkkg7eBnyySbBklj8pAIYkrleSxBb5cbiDg9VyRjHjYjEuSbVrvVapvTlW+muz0tG6st7nFVm5N/LV2u2uXfsrv022TSFknV8ncOAAFOBgHAG4YDcZ/LvzgZ8vBJPDDIyoC5LBSVUe7YVhngccnmh3fLqV5yvI+6UBQhlHOc9SByD/FtbNVZJQnb5iQpBOAWO3IG5flz3BO4AYGQcjxK9dSTb2XXfR8vfXe6tfpp0R582pJy0aje1lZauD1d731s7LRq9tbDCoUnGQZB83JVdpIyo+YEkYJQn146EUx2BQIDwWUKcMDgAEk5DDaABuwVJOMYzlULOcFgPmJAfPGcgglTwQMHGMc8jPeMjaCUZyQQvzDKkfICFAJC5AOHwdoO1SK82pJJOydu33O3S+vW7e3knm/Ta1/Je62vPdWu3bTbchkliDpvOxwQwVyVVlDDaN2TjAIPIUbPvDJBoKFyMfNhcglR8w4K5XAbGQevBBAPAGGSqrGFdm9VYNkvsAO5e4VQqblPByh4CnJwFywADYx054IPGFJBOVPJJyCq9zwBwSleT1Su1bRO6fKte+jWz69miG9dXa9t7bWS0vor7/fa26jcLMCu5TkhQg3Z3cbW27QxwC3ysCfQlgGqtJEIRuwzFSApBZnfaUOcnaAu1cnnLDr8y4L7hJIzLKV3hijR7SN4zjIYF/uLhmYLyPvE4BcTRjKggMBs+ZSMtyAw3g/cIyPwA28Vi1e/lqm+i0StotV11/CyJvfppe3e2z2vdJ9G720d9Ss0zqqEx8KyLLt2FlBwR5SgtuHB4JIB4OSRhJAzHbtwVniHWPBGx8crllywGQuc45+Y4a1ubgkEjgAYJwMlQT32ksNowRgc4JGKczHcM5KpJEuFYlgCJAM/dyBnOAcjjqcVjUdlq7+9G10rLVdrO+qaeyf4O34u3rrG+2+tt7372GTAyQzbkO5VbBOAp2KASpb5wCcgllIDEKQCytV+5MgNrjA/0HT1OeQA1sjYIXGCAM5JDLuAAZd2cuZo/LkAYDEbbmBG4sVGMAFn3YYFxu3FTwCOl2Rw5gJY5FjZBRz82LdQPmfcoKsud20YAPJIO6YO8t3dKK5vdW3ls+z+ejsZyTdak4uyUZuTvre0dOvVel76iM8SjbKSFAHzEk4T5VLKBwBiQFipC5APIXFVZJIggbG9OUh5LcffDK20LkgDduYgEbjtfFPAMTuS5ZJW2ldpJBZsFQc7VQjywSoUD5WAGDUYX7ynC4LRhWUOQuWUNwxZj8wAbAZcemAacndq107WXVN2V2722beuq0textezXfTa9rLl03s332fbVJpoX97HOXzH5a4VQTuzkhX2qhbj5mYkgMo2jZyHSPG5RQ6+YXV0UfKTwoK7tpGVH3lU4ZRtUbiVpojZSQ7MZTCQMpkt3CANlBgj5mKqxOzhWI3OVQ0KnAjMYypK5aIhQSCVKg7iQzDByVO6lG6dmrNtSbb5lbmUmt9HZXs0knorrVF/003XTR7vWy9PJPQEYjdhGSHlZjznaGwOVBYHlgOHwzErkleBGkaJMCAd5bJDbWzlwSyjcNgXAIwuQSMk8YkklMaxlVU73TggE5IVy/IOCdvyDeVH3uRjEjFlnXJKL0DjaWz5ijDYX+IruJ3nllK7kDES3B6pappNK9lzOOur6PZ9U76J3Ter3TvbRau7a3W3na9lZdNVLMwIEW8LgAKMfMEfCYZQNwALoWbeBkYGDg1HHC6eYso2AMDCykKzllTC/e9MsMFWYr8xHygpIYnkClASuzJ37Fb5lKpICVyW3FtpBJGOoBAgZ5ASI5CYzPgKRJlRgY25ZsNjADgdOMDAolOCab97laSSktPhTTWjtd6pdtV0bvrdq6SSTv3srdErJ2stHZX8tF0UCQl/vABcKzbZGCFfmI3BdxJcdc5IO5SRF+8dfLON+5TlVBbbGRGQzA7nVx82R6EEggmkjjfZKuS48xnTO4BWwCqbiQSzE4kG3kj5TgABrELIpYN8r+UCrNlTuVwMsUL/AHTgZxtwxUsBWnNZJyutrq7vo1ZaNWVm0lorfIptWT220u7WTSv2+7btsAQuJHB2DBjGSXfcfnyvO9UJKqoRt3O3kByLVoqxFVL792xiwG8hh5eViDHbsAxkMQW244IO5RHnbg/wZ2ZwAwA5XaMcrnYN25e3BIqCQTORBECnzBXkkZECgFCwHVg4IBY9iGYHscpxUU6mrbTS5U3sle1m18730s7Daae2qa3TWjUdk9k1re1126lVSW6qxOQQQM5ztyMtgFs+g2nAyFI3FkbhmIHBUDK/KMD5AThckgMBg8HAwAQeHry7Nk7SFHIJIACkY4JPPG1sMOCScDNeRWVmYB23bV9F2kLg9VO7juCCSvbBHBd6O2ieu7s/d1aV79Nr91rc8JWb5b2bV927X5bJ2t0fSy637W/lGQFOd2MjOR93pngj/Z4IHBx1AQoIJyWAwCDyAWGD8wHB9AQDgDgA0yNl4xhgODk5bPHIXgEgkdSQeCTjFPLrx1Bz6D5c7eDwexGRluQDknGdk1ZbK7j2Wr5d/PV6Wu7aJNIzcGtNb7N36Plt672t1+5DlyWPcgFkPXPCgYz/AOPnOAAcHcM00jODksQQFIIVVLKpzhSNxwMPuxkHcOAMtVtzCIktJtDFypAOCFGCWKgnHDYG5AuQGJAtKvBHHHBA3dxxj5QMdlwSRgZABGZcm2rWtdX121hdtaKyV979LPoRKXJ1fTW6d4+69Otm9r3WquurhYjI6LtVc9wR8vOBuzkd+OM8GnDoSqkZAKjtkddo4BBXsQDggZwCKR12KWU8lgWHIPzbcAfLjOdp9ecdGpcqAcnAJ6AqeSBklecAZP0+XHThqWl3ZaqzTldcvKnH07OKs4uWqV25vdJpN6pNfdprrtr0fZLQaAPuklhgDqeNwAAYgkDr93Gc8gnAWnKCq4UHA2FdwJDKSvOeRxkAHGOvHFL5ZUYQcrkpySS5xkHbnKkDGMEdOFywpCDgAkqF2nIJBHzAnA7twRuyOMgr90il7tmrX0trfS8b772ST82ldX3d1JfF1t93LZ2/D56FtcEAMuSApyepzg5JAByO3Izx2zm0hwuFXAAA6DGOAM9W4GDz3AxkHjOVzuJGMAY2kcBMDkZweOCCTkD1zip0PHLMp+9nkHGAenAGMg9SMducV1xaTvZXdltd9NvPpu1+nLON0nfT0d7u3Trbv5p9y2oQg/MUAIwxwQDxgkdCOTwdy7ewIANhDtQZfe39/wDicfKACe6jB7E/LyQAKrq24gAZyB94ggfdOMknjJ4HXvwTkzAYByTwQACSTgjPTJ6evGckjitYxV76WvprdrveyaTfq3p1uc01KaUe+nl0Vr2/y77lpSw/iyeM443HCgck4zjoRnJz325nyT8gB5HByBk5UgDcBjJPPy4IIHDVRGQAeQSMDJ4zleynIyAMAY68YB4kSQYUHIIwpPO49ByTznAxwOwUjjNbJ2aV720/9JvZ6N9bJLp10OZwu1s2lZabbbL79PPrZGgkjB1cAdcM2CGxnPOWGSDyGIJxjjAIN+KYkgA4PYZXkHaxxweTkEgAjkZ5zjIRwCOnTpwcHggdTj06HGRjqKkjlY/eBXk9eoOR0zk4PAY8E4w3bGlOTi7bJ3atZa+6+qTWyv8AneJy1KfNrbVLl81skrXvtfXZWWm50UdznaWO1sHGeTgYGcnkk98gN13cncbkdzgADLMFO4E4B9SB3x1yMlcZORyeZSbABHzAMARkt/cwSSpPOABnC9OetWFuR/ebKkA8HGMADHGCRjbu55GM5znpjUikk7WST6f3V3vdad7t2vdHFPDJt2jraztZ2SsrX9beT17s6Vbg4BDcHGcFQ2QFJBAzgdCcEY6jgNUouSVwzEEkYORnBIfCsTxuxnnsOcE1zX2lg6pkkEDKhuM5XAIXgbQAwHPQHlcipROGwpPI6kEA84yRkHJOMlhzg5wBgVqqtrJNa7J3Wnu67dNn2W2+nPLCJtNpWWq7/Z8tOt9t9t0dNPdHy7YsQFzIMgscnaACwBJBbB6nOCGIJyKYZzKCwmVDGcfN/wAtMLkxlcKw4ABDHHJXBGDWC9xhbds7iC4LMfMwRGCDg9j34OCchsqcK08gxg4QkNMNoXcSV5ByBwFwwz36jpVOq23o3dx66pe7qrvzS189jatg0p072uqUWtHdtJXb3TXa993u9+gN2dilQxImh6ZTI3sAT0YkHOCSduMngipBckOeVIYMQcqxbn1wSRwAAcYPAJ3YPNSz5VfvDE1uByvIBYAgljjoNpOQQuThiBT/ALQ+cpMVJOCGBdGTeCQAwG1sgLuxzxjBA3P2+rtbZK2lrNR11s73u99LNbp353glyxe13L3rNpfw9L2fpfVO7bOha6jwOhZuPvADcccSbRgE9ASxYhQF3A7aqpdHzZwC7fJESq9CwbGRjqCcFSAcA8nHByY7hMSBsgAlWU4G5lC/N8wbCjGB8pwzbX4GKoi4LyXG2Rw3lJhsMWYq4zgAqT905GcsEBPBqXWleKst7rbblW60s7J9badNxQwUbSTTuox3u9pU7ddrbWWr7HSm8ZedjuAUG1VKlclB0I2leTuIACkjPJNRi5PLHK7wpAB2hVO0bcJkgg8OGGFBODmsA3ylhF5uGcqcKXXqYyAJCvGC2QuMZACnO4UPKXCgMQEI5Kkh0XG5CODkclgcKVwGy+3CjXenlsr3j9mN3ba7a7ta3StrrHBpWUopNu97ay1j5X6a9dLWstdV71SSEZWfId8cbcBMmTcPmIBxwd3GAADmomuPmQNJtOwMRtRS4JU7SQQdxHUjClThScc5HmO6uVLRMHZTlVKlAATlQylUb+83Cn5ckYqMSkoo+ZSGH3m3HOFBJU5JBOdoJODwcEjAq0m/PS3TbTXs/nv0sjqjhlGzirt2T6vWMd3s07666arfQ1DOwAADNl843EYHy7VJAxtQHBJy4JwQRwY0kChgjK24swCkkD7vB2gBMAgEHIJ+YAcGsvzCzOM7CGBwXBbflPkBIJ4BGcAqSVVmzzSlpFKtuwVTJVcr6cghtwAGMfw5BODms1Ud7rpZLXVtddEtfPe9ne2h0Ro2STe7Tu21pyxavpo99NLW7J3tvKvDIcsDhgckMNyEgoNnGQQDgkZXAwGNU5nExw+SockqpUNkFDhuOAMZ29iAQCR80IcnEhOTuGGBA8vAQYwNzM3yjIOduRkjsx5mDZOSCOVAxuBAJGeMtnng8+m3NRKqmlzJtSS2tb7L11a1btbz3cUdtKnytJWTSV2l3UdHZvSzvZvm0e92TSyquBnDAgZ2lyBwF4YHdkDgkkNhQQR0qJuYsHLPydi4Csi/KG3FQWXPA4xg980zzBkDBOW3gkbjk4A+UnamRhWO4cdAM8tV9zlyXUKCAhJO5yQWZsLlgcnJJJBVRgqxU4ud/eSTtypLT+7q1e90rtt7PrJWZ2xTWm6tqrWs1yq3RXau+nezvdtZ8DciMSzAM443sdoLHc2WZepwAM46gHEbMVO5GZxIuGDAbfMwOVYAqpXCDYqkgFhyCacX3KSD8pG1gMgk/KTuIUlMDoSeBnaShFVSyTJgttVZAGILEgrtJ24Cu4Ufe5BOC27sU5pJJK7aTWtrtcq6ab631Wvye0bu70tprdd1a3zt3VrgyHfK44MqDc+1mCsCSrRphVbgKc4IjQE4w9QkOgTcI5WRVJ2PsAXOAzp8yucDLso53kMFbkyAt8xLF2YsDktgKcEEqTlSMABiCS3tktESylVjICBgDnaxLDy8kAAFdwOS/RSSqlgWAzuk7vT57v3XZq7Sd0t7O9ram0V5p3vq12UU23d9v+BdXFnUtJGofYSTGx3FWYZVioBDD5cnYOjDbywDYcDsVEjKls4Id8hQAm5yX2FipHZhtDbemMo8bFyxf5BEuxVIJVlYNubYC338dGzuA+bGQarF96k7mDYTI3gKHRQGPUSNjeSANzEArhuBlOVm5K6cmk7dNl3Wj1b+d3sONnZcztbmdlsrx0cm1e9nuku2ty6CCrH5lQoQ3O1Q21SflG4qFB+ZlJ7HJJYVWgmLAsqMsa5jEh2th8A7VBAK5OTyrHbggZBCuVhvaIZEcSK7u2SZGIGI8kA7OCQAGwcgYAAMZm+zMqHcYmbHmKBhQN3yfM3Kqob7oBIG4HflTMp8tpPRLSWive6ta12tU7u62370rWtvL3Wr2vyrbRtO/XdW+L4nrOzyKUhEUhcrkMzlkGDGMybhtODwgBI4IJDMKjKyqpZDukIG8PhVznMhILAbVAAUZ3qDxkYprXCKqttbfKymBMjcyAqQm4qF2ku27JGTgbVwVpTMSWITaSu5iQjqGwrbifkX5yQqD5hgnCgcUcybSu9fhtfql2TWuu+vYVprW2nNrrdyd4q9uitpFW0to3oRXJdYZAMndCGfPVW3KpbCkJg7B5WCTg4xksKsbizOg2plcRsFUKPkQBRl+QdhUdtwwvAAWhcljZPvUowUgpwpYgxgseSwycA4Aw52lduKvXJmWEyRIJCqrtDgBQmBuyCFJZduSuRwQCd3FTGVpObTtGnFppO/V+8tbO7bad9lsaOOkdtZPm2dlH2drydt+rld7JW3ccqITahiyH7RCTudwSRt3MxKYLZICsBjGFABO6m+bmW4dcnc8pVDu+Vd5AAJbJLlS2D823cDkKCWwq+603qHY3EJ3cAsXK/KCdynZtIZTtUhcscA0+SJjczMxTaJJcoAAS3mHIlKBiNwJLsCQSWGQDxSbveKtflb6P4Y2T9NdUr6easJ2tGVmnDR7p3lGybSWqST6LS+274yGaTcrZKneCq7WwFIaIElhknOFbBODkjOFf5gUAYkE4IBGMbWVR8vAIHzkHA4+7hsQAtuQorhQdpLhW+b5RtTcwKfIAxcgEDOV2gCpVzG253aYOoCKEGYsYUopB2kHYcDBGGHAfNVKSdru8dVfa1+XfbulfXydrsh7/EtUnFKL0s1/K9nJ3fM0l33Y7LDAZcMEz1ypLBRjLbgzMccnC7SehBY1GD+YG3nKE4jAGCVKMd2ApdWCk4w3A+boTVlioSNgdxCYcEHHUkhlQ5PO0A4I6cEYxRlkLYRyVYkSADGMAAheSjZbaQFz3AyBzUVFZJuN3pZPS8vdt0Wreytfbaw6bTSXLZvd6aL3LvdOyckratJK+uw7FCjBWJZlLAsxIyFOAqkbdpXcpJBAbAUtnFmJywKy43YwGVVAZSBtCjJBG5iQRkPkoeSTVBHSUu2GSRQQyNsKZBDAgENuwTwCu6ML6gGpVklyQ652qVD4wMLsxIFLAfMWyeAwGSApUhs4tO7UtLuPV2uo36Lye1lrqmtdZLVK9rava/TpbVWa63Tu79S0QZ8lGaN0cA5BGzbwzMi7i28sVLdR0IC5YxlJVACMuFIzuXJwdu5svnPzrhQuNoJyp4IaZmxhIwrHErM23y9pdQHYgAFmxnJIyMYyTip42Q7snBAwSxADNgKdp3nk5ABOTgLyCCRpBR0953fLfddY7aaSu/w32sk3Gzlom1ZK17PTvZX76WSvfRjNxbGGCKBkP1IcY+Xh2YYJbcF3Es2I8sQaYgEo3OpP8IDFgSQASduB1xxkbh1JBOaleJDgZ4VSVI3cNhxj1ON23BUAE7hnOKgCyEspZURQyo53FjjacZAyVIwR8qkAcZzxWiaWrei7rVRsrO17rdNdU+jQRS15ZW2v0srRVlZ2s9O1lZq5MN7lGV1yvJU/OzEBcBzwcNgEBuAThgCeJUZ87XDK2Ax2n5MAg7QWJfsSR0BwrbeCa/yks4yDw3yszBXI3EgD+JsbQA2ACVB5+Z6NIwifIDumXCrgc52qT1AKr8wxhSzDJXJWdb/AGujurNPla6N3T6WSVlp0YNO3Szk29U+2mjvZLvdO9tjRBEmxlUhGKMCrNkrxkA8E5YYwSCDjcME4txLt+U5wWzkszlc7TtKjPQgZGfm6gjg1m27MC+SgjVvMjUqd0ZJ2uNrsCVJ+ZVwTtPQZJrSgkUrkZwBgrkAl8KeFzywBwGYkdBhhjGlN3aWielu62d/v2b07nPWk72920VfXS3w66X1Wy0W+7u0teCNTsXBLZHzDHIyuDncSzc7htUAggngV+hH7AXwOsvjp+1L8EPh5rUQHg+18SD4hfEm5kG23tfh18N7O58eeNprlgwXypfDvh69skB5ee7hgXMrxhvgHSE864jUE7jIuU64GVJwTtQHgEH5cHKY3Hn9v/2D7MfCL9mD9rr9pt4Vi8QeKNM8P/so/CSeTYhfXvHk6eKvH97aSHDqdL8N+H9EtL2ZMiHTtbv0cJGxB+14PwdPE5pSnWS9jhlLE1pSSUVSwtP6xK/k+RJK9m2urMcNiaGFxkMbiLSoZdTljHCbSVWrSSeHot9fbV/ZUrr+a+2hwH7U37Rut/E/4k+Pvi54vvom8NeGPHnji68BaPIENhL4o8RavNO18kIDJcx6TaWumAFVMklppGhadGix7Vr8f/E/iG98T6veazqEsjy3MkrxiVlkkRHZpN0ztgSXMzZkuJiCZZncAIm2NPVfjT44TxHqltoGjzPJ4X8MeZY6YVyRqV4X36lrcuwgSS6hciSWF2G5YREnO048Hkd8bFYbBhiQOF+4SMAnD9NxJ9WB5APnZ/m9fMsVVc6spQnWlXq3k3GdWTVrLVKEIWp04p2UILszHAuSoKU42nXq18ZX05XVxWMrPEYrE1klrWr1akqk5PVycr6XQwsU3EOvzdVOG2kkHYBgKQMZVhkqSAOjEU3Y7XUYaMAjJH3emCCTtQKVAYADDElCCSxexyxIydoKjaWJRQV28dB05xnBDbugJiYKU3MMuUYgjjAwB2BJGTwQecjgjJHzt9dG+m9ultN9nZXe9j1Ie7bps3o1dpRVn2ta3V9ddi3cGZjbF2Dsba38sAgkZ/hYBUJfoWLoOQTnliKTHkEcNlAxBIA3YBO0fMVPfkkAAHKYAt3Tgm3G8kixtUBBbC5I2gAb8kMchV5JAZRuzVEtneAxYlmyGVjkZXquQSMjGRzkYbPdJavR25ut3ppp2+Svr9yqGyd+iW2mtt/0Sff5uKhCuwHc2w7SQSCDjOFIyG+UYLKQDgBsnFidAxtip2k2qkliRnY5GC24ghsfdXhgCo2NnNNSM/K7DDAg7jjtjjbggkj0UjptJIMk7hDbr8yk2xI/hVmaQlSWYcqwO0OqgEhfusoaldNO9t497rVPRdezXmtt12Quovrptpb4lqrX79bta2EYR7uPlwAoYsp5BUnkktt3EBiFGOc4JDUAETWqtlWZouTkMd0ibV3KoYsQpIOdrH5crgYazNgMmwsCrAEKylRtJGcBy4Kep/uk8bqcDuu7VmIIW4hXLqzDhwAWVm5BJbGDwTjGeKltu172co/K7T1TerVrO107aX1FtGWnR6K77atX6NXXVWWl7i3A23V1lmG25nbPzHKeaVJGRvYggAnjdj5gpySsbA5YYwVAwyZ+bCnO3g4GRg54J4PGQXjOLy6DIoLXMylcD7pcjnBKnIBy6k7dwyGGWETEFduRtBJUDttxhSoHG7v12nHGCQKTau7p6tq2yWj1T9dEuuq0Q6a9yN9W4q1u9lbRXflr3vsiwrgzWxO3CXEBZW7nKDKjCkqc4GMZLDPWrN2qtc3Ow4C3MzD5tuQHDEMhDBc8FvmKtgqQDjFKNt0kW1SWFxGEJDcjcikZYNncASCV2gKQ2CMG1dFvtVyCCG89xIQ4Yc4YHcODlSrOwwGUq2AcgaRqb6X5ZR6SvdKCtdX00a1Wn3oFJe2XlC6V+vNCzvq1bVJNrl1uthQWYrjBBIwf4TyuAchmK89CoIJI54JnWUkkANkq2d3CqTgtjJXJ4wO/GACcGqC5xkMxCsNv3yxQlcHPBweq8FRnnBIxaDlFVm45VSQD1ONnQMTwDuxnIAwMACtYSatdXUbNx93bRpt2vdy1el7rVXuaxbbs399rrbRed15662L9oWMlwqq5ka1lw2QoyyDHQZPLbdgJLAArk5JignTbgkgocMuW37gEUgYDMVJ3AEgDcQrKpUliyyZrjLBlFtO3Mh2KSm0qCMZztHynhhkqckCqwbzCTtGCuVICMpf5WWUEbXK5bKkMRkDrhQO2nUlaGyd5Wi73aTi000l8112vqjWPMpbXvt+Gz00a8urvpvfiu0nZo9siSAM5WaMIdq4yykL+8wSw2jDZBAXIBq60oji2qwBMkOBvIGCybQCQF2qABncM4K56isqIySg75cMAdqIWdgxXgupPmhXL5KElQMBiPlJexZI1UEhhJEGdt4C4YDnJJ25BKjBbnJPGR30sRONO94+8mrqyvdptWd/n1v2OiM2la9lK27tq+XonZt7Xs7Wst7vo4ZcwXbKrttltCcShAuXnyygZYplfQhcMM7ukUEjibdvBDhvlJLxxuG+YKAyyMVAwpKkr1G7c4NUSbbW5J2v/AKRasQF+YDEpO/B3DACktv287irIVcVhJLIcqSvzhTHJtEhT5W+YcMrLjauJC2cM2MHHdLFtKhbm91JtJu7s1srKy00Tb1fbQ7XW/d0pdVC7eie/8ravvortvTc3xN5i7d+CpDDaNmCMHkdQW+UlV+VgpwAx5VrrYhIVj9wY+c5yVKsASeO4diNpIycc1hebIuMBioIyC5UspONynewbHKg/MDuycgYEpmbblckgqQcbVwdpK/Llj0542s3Odprojjm07Jr3VaUra25Ulu9dXs2tt0CrN3SV+lpc11dRvbTdrzavub6XKsvVtm0cgjO4leoToeACB93naQMmpPtOLKzJIyxugqlyWw052ksTgsFPAP3QfmyOK583IVEB3YbACAED5SvygDHAAycjIIDD5WYFTKBY2mGYbPtZzuGVAnYgBQGAViOf4WIwSVIA3+u8slq2+VaX0+KF1rey62VtF0VkTKu1OlrrztcuqWkdbuzv3Tu9Hva6N4TJtBLDDfL87cFztO1cDaQDlgOSMFgCBioxcH5skdGyCuSBjABVAOTgnJyCfQCsAXSfIr5JYrtDZADgoMAueCDgg45BwpOBlzXW3DEll3bScMSA2CcgjBC4bceD696tYxON3L5p6paPVrqrvV9GlsrPZV+a9rJa397s15K+r8tGrO9zbE7DHzJjC5HRic8hxkKpxxheMEBRkbijT5Kk8DHAOMnIXhc7SFB/hABK9CGwTjm424VASqsPMIPRSR8wA2gkcqXyq7Tg4yQAzjJIGPugKTgMARgjAJzgjPORkdeKHi4p25nrortq6dr6d32T1vdWe79rd9tNNXq1buk+u12mn5Wey0u8HJwNwB3EDd93byckcHvwSBkZANRCTcAeeFABA+8BtC/MSMYPHIPGM5bFZTS4K55JGTxyCBwBgcAcgAl+cFQSBTPNMgIYMRgjGcEjggll57ZAOQTkNyOMZ4tK+qWl029fsa9XvZXab62W5LqOyfN162d9Vpayvrpa17Pr10DOfm7lWGNhGSrYBLA4BBIOP4jjbksADD9oJwcE8HO7cRn5ecYXpkbSeOQMYBFUWmHGWIQDYD8+exTLEZ4CleCCV2sCxqJplKglmzhduAoB4UHDEZJ4UkEEEYJXccVxzxEr2lLfpe7vzRfS2nkkrdbswlUSeyV3bXveN7q9tnronfvpe15uF25LNkHIChTnHy8MvKjp1OMlOm2qzSkbsEEt0HzZwQNxKrwQvdgpHDDIPIj81vmyCDnIOWBCk5+78xIPGcH5sE9Mmq7M2EK5YjHXK4U7MliAccAjLdckYK81xVa8pWeqSt7t29VZeulvnd7bLKVR3022e99478y0bTelrrTXWw+R2+UKMnAyWYAqCVO5VGM4bIBznBxtKjcIHAOU6Dgj6ZHU/Nwc8DJDZ64OQ3cc7c7mIxgqBtwVJwBjkdiT7AEZAhQkZXdnPIJJzghTgYYgHPBAABJ+UYINcFSqk5Jpu9tHZN6JtKzu7u27T8tjC+/fTq2+jt1eytfbTZdVdwmDydpCkbWdzgjGzsWyM7zwCpBIJNRlxINrCSPjdn5VY5KkMMYO0nkqMFjnI4zTgdwDMNsgYDJ2kjaAFOMKxyW5JCnI2npkxSSAKuQxOQhYA4y3cliW3LnH8LBTnnFcU5dbq1o3SvppF72V9btXV9baJtESS031e0Wlp7t+z+5O19EtQ3sByOcBA2Mbz8vDddvUEBuX3ZwT1Aw3Fs57EYJI5XORxhjxgZJBGAMAEkqB02MAwAGAR8ikZKsChIUgnOFySSCTzlauBAgSJHYM5djnOxSVX5izYK4Jx22jvg1zyk000mo6Xkrt9Nk091ra+iujNu1tk2k7a9bWvb7n57XWhY/PgqxLcqAOVBXkAghsYJ45UFCcwNLGylWYggqyMm/BAPy7Qv3gXxkBsZB6HfRLKBG7MWI4+6drHeAONpI6E4yTtHPIINVkRY/3hcyAIpC7d2M4beh3KqnC5AUABgThlyzZty6Na7qzvZ2Staz31ej10WqCKaXS+11o+jWraV+uumzLjAFhkkDCkYz3Kgcks/zgAkDg7h0Zd1VWO4sAQ5E9tg8PtGyQnDMfm6buBnjDZYcOLb/MRTtyCysQNoA27du1gSrEDOMqVBIxxUPllTljwZ7Yxjcy8CKQDB3HGckpnAwOQrZrOo5XjZaN6u619L76a6XettNxy6bb6u/pp9/ye3mNlhVVlcAvvWQAg5VSSSSQxVSrKMBeWGDtIZgBdY4eJdoDpp1lk5UZD28R+Zjz8wbAGArABeDnKScxuNygFSpJB5+UAAkkjgZzxnAOcYzVaVZZQlxFKAUiht5UXBaCS3hEW2RQH2xSqgeMFsOwYcFWUQ/dfNHV3jLl0ezV7q+rXNpt1fK7ImWlSnLRK3Ld6Xk+W2r762vtpurJTKQJEZDnlQ5AYhgSpJxnaDkHcOWUgLgD5gspDEdCVVmBxtCgYKsGAABBweflGAPlbmqRMqbRHkAhQd2VwwZSCu8sNz5Pljbjyzt7BRKCwK79xcqrsQG6kqCSMjcqqTztIbJDLlVerhVbfLZp2T15dWrPVaX+y2mla+j2to7Xdr3Xxap6Oz6PXXva7BpCQ237xLImAAWG7LLja+ACQwDAAjqOuVCJJtMibsLt2klVGQmQoAGdo45PB2nLLk0rxFVNz5oVc7TGMlyQgKzDGDwVA+YsOTkkYJhDhXBDsxMZUA7wZCNoYgKxCqOAOjgBQN4JBXM7tNN8rVrtO1+XfrvfR6NNWdwje9rJK11297lTvZ73d/xWyJGiRCxVjuEjMQQWIRhyQhZ9pUH5X9SduBkU0x7Arq+4lYw2AxyA/LN8xUHHGAN0eT8pVc1ADHCUSMli4UPNlSqxyBSowrjk4OcEnOMHdkGYq0gIZkTB2BVYAhVcfOwAJJkDYQknLBNw3YznFKz5YpSTWi5rX062Sutr9b6vV2aXZK769em3nbrbSzadh0kSszqHVVbbIo+6Yxsxl87iVBReBkbsMH5BDsMrxLFkAxqHbZlsq+MOzYBkfnaflIHBZVINRbnD7wSHDbCGLgPkkhlQlyxCkKRlicfMpUnDSrSDbJKSpfAKIE3H5RuLtswxxt2jkMAdowRUztrOMbTurXbWja76aJdLpbLRA+Vrbd6fh6ad90u6TL29WWRkBRVQLnaWDOFRztKqeAdxbkyLgq+Ac05AdgKEMFXAAGT5iqp4+83yjIDHd82SCyljVMG7QrGEjkiY7dx+ZlAChgzb2CMFyCc/MpB+Y7QZlSTO0MVQqAAFIG4HAwqNlUOwncSzgMxGRuranJzafLta6s4r7LbV7Ltrp1uty4va2jSS63Wib66aNPWzW1nsrCyKoCYJVoyWfIYId2HZ8gLvHzDcnAYDIwApnEkSMrMoLbhuAbllJjJZtuFK/NuwMktg4HeoJcEBomyCbccjf06hHX5RIMBjkADLAZWpY8F9rxtEY3wHDIi7FKDerlQ4ZiQS4GGGTheaUtVyqyaSSvG+ritPS1tb6+a0Rfpu99bt3sradN7b6b3buUEwACQf93I5xj0xgYywy3XHVcgxSNuRjjjOBle7beCRkg4PTkjg45AArg4GchVAJbaM4IYAcqSOMZxuHQYBwI0dAwIAwoB5A254PB+U4H0GMktxzXnXvG1+qavbrZN977dEjxYqzukr3VtN9Va3Vt3VtNL672LKEMTwVZQCNww24BTtKgZC/XgkY5ODUuV7kAEY+7jIxnDYIIIPTnHXGASKgV87W3AYf5wSRlRtPzYw4xgD7xKAZGaaCC6Es2MkAZOwjcuzeCVXGc5OedxIHGS78qen6vlvGyte17XTs21q9LES1TTdl6PdJXTs79Py0ROFAxg9f4wASD8pOcDJJHqeeqjBxTxuJHzAtj5B/e+6QScgkkcMBkED15MAJyMsSuRkYYhidpAAHGeflI5xkYbOKnJG05BGTleM4+ZV3YICkA5PUDtg4FVvqox0+9ba2tZ31Vla+9uizdOS6Xe19tFZb/DbZb67kh25ZsZZQMbstgkAgYLdBxz0Ukkkg1GyFBIwYHe33cE7QAuARnAbjovBz14NPyFHYrhSMHntngDoBzgE55IyDy9zgsSMg/QHqBjHP3v4lzzjJPJYKLu7vWy3sk1blWuivtq3103sYptNJa3snfW6XK9NO93rfVbakSFgThw2BllO0kAbSVGMgYxg544yAckU/Clgc46tgt/HkYHAYEDnj+HIxxjLcJlmAXIA3YPY7SSdvG3qcqMdPQASptwQQfmBOS2QH2ggcfKM989QRjuauGyS31evu20W2jaunbpbuDa0kk76aJL3no9d9lfpe3rdxhzkFhjpg9T0GCzcknnpjJ4DYIGJBKCuRzyBwuCTnntnj34yPmDYBEEiszZALbTg9M4BX5xk9cEgjgDGCoyGKLJ1G3PbkD7w4JXhec8ZA69wTXTCTXup6pW6K97baa6N7X111S0HFSSa8r23je2/TVWt+GxfR8E5+bjBHQYyCDgYB9MnqecbTirSYBAGRvwTgnaPukZAzg59/lySBjJGYhIA3cEHOw5+ZRgYwuMrkckHk4znkVbRwE4BBOBgknJBX0x0xwc+mMhWFbwlLRSbV7e7tazjeS/w8vS/X1MJ03Hyv216rXya0btva2juW2YLvJ4UZOCflwNuAQDjngA5wexIHEscm5V2nh1Q4x82CFzwOgIIAZchht696sbL0ByGUDbwemMZA9Bjoc8cHFTAqQMsVIIOeV/ujAHTkHPGOgzjqrcpKTd1KMUmmtPedrtb2s2tG7673WmEoL4XdtP4n1tbfq3o9ddtNWWRJggdxg4zzglcA8DJ+YYJ47ccZd5u47sgjoTtO4ngDGQSCBwB1XrngYgyWyc4I4OAxOwEc4AyeBg9CTndwDhgZF+XGQRwMjk+6jCjGBxnIGDnGQajN31sulk27Xs+XXW78tbWdldGPs430V3ZdrPRbdFZPTz07p345C5Db/mwVx0DAAcfLjJYEgFu+09RUnmEru5XAVwc43AHJPOCD7YIIHO05FZ4dhkZAHBx2JwMEHOPmUZxjkHPBI3TCT7oAbJwue7DIGckZ5zgkgHPB6ZOieibfprfW8X2e6ts/wDIydJrXlemz1VrtX1tppa2+/d63jJnPIwAemWzypOC2BkEZYk8YB5BxSpPkgg5ViNzDJzkqMjbgIF5zg5GARwCKplyQNhyQ2SB23ZyBuJBycgAg9yBgklFYZUAnDAkDBKBlYYfG4AkgDjbg4yN+QDSqNaX0uru1nf3bO701XRNNaK1rtSqUWndJbW9Ou+0ur11d+u+rI5VLYE4IaTaoIDFfLAyPu7jnOBjB4JGWYAVhjJPBAyDnIJ2kBRkEALtJ54IOAO+fLIzi2KhyCzgYc5DGMgBRyRwowSMckv1wHqyBcbj8/zAbvulyoCjnaoT5QQeB94ZPy1ftnzXTTsk793yxfbXs9b6aLVXuvRVqaa/5dwaWl7Rt3aVtFd76PZ733dWjj3OqOZoAAVwCCxyQW+U8ZyCBuwAQCMlizsC4dctlyWXoULBBl3A+X5SQwHJ+8ASaqzMoaDJ+Y3FsCOgGSRglc5B65ByfmJXaKY0212GNxMkjbRk4BbBHIxg9RtBJIPutQqq5ua6vpG/R7Oz1ve6/pGDpJwikk23J691yry0frdb+mi1wFMQbJLDC7AOGwpBYjceV5DYLYBY7lODTjuD9oulC7w6AORsAByAxByO5wnQFvmIIwBH5xOQmc4xxyOSME4wGPzZA5AweQAaqwy4ubnaSrlRnkgEEgjAUFeT35BCgcnguVROUX0u1ZabrXV6eret7bLUKVHSV43ko26tP3otPVe7ZOyV38Kb3NAyiRcIMBWDDAVQMbSU5PLHdj7wB2gjtgDIwG5WHyrjGMFgE+U8sSAM7gDhgR1YHNXfsDNhiMluMnAOPmA2kY6KBzjI4IJFEcpI3PhWchlJHzAEAYb7xyQB6luD8oPLUktb/otOXSyei1Vl06pamnspJXSaWii023d2tZvdWSdrbPz0nkZCQXJJJKYLNkZ28kEbyozgEjGOrbs1DJuZiSzAqp2KnB+VVKuXIRmHynIGSzKowBgCnLOigzkuC0ixAYRSQdoZirFmII3ZYkAE4IOCacZV6MzFSAiqWyAGIA3cEbcE5wTgg7TwwI6ik9bbrTZPmtbs3fZpPy7Gyoyio2T21T6Ncmmu97q/XX5KwksPl7433ngMSWEjlVQyBhkthQBjnng55yEM6MoZdxZtik4XK5ABB5IwAQoI+VMc84WoGd9wWMIqYLO+MEHKg9ggZx8xOc4I2nIwCN2Jct8gyUC7SNqgKWIC5IwSMDIwBxkHBhTWqut0nZNKy5W1t5/PXzNVSiknve2je0bRsnpo/O/RLbVTsyqSzDAOQcNk7SU/1agAdwVwcAc52k1CJ48KwZSj8B+GAcbTtJCkLjAG3JIYblyRktEjqcMu1t21XGDtU5beeWYlmUkjG08N3amM8ced3lxxN84GDsJY4J5yuWDfKwC5ADAg5yuZeSXK3Z/Lp5bvTd2drXNKcEk9LuyutLO/S2zd3dPRtJ3u1qjSJFGVACKSDgB2DNlQoPDDPTcxB2r6EZpm+QKSVUgKN5UrlUU9QN4UuBwcgHoxUjioJjIxSWNVk2ks8fUqhO4PGxIDMoVhu6YPIYU9y3lNhwj7SyMwUqpYZwAyABuDgZCk+xAqE2m7KyuklFPyej1T1t3SevU3SVlZ/E7N63VuX4lq7Ja9Lp3a0uWM8ucFAMMny4DEqhXIxxwAdhBXcCAcnFVbp3jVmxwyjcoQs2QBwAOh+UlSfmySCc5FAd2AwRFsWLbuDZk25DD77SAOx5Gf3gyAVB4jctIZN8iurHfH8qgqBjAfcVyOSQPmxkEHPW9XGysrJJPTRu1tE/RrS/TzNIprl1u7RTWt3ZxeltPO/nfV2ZEsm9UaNXYFANuQr4Oxt0gC8HnAYZ+bBGeqmVRi0mDlCMAsAfurlVVV3EkqMYIDbiTg00OZMsxKZQlHIViWyVGFYRhBvAG4AZChQyuARGYkk2sZDvjjzHIDwJBtJDKrKTjIU42EAgFDgEQ3dWUbtWb6a3jeytpo+1lpZ3NUkpK94x3aSu7WTXytp107E8ZEqRsrEuAyuvzAghApQoMFWUbecg5w2OdtRPGkcexGZFBMmDu8wEbSF+Vs4wDvYYAIVsliVVkOYQVkQKpQlFRhh3UAHchOFbKF8KwIGcliQKQSrEpXLFZGKo4AKqroPlYuSpYZywU4yMnkAHJzSjHntdpatPR+7ZK9nZp31evorB73M+W3K0nFX6aa6vbqru9lp2L5mAti4KsdgCbQgKYUIS7bWBGJN0gye7BiBuqsLgLguQxWEkvtDby2XKq6hlLDIKMqcrhiVbJaKJ45jc2/zBIoFQlsgjBBLKFCnAHIBUFSCCVYgFkNsAA0gaRVkxGoJ2qAUIbBG4NtXcVcgEMCQFBAhzcpLlV7q176JqSs5K3nuvloyowjFNS9yzjJK2qi1FLbvqm1e1215TRBZUSUA8naNx2Op+ZiQFOAoLArgDJUHhTgyKkcQaJFGQSwbruYKoyzEgYJ6YypY9c4IlVkO4Lz8pU4GFTGDgqFBCg44zgc4O4gVTuVmG5jtKFSgbAV41xtUMCMc4ZsbPnBHzE8HTkSV38VrNqLbj8Keivvtbfa7smxRXM4pycYp3SbWiTira6t72bVnr0vaO9lzbsSN2Vw23IUAmMAMo4EhxhhvAXJJAxirzcsRtMfGQgAY5ZF2kFQWBLE4UgK2OeWIrLmVYrSQAseFLAszBizLuJPyggkMYgwJwfUDOm373cvmGMAAxgYDrtBCk7ANyE5OA6ghc4XuoOTlO7u5RiuVWvZXTV/v83olY0lZQilblcp3ctb35H06L7rNpaaJpRg9uyE5Fzb78GTCjdzgIFEgBJJAyc4GCpUCCWZFluM5BincFt2SxMuAC0hXbjJJG0grtIO8EAcoZrVCZ5Sbq3ZpFB+Vd0e1cOpKudwyVcyMc5+djTmRQ1zGuFU3M/BClsh8YfaScMcBVwoDKN2CFKy5tzkkm7JNczT1tHqr2u9N7uy0uNJRte+qbWj0XNFtybbkrvRvrdtoW3lJVt7L2BVQBtGVLZOMnc2BwM5UrxwpbJI7lTHIEbGMFVYSMWXcDkAlycDjvgBgRSLGAQ5ynALfMWAcsuT1DDA2gAYJ5DZ+UiJxliMdX3Ag4JUsnDZyRuJBGAATwQCVILtxs/vvrbR9Ldn5aq6VrCUUpcy3td3S1TUbaNPRaad3rbVEsz7gmCU2lcFcAqcDcqqDnK8ZG5ckAdCRVfYwV1yfl3fLjPJwDljuwCNoJGAxwCcggqzKwVULAsVUcfIXUqT98AliM/e2kfMpzkYYZVBKLuLBRnjGRkc4GSSSfmGScZLY2mh2lq7N3te+t7Wtpbrst7662Y4xdm9utrbX6XSe1rL9bIY5YhdzAqAuQQowMqqhgg3b9vByO6g5AzUkTq5LEdEwdylQFPXja3JJZVyQwIXPOKjx84AyudxHO0ZbAUBVOCwLbV7HhdwKgVYQEhj8pPLgpg8MqgBgpVWJK88eoLZI2kVs+i+K+qtpb06q1rO9kr7W1olZKzSutbWauml/wAFaq+7Y0t0BkY4BKA/MChVMLuVxtwSQc/KT93adooQsgwA5VAxQkY5UqCC2XySMfuyQATwFIyY342kbgy4yFAfkvknG3qNqt85JAwGUrja1QN24s6DO4KjKoU5U7yEILhiMkZDAcDhgoptJJp2e7jsmlytX5m7pPZXXezTVxxUkk07W23btZ3VrK7fS3VPpZ2hIQ424K/KrhiCS/HJyFcKAMFjyCPmyvIexIIKDHC5GMh3HTGGIAwcA84JJUMCVFYFicMgZSQSMfNkk42+Y3KkDncDgn85VbcQMHkhkwBxlhj5gAqk85Uk5wQh3BVp8yb1d0rK99E7RV1s9LatX9EKyurJNJJaNPS6W+jutNN+tmOVXjALMhCsWBJzwCCCDtHICkhRuXJy20gYkDOxXIXiPeuzCjBI+8x3MeQSMDbvyCAp4YDIwywDkMFxlkwr4OSjE8n+915G/CvikzgqxByCUZs4VVO0ldu4dcbW2sRyN2Wxg2TaT6K726Wtta7v10tfRqwtb2a106q3R2tZW9U9t7FmN3DABScguTuzsZSCUIOAeTxuU5OGB5YVaE+07emWBUH5QM4I3cKBu3Bhg5yDgg8VnqVPI+UcrtDYLE7QGDKSMLgEA5ByWY4w1Tq8gRU4JXGGYZbIVMgk5JXAHzE5JUArwQbScbLrra/RxsrNq3RrVbd2ZVI3ae70Wi1SVt2r3tZW7rbW523h6XN+oALOEwhA3M7lQVIwNzMxHAX5m2gKPmDV+vP7cfi//hnn4B/sy/sZaLKtn4o8D/Dl/iz8ZoYZCJrf4zftBWOneJ9a07U0CbotT8EfC/8A4QvwYQz+dbXWo69asEmhkFfmr+zZr/gzwf8AFfwz8QfiHp0Gu+D/AIa3CePNV8LzzLH/AMJnd+HBFfeH/BOwiRzb+KvEiaPourSRq/2PRbrVdRI8uzeuK+KvxV8Y/GX4h+Nvij4+1SXWfGPxB8Tax4r8Sak2QtxrGv30+p33kRyM4t7SOS5aG0towIrazWGCBRBCip9Ngswjl2U4hU5/7Xj5fVoxi7OnhY8sq0ptO/72ahCFukailoePi8vq4uvhF7XkwtGft8RTs71qkIwjh6cmrL2cXOpOUHvUjRa2OLnuRIxC52EKCSV3FQysxG0hunPGCScdSBWdI4yNzeWANysdpGwKoBIIGN2MHAIIGCVbkxNKxKjaOoOc5LZK7doYD7wwOMrkfdztJhlkfYTkMqkIF5JxxnLEMSFPoNoz8wKsDXzs5Xd078yvva60V7aXt6vroexCkorS8fh0TWmkV1tdW1+0raXbWiF8nAGQcqMgYIGAcZIxgjH3eTgetQ7tokB+bepIJz02KMsQSoUA8gZOQWXkYpqtnnaQxYdMjaCByeDkBupGN/c8UjN/rAUByjKMqCBhQVyA4GSQcYUA5wwwuDi20m/K1rrV6O222/XXfTRrdLpaN9dtE2nG3V+Wnyvayjo3bsDaLkBVs4NxXDFd2SCSpXAIOeAflxtK4GaAYMylSpO0BmycnhOMEMyjGAWx0OMkANU9wd32cBW4soCN5Vi4YOAvuGcgFguxyQCd2DVJgu4sMlyVDKN6qUDZbOCMrjYuSoKlW+RgTRd7pNP4na17Wj1tpZ26Wtpd2RUFaKb1fLdW5UnrFq7fTre2muysywJCwBbG3puCjJxtAJI5O3gggfRcgU+ZjI9sVZADaoCAFViqyyKOAud3ysAQSSAAMngV48EMpBwucFtvDcBNu4ElQTkA7hkgBiSuUmlYi2+QoqwhX3EknfOxDKPkKoRlV67m3DvgF0oyb0tyyXXRyWraW/R+7562O2nrFvq4xfV21Xf19duqSchYEj7wIwuSSMk7TnOCwxkjIBzgbuBToiTcWZVetzCcEgFsMn3sgFcc8dSAWOfkzXDlSCRwCoOEwGIwecDeMYIY5yCO44D4+bi0YHbunhGPulTvQgbIsnLKM5I3b8H5gpSpvflez5o6LazlFyuno9dNlrs2TNe6/s6bNO72dmnbRN3te+25PeE/bbwYO43M4wQSeZB/E+ckHBBKqWXOQGJAYDjAQYO04YsQq7sDPAIKkAgcE7QQehWnXh33d0Bjabq4OTlmGJWwm/cGKkjjcqtuyoAY8MXkryMkDcQpyxAUNjhjycjIALAYZgxBNNt82ttVa2qVmrWWrfS/m3fXeaXuwgk7e7Hbdaa9k/8AhtrD0kYSW/GXWaIKzElim5SpBLBiSFwMg7sjIC4zZmMhuJiiswNxJ5hPIIyCdyh8KRhtzZBBJ2qV3LVaIs1zaKuCy3MKlgvC/wAPG5huBJ2g44YBVy2KtTH/AEq4UAZ851IwSeCowMhASOqZCkcjO5Dm4aK6tbmW/RNR3V0rNXu93bVvQlNOsov/AJ9vz1bg9bdNWt76LroIGyylyEO0lGGzBzsIJJbBYrggfdABBIYHBu27fLDFcbT8ykiQAMQGVj1CBsDDoMbScqKh2g53Eh1UAEBlG3BwCANuGL8sQpIwWAJGBchiADsMg3DB4J2kIF3YwgJwSxIOGUkZzonytNpdGrXV1dPZatXV/e38nobprS7Wva+nw6fct/xNSz3NJOWyD9kuQMEgFdgOGKqvyknhhlnJwQuMVVBfy02PHJIrBnLqjDyyu4orlhlhtJBPUgEnBFSWUhWSUjP/AB6XKAqqn5fJyCSxIwWziTALckkACqkWcIBIMFfmYqCRIVQY+Q5XAySc42MxTC7yN01ZK+yaSVk0m49E2r9HbrdGkW25K7ekbWTtdPZPVN7+mlnfawAQ7TMrBuYwS2BtXaU+XeWy/Cl9x8wZJGCBT3cNbElsAyx5QgFlYFMoxBJXAztYsSVbuNy1CHU/MpKkbEbJVTkEfMMKSRkg7yBtUE428mKV2Ksu3apeL95lTvyUJZFbYFw+0njG0gDlcVp7XkjZSvdS2fWybbs7eV7q10k2maJrd2vvv35btvou/rZq2+/E+LS9AI2Ce0yCQ+f9exGxfkOM4yG6EhcgU3duVwQVXAO7dknByCWO3arHdtPIYMQ2CCRDCxazvi2QRcWu3B2IOJ+owCSBzlQBg9Nwqt9oEW3PBLYztbuVyA2CoJJznOCCSx712+2i1T5k1zQ6Wjq3snu32V7rXexqp+5BO7SV77JWkrXuvk9uqXYu+aQAyAMRtwFzkhMAkDa7rtz8+R3wQBkmDzmR1kP3mGCMkKWJUjbs2kArtCk5GVwu5eCxpWGDg8gBtpIB3Mp3HGEIAyvBywwAcEgLId3G7HT5gAxz8gXadpUbs8Bjgtgg8kGlVTu01eNuW1ukY2v1+5tJLS19VGWremllGO6t7rV2ruzUUr3u9FcsiZ8g7fvDIyo2r0LAKG5zgEgbSwK7fkG2pDIos7Eg5x9qGOMBvtBOOMLg8nGTnBIAGduYZgpKry4GWCnkfKpx84JzgfKNxYHpngCy0h+w2OCFJa6JVgp+Xz14J64J4BAGOf4mAp/WLta3SWjTXeKTVtm9XrvppqTOdpUX2na2+8OlrO1/TS1rIkLlSRySTkADgDIA+bBA4C4YtuYDH8IyofGdzEsV5BYq+04HAAJ2ksSGwVByqg4zWcZHUgEfueW3ZBYMB02sqhyApKnbknGCRuFKjrGzFflZgGLbwyYAUMobK7cHBCABXwByMCqWKcbczsm7PmdukXpfS2qaWz3XlqpyTUul1ppbpu1o3p872VtDRVgBkNgZBJJBYNhTyOW4ySTg7eq8U8HBJzuBOMdMZwxBwBk9zuIIxxxiqKyAjKMGyRjk4wdpZguOQM+uQSAPlwQ4OQSBkqAAxb7oOFI+Q/w9ecnHHLDpft+ql2at1do7Ozu7X8te7L9rd3el+W/Zt2S1T9U1Z3drPYtGTG4qygdMsBtBwjYwM4JXjIPAy3PADXnwoOVxhRuAJHVflJHzg46DZhgBgk4zXEoKjGQMnGckEArndkKdo99+OQ3VctLEnOV2HBGQnB4IHHGTzx0xmQdCaiVdv3eZ7R+Wi31266ee2xEp3S5Vv8TT0T+zsrt6XequtHpdj3nZwxwysOFDbPmIUHIyNxUkYTIHXaeTuEYkZQuXDMwCuzKAC3yg4YrtAAJypG5yGXkjcGucjucFWAbOD05JODnkjpyFIIznNYuu9VwxIJcEYwxKghWL/XPy8HABZWAUck63LopN6pLRp7pu6T217aNW0d0ZtuW7ettL76p627Nu2ySd+W5c3BAoGSpIPJIwcrk5Dcr7ADHHQZIi3kgKvUjPbIIwSGAwMjOR36beBtLEkLbiAcjLHJ+U/dyNx57cjg565z8rSzoMnPzYOAGAxgLtABCkA+p29cHaSBLrc21oxt6J7a+dr76rpvoCab9Nba2WiskuvRp2dnvZi5GQAAW+XIxj5htAyOmMkAnP5rzVNwELOUfexw3QEKdnTbhdq9yeW4C8EirDuFGdwJbaODgnkEgAAkMAR32gcY2k1UMoQZLkBjkqSRy20bFUE8/PyuPmOCARkVx1J8zTUndbtPTprbyV7uyWitbYiTT6/htt3vtZp2t1t5ygSEoQTwEIKsNuBsJJKliWAGDuJyMqecVJI4jIAZMtgKDkFjhckAbsNnPqQQAOPlqjvkLLsbYNigpgneC4IAwo3huoA5AJXnPCtvmzltqqx3AZALDbhgBhtmNw6swBwDuXbWHtLtxSu3bfXR8t7ruvsprRJaakXeyfVK2+7TtZ7er6Fl7jcoWMZZvXGDhlCtyepGTgdOnWozLgLnapxtAYKWOdpAAw2QCcqDztAAx0NfEildygAnh8j7vyoOCWHYsCQvzBQxU8lXVQwZFJkztzuIYj5SWAUYBXBy3LAEgALknOUm7Lv0eltEnZNO716d7apWDrr0ff0Wj9NraeZICyBVAB/DcCMKDyThgMkAhcjHQheDcMlSoOASpwMY4cBgRwcAHgbQwBGMioiHIbBXJ+c7xkDhQMAEnsFUlvu5wQCqlCxBVThUIJc53uDlchUPK/7RyGAJODtxRd9FZW02a6bJWVlfe/Xbs/u3s076Ncv473+Vt0SK+7c2Rw+ABgnJKk5woYcnAI4Dc/Nxlr5KAkDiRNwIRQpCNguOTsYtgDPBAI2krQrZJOzLdchccjbjgnBO7nIBBGRnOWpWfIYqw24IlXBIclcGNghXgHnq23jByMgdmk5adV1Tvy+ibs07a3Stvazs/W9kk9Oq/NPa/Z6bjXMi4cZYkplsABVIUMcnIYKQCTjLZCkjIyJuSTzIlw2wwzQFiVuYAjbllMZCh3D5SQkOrBWUcYLCZNodd+07wrMyhowAQIpiSzBspuHAWQHIOM4WNVB3hW3ttd2bGC45wmCRhy24HaTsCjIG2sXurtWdurTVuz7vRJaqyevQTUZRcZJOL6dkuW2qT7JbaNeqCVFePMRPlsxKOxCOrxk4hmySVnjK4YBtrq28NsbCOjLhfmUBxjccDOcKpJLHJXnaThWyTuB4pZflG4MXSRc3EClSZPLVj5qAgKtxCW+XrkbkfMZ205QCFeMgo4+WTaB5gViGyCM7gch1J4brjuoXUrvRpdLWe13ZNab72evLtq5hHlvCbTtZxei5o3T1s/itZN3s/JDC55VTnBDjOSMgKFVhjyxkEjBIUrjGelQgNGxYncsmS6kFgDtRiqcLj5x1A2svdVyKkAOCDgncWAwAxA2gAMRyWPAO0KeQNrEUm1ArSuWJZSpwWAjBC5CjauQSMhsrtycZHNU9XdLW/dJLo3Z6PW/du+jsi0m2rLVebS0t56/wDB0SGJkKV3BsOSSqElQ3Bxn+Egr8oxt5wPlBMUZLOWX5hCgLMCxDAlXOAAQXAIGcsAQGIYrgSqrNvEikjJVR2KkKCxwxJJCnYwGWOc9ATLFHHEWQYZyxAJ64O1QvzMS+1TgcAsM9xUyUnyrZLRvToklZN31sno9ba7DjF6aJLVNaarTla3vrdro9ttCuXaQssitGgDGPJXeZOFBflWCjBz2Awc5XlY1WRYzuaFlCuDvQlgAQZFLMGCkgblAJIV2bJIJtyEFHZiSoXHcZQKRnO0ckEBWHA4JGRg012FU3uxU7PKjTaxKgABGdgNvzFv4wAVUKo7JrlaTdnbmctF1jbW+l78qt9yY3o11dr3dl1it7re3nfZ3vrLDsBZV+Ys24g7iACykYZioKqSV3MAWIAAAC7pDII2ZwoY8CQkNje4UYCL8g2puIcsAhGSwZ2WmxSx734AkyxJbaQ2McEtkhgQMkhAxHA6ASIXZ3Z1QrG//LVF25G0CU5OWKgZY7QQSpwCxNUmmo8sle6Tdm0tuq11Wrb+dnqC6KPXld0rrXl2v5a3f56iPJN5fmR7TsCMVUKTtBAKyYZShCEnAY5wTkA1MsuwW5k3Rq+CvJUxMxTK5IIDc7judtqncoIWqI+dZ1BZA0mMNkMw3IqqpQgJhc5OMogC4CgCrCxssgDMuxmDReYGKLEXQhWY8AkgY2gLjheCVGUpSSdkruNmnLWNutml7ttmmld2td6K9+r5t5LzbXva8q+fe1tSiVGGBUoQA3zFcHCrjLfMckjbk9hzgjNQkZKMSflO4LypIwo5Y4yR3JC/dIxycXMkAhsY4wFzlQcBuAeMj1Oc4OMcGmSBnAxggdycfLt5HRSOSQpU9RtJweS1km1zPTbya0/md3qr28+55UHfytZ39Uuj1Wj5rLZWXcmjG9c7l28gjc2c8HBA5AByAT0OCMipVbylwxU5OQcruOQqgElM4BwSTgrnkg5IZGpBAKNtIG3LDB5ABwdwVgQcAg4xk85zNjIwSCuDgA8KcgkKAPvDnqSM7iAo+Wmnon1a2ttorPz0ul2XorQ1HVa6NaX6adXs027fNaCKAwCklgojzgjcXBDFSOCRsIGCR6jkVOQQBgMwAAG3JIIxxzu9QSCcjOFOBVUArypzkguSWyw+Tv1AzyGHToPWrAPygBivOBlyDkAEZwAAG6DHLH+6M5Iy5bp26JX12S00s3tt5qy6EyStpqm1dK+9ld2dtt7/AHXd7KenUgcFlJJJ+7g5wuMYAJGCPTgrSjgg5PIBOQSD3x6enI55yARkFrEcEnB+X5toYE/Ln7/YEEqBncCVLAimlwuxWyWYEg4ACgYySzEIOAei9SM/Nglpapu6tZact15WumnorWurLbZrH2bukrXb6K2lldt+T30v11LC53HA+ZcnBw2/bjuRwAM5BBVsc4Ycm4EMyjGCFYZ4DbsnnbuIzwOMhiM84YwBidv90DaRyc4YDdu4OAWwOBnAyobigSFt6kFcDBIBGWUAcnJb5eA2B8xKhh82TcWrra91u1HROMmmvh6tq+vTqEqSSeyta76bwTjsu173aSdrIkV5HBIUjkKxYrkn5c7RgnOSePvY6dM0mHPOQ3G4YDYK8Z9CTlScnBwMYBBJiQOJXIzsdVk6H5myo6cEDdkA4xjAJDZxNkgk7eoAYtnOAB0OR6YBOT0yD1FU5bq0Uo2etldO2m60fRaJ66t2Y5U+TVJW02/7dTWqvvb3vv1dhQWXDKCc/e3MGIOQACBgKcE9DlT3bIxOrhsYGSBjg4JPqARnjgAhflyeOeaoJJO3+HJ5IxwRjn1IGMEcAAnaWGZFIHTkEdR1z8oPJ67uvtjnORjoUttb33u7taK2rt897eSRjKN9UrPpr6b+ifS3TfraRvmC4Zixye3HGRjafunAHc46ckVZ3hOwx/CW2+2CeTgcjcB8uCMYGKzSQFDADJZQRhTlTj7pyC2e5xkjJwM4qUSEEcMx6MQeG+6BgAgdMgktjAGBkZpxmr620fe21uu6d9dUtL36mcqd2rXeln3svmrR6drW12LpcKu5t5UBcnOc8jtyCc4GcYwCD3AnUkjPUADpnpnsMYUkcjcT3AANUUYjaGIBA5P3RwRgY5xggZyDg4BIAAp6sRnndkepXBGDgnIx0BPGee+RWvut205brS2rvy82z000vdX9dsXFrR7XXfVO2q7XtrtvoTg/L8rbRn5geSQOo+XJBPBGCOmCRzmcM3LBsZwMkHBOOmAdxJAySTjDdGBNVo5ck/KcgYB+9kcHAXKnJxwCMdj8xFS55zsBB5PJIG3kke2cMO65IBOMEckr201ty2WkVb0s7bSWunzBpbWWz3S01i9G7J6Xb1euvRMlDMSAwzkZzkKBnaM4yAOmWXOSR8uM4qOaUw+WxZTFlVmJUNjdtZXG5huG4AMQucEAZG0hu7buYsGUYYkbiqqAC5UDAwACDkcFc55xTWnV4y5KhPlJSTaAeQQCv94knZhlwvKkgCpnV3XuxaUHtd6Wb3s7a732v8ohSalF2vG+vXRqLSWlrrRqy7dEWXlYG0bI2iVsAjLHMDEFSdgA4YqD8uBzn7tTK7kffXO5iWUFspheQBkA9CeAS5B46ig8iv8AY9pAPn5DsUyCYW+UgZOCSGHJyPQDAsu7KhaHZkDcS+OcbC3GAMgbQu3kbsggDFDqO932jsm+kNXZq7s++7SSZtiKd1TjdXlCLv2fMunS17e9563JXZ1VSTu23VswJ5LKX28Fz8oHAC428YBDEExMVfdtOCJiwaMZIILMVIX5ivTcGJI+Ujhiaq3LOYiMkFZ7YR4GFfLgEZUkHBHyjgMMtwwwZUVVLrnkkqVwzFWLbcrkBdmNoU8gZOT0BIz5m19nRS0u+idt3dO9tei3TsZezShFybUua2jvZJwumrWad93td9hzOQ53RttCBg3HzfcYjrkAAEjJYYyznvVRWlluLlNwQgRHcPvAIxDqDnO5yoweF5BOQBVouVGSpwTsYDI4IGWC8c5G4knIbG4YyKzIpG+0XezL/KrbR02rJ1IBAA2gsMnchPPy7ib50uXmu1q7bP4Voknq16ta2eya0owVptRSaikrO6upQSvfa92k0rPXQ1DIGIBXzGwRhlIAXcoO9nIwcclh0YsOuQVVnIZvvKuIztBxGSOgH3QM5JwecAqAGyK6PIFU+XgsAGHBKqflJJAOSCDknkEqpB4p8UqsXQsD5fDBgoG7AG5dwBOWYggKMZ546tTSdr2utOru1G6W+qV1fo02029I5FZq10tZaptO8bt20XZaKOnnoSNL83DMVQ8rgRsoBUMxJfcMMyhgAOCQQxZgwzeWE3I5ZlX5VU5XbtwpU4AUYyDnfjJ5INPeUqdyAFcDzQGGGXcBgNkBTng5Hyqd2GJbdTMpkwUkKR4JGBkkoUO0rgMEDAjcvG3JBwcVMpWT11btur2Sj1Vrcu2m97WNIpO10rLRtNpJ2i7R622a06drsuAqrYCMpZlYlWO0n7rEEFQQc4C4KnIxkgqHYQO7AsNyEE5ABICjcvKgZyDjDAEEnPIqg8gEIkUnkoE+8CjZGOgLKDzkFskYbJ61MW2hA7M0gHmEgZZiqqMbm+XG4EAgBWPGC/QjUs7baX021aSSsnu9Vu1v0QnF2td6u1vS19H567+nnPkrICQCCMqMAMCSFOSGO1sAnJU7ScEEtzWuDkxhY18stvbeFO7APykHaVGATnBywBUFmBEErPKkcinYoYM6EqGdQE3biu3K4GVQkZAwRgVJIwkjblgjc7QSOB90lQGJwCRgdckjOOVzaNJtX5Xd2vrZ/K1tUldbaaotR5eVvletmt2mrJP17NeXoPEpGflUfPsUHOOAAGfO4lQrddxO3a3HBKs78ZO8lQrOqrkcgHIbKsOpHIYg5YDBqoWKsrNkRyLtYtkj5duxvnPyll2Zx8y4OcKaldn2s2N4AHBIwV+UtkEbfl554BIBIA5W4yavezSv0W3uq97tt63ate99dWi0mrWV29Ulpqmk/iaaad7X6Pe1x0hLAxq4DBlKqBknlRg7fuAjoCcNjaSp6xynCgldpARSFJA2EZYZOeh5APy7QN+4A015AnKRF2bau1CoYg4YFmQkEEA4+6eCwJXpA7uw3CM5Kpu3bG4JXnKhduCMFsDGNowOqlNWaTte1krvWPK9Xs3d+lntsaxjKydnZuyTad37t+y1fXXW7dxVYhcFwSDjCsScADnOWbAPBwAWxgqetSRA7uAXzyATyAeN2c5UYII4baT0IZqrKVfI7E9uAQcDOccYAwMdTheMAmyNob5scLhSQB8uFHz85xknDDA/h64qYt3TaTeiTvdacr7WerevVteSKmklbr3TV9o72vG2j6813e+l5MVyWkCBV2AgSOA6s3yBlAJU9CxKsCCOSfmBDo1ZlAEewbUkAkWMs8mBnO4ADI5LEEtkd+C9WcEBnBBZywCZYKMFyCmOwI3H5jxuULSGQsNu0ouPlzgsTwQoyxIXPsODwSeahX05m/y7a6X0SVuzt12HfoktLNNu+nuXfR9tttrWuQOxFxvYMAAY3O4Lu3McM+RGxXqFOWYFcEfKQbqbiDtyQVLHcdygYB2A4CuR8xUhx8oyp5qsSrK0khL98Esd6qDlhu6tg5BwpyAzEYpIpCkSsN0qswwgLHaSFOA2cDauVdSpBbJU7duHHljO1k95Xd9/d0s9le+lntoloimlNK0FdO1t9HbqmvNauzTumrxRYRzvwGTCARyBwMsQVwFBcHbnJ343Zwu0jApLhWdSm7yyWUqQmCMMSv3GGd5GcE8sQSAiuajy/mL+6JDMcncoWI5UEsOm7HJwSMHcgDA5fcABcEFs4AUnJY4XCEKD8uWORxkYOSDhdWtJKVrLRpRs72T0sru2iu09fvE1acXa1+SyT1VlFbPrfTW+qfqZVzcK0U1sFO5AFd3GAdrIpGSScl1JDZIxnA3DdW0zmIguwx5S85Oc8AKmAQThS4JUFsbj91guVeqI7fJUhisWTkBtxdcltoIPDMNvLDClQyklZZZAskPyfu5MqGDAtGSwKHDY2YZXIGWI5Cn5iDzwk1OfNO7tTWml1KTTX/bt7a6vRrobyipRglG0btvZauNO9mo263srddd73F8sG1ZJI9v2u3YbmJ5Z1DKwJZgFGwkMmDglWwAVinVWubhlztE8h4PACyuNpIQMVKsTuO5CQF3MOA0BftFu2cL9stxhSxC4dQSqoyqARtB2Y6KRyTh0oQyzM7Sxt5kgUZJT/WnBXcyOQW4IA2hRg7iDhJtyd2k04vdXvypW3Vu630V7toxStbV/C7Xeu8dH2svy6sjkWPcH25cplcM2SSV2lgBktjHOAMjkfNkQDZvXIPptYq28kg7csVJ4O7HT1yeC4sxBKth1ccZJGxSMkkbmCtkMzhmHYjG3dEcqWDKeRv8AlyM52gDIBYgFeH4IyCcsBVNra2+t3s7KMlfTyvrsktHoaRuly7rSyt1SgrX1XK2vuejWibgXJJ3wui4Y/uyh24UFPN+6pAzznIHruNMb52DgAsittKN8oyc442ZwGIAyMgjd8jKAclIgyYbcMYXaWzjaWZjuLnBJwoDKQcA8gRmUHIMeWwcszAqNuM4HKhvlGSCOAenJF2te8rNNa395cst0klZ2u01Z2voyr21VubZO1lsk9rX631vr2ZIAclQVAJwSEOV44HCsQvQMMnC/MCSAS7Y7KQBjav3iQd20ISilwCFIz0DBwACAck18bZOTmNgGGXIyTtAUjc5UhgwyQMgALu4xKGBCA55RgG+8D93ABDZxgAYAG7OM5GGad72ik7t293VKy1uubXW7sn1vo7uzSutL2svTl30vZa6L/NNc/NuUAZGWULlGJYFQckEcBeVGMcArkgQsXcj5yjxuONxHdR5eWQY65BLEEDBJOaczcMdvzZ6ryAvykn5hk4JIB7dDnrRkKpPKg4YA9+FUqxAyS3QoT1IJzwKnSyu+qb1391Oya26uyvtq76pJ276tW67tNrW6s1tr6u6JBtyc5UYz9AMYJYgn5SDn5sgAHoKf5isv315GPlYMQcjO7jdtJPIIx1OcYxAWVjjaSvDHJTGHCjb8oXHTOAeCP7zYqPZ12ABo22g4K5QAHcRnJGAQTgdsgHkNSdltt8PnaLst1a3XZ2tcFFO7bf2V8/da/HuvO9zQCqvGTtCnILMSDgAE9wG2gq2AcAZzt5jztChh8uwITtG4HcCfu7gCpKcdTyQRnAroXV2DMWXJKsdwBIwCpBJA6HdgEEEBfmBy9doO88gABVJP+sO0jA+ULs/hJ+uMDaNIu7TtaySaduy95X01tdW1td9EwtrrJNu3XVNWto9rXts7JbLQso+CVIBJX5t3AKfIDg5X+I5UgAsx5I7OiJwdh5PzfdJXBK4GFJCvjrjICgAEngVt3I3AkAEFvvAKCpO4ksCpLMSBnsMFQQAljuyhA3llYPhuxBz/AHXO3IVTkjjBJAqXMnZKFvd6qPSL0vbvva/V23T5Va1rW5b3s07cve7abd7WstPMtxygDdkElsKCCQd2FYjIVdo3HZ7KAOeqiViSCVPAbBUADocbhjG49ACecqoU5zWR2AHyjaQvOQeQQo4ZiFzgHBHHDHkZDi7E/MMkMoG0/wAJC5PAYk443A7j3HXDjLRK66JdHe8PXbXst7N20XJFaKGj5ZaNWvporq1knorW7LqSmTcoDEqG2bWIYlSdpGWySqg8hcDcoJwGPKNtBVSxbKjoMrgFCuS5wVYggf3uCQrEFhSc4YqRjcjY6p8hBXGScnoxKncwACsNtRMACwAP3yvOAegByBkqMjnGMEHgClOTtzN6NJpWd0vd67p6Weur0W6sKzdk7LddE9tn3VvVu6um7AAADj5zlW9NqkoAQRsyuQQAQxJ3BjjpG5XaQCAdh3NhSxYDk4wxBAIyAcDG4H7uFcHK7mUkEBeWHGcgnkkZPQ/LvUkEnkhkpZVIG0YBBwDz93kJk9QOTkEjjBHNZt7t6pKydkm1FR6q2luj6+lyoxTa1Vml0105dra+dr+dmaF6UZrZmOD9itzt27MsuePnJJLArkgjgYxv60g7MflBHQkEDhuDgAEnPReWyoG3kNVy5Tm0CrjFjbkEqQCcHAAIYkZYMcn5wAclwc0Rnc2HGOrYAA3nbkYyAPToSQdoIxyO+kul2vndbt7vS+u99Ow6bVujWj6N6ONrX0b7ppaJ6faJcllwNuMkcKAAxAwSFGMKCCc8Z5B7htwW/wBFBVgUtVZNxGGUzOSQH6IASV4Icq24q65DVxgYYLjhSwPQEYI3D7udvykHI4LDIqW5Zs2Q+Up9iVW2jgbppTg9WwoI+UZXoRydtN2cJO605L2/xJXd9rPfV+93R2UleLvyK0Y2fSz5VZ+a3d9ujs9Is4O7ht23gKRwduG7dSDgnBGMdCcyRs32qyXIOJ4sFcAK26NgpwuOMZJPcKwYY21GzEgbuu3jgluwBBwSGO7KnoSOdx6LbNvvbFQSALuHc24AbjIgONxyFHBDYB3EA5YgmL66v7UddE9467u2/ftfuTK3s6jte0ZPRrl6aW3bV7pNqz6aNkt4zG8ui/LC5nYkbTk7z/EMZyAANwwenD8CMMGwGVj90HadpIUpkseXBVj8xwMLjdkkFpL3H226ALNi7nGd2SP3rMV+QADtlQXA6qSORArYJwc7lxghmG4hMhSeASeVOSwAwcAcVzWk1s03a2j+LfbTRWvte9nuiaesIXjpyq9+1o3btrZX21766otw7JLq0wQjG5hUMSAQCUIyctknGcgc46hsFZbl1W5uV5BWaZtxY/dDYyzSAq4yuQ2AQD93gkUrcA3FsAXUfaYyzEgHPyjG0KwJ+XAYDaXwMKFOJr6Qx3lwiqrBrqRSwd2CDeCR8xUZIAGC2FOeWUkVUZOKfdTXW7d4q2u+1tr7X11ZKiniFv8AwndatLWDbto21vy9L/e5SMY3EDqSSCf4MjCkjJPVSpBySDg4pyYBOc84yDtwckcLggAjopYNjpjGVqBXCEnJzjgHAORtwxwCTxjrwOWU4AqUTGNGaThQQN21mOPlHXDBhnHOATjL9K0i9E20krPXpa2rWlkrdFbTRo3il18rNqzWq6322TvddVtcv2ZkEkqkAs1tcsp2pgMIhg8nDZ9M5dhzgAg1lJBU5wCQMfMVIyu3G0AEEjjLEg9MnpYseZZQrDJtLpiu9ckNDx0XHQYXP8akqQVJFONwWIIIIwMlcAZ2gYZiAwJIAG35gAGwwIOqnon1Ss2rWb916bPrf5rR2HH4pbaKOml1893sra9PIt+ZwwBUjOAvOcEAHcApxhSCckqBg4IJzWmfy4U2ggF0UAZxgshKgA4G1V5wecbjwWanq+0qAvJX5k6hgCpJwCFxgE9SVKkj5c1XmH7peVB86Jh8xKplgqggfLjDHjnccMMcUTqSs2mr20fdaXv3t5+rst6e61a6Xtfttfy+Ss77GxCR9hvCrfKs1rkA57zZ+VTuJJyM7iAxYjOQRRilVlfCnGSDuI5ClQcbhu2r03gEh8gA4+a1EFawvGJ3Az2ir0OMmfcCmAcDPDZ6emc1V65HQ5BK8AnIODuXjv1PHHQnNbSlb2TTV1TWmjtq1v0W6Sv10u7XtyfLTu9oprfS7ut/6fXUcJPlOxSxJBAAwcEqwOWXbheAMbSG+fG0kU4SvvAKYjwMNlCxYFAyqoIAAYYIyWxgrgsBTAdoULtwCML8wZRlSScZOMkklgxyM9DwhLbsKwK5OcqNxAIyB6HC5LBiwOcZU5VKVl8Wra6K1/dvv+V23q2t7ib3vq3debSgu66pa3feyJWZ16YB45IyMAKMHOA/PCnHbBJbNPZmaxsWBKANeEnGN5EobAwGbd8p9U4OWCgMtR3UAABAm0biSVKqAMZPzMCSPUgcleTxLv2adp7EhiDd4BGQB5o5Jz1H3uCAuCMHO017T4rS05E7yfK3aVOzaTs9L7W2S8lNST5qduk9b7pcjvtro01dLXotx25twIOeoYKpVgQQSp3ZG3ByMMChORndmonDSAJu2HerBmJDYBXBDlSTklWCj77DHBBpiOQ7LklcFuFILZI4VQQm9cHHl8AMDg9aidgXwS25f3QK7uBwfMdiysxzkFiMIBk5ztGUql0rq990nu1y9d0tdlazve+rLvpbRLS62vqvuvq9PPTq9FR8rAkkAKxLDH3AoXnKjJA4+UZyUIHBpdwUFj8q45A2nBJXjKgkYIHyEZXkgmqSPJhS5w4K7lOQGJCsGHVirgckkEnbk4ORN8i5O4jOSOoQHAAQYx90fJtYcjlXyQDccRK3uLW/W97e71a0va+9u7vuueT0T2166badl31aXkycdfdG6gLgNkY+YnBxjgjhsncN5FJu2k4zkgnP125wBgAHHGT3wcqCaiDBugIyuFXd8zA46nnJPXJHBA3DABDCxA3EgEkbcbRg4Vcc5LbR249vlzlOcpO7eqtpZXS0aWiXXfo+y964273bT02d2/s9bLbpb3beur1kDdCDxk4OcHsCoLYOOhycjcRkCkbuSwU5XGQoJXuASQeSBnO4cDJyagDbSAhUIxG7IIIPAPyqSB3YEAAAkKCrcKxbKkA444yScAAY6kfOcnIwCx6HnKc3bV3ta97vX3U3bTZbq2773Hvvv100+KO60a1vd3Svtre797AuHxjlQ2MnGRycsAWB/iCjOAp5GCxizDuSFVlPscD7w43Mc8qCvQHax4aZATlWXIAzwM5GABlgSQMgk4z2AJw1V5GYtgMeDgLgn7pGQWyGJxnHQAY3EEipc1bbfy1u+W7unbonbpbXo0X6J2vpqkkvhej2srLbVbNXHMzK6uVYKqr1J/vL8+04AGQdpJOxl3YJwKY8auVLKGJZW3FgqqeygDChSNu7G4FgBnJzTyzmMsq/OBjoMAA/McHnaB8vJG04z83JYxIC4HK4IJP8QxkY55J7dO6kHBrG9+zTS382rNN6aLp6bdU9tH26q6tb8m9OqV0+ye0RkxG5bDDgDOSVwwyzMAchl37scAk4HJaiKgZMt5hYPuZgT0TIyWO4ZAIOPn6khhUUbliSCMhdpUkMEPy8sNpzxyVBzgMC2AaCzqVTbuYqrOW2qscZKKSAVb5+CVCtgDkLgkqrr4kr6WvbXdLTz36W3tYjfon53/wtddfJtLqPdwWO1l3bgRk8LnB2ndglmJHGArYwT/EGhuS5cHKgtglgZDtIwuQOTtyg5yQm4jKFPJVFIGW+cyFi3JHJb5VIjAYYODwdwPGNtA2AqQcKUAADAKGBU/xP04HGM5yVJIySPM2uZJapqzvrfVNLR2a67vysUtWujdvy7rtp6bdB2W4yVXADAE8EYUbGbGMknOcHIyAcgGmI52tnaAflOR8o6AKDxnHyjkZzjBI6rvJJ3Z3HGNrHoWU5JIyCOOQDxgN0JLCGOFAHI+8ecdAQCd24tkEgYOeRhcUpJttaq1rvSy+H3rpeb2tpqnZuI0kraau1ne99VfVdfk9Ldd5CXOASuGAOcFWPC4G4nJIGSW7/AHfVgxTtbeAM845JH8BwA2ApDcIR8w/hHYIMqxIBOBk8t8rYjAAB5YHHDZBB44YgUMTkZHLKCM8Bdu0LuLnAOQcnI5x82QCubd7p2a67WvdL5v06rfu3pq9NFZuyta2tl1XW7u/NJjvMkj3FAoBwgjZVKyRkNv3qoBP3vvEgxkhhsOGCuIwoeIEJu65KPG6k5jc8tk7co3AZB2IIVCxChx83BQjj5mYruJ+U5Gc5P3lHXcByschCMJPlV+JVYgMy4JOMYVWDOSjcnPAwFKsvJv1a738tGtGmtX13E42d1q9E00kntvZ9Fp1s990O80Lkn5ELGNGYB/mYjb8pAIxznauGwQRgkhqExsYyiC3mR3lKBy0T7iPNiZiFD9N8asElQEAZQbECCFgDl4mUyRsXxvMbEKQMsRIgARgCMk7gCG2swhmmVg7EAFWADhd27JAG7IQqwMh+9tOPmBNS1s0rNW0235dOieyttfuS480Um7W2to4vRq12lo0tVa2ve7klUx4AwBhG3od3mwk48yF1DFkbBCnncVIZcjg+ZFQPhiV5IBIK4G0bm+UkkEEMBuwSDnFLhCEhnkVITuaFnDbbaUh3CHMmRazNjfwQhPmKuA9RFXyUKMjKwDruyN6Y4QBiuxi2AwO0rgKWBViRk7t6K7VtvJrTZN99L7apNIpTlrTnZTi0lL+daJSXfl1ur6PurBGZ8MGVFwSVwQWIGBkHgMrYOH4IOcKp2ikSRpf3asseW37SUXKhlB2ABmOSDleScHByQaa8isrABuCqEhV7gEABup4Odw/NsCghXMDtuTYhG3ad0iblIQlWGWByxyBt27m65qGnolJys4qV/OS1TVkmrvztp0s9NLW1aXLezs3qn+N3dXXlezRbG6WPLgIhBXBwd2AOW34/dnBIyCQcKVzgmqvnupZVKABgrHcc7dh2qJMHJ5JYbcjO7B5NhdzRqhzg4z1IAK4ABBYsqA+vBxjqAYVcY2lzt6b2wQAcfcJzkMCNuAc5JJWRfmupum3y3UbvTm15Wk+2rtbolqEne12l9zurwflt38r6iNKUcI6Bc4TcAhIRsFgcli54Y7dxYYDFnyyBysX3bUPEjEyA5Z0JAOHZ8/LxvdUw+5Rhck1GqH7o2khkJRgCnUMXViVUlmIOEyWbJA3cVKq5LqYyWO59wChWUEYCglwoYA7SAC3ONpxWUeaTXvN9tLaWi7uSTV9Nmk7Ple5F22u6s0r20ut7XTaW7fbXTQmQxybzsBYoVLKAA6kLtClyWyz4GcBWYDJKqoqC2jSWVlcyKFfYDH8pRQyqqqWbkbcFlXBLKrOFxmpPNzsWLcGYoh/dkKgIG0lT1woIY5+UHcQ27NWgViZFykZyvDDa0mDGCcqTt3EffVcngYYgE3UUZpvS0YyV2krppaN/LrfW2ly7Jrq+W97aLZafhdu2t3Za6556cZXKch8ck7e2BhiMAjcSM8cgAVW+cH5SSpAyoOCRjjuQPlwMjJPXd1E+1Vyc4yDySw2/dOdoBOCAPmOSvTBBqu2zYJEO455UgcqrKSWVWJ6DOW9d2SOa4LqUbaLto9NI839LytazPJhd6X66aWettum2npZpq0SUNIiDbHgOURC2Wy/ykkKOSAN3yuGOOc5qTJRdxBYZCtyAPdhjjd8pwPmIAHUVXO8sp6BPmEQBJUg4LPgktgD+Jjxkc5OJS52nI6kKAMA4IHTG5jjJLEdDgdOgm9W27XVm7WtpqtrJ9nqtbXYSjeysnf4rK+l1u3rezd7bv52kZixXcQAu3AJBwAFbDgBhjBG5Q2M5JJ5FPX1YcZIyMc5ACnK5wDwFAG7od24ACNcjYyZKFVRs7iDwCvGeOVGcdAMAHoXINzOmSVQg4IGeFXAB3FQD32/KSAchzzSTv3vu9PLXV+V3ZbemsX+Vkr2buvhV2r3Wqta2vS1iTzAdpwcjAAIPzA4HOMv6D7oxhSwyM0mVACjnd0PVlOBwdp45K9SAxAII2mmkcLtQuwIOCAB99RuyQpzwcEEtyNwbrTgN7lQwUlR2XBwVwOwALZUdVOXwQc1S1av0aTut7W306eXz7ItHS7uk7aNu7uulrre6tu76pJieYUJBO5hgn+8QQuMggs57nj7owRkg05G+UgrktkjO0cALwWJxjPQDOTtDHdg0xkYtwu9t4VySSSBtwQDgkkgfMG6AAg8BZd+1SQpDEnCqAu5QcE/xZUZ4bIxnvwA4t31V0tu62vutbeT08tQdnyrT3lZ7XbcYuystE3fXW69GgBD4cqAULKO2drAEnJUsVIJIAHXJ5FPwCw+8p2554BGVxnPXjGANykAAnoaYCpXcA+0FRwELKSVILRjcSMZ5yCMdWGTQpw4YAuTuIYbSFbCkAFONq9wR94MQAQRST7KzutW9Fqkm1o7NpdettrWT7/d1s9NG7dtlutB4XuemR6gEfL3JDHH0zj7wxzSgY4BDE8rnoM7eBuGAAc8HqOVwCQANgZOAGwADt4yEOerZBUjD+ijll5pCcAYAkBBJYEYDEAgY2nvgnr2Kk9K0UmrXXzTdnolqlfZaR8mrWurQ4prb16Wvv89Pnbewo+ThdpPB3EE55AOM4O4H7oBG7t1OVYxglTjOFIPGex2nry3BxggsMLgjNNG/b8wVyQudvHoQMgjgY64+Ye+BSMFABwTz6NwflzjqG4Gc/KTyMAA0c1l01s0klFvWDte+krdHe99tWZuEviTut/ndd9Gtlrdu47zOBlSfmXac9QMHIxjkEEnsOjfNlqkEijgsQWGVHqCBjIJKk9OOVPXOQKhEjBgpG4Hb0C8429gc4GDzuJ75IyC4qvTPI2/MSM5IXuFx0IyoOOecc4uE7ydtmlp9yvbmukm9bt76WehDV1Z6K+yd97O60drvd7a3tuWUlJJJUgjuAc4wM5JyTnABOPp8wFTeYSOoxt5yccYByeRgEA8EcgkH5uaqKeAQwYALkZILdCDkHJBGBnjGOQetSKSARjcM5wcg8kEDAPbOBgjcTnO3p0KSa0stFrp0UfVx6rR6X1dt8pRTS0vdpbaK6S6677u3lqyZ5gVXJCksuN3IK5UHJ4cDJAYrk425J+8VZ4SnOBGVxjJVUIwQfl4wobAjPK43D5SKrtuOHV1Doy4YruTy8jeGJJUqCV5OcjkH+EV1i+0MAf8AUKwARTjzJBty7bVT5AOVBIbIBAZeDzVJ3k0le7tFa3t7ru+nKtb2SvtvcqEItK7cVHVuz3fKly2um7aJ9Nb2s72xKZpbdyxa3DyhDxvdlhVS5zh1AAHHA6kYOALpC8PtZXA+UqWLn5iR3UFm7sGyQzbRkCqkq7BaxxnOHfaFIG1fK7bVIypb5RlvmJYZDEUqSpueLJyhDknHynC8YbBDEMoZQCSfl5fqJ6cs93yvo2tItpadNulvuY6i53GS5tIq17bJq17fPR36pLYfM7tCBKoWVbq3AIKjIDgE5LbnLMpJOAWO0sMqrVKHBllJySHZvv7sjK99pz6HjB4BIbGIp0eZIlTBcz2/lhd25iHBAztJLcZyQCAfmOV+aDJWUqXIZZHOGOOrj5W3dWOMnA2/LjClmJ0i03y2urxj01fpv1Tu9dm9ybKUV8N/e06pe5pv1s99NXp1V0yDd+7j3BlDYKOSBwG2hmySOiHJOQAc5zVCzdTPd+YNpEbYyAPm84kZyCBnODgEEgrwOKVpxIRtBAQgbhjd8wUDZyJMK2MjBO3PTGDTiVGmvFO5fLQEZYrj96vBZSTjDZwcgAhsnrVOTUo+7dczjZ3+zHa8e17aK2mmhVOnaE07q8Ivu1dxs/ue21/JmrJIwUtHGHLFQUJ2jBYKGyCpJHzHgZKjLZJY1CG2kNMw81c4CsUVSyqmFGMl+W6kcAk7hxSAkthmySv9wt83Cnr1JZSSwwSBtGGBNVpmbzUVgWLfNncFHmblAAzkhF2lgMBhu3bscElJ2Ts27pcr1SfutO2r6J2dlZbK4oU0202rtXbW9vduryWmnRJNvq1oXJiAjLvcBifLAdtwfKYQMoyMgfMQVGBnIwBUYLKYGd0+UcptwNzYC7S2CWVQWBYlg4PUtimguHVj8/yAuWABV1AbahBGGyMgkHgs21iCKY4Ysu4EofnKDl9ysqgu5CkqVBztOQTnjOSrt2lZxd42Xo4yu7StL0V76q26Go+7y6W1d9bttJWtpbS99d9mkXgxwAF3fKBtIOOox0UBQS2FOCwP5VCLiNjliQVYIcqw544R8DccnPXJ4LdATCXjlZlYlsL8zK5UMHC4Hcl1JGBu4IIw2MhqHZCYwmQowpZuXO5Sjck/OflwARtGFAXBq+ZvWLsrd76rlunZ9H0Tat02FyLl1UnK8fWzer7Svbrr5q7LJPGQzMcgcZI6YCknOW56EEFT2xzXlm+YYQsoGWbBwNrKNgyFAUfLjOcbskZzkcxsNrI5OBg8fK3yk852kLgHbuzwCWz0TdnAH3FUqHI5KHb84yWUAgks20g5HcVaabs7dLJNJuzX3dPXV3UrscIpa2em17LorSur3s7PXr5u407MFnQ7Qd67jtAxs4QKMfxYfGA5wSRginb8hQqMFIywJLZGBggDcU+UYyOQuOWOcQiKIMXVmEnmZJy7EMQDs4IG04Awx3HkAEAin5LDcrhsY/dsoIKboyUOWJXOeAWICsW6hqlSceZNWTtdJvW7Wu/ZWSs99FayNmoWsm/Jz7+49tdls9G/PS6Fk3MESXcCSpZgoLDBVRuKEqMkkYVSpBJXBBjYMww+1JFJyB91gvUn5txViPlJAGc8Y5FolhtByBg5bdkKchW4wB8vcc527lweDXb5idoydm0E42HBHUBiSD2OCGGRhTgFfC97K62XW8Xtreztd3S7pXY4Sb91WilZpu8noo3fo07206W3Q1G2KOSSGCkgAY+VeCW+Y8ZOTyQMcHkSeaQ6hfungswVh5hKDHUgKVAJGHGeQM5Bi4YlfUIW+XjdlTjBAI55BwSN20HOaniGWYZOAyEdFwAMFhxxtJx8vA9RngTlFxt0abdu2v4tLfvdO43bWTTvrfX/AApPe+iab0ulZ7pXkBMbGQkFXAJyS+zBxyMBcg7s4ydpJJIyKiYiZSEJK9QwBA+UAhQMA7TwCMgKSCeOacrs8e51CuS69OSoJVc7vmyw4bAx6YbIKxMuBt5I4G7pgYHy4AycBecbugYg007q+lmk9d/etZvrrd23V/Nq6jePNeza5VZSk9Eopq+zvey3tfVdQDNzkcldpDZJVioHOdxIbIwBhm5yfukQgiHnopV3JZfulzkxcsqgEDaoyOpPBwanOCZBgrkn5stwCVKsANhXbySyggAMq4ySK6FmjZJm3bH2mRlAG5VCxlCxbqvRgqnnLAHkzNrm5UvsqzTejbV02mk77badLIuGsfK8U1d832FvdbW2vb3rJtFhLpWLFVYYXBBKZAwoJwBlskngYOFIIH3qcJV81FYkO6vsDFsMRjJG5VBUckD7w27Rnis+SZ0k5dXSQqzsgAIJYAxrjadwGS2d27jGCQtTF1yrNuDogVM5GQ+0ELhVy5ByQCM5KkAgChVFJW6rlvKWis0nok30tp3WytZEqasmtdW007tKyit3pa+qtfonZWG37BoXWLhAsZ/hbLFycr8uTjPzNjgHbkZyWRbnQsWywZsj5wdqklhlhnBBA3AD5hl8ACmXMm+2k4POSqDO5SWTJYjkqo4ALDggkAAGljJ28KEOwZAGCSApViA5O0jAYgc5KkEE1g23Wd1p7OKau1f3tNH91rXd9Em7LVaUtLL37LW9rKHXt57O3Qtqp8y3YqDi5t2DEMWUbwdpY8cEksowoJ5wMErct5FxKo+ZRLJ6GTlydo3FlC4UYX7oBJUkkAQwh5Ly2G8hDeQAAsQF+dQWGcqd25QpK9FAJAPLL5pVuLhQFKi4kUsVO4kOxyfugMvILBQBnIG0OavntzSUbXaitLpaJu2nRNfdvfRwk3OKvGzjKTT1Su4rqt1Z/lq9CLc6M2AX3n93gt0zwi7VC7CMZUEAE8EHNKpDJGQGzksQRnG0A7CFByp7BiAOjADJqFsBlY7t5jKAKVUc4wwHXaA3J3BmAyCEJFSZXYu1ivyqW29GB4ICoflyxBXOTleCQ5oi25armim0rtKzvGz9U2na+mt9Hpbj979bq1td33X430d0SuAOFYKzKu7DNuI24I3KTtUA7sEHLYGVGKBIu4KqliyFTwuCDgNnDDfyCAGCkEdQcikLI6OF5KjLqSy7WG07toYnORwTyq5BxxUaeoONq5bB/vAfdGMg9yQMEcHP3g1K8lbX0u997tXva3m0kut70oq1mrWte9na6irpPq3ba91a/UFYBeAy5wCck/NhMgqnTHzDdsbAwOatBk2KDgKFGCR0K4wAxzu5+UZPzY65IqqzAEBVACgZO3p9052fNwwwWJI44+YlacCSAuwgrtcgY+YHa3HUKCMY+XkgDhhmktNU9NG7pu12tdt7X00fS97iavayslZ6q2/la17LRbrvpq+QliCSFkBBO5eoG3JJIySGxkkDIxnGeY0AkLKWyR8w5IXdhTkFgScsMBe4xgk7aVstyCFGwAZwckbcNuYdtq7TySQMnJAqOJs78kHlVGFVeAP7x4ByepXJxzyFFJ7xXR7p2jsk9HdaPSytaz0Gl7rSto1bRq13G+710ezfWy6kgIKgs2OgUEE9NpyxIycAfNkZBILA9aCQSAxIAGQ2RtJyuC3IIXI7AkcEgP0btySQcnAOe+QcbgTjrnCt6gbvmPLSSwGDsPc8fMSRv5ZVBPC8D72BnHWqvJa6fDZbt20bSVtXazf4eVKzau1a9n5bNrW2mu99+5J5pCk5wx5GzByRtzuAVTzkE9hnnggmRZDncTglck4zghhlSoBXB9MgjcAGxjFUnlTtZiGUBTlQv3cswJOVYZP8LcjIOBhwIyCQc53A5wAMKQAMY65wQGB4U/eBFKTT7t2bv0vZ31vu3oktlruzRwjy6WurbW0fuaaXejWy6633RbLABtozlC20sQd4wCPlAUjIGPmzkgqcbqgDggMAy/MFDZXaV2oCCU5BHZckL36gB29iAc9x0J6kr6dCMZII5POMEgqFCphDgFg+c7j82MhyCfukk4+UAk4wcGnzNp2bSt1VtW46LTqr3u/LZmSsrvfW1ujvZJ3un/wbX3s1BDNl8uTyoyoBJ27cEqMqMYYgkPnkKSFMwYqBhCQAoK7ScHKHplsknH8RwfU1Xw28MOW+9nkldxUE9CpBPUdzgnJ5ExfZt3qCxHzAAZP3eD6YPTLDOVK8EmhPfo1Z367K/Vu6V/PZN63Ibu11076paaWutLa9fuROHKhcoGJBYcqpLBU5+VSpBOASSMYwDg4VjMSwPUbQG+UcOQvynGCuByCNxPUYOQYVJwTyGDbg3AQL8vTnb83LDjDDqBgChQTwSrZJfJKg8bTgHJxgDAVQBuyQQCAK5m7aPXdX2slo0rJd0tH6uyBJ6ap9NPNp9Nn92tuo8Z7DGSGYk7sgbSTtADHOOW4OMcAdY2LAMoAYuCcE4AO0EjAGzeMEhN2FPzqwXApS4Vcgl24TC+ZyDgDLfTGTlcDGSwyaZuyhBU5CHdn5cAhTkhMBQODySeSoUggMnJcu93113s0nGzT/AOGfldWk3ut+j0u7rbo913031RqahLuNpuVTnT7USMmFPAKhXBYlHA+9wgJyApHzNmbhx1xkbckHj5Dg5QbTtwdoBGeNwHW7dCNWtdjctZWzNwwQMVw2C24SByQx+5nAyAOlE4HGRy6nncqgkqQGxwccHGecbs44Cbezemisr2btHX7NrvXZvR7Wu6pfDBxurOKtLS693Vu/w32VrrR21RIWAGWVs9ju+8OvLfMwYbegGN2A4HBL52GbQlGXZaqNrb23bpJMsAcfIeOBkhgOu3BYFyT0J5OATjBG0gjJDEkAAkZYsM5zgTXTrizG1PkskywVQB+8kBf7xyowQrfw5JYFfmD97km76L2atpZ+9GTelm7K9u700VrdNK6hLZPTR9dYq1l2+K+763d7wuAdrBfmypXAwyjIJ+7kAD5ctuAyPmyMgSW+DdWWSAftMJLjKkYcEDcWBzn7zA98KSSDULbcEKWHI2ttGGBwo6lQFLdOCpA3EqQtSQqPtNkRkn7TB1YEcMNuCP4SScDjAUMCAuazb9697O8eb3ldPmikkk20tG31082ZyVoSV907aJ22a0vp00tfS1ye+Crf3ihjgXc+SXJ+XzuikgAkNyhxnsNrggVFIMeSckEYz1IBUHLMCxBwSCBnnDBSM1Yvd7XV0XUBmuZmbkEEmQgjIzuzlfmwAx4O3ANQK23GSGO0g8jrxnG4gjgA5JLDCgZU5qk/edrqze/a8dmuytZXbT0eiV3S+GC0+GKe0U7cvVbPSzld6KxZiObmzBBb/SYl4ADYUrtJC/NkYBbDANzjswlvNoubjCEMLhxjhicMGAXcCpztOMk4HzdMZrW3y3tmN33ruHq2BncvHcYHOApYDtkECrV2EF7eKen2iYAgLlfn64BACg8sCo2k7gRkmqjezta3MknorWile9722fzve+jhX+sx0elO70SS1gndaXXrvZ63syihjSQqitvZi/3myQSmSoPLKBjKjAz04GBYZnyML97G/K7QSSgz1UHK9FOSTz0GSMm4B8ZdSu0jOV5OApXaMBmDFcsNyg/dKmhQx3bVAP3WJzzhV+fBPPYEj7pGAQRzcZaJWVm001ddVbR7tu93136adC+Jactra6/3ejWtno3bz6JmjYbzLcBWCk2V0QzkDaTGTg4UgHn7pI6AggDmmknAbcMDguV2g8oTuZvmzj5dzDnjknmrOnAtNMA2FFnebvnx0Q4z8pOBwRgDggED5lqm0aSRbRhdzA7VwpDKM/MVBYqQVBXJUELg8g1bk0k4u+j0dtfh7PTezul8yU/3kkrXUYvdWt28r3WttLdVvaiDBUbKlSNoPJzkqcjkZ5wMgkggMOCRVS4+aItnBE0SgHYp4cYz/Ec84zgDaVIHUzxoiKEwduAyjcXXcduSclepBGF+TklMEAGG7K+QR8v34VJIAAzIoJJx8xyOoADAAHBXgm26bldPTfdXTTWut7er/Iu+3Xpbz01fTTur2b02NaEhdPvmAPM9n1Lnb88+CGwgHfcWGRjkYGBQLDGMMMgn5TggqF4+TJOTjgHkHch6VchcHTL2MKTm4tAWO47RmQEEkgEnYCpA6k92INBRgcMVXGemRnjIBUZGAcHkqoyFIAwN+ZKMH0cElbVq70d/R7Lyu7Wat/BBO6fL53tfTu9HfS1rdNWKXOeEdsjbgMTkfKTgAHAHTJIKYGcjcKakhG390xDLnA2nD/KPLIHAwMADI55IKKRUI27W2qd2Wzks3DhclMElQdwIKg85DEAqKcg5YiRjGT+7UqQoYBSu/LAueCUJBJ3AgqGKmOa1ld20b1VlrBPft0tqxa2SWutvPZbL/ga2dtLD8hU+VZCCd+A2Tu+RiCF+X5AGyDwWIK7RjFotjTLAqMAG9AZypUkTJuUBsjBBYgYG5uwY4qk0pG35D5b/AHmIGCxKj5clWBJ6HJbaSwPADWicabYZYY3XYC5Cg/6QCOQSCV7YBUZIYc8HMnKSV9I2trr71OzffTts9zKpbmo6a876q/wS3d0r+SW11vtXJJdcLtzKNzHLlsYDFVKg+xY4+RuDwGCyEHKMwK5ALKuAGAVlAMmflY4zgjPb5ukXzblzsCYBYKhUlyceWGyuMBQcgjjJ43Cl3lgFCfKp4YhQu/A27c5IUlsEYJZjuXJzSvfT0VvWyWi76b9jZq3TdL79GvXpf8LaMlBK4wwCr95ipG0OB1O1MqgzghTtbarDinqdow5DFcAN3AG3G7ecgZA2nAOAC+GHFdSTgkEMGXqA+eFO4gkMcgbWbnAJBy2alHPOCAADtPI/h2nKqc7gAAcEEbQx4zTjazv5a9XstVaztbb/AD0L6elr7Ps3ora+qafyTb3IGDg71JPfLEYOD1BGOS/rkkEYUorRsynGCAMqc4J+XPALcLycE5A5GQflaCrAEEjdwwbBIwFJztCkk8HsSOmB8tMVwCwxzkHk/LkhcbeQAT/DjjPGecU07Pe603va+j89fTZ7pLRl9vS27XbXW+unklZdLkpKI3CnJGMAk5I27ScYGeV2/MCCTtG0laPlyF55Bbk4G3jOABtOe+3nHOB/FECw3BTnBDHOSpOF3Ns6DaPlxzzwSACaN5U/J8wIw2SdwGACV+YfKw468YxgqvJdJaau9rJ9uWzb7+dnffVaOk7Xtq9kumjjZ6PV3XTf8RTtyrAcgkDI2+nHYlvRucgHIzzQBtdnJAyv3cHCsCuUycgnALdFCq27G3O5RgjAUjPzDHVVOOAAApyee4J6EACmlPn39c/JySFGQCcBdpJOOTxg85KkZldem/z0W9tPLV7J2J6dtXrb9fLta3ceBjlWAX5TjAz0ADAjbnOMA9wdwDAktG2Cx3EfTg4Py4YJgYY44J5GQMjHKkYBUDlSoUc/d3LkEDgqeCOxPzYPAqIqRuZevBAJ2qFO08gcYyCeCejdD0H2300u9dLdd2tLWeyfXrN9tHquy8r3dvLT0aEjUxlihwWbnG85Rdq/KSBgDHBxwSRjAG17PjDBwD3LHgk7TggHAJBwOW+UZUjpURcKFbaSW2pkYDFiE5YEEZA6bjk7QAWDFaGQMVD8ggEAZ2g5QgZHXGOc8BgQG4wYTTSUXZ9G1ZLWOzW1rvu/Pa9WvrfZf8D8Om34oUlAVbDDBC4JAGSUwfmC84H3ccgZwOlN3Zba642sNh3DB4Qjbn5iAu48DaQD0IIpQDjcSOmCpyQPu8sSOuBu3fwnAbPOWfLGoIJLEqcYOeQAWJbIXr6AAEjPzCk5NWdra9dd7bXflbZLWwJ6dbK112enm1dvo9GvVWcXXBaNQ2RwS2eFCbiykKcqBge3PIGajByoAUjChmbP3eU3ZCkAHgkfODtAIAAwrtzDAxhdueDwCAp2gAYyeoByM4b7pwWoSI9u444UgqS3zBeCc46ktxgZbgAkgJPVRS96yT12V4pbavVNJXaVnyvRNO7/AMS3Xn8KV13eis9d1unY+VgVLgYfOVJwQSp27huGGPORwBlsBgKSMMVfacbDlJWOQwxGFTGSrZwWB2HcSRhCDSgEsFKq2DuGQBuYeWcjGCST3VTng8HinlsA7VIXHqR1VcbMD5cnAC444y3AJhdbvS9nbdfDZdVd3ur2Wmq2uXejvorO3lpdbPS9tdPLW4gUhQA2ZGx94kBs7BjnauPlGCQGOcFuFNOOcKeD0JAGAuOrHO7O3gbhyM4IOc0gIGDgZAwePmx8rFuCWwpKjGByAckNkKWGSoHKrksQBkfKQVLKMsVxnB6Y5yMBRsr69fhutLW0T31XvPS+t7ascXbS9r20t193W76del0ul7EruAuyQ5hZgMIpMikqVLoVKgMOCydGU4O5icVBlGCkMSCJQ6vhJULBSyqSx2ttYlSMkqQy7hxI7ksFIb5QCwOMADZlgG5Yg7tuR8oIB7mpd0brskbEYJdJBuVkYBiDgMEKPlBIi4BGHX5gGKab2a92yV202tG03d663TfW+q1ZPLo2nrePu9buybW600ts079SMukroWXKEPgnG07mCbfnGVH3gSCecYIIyXrMsqC3ndQ6OVs5mJCtGpZjbSvuRl6boWKnacQvsVg6wRs6sVKbWUNgHDMFAXJQDJZGx13HoCFJ20SKJSxAXdllYkFt65IY4JDHaTgMeF6YxzUNvl5oxUntZ2Wl07aq2y3e3VaaTOKqWaspRknFp7Ncqta+qez6WvorqxuBbaUBCsRtYbiCHYsOCpXBV8EnuOQS2HIwBJC4DA7WKqOWCn5QDkOx4ALFTg9tihggkkMcZcSSBGMRZtnmqMP5LktuNwgDGMEBpAVAyQtNRWwQS+Q2Qu5uGwAysdo5bByrbcMAxwNxrNTfutq+q3fbleyVnZ2u9G1tK1hRmublduaKu4td+qv00ev+TRPbkKXiYMH4DbigUH5RgDJXDMNq4x0wdp5YkjMi4IWFYmI3k5BZQBjJ2sIy2MAAhmySAeTGGcKhVzk7fMwBvQMAG5Yhyw2j5uCDnrTflfhgxIXYCSOxyrAMzFlxgArkODzlgrVUpr7V2mmtNnrB6NN3Wr1T76WStr2Xy1VnvF76tJ2b+7TRDvJOMtKi5Y53MHbYQAN24FmAyGGG44BOQQJ1CpCGVkkRNqOVKncw2/MWfJUL0cEAYycYYmqbxyursNpyFcsWJUKBzGwIOTkqWUYI3FiMKckICM+5tqufKUJv2OzFSGDAorKuCysWJG0t82QlRCaUn7nKnze827rZK6e+ltPQUXGL2XTZtaO2r8na/TZ30LaypAGdsMWRm2lCcsdpCqQMbVO07gQAVOdoxVdHEhVgRGrPGN8jkbmKx5GQqjbn73BAGCoABYSgKTyoZgDtyq4Yhgc8PggkjAXG/oeQSZoiN4bChwwB8wgR4yrE7d2Qg4TAwQM5boSSUpWV0k0rRT10irp6PtsrO2lk9QbvvrZXVt72i29n59N0/JlNd5JJV84DcjjnHA+XAPTC7SD1yD0jbzCxBQ7QVZsghcYzkYCgZ525xwTnrw0rMVyblxg8DdyA2M8Zzgg8jIx8uTimFJOT5j7hxk5ZQwwAMZ5BIGR1I5AOCa5FJpq0Zb6XcXe9r6a9/k72ueakrtuUPeS/nvf3Xd9nfpZ6rvYkUENlQM5K4wcAke+4EDoOoIOTgEVOybEG0jfkFhktkDaWwAMGP5cADqeD8igrpR67gGKXStIdwBl3sgrOBgh1EcijJHBAXd8zHaDyLDa8FLt/ZOivkLlPsL4G5RnH70HlVGSeRk4wMCtkoNfFezVvcbts7u1raJWeqTlpoYydXmVqXbaatJXVtUnpv+PzxAzKW7jcF4yMfd65XaBjPDBiCu5WK5w45cseFKuoxjqBjGXUHkYBGBgActkjOpJrUO5CNJ0fgKZB9kkAYgDazKJwAABn5cAqxKg5wHLriZQnSNFVkXAzaS4kJYY3ZmwSdqrzgY3buRTtH+e1rON4yur230va6va70381eo+V+xbemnMl0jbzbbT1vdJ3a1aM7JwucYBChtp5AIwxJ3sG59AcYJ+bGHAnODyM4A+YEnI/AnknJ4IPqc1fXW0xzo2jNtGGJtpF5JQhmxNuyMYB5PBz8ozSpraoS39laQylQSpsmwMBeOJQ2CcE5JyQc/KaUXBNXnHV7qMtHb11eulrtWu7a2huqv8Al0vJc0P7qt176f8ABbM5tp+82B1+YnK52jIBUfKDlgR39epUMrKoBVmK4wpGWxgMTxg5zlsHcCoHQ824NTW34Wx05953KZLMSlWdgSg3MfkA2qVB2ndhCV+7C93DJDKg06xDMwZpooZkZXAU7EIn2qhwAVwFG7Yu0hQK0tfm6Xaal3i2lo7t2aei73aKXM9HCSStyu6d03Fa3a2b0d3ftsR42sRuckjaQ24bAwBJO3BxyMEnIIAAweXKWUDHQABgcnkYwcdeCSMkjHTJxVRi+57mIyMjbjIhYl1BPJUFmJjUbdpbIBPfGBMkyyIpDYwp2juCMYBA5BDcDOcgbicCs023Zq2tuuiVle8k9Oje6Xlccou3fbps1bRrfTT03utWpEJBACnBxkcdtpOApK8Dkc559MilJCjHcFQRjJA+UchScnqSVPPQY6lg3bT33EYBHCqCvHAwMeuO4HQsDJlh8owwIA7nI43EjCgN1PGe2BjcC076rVuUVtdLRLb0V7vR7p912v8ANa/1r6i5GRk5BHByCqkqOx6nvtAxzwCMUm3AAILMGAxu4woBHyqeQCPc5xnjJpC5RQTkAgcDk8bcnGCOOuemBwMZAcGJC7c4x0UEjbx1I4wVBzgk5XAAIANJ8yWzu/NNX5bNap9HtqtNkrBa9r/h8tl/N56vW/e8YCjjPBG7pkfwkD5RgEdm2kcZAPQOjG0IOSDkjkcZIwOTgkYU7cYzg4Vuig9flyAQQMkcjbg8jKjOeMYOOpIxUiDOW3jgcr0OCFwxIC54GcgZGQG4PI201e1o72t3i9badba63XlpjJyjdWsvdbdm7O6tqlo7baJNd2k1IN2MkEcKBnjBG0cnjnOMkDnBGScmmF9qqqglnYBVAIyThjgYPGASOMFTjB6GUH5Q3O3GCOQdvy8sQScBR8xwSuR1G0CkX891aP8A1SE4J4aUkKGRCCD5WCQWBAY7sEZpKbu1HVOziutlZN2avotIt2vq9RU43bdrKL1a0s7L3brVtvTRJNfePf5ztAYwKfm27R5jArkdVPlD5gR/Ec4O3OZRIETeQVQqMAsVVVyAoyMqpBKhQynb2JBxUTsrKAzbFBDAqWULhsBlKZXAGM4A5UAHptYkYlIllX9wM7ImOTI64PmSZCllIB2gtng4I4VmrRklb35PWV7Jq8e7ukra76tJ3bstOWHKnJ8sU09be89Hp1cmkr9El1VruW5jeSBBulXc7FsNhiUHKA4+7klivAVd2QMg3XMeEdwCdwdNpKj5dxVF2BgzMSQASTnCjimySCJA+ehVcbR8uQ2AqlcfMpOAAQSQuCucWLaWOy3XE8YkvSmbSGVUaO1WRSftM68B7g9YkIKxn52+fYtaQjdyUndtxbdvdiko93vpaK+b2InytRlCL8o3Tctno9rXd2+nW+zfKRZIokIGoSKNqLytgnHLqQSL1gAWIyYASA5lJMeb+8ZQWOckZJPJBJJIbJJ68uOuSpABGGkuzFnJZ3Z9zkncxI+YsSWbk8lST3YEjoYwEUsQF4UDPUHGAcDI64GMluc4NaOV3dJqKS062VtW11bV2+j0WiSCMOW17OTau1d2+GySbaUVeyTu77q7bblLKd4BfAZV4xuwAMkEq4IHAOcjqe4ENqzfaLwY3Fo+V2kZ/eAgqARtKg5Xr0OeN2FM0SxrIGcHdsCEc4XaDtBO3cWYjlsAcLxgixaWji1nv5mEYuGEcEW0+ZcDfulkCjDCKMZXzA20tuXtuE8znKL5m3G8n1cU0tX01bsk/JLR61bkhNy0crQiurlzRenlo79ravRtKCRuAUjJ3YBBPGMsu0HkY/3RkqeF3UrA+W+1ATg4DAElQwJJIxkEdSW3DjqCQIwwYBlYHI2gADLMqjOQrHkk/Ll88cBhkVE7lV3M7MBtGwDbtLBflU/d+Y5yduDwRnHBzaLmu9E7p7WS5XfV2aT11T0010zUZN2Vr3W6ervazV/S+uyd9CyxYrIBx8m4NwWLHAG3HALHrksu3DDBwRWjLAEtuA24I+Zt2AAr7iDk53EBQT93OSA1MWUhlBlcqVykflgbXIUZG1tu0sRncSMgg7uAZUIydrGRyAwJwoAwuQuSMAnj7pGThcEEEupSu1ZKya5lbW1nypv8Oi9GUqcoK2jvqnZrVJPRu35tN6IbC0Zg2rlVG4EEksWVQH3bckNx1OMY9AMSR+XhSO+Aq5O5OjEkDkZycjAIHIwSMMAwzOpAG0sY9hKmQYIbaSRkAAbuN3IBySacSwJ+UYIGfvZydvyqD8qkDhfm5OASQMDSHNZJ2SSjFX63krvfTvbrv01qSUm7NtvV3la3q9NttWreSuPDE5JIXPAOCWOFU5Yna21iAw2gcgAnAFNcuwUFcEYOArDcDjr15bPQlcgA9RUak9XG0AHAxnAXaVOckhhuCnORwSckEFWHTJZSpVg6q24NhdoAJAJbgcfeK5AquaSV09+71abi3tfXX0V437AorT3VpazsrbLTVa/3lo979hxJO5WXdjnIGFGcDnOBlsfKQNzZIO0kgRsANjsjZRhtOSvzEr0AXJG7vgkEKG3BcU8nBPGAx4AGcfdzzgsMAgNuwCe4ANQnar+e5fd9zuEAO3BAGFAIBBOcZJKjgik2uVLSV2m9dndX20dtFrZa7u0RqPvbWSh9m97vl9Ur6p+a01ROz/NtwcnDbiNpIyo+Xfk7u20DAABBGc0xssMNkcrgqCMYwCckbuuAQCoPCtgkEJltrEu7Lldi4DbAAMqjJ1UsFHII9s8UignIVXHB4yuQePmIBBYYBOeDnCk7QBUXbspW3095PRSWr87dU72vZJ7tK21vPffTRN623769xCVzk4GOFyckMCvGHHBJPIJOBjGTtxKrPkZwPmGD06BeDsDMeOSeGIAJOAtRFWOQQwGQSc8sdqkYO1gGIbIILY7Eg8yR7FONrAFthBxnccZGFJG/vtJzxkMVG2nGa00tfbvrbp663VlZ3tsOzXd+Wib1XXXtv1u9r2JIn2vPASQYXBJYEjEuG+82eVyQchVJzjJJNEjEYAI37hkKpBwAPmO3HHuD0HzAYBpUK/PtT5hJhsBeR0UHDHPXK85+QkgcGmH7zArtYA5b5dpCgYBY53EHk9idoOQWq435Ypuzvuk7pXW9m2tNnp16ph7smm01pFSve2ii7LT8LrfVdR4VXAYksuBxkcA7QQwAbbjPABIGQQecVUmc48pSfLXGCMHsAOR/DnJ5GSeu480Sy8hMuhGC64UIyHaCY2BUnkHgDACjYDtBpBtxn0Xhs53YIIIBznn/AGSCeBglTWbm2m1fXeybvpC992rPRpW01sy1eNnKzbS20/leu6fql1epBu3jAyjqy5LHgIoAzkhhxuOACGXPOM7qncnlQu3BzkKo+6RgbfmJLZzgfeIweQpqIsVJZWBY7QVHOBgZLDGPl6EtjBxnK4pCzZPzlgRuOcgdMEjbkAhT16fNwcZyk2r63vbe62ta2r1V+is7a2saWbSstFrq7ptqOt2tHp7vW+iW9yeUJGwK/eG3nksxAbcMYOQAecHoMAdn4DFCSygrGAeFyQuSnA4GAp6n0wGJAfZxxyMt7eRtJZQylBEMq93MFB8pHCZCoFDytkFeMEs603Idi20BS24KCcLk4CRljyoIwBj67SPmhNuTnLb3VHdOyd+iW7em/UNF7qVmt23opSUfd3u3orrpdK7ZLGG8615VW+0Q7FLbWOXQ4JZc8FQGUnIBGRmmXhUXVx8rAGebIYl8AygDIXgnLZJIypOSCpBDRGZ57eLzNjvLEu4uF25cAnkk5DYw4GWwFYDPLb3MV5cggsy3EqkMSwILgA5yoY/LwxBYBVJyAcNNpKNtOZJaLVu1+nZLTrorCUbNXeqi+i6uNlr3+bvdqzuQgkEtGQFC4wRjc2Q3KjBAOSCQcgDap28F20FRhlB/1is3DHgHbgEDnjoCpPCjDDDScggHCggDkYIAAIKjB24PsvYcHgL/AC5BJYnHJ2nsCFHJzzkkngH+E4p6rXd79O/S7/B9C97a2/4Frf8ABer9b3Tg2UyTt3EMoC4BOVz3UgljuUEkDadzAkAx/MQCACFX58AA5wDl+MjgDnABYYI+YmnEFUVWbfJlQSB8pBVcBTknbwCGwpcZ6kHDCQG4yc8Hr04GMYHAGBjn5gRk45V3p39fS/W+1krdUvIO/r9/n/XQepPpncQQhGCDlOAN2VI+8oywy2F/2RsEYBK4YgEkHgYJBIyQcjIPQkYIHLFgDA4J64dOVX5cqWyoBGAOo4AznOMmlHyHcpbIIwBt5Py8kZHIBONzEYySGXgF3rppdLS91trf779P0Sv5eXW6+f8Am/1JGBOCVbABOQTwODyTk7gAScqu/n5cHli/cyQRvy5LbeQSMdFLY29Qe5H1CMzBWOCDyAqsxDHCgDrk8jjAORxjoQgKhtw3A4Vdo3YO3phRjaoCgAkAhixYEHFK15RSV9N01ZXWjWze1tvO1tSl8L2XTu3bl0v8799New9gGCE4OdvynuuFPJ+YnBxkYBGMkZBpNhJIbaeN3A6jCkD1YnqSp6HJPejGChIAbAx14IxkfL0yCW6nrxkchVBwVXBUFiQeuNgyMZwucYJHHfIIAFrRpP8AHpqr6W1uvzTERjJBK5I4OeWwcDnHHGcYYqSQxC44NNydwBO3ADE/NnaCu7DHknIySAueNwBINOYAKAxIwd6qrDOMhiDwOPlYAZGCAud3AQN0K5HbuSAVC5HJ9yCcHgKRjJqeZvS+nR+iWuiS+bvd6XWie0W7Ky6a67NqNrWb10vv1s9kiVRhuRxklgWA67Wwu49sjAA3c4AyTUquNrYXAPA54IIGP7gwGHy8jvuwcAVWHCgEgEjIGO2D1AJOc8jOBjAOOQ/IIwWLEDB2gYJ+XBOS2WGDlcDIAxnoKjKVrNXd1tbVLld+Vt7Wto21pJdb5zinqr9E7vRWcbaPR3Xmm+rWpKCuRgHoNwySByMkFcAAAYU5JHYBTw8BQORkZ3LyASDtwMAkbT93JJ4OQVIJqFJGjYBvnPGSEOM/KAMk5K85wAGJKksMczk4Cn1XsckE4HBAI5zzg4OQVBzg3FqTafrtbslyu+m3+TSteGmrXv8Aj3Wt7X080r6p9RgcYyRhi3TpkYxg8NkEAZzg7RjaMcojcnBOTzweingK23GMFRhvQ45HAMZBzgkZzleRnGc4x8obBJwMkDILVBzkZxxwCoz2AAzjp1JHBY4JUgUryTTevla71S287fO+vXXSnGEm1azvazvqrxs9L2bV+yTXKt2Txg4wGypPHy7sfdIBPAxjkjHP8GCSaR+FIIKlQcBQMEYU5GNx6kck988jikQYAUYbA3DHGMYwCAQAe2GHLAPjAGDA+Ygggghg3IViBkhRtC4IwWBO0DC8k7ZbdrLtp8raK+tk10aXoNR1b0dmujd/h1bvp8216LbSvBtNoFwGNjbMwLEDG1sE7h8xPy845A2cHBNEsr5GDznJDnJ3YwBlT1547noKvXp3/Y/lIC2dsAMBH4XrhQxPG0HcV5IJJDZrPyy8EgnacFcFhkDIwDjAyxPJLbsq2D8pN9k+i003UeWO9+ltW0k7t31JotuCWl30trvHt2a2e7XR6jg/ykYPTOeoLHAAG5twJwPmIDc4AyM1avWbGnZB+ayQ7Dzj97J13FeDgcc4JGc81X3KqAd2BxhRleAuWJyTjqSDkDhRjFSXLLIlgEyGjswjZBHzJK4BGcl8HdyBg4K85Jq2/wB3NN/Zp21skueN9L676/jo7HQtFJbWsl8vm9n/AF1GbieTzgYwoBI+7kY+YgjByCAAeSCrErJA0gubUKVG65hK8qo370wCVRgBgc5zgYboCKgG5ejZVtu4ZJLHIBAxgcnByMkbgBzkU+FmF3a4Y/LdQkAZ4AdAAAvHOfmx8wPzfeBrFStZytZOEX1cdY9Vbb+8r6Jt7ES1i77206bWt+C+ffYnvyWv7snJcXMwLbickyEbQe+QDyPvADOMEVW4JC8rkg8HgkbcDKjacfNyMADjIGKs3zs97eO4Bl+1zYOQSGE3C8YHO3dkIN5JAwcGqhyMA5PTpkNg8cZDEsDksflOeWG2tXpzSbT95tLTpKKt2TbXXuhU9KcNfsx26PRtr/gWfTYtQqPtllsZUY3MClmIypMg6nDbRjChQSVK7sbd1T3QYXt6A5Yi6lLZJcn5wc42bSMH7wyCMAgAkCnbiT7TaKu0F7mLYWIABLjjBBQLjd7E8qcFgLdxua8u8tuZZ5jl2DK3z5ypxgqx4yEAcBVYByS1J3e71kvs2Xw6K/bS7d/XQm6VdaJ+4119580LK29nfX/JK8QwXJKscruByqg/7KZYgAlSQDjjA3K4YCQYzkrgBDg8HJwAoyQDuHBB2g52545qAYG1gDktjAJHB2kqCBkcknBzg7SQ2M1J5pQZfJU45BVQV4AbachtuDk5Hc8gYpp2lZ/fJRe6WitZ2sne2q1epupOTV1ZPl0b2ty+qd1q9Xq9L31s2Jdbq5Zy+02F2VwxABERGWI6ghdwbOdw5VVWq6Su0g2xkJtBLdQSdv3R8vP93aM44AZgTVqzuI1llRgdxsrtQQozuaE7TkEJgksQRkE43A/KGoLIVAI5AxkgDOTkADaTt6nPB6kAnIBrZLybdml15Wkr9NPJ/K15gnzSuukbaLotN766PfbRaaF0MCACAAMHoGAOV4ycfKQOdowSOcsKq3ZPlLkEjzIyCHYnaXTOTg8fKGyRkAgsMsVpN5C4PHTPADdiTnBHGc4J4AJbIBxFNITEOTgvFgcjA3g7QgOMbTnOdwBByF6kpe44tq/Lo9XzaR1308/Nx1u2nrfzVtrq6VtE9bpdX1f3o2YmH9nXowmTNakEqN2N0owcvkcBW9WyWVgCc542lSB1PzZxtBClPlAPzZ75GMLwQHANW4yF0+85Cq01mApxwu6UkkADqPm5bGCu0hSVqgHKgFTnPyuAD2CZJHXcFypLAYOAd2MjocrRpN/yRv8AgtbbPq1rpppa5b+GG6vHVvvzba3ut1387khIOQzKHyrkbcg4ChVwTk7jwcDaeBgNk1KuBjbx8vJwqgkBe5y3HYEZGexxVWN1BIUYxnBJGc8ABQDtH90EkgYAj5HMruAoxkE87c4znA5IzubjBzjJ4JJ4MqUfnZK27e3VWV9++/TUl6a37fmv67dwd5Co2jBOAWIJIX5DlSSCMEYUj5lB745tOc6XpzFTy96ueflHn5GcZABOSxXglSwJ5NVC6jBI+bOSpBBJ3KAxyQ2OgBJO3+LgDE0spGmaevJ3S3rAbfm/4+AOu4j3Y5wCQcBfmbKT95u+8fW3vU9NPN+et97MwrcyqYdx/wCfuvd3pzVl+Hlq+yICxJRASo3KwbLAZYpyCSASx6E43bueQMt3ne5JGRwQAVJACZbBHOCcDAAU9aXldwKhv4lwVBKkDjuoAGN2OOeOajwQMgqBtDtwrAsCu4NwAGOM4LFRnAZgSaqTd+kvW6X2bXT2u9XeyTSa0eu+rtolotNb62ej6r00enTZ2cYAIyVDBcDcqgqewJAzzszyeQTk09SfkzhCQDu2lguSvB3kDLNkbhwcjvgmIMUHByMkgNljglMLhSV2rgB1bgnBU5bCqpcEhtpySQ2Bgr8oGC2cFiAUIHPIADZNXFu9r6q115rl76dX5W1Wu7v57devTt9/QkD/AHggxn5Pm5GQUwF3cnk/KWPGdp2kgUmRgE8YIXgAFSSvzYKngchTxnHzLnmkO5lHABKgkt1BGzZt3YIJAzyOmBndSKA3J2qABvBGA+FUhvmO4bcY5UkAcg7s0+bW332Xdpatd+l9lrstWvh3urq2tr7fOV9L2t07jzuYc4ySoBGNpDbMhSeCSCMEA5UDLBsgr8pGCuQuMbjkEfLkj+Ibccgfd6kgAUxSSvzKchiDtJGF3KF69j/eU4JyCoGCVEi5Uocnbjdzz0yzYAJbk9Tu+XIAXOS6dtvyey+/TV6ivbp22Xdpa336abb+jerkNhlOCAc/KSV4HO/oT64B4wxBG6gnbgbTyBwMnj5DyvocKQxOV4bOKjY5AbcW9cjJxgHIA45GTjoCM9OCitt65OBwDnBGVwSF4yOxHUN027sy2101et29l7raWia+aXeWlwTu/TrstNFfpfv0TvtoAYlRnAdTheBkghOBjcCB3JAXj+EkGmthsP8AMpQYHDfMcplAAR82Dx0ABwRychXaSAwzwSDg4B2EABTtCnpyCPm3HgZp2E4bkDjA3A8nGScDqozhsnG7jPOVaUrXlZ3Wml9bWv2u32XS+1xp2u1e/k2uqWl3rs9Om63GoMc56bcg8DcAO3I9cZJ54GBlQ0/MASxTkHquRgocfw8Er0GTjgjJUlQN2cjkYC55BOUCsxzuAOMghQBzn5uQ48ZHQjAxnk42jc3Vskjj6ZPHQu0pa/ZSXqnG7210+9Nb7J7JRvr0W1tVa3366pdV0ujEDJK/KuOPmAxkcY+bpxjKkgHP3uRFkttZBlQQBtZlLKQhbIUHGOhPJyARlSVp7beA2CDtym0EFhjnC9ACBzzggNkjNIOABkKAM9BwQBhRngY9l25HdiTWbvpr0s+8Xa7v6bK6vs9tGXafRbX01tpZ66p7cyV7u621EwxIYE7kRTs+Uq+SCEKYXJx8oOD0IwvNIN2B8gJUjdg7ModuV3EliwI+UAdAxYcZAWIIJDHkAAZ+6WBKkBVKtnJwcFehLYIpCSoJYs+SACcBSPlAz1weScjr1Y4GalWd27WdpJ66qy1s/hs7PR9E995vftZ6q737Xdut7X9H6KxIBBXIyFHUEgFRgE7jgAD5SBwA3amld7R/PsKHjBJJB2ghmyBuDZAJG0jIbB6KH+bJBLNkgj1wpKjClQCWyMH0IwCBQNwU5G4sVJAACrwmeRj5gQN2cnOM5FFrp3u/evvqrNNLRrXS67X1v1fTVaPpo3bTvqr32sumrJDgHPChhtYcgAZUqGG4AgBgQBy2c9uW5CLgYAGN2DwVwvfDEnKjacnOCG2nDUZwABnA5IxuORjvzwQORwDkY6A1CSXkVW+6TuBGwZzsJyT1z1B2kYOCAcbU/d2jq9E99bre9r31vrd2W/Ru9tEr2S7XXuvVvqt27P8Aycm5mDLKNjHcQVCgAhSVU4zuPIZQTxnh1OKeVTcWJKlxjknG7jGMk5JBVcMWKnHcEFRhfm+UAYJAwAFGAOBgEc8HbxnvlqaPmGcbVPqBuJ+QFyBuPA7YXJPGOtQ0opp31d73bd7efROzd/K6auw8ndXSittdtOmqTVurto7EhCSQ+Wx2y4zBJnGDtYNHIWZR5DDaFIUnd97HzBoFMiEKQyvHIsbqTliVxkFo9z7SAAjEkHGCSACZCSqjpnaFwcZZWALbjhsrt+bPXOODwVkd/MxvCGWE/IwUBpo+W2NlvvglfLbHK4QHkGp5FPl1S26q0laKabi0nJOLt3tbbaHZW5bu/wDkrW0b3vfXa7VxrBMZ3BflLKpcnypR93y8YcOgwFxgHBIbkBWvJLNN8x8y5Lb+chZ0ySZV3EgXOAN4K5Y/MAzEqzSASpJO4hCSDuZMZVhgAAEZO5TgZAIHYKp3hslo2Vi0coZt6NwUdGypwS2BgYycfeFRK8mrbrRtOV7aOzve7dtLtLVp31TiUOZ80bqcVZN3beysr9N76q/S2jF84sOEKrt2BmUZUnB5wQRjOCCC/wDd4IBaSkkQUfKAcRhvlbcFJIYDggkA7SwXgkk5arkzR3ahzEq30KkzrEoH2jDSObsKXba4UYlwhA+9t5LVUDsF4VcM2MYLYDNzg8AEEHcBknI3EJnLV5O101a0mrvdp97u6vda9Wm3HQpTc4py0lqpwve1rWaakm09038V9ddmwrgTQ4YK6yFm3fLGcjhRnGchD8pLbM4GcgPjwjeQyjaAWjfhyGBKgrl/lB2r8nADpkEEqC9VMYJU5VlZ8HaSJPlOMrwrZG3aRhhtCDAwIPP3kDyySjZACgAFflAZyAN249sKTnG1hkuyhydJrdWTvtdPTbdqzut73uat200v1T315emm+ut+ml29Z2IC7CVDs6sWKqVAdVIb5SpHKkKvG0dfLbaBLD5e9QQ5dVTDKYwcfKcjByGY85wMj5T81V/NdhmWMHYxCtyGLAYGC7fMSQGG9cEEkhTk1ct8s/zELiUHMgBRssuQWIBBw2M7Si/MAAflJeLbafSy0tJaR5barXrfbVaPSz00tffTq1sujSbdna6v95lkEEt8xYgE8nC4K8bVHAHLAEkqep60gO04wQpxu5B+YEHpnGOc4xlR93HQuZWQtFLuV48hkYHgjGRgcqB0VskjkHIzTBjBz0zjGSM42kHsOvXJxnB7YHJazaas1pqknfRNWemna92n835trP3rPXtba1mk/S+q1vfcJVDgbsrhjsK8FSoGGGAq7WJzzwQvA6kkTYcBlIkALFhwrgNgsvByCvVfTjoTlgBDsuWYHkNjHGfl5PH3gecYzwcN8pXaGXneCnIKggjoAVIwMg9QDz3pJPV/avZx0s1eKd9NG+no/nd204PVNK1tWr21stbW0a2+1uTsuAAqgHOHwGwenPXOcqcEYx0xgZpgHzHOWYtgk4wDhfl4zx909eWIzlScMD5/dvw4GUZMYfOfunklgDjaeCeeop6KS7cYweMlsEZ64+XaTzxg9x1bFWmtLaWdtkrPRt9Ndr9dFbYi3Km29fRWtdO9300tZ30ViXBX7oyvXgEANtXJbBOQeSFJHtx0VEwOAuCd2MHrgNkhcgcg9T8vBBwaTecEhQcH5t25gRhQTwAFBxxnnPQZpQyhSSTgYA6j0OOPlB5x29eFGQ16JbdrPSL07La/Rpq+jIfNbdbrZ3urqz00STtvbfa6I5EVSQwbcxyCpAJ4AGFUgYzt3cc4BBUkgTIA8Y2kDjknruAzhiCxwR1wFG3gk8mmAEsWH0AG3tzkbR8rc556YUjK5YOB2sAq8lgGGMKGwrHd90DHJAJJ43AbBgSujWl7WTWtrxWrWl9nsnf5jbVkk/eXK79m+W6tdqy0aaWrQ4s4XeCVClc5GRsZQuCOG25xhewI75xG2YmaVAEjVsvGcbgcnDgZIKgdCPukc8ciU4wvOScfL6EFMeqkZB2hfvHLdTyF1DDAwChyTkjlgCBnAwSSuecBjjBGKpa9Wkrb2dtFd7N3tvo/IiL6O9tmrJdvne6drXemiWw5X3hXQ5GDgqeSflBD4BYHBwSTyTnoWoDlmz1JXJBycABc8OFOAeF5JBJPQYp1qtmryNPBPOp2lVhuEgRRlGbzD5ZY5GcAFcZAyT8tNYxNNI9tG0UTkhIy7SNGv3QjORiQgBSchflIyMfKH0Tbi7u3Kr6rTXVJWevW9tuom0m0oSSUVq+Vx3TUX7100r/ZSb0QrZBCrnBAPI5DEpnkDZkEBh83JxjBwABiTgDBDAD7uCBtHIGcZIHAGflI4IOYwdu1STjoWyCTllB4ckYHXAAJ6qAcirA2jn73GBjBOPlAJYAD+6MknsGyQADrrptffa6btpu7Xtd6Lzdy9l0ad0lt0Wrs9X1s+q7D02sV5IYL06KSduPmzk57k4+5hcnFGd3zZ5DDPYAfLksWycjv7HkZwSwDapVc/e3Ej5SoKrgjaCCCD0DdSWAA61pXMrbU+5wJHyRk/KNisQMkHHJOSM9waV7JW330tq7q7drpefW6t2tEaal10Vt+14r8X10vdq9yV5fOLBCqxAhZG6iQjHyoQowhPU8fKCBkbsqdqtEjnbH8yqijaMjBGSSOMMclcdu4BqGJtoK7QcYUja2BgKB3G4HA4Hzd2w2WLpCMLhGZg4G5VBYhgqtgNuBA+XBC4YHBwcktaR11enLJSXlpbsknslZW63NuRpqKXuqyj3vbR376bt7aJ3HySRyskTMAGIZmJU/J8oCbiFJ3HHfa2MDD4FT+aERnc/IBtJxjauVxgEkdCFXGxgSNxIBxCwXaZG2gqyNngYDMSQSoLMSX6dCQxbOCabLazG3ivPkSGSQosbMBKflXEzoV3FOSEfB9QTsyVG6vo5SVm2n0aVm32Tu9023fR6kuEJKKb5U3bW13LR2i3bWyW19F01Lwe4gmtZ2igASJ5IIJFWRxlfkluFBwsoYbkRgPuhtoIY1Azu8jO7EyMSzsfvSMzBiTyRls47BicNgACoSpXoNvJyzA5YBx8hYbc4J4AwFxlRzyiM2T8vcktggDkBgFJzkEAk5G4ZB+9uGq6Rbvdc2+/wAK1ae6aa1ta9uusxjbVJN25b25bpWlZJ3vun1b3a00kVg/IByAFdGGCMfN1UHkgk5HP8JA4NMaRVBlYEDnIyQScKdqDlSM+nTnnrTiTEGdnwgUkqQcgqEwEJ3AHgA5yc5I4JNRxWr3EP264VI7WN1VYyQrTuduY4UCsWLDO9yrINpUMx+Upzd+WPxWd01a2zc5auyV9rXb1t3ajFLmk3y3SXWTk+X3VfW976WVtGXbDT1lX+1NRXZZBisUAIjkvZBllijTr5PygSSD7wwqHO7bLc3f2mbzGAVAu2KFATFFFhlSOMDaqBVK/MAFOOB8pJo3d5Lcuu8siiMRwxIrKkQXKrEi5G0ADLFQSM7gRytC7VSMMwJbAO4Bj8wUBM7ic56qQAWBPK5wqc1ZQV3FO8nonOVlrfdJWvG+iV73ZHs3JqdRq+0Iq/LCLs3ZdZae8+uy0siZTlyoB2jcAv8ACuWCkkgkFT94YJIGCMrgUhwcZzkDJyAMnAyecjgZOASNoBUqQRSHaowoCjlm44+VlUsBgIcZJ/iIzwcc1EWhYKSeGJ2tkFQSFGCTt2gA5wAdpx05xpzcqV29bJXXortaWu7N3s/ushRTcWk3sk7JXelr26q21uui6EuWK4ZAG3KMgDJQbSjfeLZyRkgjLHsTmm72wGwVGdhwQudoxkhjjrlnXAxtyc9S1SjOArklQdwBKDJIIGNv3gMY285xkDnMMsu1owrlNxw52FlyCnysSvQcucbjgDjnNDm7X2va17aq6TVrrbbe2m7KjDmskrPe3VLR7dtE7Ldvrra1wqDO44KrkEEAZHO44Upz93g9MAn5Q3CjIKsVJYgA/dzjJyeCpBLDaMYwd3BqHzF8sZZgMbHzkFs7VPUnJb73BLJjnAUMJ9yIAC2FxgAbnHJXjLDYG5AJHIB6gna1cyaV7NaO2iadla2q1aS30dru/Rcqi72d7tb6vZrVNO99U1ZaqwLsDEtkvhsYKj5TsHATGBjauf4gVGG5phXAG3k8MDw2MAYQr83ABGVJUMSDlVJzIpyC20kA4XBwSuVyu4LyACDyduMsCFXBY+wBpJCFThUQYwGwgDAoDuIHIBXHc4BGU7K/nvqmmk1fo7Luk7t9VsN2032Wyb10volvb/Nt2aEG1XZlJDEDI5yeecAkfw7RhjgA5UcsVcgYKwZVB3b1BAbdHgFSVLdCQGOCcnHAGTUfyq+AFG7DbvlYKG2gjAUblByOOMYII+ekaQxIzcSxoyqo+6FU9GGTtyQDxgjcMkZywHZa666vZP7Ku23d28nfr1sPlbat1tvZX0Wib0vZrfp5iMoUsVLBuZd2CBtP8GAU38cBgADkggHGJEORlSCCMqMchQAV+6CQwOQRktj5T8uKgdxI6BRk7g2flKDJX5CF3FVDck7sbgRxnhVAiLOzFUZ9qoA+PMwnzgsFAUkZGMlf4wQAKUZKLukrX9FpytPs9dH3Vkh8jsr3UmrpWu3tZdelmla1r30ZKwA5Cshfa7DIwV4BOwleAcHDA4Oc4AO1UwHBAZgVGQACnBHQBiecDgqWUEsD1NGWHT5xjnHDE4UEEqMHBzgAHOdy85BaWYK3J+VuRtKgtlVBBBGMgDHJPIBBLCri+Wzsly8qtZpO3Lpra6adtL+fVitfdW2X2r/Z/R6Wt+RZyQyqxUsR8uNoO4hQeAfnGAN2MnryuAKhmJA2KCrshIYMM4OOASFyWOQMBcqduFfBCTIuISpIKukikkiQ5TeY8Lggv/CAQDymAR8tYyOzMzgFi+OFwVIONmfm3AqMlSTkg8k/MVKpa8Gm0ra2Ts7Rbburpqz63tttrUIJvnTWmji91taztrtptbbYmV0WMYG1QNnPXkjLDbhsFs8nawGc81A8gbYQ2GBXDKcZ4BHoRxjnqRkc4zTmzyrsjsSoG1NuBtBwmcZJIYAhScAYIIxTSAANwJIOxMLwPRjwBzknAP3h261MXdJ7prRcuybXW7S80ndJfe0knd6uSVtG7p2vvrbu/LQacqxUt3zkEkHoQARndk5AIyDyBjBFPt4BcyhC3l28Sl7qYE4ijGMqMIdrSfdRW6vgH0DVSSWSOCOJpLqYhIkPzDLEAMRtwCMMe6lQDyBmrlwVt4hp8WyRIpN11OoDi5uhkEq5I3QRhiiK3BcM53FwtS25Npq6Vua20no1Ftbf3tfW9ynf4U7trZacsVZOT9H8PS768rG3U6SyKY0WG3hCxwQkKSkfJUygEF5ZCMyS7dxG3+EDERJBLDY+V4UKOOF+ViON397k7hjH3QREc5wpHJAwFzgMQSMkEYyFzgluMbtrGn7HciGKNnkkMaRoPnZ5G2hRGqgncSRtwMHjbzgm17qae910tp7q0d3v5pJdLJsElZJbWVrvSySve+l3vd677u7JLWJ5rqPYjv5MiSyOu4eVDG6l5pGKkRRxgje7sFHUHbmopyrzSuGDo0rsCCCpy4IwcyEgkMRnoeCdrca15IlhYnSbfm4mZW1e9jY/vHjkBXT0dVH+jwYSSYH70y8FlVaxWXGwrkEYBRi21c4PcgMvOBjbnA7EgTK7XLrq7vsvhVv72ybabWmy0bKfve/eMVpGF9bx0fO0k+XXRLT3dbX2YTs2lCd20AgdTkLwwyMHAzgtkYIG1DilUkqASrHAB24ztJU54JJYHgYIPCkblzl3LBlwCTjdhcA8hT1+UE4OOOOgPABdbwSTlo4kDt1C71UcFPm+YhflLYJHUEgbeVp63avZdN1Z6Ls0vK279NG2ktdGt77WdrP89dtPUaxXaOcfKOcn72VPPGCTkcZ4OAABghM4K4GAEBJZvv8AC9N5ypbBOQDntnIImukiSSNIwDsRUd+XVpRkuyZUMoyAPuggHIBXOIFCjCnHRQQN3Q4659z2xnhgOlC3ulZ91rro7PTTTqr/AH2ErOKavrd2e7TSs9e/n0t0EG0+h25OVAO37ox8mDlemeVAzwOcOXGMjoSDgk4PIwCFHAwdwy3U5U8lQigkjgYBxnbuLcrnO7nnGegyRggt1awJyMgjJGRuyQMZXaD90Y6gZGOemQ0/KzfTqtFvr0+Xo9Lu3y2/P+r21+4cxADkYBxkApz8uML1IwwBzgnjknGWAAcseCep28qQTnAwRypGASTg+2BSZ5C8jIBIHX5sDABAbIGcDAOMEHjATqMljxuXlTg8DCngAMSAOOMdO+FyvmvfXSPddH3fSWqWq667id0l87+tvu2/qw7bgZPGcEkEgEEAY4+U+59O46FMAZZRyDgAkcHCgc9vQDJ6Y4PUzyp4+UDJHXBIOVIwQeyrgnoCR0DgRjOPQYAGQVxkZORkdWbI/JVFNaadFZL7l6dXb5fINdPPu+/V7206+muqYxmDAFx0JGCxyc9jwTzwOmBn5sEA00cYIw21cAfxD7p5A3NjByoJHIxzgipTg8cZGN2RxgAEEscjoBhj1AAPQNTQB8oHHAIIwCCdobnjB55BDcHAwSDU6J3d9fdUbpL7OzV7ctm79HfS1r6RlaPo7Pso2Vune68vWyZ8uGHUZBbkEdAAODtyAMcde2QcAU45Ck53dAcNgAA49hxuBPT2zSLjn5QByRuOAclRgE8cEge2R8wZVIUnOwBCMhTuPJP3CQDz9Dxn5eSDgU9NF0Ssl0s7aaaaX/FMjWzvre13fXaLWl3pbRdVaw5VOQdwwVwFwpwMgkEKMkkgZbJwCGHUYcccDnJ75AwW2gfKBjBxz82DnqOQVVgP4TkEKQQ7AdDuCk43A5IUnOcdQfmVFYA4AIGTnBOMbR24HByACy9Bx1OkdrJX0tddrqzV/J67aW66k9Ntbbba289r+Yj4yAqsem5g2SR8gznkEnnBUnGRxtBBrEhGzg43Fe/oOvBGQBk4ORyRkDAsEDGd2TkHbkDJ+XICg4UkAEk5IxxjPMeDjGA3t8pXIIAIAAAGTnI6HGOflKaa6W0TS23X5ea08lsaU3yvRXvo/K8k7+b8krLz1QJwPlBI5YsxB5JUYAHHzAbQR15HTo4kFOMfKDgYIx0Y7gckAcAAjGflIBGQxQwbByT8oAYEjDYIO3AwpwedoLDGSACKmZhwNuflPmMNpBPOCSp+90yQeVC45wKi7erT1dkrW6J6pPfvdK19dLyNnpp1aWqslZKPRLpfTZadLFu72B4NhIzY27biSy7trcIeAy5GArAZORknANEbcZH1YE/MTwM4wAcEZBUY9cYKnRvWZvshaLCiytwoKjkEE5yWZipHOSQFODyVYNR5U42lsNg5LABRjPQAFcZOfuk/hTd/esrrom+lopRWuml7WXm7GVPWCs02ls3r5N79d3Zvbtq5TtTCEFm5KsNxBABAKrgj7oGQ2TgBeOBNclStjhdu20XOFKq58xl3YByPu4YgAE5ZcH5jDGMAZJORnnJ7gAFQSAR0GMjJGMrk1PdH5LHCgZtz8oGD/rnGcLnBAwwyTnIfAViFtO8Ki7Kmm9LP3o3S7NvV21vp67Je7La6tvv8SXklr6a72sisSpOGUA7gcgkMSCMkDPLei4AI+9zgUsRJuLZiCSbiHAPUjzFAznIHOcEckqQ3QGkIKkDscY6Y5x1C9QeuCfQjqKlgDNc2wU7SLi3w2ACo3rhiWO3OenUdRgEAnNuzT84/fePqvLVWur63uQ/hlZ3snrbpaOmiSdk7Lr5tJIkvy7aheOzcieXoxcY3k9RksTnG484G0jGM1xsHOcFhyCMZJwcAAjC8LgEg9Cc1LqLf8TC8y/S5lOSMhsOckEKvbgZC4A2jPNVlxgNjHtzwCRxjAIPGSMDJI5xzVt6z0vdu97+W1notOltb9xQX7qn091K3yu3rr5ddtSzalRc2pO8sLiEEKSS2WHAAAIBA2hgQQcjGDVi6kAurpm4xcScnqGLjHzAtyTyAeMHJwQ1QWpK3lk2R8t1b4BXd8oYKvfJIOBnGDgnOAalnCi/u1eMFWuJQpIUhT5i5PyFV3ZBOFyVBXGQAKcLpNXaanbXtyrtZ3fVb813fUlpe2jpZ+ybv31j1+fqlbbW8TOuwu7Fc4GX3FSGxtOQVBHBw2c9SOuKaGBVWzuGFXKnPXB5A4685BIPBGVGC5hGzNHgEAFwXKHepA+YEc8ckFlG4qCxDkCgNsJQqzIGIGP4eARyxKsByB0OcHHGDopJWbVkld/er669+q82bxW2zsk1rsnyu97PtrfXXey0tWaqzThjsKWVw4Zth3BtpH8Bzxy3JJH3eVwaQOeVBCbQwLHODnovOV+UrjeSQTnIODVuzUGS6BBY/YbrIUnggdVZRgKpxg8FeuQCQaKkZC4YsO+7jOFAXnk9RgKfnwBjIBoi1aKXVyTbtrrFJrok7aJdl0CLfM11srP5K3Rb3tZXexJvJKNn5vukcjgYzwpB+X+IvhiSDtI5MMh2rnaSC6EgcAMHGAADgjGGGMHgsMAkK4HGGUg8AYGcZ5JHOFwxPUcrnAPy8NkOVPYF4+cgLkspPAGAAcAHByVPQjFRU0hK3RP7Tutn5vTol5aq5bso9r2S3bVnF3s3ayfZPZu/Q1YyF027G05NxZA5BwOLh1OAxjZcBgOeNxbBBbGe2MqCQuDuwxwSflbgYIzk8huoxjHObkJI069BG7N5ZHJQ5Q7bpcKxbAyM44wQN3pmky7Dgj59u4g9wdpBIUEcDAwMj+6Rg43veFPX7Kt0s07at6rqraaq9tzT7MFZfCtNb3b6+b8tOwrNgHoDx0AViMhSSBnAGOQcYOMjIBpwcEAMCGUK2RkMScAHjcfmxyTgYwWO0VDxjIzksAcg9gD0UZw3ByxycDAweQELuGCwPO71PHGeFBA5IxtP8PGcwmnr00aej0undeW29tetrEaXs7K+mvVO34E+7C5JwzEZOT/EQQCBkNn7wA5YfMe5qxIV/s/TSCC2+8BwRwfPTqAMYwcY+vRdpqmSAMgFlOMkhiMccjHy4HfryCoI4InbP9n6eQCAZr0knPJEqEgYAX15B6/KMGs21zLf4N7Kzip03rpdt9+11a+pjU1qUGnZRqX0tZrkle1762baa7NaIYXKgbSF6ZJGcjK5JXGWzjkkhhnaoAphbAYjllOVf5QGwAPlJYqGbGFI+XopCmmEkDg8dO/IJAzg44zwM5I564GE6sCxJ+XaowqkZIIwePmJAxkAgdCMc6OfS6Vl6Xva1397vrpF6N2tv16Oz8mujV/NepIc7i+w7s9Mkg5+bBAKnbgFTkgBvyCjOMkHAYEHoRnb8hxlt3Gck5GM/dxiJST8x3Es2RxzlTjJZiecgHPHYEFjiplz5mWG0beQwJXLKo4AI5wcjnIPPJOQKWui1dlun0T3TsmtL2d9Nmkrvm1SdtLO66u0b9d0rba6ejbnKt95QuShViy5AwpA3Edc8huAxPGGwaTkbc8HAxktuHI+8fm3ZBHc5G0nIOaQ52hSRjcpKjcCQduMbeu4jcG65wAB1AFBBACleMfKf9lsgfLg9NxAIyMZqnLVX0/vX2Xu3383a3Mlr02C/3aXXS/37u3dXdxTjgE8jGTkkHoCxwBkk88DkYAHJw/eV6EAMehUHjqRgc8Dr1xwRleKapVRyoBYjoqkk/LxkKCCAMnJz0ByBmlAUAHbuLDnvj7oxhSF4PTnrhgQpwRNyvq1e1tWmrrdLfvsmr6btISSfztuvTRbtbX26edhOBwB6Eg85xg5IBwAOzdOgHBIpp+UjPcEk4/iwAQQDtAIGMEberAkHhWO0YOcrx3JUYBOQBtwAOcHJ6DKkmmYwMDJyTgcZ5wSP7oGM5HTHfFLba/TfX891119NetLz0vZPa2y3adtLK9vvJMkAY4JIOCRjPHLZG0nrjk9AATkAClgMnLYBI2jA+Xgk9iRnA4PTJxjNMAIOAQ20Aqx44O35SSSAM9OCCeOD0QrnA5zgHJxgnjO5iByc8DjJAU85JafXvbdK/RapvfpZq+ifXRW1XTZO+mul76O3Xy306Em7YeCAFC5bgbcY7AfLgZB7LzjPOG9SDjGBxznsM8AY/HJ7kEjctNBDHaRnjv8A7WDgEge5XqQMAcipOD9VAHGOOMDOMDJ6Y7egxyryfpZWfXotVbaySeqt99nZ6edr2vqly6LTddbea0shjFhjAyAQCB6FgTkL0A9OPyPLflX7h475Cn+6eq8gjjIJ4PQcBQ7GSWxx1I6emMZwFB4BHTpnHIpAIxjK5JLHBwDnrjGMfKMHJA5ORxnESlJW+1f3ZJfEno76OKu7rt30IuuVX1eitZbaJJq+jXy6PybVyoLY5I43FTjGMYP4AnIzt27scCgDOCMcDBbLDg7fcH0brgLgDJNP4wARkk7eBgAEgfNwcg8jcx5wMgjOWfKAwPC9e/ByDxjAJJwSf4uMYBIqObbv7vM7X7NWvJvRt3ey1ertd63t1082rWWl2m2te/pogXco2ksSThmB5ByAMJ8qqFzuwQeOoYdV+bdjjkYZj1zleFBwAepAAzzleAdq5PC89MEkHAz12ryp6jufUEAEBNwIIOfQjqD0wDjjOOfmPIJOCDitHbl0dru97t7tLZ6eqel3r1Y7fJd/6332ImK8DByWGMZycbeijPpkg4yf90kvCgHA25CYKAkFhxlmAHJOe5BHUgqRhERAd5GNwDEdc4KnG0EYH3SAe+cHHy08Bi24Fi2ecFsrgqMYHPGcDB6EYwMCsk05avl1j31ty67NW3Wi08upvJd3ZbOztbrZ6r5NPbfUyo3HcCg27gcdTtJ69GJPOcA9ADnFKNoYvjBJBPUALhc427c4PPJ4P3jsyKaAuSpwNoYHggHOMYycAkkFenUnJ6UEkY4OeAMe5HXJ5OOTnB4AORghJ6r3lsuv+HZSfKnbtrffRgndfOy7O6WutrX26266pXVDjIB6sCSflbsSBsGDtBOAO3OMAbRCqtuHJC/eGP8AZIJKg7eW6qc8BehOE2Y+6vytksMdGG3JHZTjG3JbJPy8DBVAADgDbnPIDcNtIyMbcjjkAnceO2VG93Fvm2S5dLfDeytdb3bSV1ytJomOjWnuvezbS0SuvtauyunovLQf5SSRswYrPyxV2OJkwHYJ8xAkGCFGDuySTuziJT8qNyduBjPzA9CCQDh1MfQkEggsO1SqMF8DaWyynBAXPQL0bJ3YBBC54JBJFNlVs+YQTsXfIVUkE7iRLt3DlSwEnynO4DrklyTupJNd3a/Ntrs1pZ31kndtXSV3bld+/o7X5X0bSV2rrXXysOJIdZo5dksZykqEkofmAQgDuzhRnsxDBkORNIUmVrjZHFMMm4tkVV2MWytxEpYAxPtAZQoED/LtKsjVDGqyoZFBAdg3LkMCFCg7em0g4DdSvA7inAtGwljz5iqwViTtIlBUoVzzE4LgqRg7scbhQ4u7kmrOza3v8Lve1lJaa9tN9VFSF2qkWlKNuXZcy6wlZa3v/wBuu1r2leNwGUMSfljAwCxUDgDBUAZ2AgEY8vI4K8Bvl4ByUBYrJzlmIyqhP4fck8k5wDuwQ8NvlyIYEwrZHmyKu9iVKjLZV1/dhFwVXaQAzEgMdbrAO2PaHXA3ucrkDJJycFlyBn93j5lPJpNpp3Tk2425U3ZPlurtXWmidr63fcpNtXcVHVKztZbWs0nbTWPXXVPZSosbbiysBgjJwRuYqyYDAMF+YBA2CMgqQMYsxsQ6gEnBGSqBpBuK7XD52sTgY27twIz0zUSifzA/lW7fK0eQ7A5yerIPvLhQxI4BLAlekyrd94bdcODuEgVsAgcEK2NwGdwBO7GUBA3K6SbfOn/glrdRa6NXtv2d77qwrpLppa261st91pe2j831IEeK5QRXDCOaNVjtbhywSVFBY29w5K8ZAEMpGEY+W+1Cvl0XV0cxspR0+V0I5DIV4wMkDg5OTjkjcTxIU3kqcDkFixUbsYHDHJJbcRkcHAXOQKt8XQSOSQ/aFUJDK5wrr8xWGZmKkvtwIZTwOEchAjR80f3lrv30rRbuudrl3TfxWWl1qtN0kcatOyWk+idrSWiUbt2crvpv91s6TIO1tpbO5WAGTkAAMCffHOM9+oNSDrhiA2Qeg4zjoxxn64yccEHAIY2RmiZWVozlhIMPvXAbII3AkkgrxkgBcGjAzlc8DdnBB4Ucc5wAc4GRxgAgjJlXXe63Vrfy3vfZaNLt3Iulvuu3/bt0+qVtFrpq2mhrIrAg5JwWUjOQwJCsDjg5JwMgEdB1FIrEHbKRvIBUjAEirknBGWDYxle+R7EPU7uMfMCBgnH3SuTzzn5sA4HIAYBtuQoHAySMYAYgjae5XG3A+Y4AB981TXu88bq9rxSabWi8rWXbW2trb3vvd3a13a21XdN766q19XrLncDkrw+FLqACF2lc5JOQcAj88kCn43M0ZC7jh/ugFVGzOAeXycqMYJYKCQoqCN4lKiR9uAxV+NrsRgDdhyGBOAOegGRngMihkIlUMpwW8zqpIwScH5skZI4Aypxk0nKKs7pNPVXs91fmSXl/Wl8+VXtC7106pfC24tXu7x2e3VbXnwp3MGZeNrA7iCQV4weB2ByBjp0JBUcZHysMDqq4Dfwcg5ycjGeRu+UZIBiVogpxMjLnGFcAEEZKgZyMYJ4bavVS3OERowGUOm1Wwq7hjGF6HIzuHy8DHJ+6ykitHe7T0WvMvK2mielrWW1m9N2oaO97dE009GrW2a+yvPfoiQ8pggR/MuSecfdJIJO4MSeoBIHynay0ZG0lSANmcYAKr8gbLLk88HOQMnuc0xnU7MPHuDAEhyV2kcDJwDnBYY6kckDBpN8JdVLgrycByFPIOCTnBJ6qMAjK5zgUJxV1zauytdLpFJeb66Ps1q0mlB6pp6dknZ+67dru197eeo9AAmQ6gghlJYZA4JU5xheQOVIwBnG7NSpktkY+ZVAU5IwQpxztwcgMpOSAcH0qAOW2BTHsVv3jF0AZQyjCjaGwCBjLFjkkkD5hKXTH+tiIwu4bhlQNpJUYOMcZUHqCR1OC8e6W3VLZK3Xa7tp56akyTs7pO+m17aq1l2a11Wt2tL6T7Qxx93nBOQOfl4GeF5ADYBHBCkMMByjC8DoBzgFiPkGDnBJ3dT0xjcARkxiSMkZlQkEkEOuSO2SMnIyCcHBHB55qN5NysiNuLElpQRtVRtyu7GS7DJYgHnJwDQ5Wdm7vot9fdXS1lru9LK+iViOV+6no3ZvR6J8rfl5dbpqyutSaUkiJWAUYDy8bVBI+UfJjdgliQQTzjJFIFXHlBtoQjJwoJPAJJyM7jjccDcOuwnFIFRGUYCg8qSNuDnYS2GI3MAeM4YhQMMpNP2LgDIBAG456gAcMT/F1BOPUYyapRvdu7b1/wrS17p2Su9bau11prpZKyTaT7q+vuu+qa000t1tvoPZX4ZFB5UE43EjgblJYEk4OXPA2/N3pxxH5cgIbDKp25JUvtDBdvOY9oySecnBCBsMBJXIyVAC7QXww+QE7vmwoB6nPctwBi9Fb5t4r27A+zGUrBBkCW9mTaGIGwEWicrLJ1dgYlJk3lKSd3a2mtrp2Sau+rsrq7v5XvvnJ2tez95JLXmltpptpZb3Tu9rsia0DwxXk20KZVW2hfAa8PBeXBj5tozGFUlk8xyVVhhiFkmkkwzuxKfIuNw2RjIAVVIUKF+UcAqcbwGAFVru6uLy5EkmN4QiONAUhiiVhtihjJ2rHHlgqqoB9AcEgd2VmI6MAflySQFU7tx5BxjcckDAwRzTTUm0uazsuqbd0rvqr9n0duoKE7RlU5W1ayWqim42V7a9LzesrNqy0RICcYCkhSCkhwwC4IVWywOc4AJKqC3AyDUCSqHA3ooYH5FQknG0Zyx2/KQdzLuC8Nl1YbbTBcEgEDC7/AJhgZZAfujAJxxk8KeG/hNeRcHg5cEDcASduehI5JAIyM5OSpAA4h3ulp0um27q6tqn5d7fcWknpqr7dbK6u1o9tVpq9G9NVasrSGcyXV9P5NlbSRoYlZfPu84LJbKEKlgoZ5ZSNqA8Asdpq3MwlkjQOVijA8hPvCKMu2IwFJGSCCzgYLDdzmpGCeRCFD4WeVCNxOCyLkqeRyAM4wTg7QCStNRY2ViV3uABGW5IXcGADOR8x3EDKFcZBIbJodkla2rTle93Zxe+6S2srW3v3mK1c3JtK0YppcqWibS3u+rd3Z6WtYUlM/KuAhGSFzk568EYxhiMAnHzDIyC4FegQuNrEjJABIXgnhSy46ZIyTgg9AopAHCknjpuBHcnJwDyMg5JGcZ5oGDwNw2nbnnso6BjknnhsYY/dy2CWkk09ra31stt9LPS3ltqGy6q19LdrPXZtefTp5hdV3YkVWIDhgFIAO35eC2GJ+UglQcZJO45AASUMjbpctsAIyp2NhAQTgDO1iA3CjtkKpXBUJyzb2GeSTjAJODjJA2gYJ64dcMgK+arBfmCBS+7gJlWzjcMKMhCud5HXCk5ad7Ju70T1eza3s0k7bab7oH02TSv9m+nLZpq3W/d7N+bCQq/upFXBXc4GdqgAszEoQ0nIXduBXv1yHRSRnKpk4VgxKCNnbKkk7iSXz/CcE/eHy5LSCPYPLjAUY3ggHptwTjJVmPHqu0YxTA0ofIBKdckKpJ3KAUwcEsMHO0kAZySq0Xas5f3Vbo9tUr3WrV2lba49Gmk7O17t620Wis3o7W1Xo9G0IHmJL5qhVJBXAcF2K8sPlyV+X5Sd64wuRmnoSQxxj5CArbcnJDK27BfbwQGA4IIxjNIIlG7APJzkFwAwbdkgfe+ZlG3oAM/KcNUblfuLKfNyoC/OOPlJV2wSSeABkAjIIGRVq6veK10fvat+7snpe3S97Lewr81ktbW1tstNfO7bvvt0ViRN5mD7G8ooc5Kk7uSvVkHzAKoBUPliRuJIYVUYkiMZJJCthh1GMEEbQCOGOQGDDjpTlBHRlXIwONpC7l+VdwPGAcZLHPTBxTQCQAxyuRjG4YwQBlucEbsjPJ6nBHLUXs7Wvs9LbaNdLO+tlu7p9E31jpa1rbrbXXezfztsxgAjOA0khYlAjjcoXACqpyACQByGYghiuA+A4qzZUlEUoQQCjMmR905UELx8wIVsYIJODSMWGDxkuAWIckK2CGdVOcMDjJUYXqDTRKhcqsgZ2JyAx5DFfm2leuDt+Uk5GFOOWEktF5JJt9LWt106JXT2flVpOzSbslrvZ6Wb/lXn997isqqrmPCbVyrBiVwACygsy7vMwo5UqzDPU7iwSKy8kHzE2Km05B3D5VJYhVTKqMODt5DHOChMhXCMqfMm0Nhtg3AHDlMgnAIIO0ZZH3bgQHhFG0sAEbKqFUE4Bzk4MZJ3HO1hjnJJIS0k7R5VaPp2Wl0ttNFo9Lsa1S1vrZ28uXy2vb1s3uPi8zb8+N2MbvlySAu0YYlQCTlW4LZIJJIYPKtIoVQrNtVSVGSQChIztYjGCWb5eQOvJEbozfdUgEq24nAIJAJBUEjccAFeCBwDtJLrYzIxVQQfKkVyM45VMqgJXa2cjBYg52A8U+nLe+nKpbXXu6Xts7WXpbXVNcv2otN6OyVloktt30fW6d9LJCSNJLiQNvMaPGCq42suQ24krlnXlywyuQApyGqMsWUFlCAhW5G4uxIADO/zAEqSV5G3uSTU0ipGUVTjcivgsWUlSVKglSGD8Z5IAGMnJBgVFYMx4ZThQCCQyKASS2PlOSAvqSBhqVul3frvrZq+6vba9mua+6S0cGrXsuVfDprb5av7979B+CxPmSIpVflAG47uAAWUBsEggnJGcbmJy1RtIIl3OhbCsNu0bi2FILHJyzEE5Xkng5qROQWYEBVLYZiSAcEnnjuduCcHHQMMzW0CCP7fcgeWsjJYwMF3XM4wquRsKvbRMMSHcQzkRLnccN62jF+8+W3ZKyd9bKyTWiVpbIp2irtX2923xbLlTS1TtvsrXuraWVi/sm082RQdT1BRJknBsLN87kK7cx3VyDvwGDwwhDGCZMjKyGBJK4+6SeMkkDJJ4IbOScYJGMq2DT5JHlZmk3uzH5mYsWLHOWyxXhckAE/J0AIBFMbcAgwCcrwMHcPlIGQSd3OQccqvQHaxaSUU0tFs3a7Ta1fRv8emisEYvVtpyk7y2SjorRWrtGKt8rt63Y3ONwZSQF5J4VsHqSScEE5Hy5JG0gHk71uq6TYreS5Gp3iZso3QA2Vm6sst9KjKF8ycBRaYbgK0mAApMOnWkaQvrN6FaztnEVvA+VbUb4p+6gi3AloYtokumJztxGTvk3CneXk99dTXU5DT3Db3C/LGONqxxoN3lRopCpEoC7VCpjANF2kmk7te6no0vdXM9deyvZrdEy9+XJa0Itc7jZKTjb92l5Kzm1o9I9ZFcsCVdMEFQHVgHLE4JLncWZSNmCrA7jgnYCAzr1GCCWOMKCFwuMsSe2AQdrDkKrEGlxuww3D5iCDwcYUtxtAwABjJGAWVxglqAoOR948JgBgSDhVbgliT0BKlWzzywqU+VXV2o7JO/wDL5vW99OrvfV66KzaWi1Wu1k391tfRJWQiIZnVI0JaVdqdcu7bAAAQWaQvhQMLk4BwVBqWaxktVT7QUjlJJe23g3ESqqtmVQpETZ+UK7LIh5kRQQTZsvJgjku3DGVDssgFGwTbN32g742R47cAEqzBg209OBUb5maVyxMm6SSRyh3SuynJxjO4kDYfl5ABIwDLXM1vfR3T0STVndrdq+l72bbJTlzNKyS0bsm3J2f3JW1SburR7jNse7IGC4wBlVxggbiCTnscZAUrx8rHDcckKrEHjGB947TyueoyQc4HOEwcClVSAuAoIYHAbjadvQBQQOQCVG0D5SNvVDyeBtBKlVIXgfKSASS3oBuGMcAkk5tNvtrbyd2o3fbr5dN9i7ebdrW001f4b3Vk2+qvezQCwG1lyACQQAThlwAckt1AJwd3Q4O0l27JOMHOAx6gjoP4gwAOAc+oBJzgKGJOdvRcDaCNzgLtYk4II5A2jHfIYnCY3dQAxIxwPnBCkkk7mLZJO0YJGB8pxT1S030te/kndO+i01u+ra11SST1vfR2235WrWWt1or7d+gjKzqADt+6wLA4+XaTkgksoyAcjC4+bYSCz8KCAFJAALdQFOF4O7By2MHHQ4xk7TTiOjBSSq8nlWKqeGPbGSTnAyCAQV5DRggDkBgH2jKhSdoBKjLEkAkjcPl+6CDgTs9tXZLZbWt0tvva76pPSwm2l066762X+W7SXkJuLMrdOQRtXO4cDgsDt6DjG1sZKlqdypYn03YOSuODtCgAcYHIPQZ46Uq4VcsDk4AwCzOox3xxg5O4nJx0xgUnHBADnABBBBBx2HAU4yDnIwSMYprWy3tbaTv0ut3d+vz80/6+/wC7+tBMgYwMBguT8uQW2gnaOD0+TJztBK4Gctxu2rt+7tIYgAtgJwCeuSc5VVGBjkBTS8gk5AAOM4BG0Dkj7y7CPTblsj73NL1yB1HJDAkhQ2CQSDzycY24HB+XkG0lZb26aLSN0+nS3Za6sPX9bq7vp+nTXoMGGcYHzAjnDdBtzkHJ+Q4UgYJIIODgmQkDOORgDBXB4VMEgdDznaGBHH8K8odw6KpQkB+NpGdoDDJ3E8dcEqTgAgjCoOTkjaAe+OeuMdMgEKCT13HH8NNPVq+q7aLZeb636/d0LaJ+q/LR/g73+e4qEjG4KFOMswDZ6KM4IDlsZJPUAMoBAy5d3ACg5AywHByFyOq8dtwGGXg4fmowpKggBgW4wcYIxkbcFcgE56AkAr3WpFBIVSNpO35yVIIyp7g5fAwrKOW4IJwRakl389L2btZ+unV6aMH8vl6L+vW4gG4bghOduf7uRsb+JQ2MH723Ck4Oc4qMlSCp/iGeQEG75dindtOGOAcALu6FeTUmWyOS275Sqlgu44GA2fQlgT0bGBgEhrDb8x4GQSeBhSBncwzgDJJzgZ5GVwamUpWk99vzj2tfb7ioNX1fpta97a/iu939zVG7oD907s5JYfKcq3JzyBnCsOrMaVURUOeSRlQAGCsCpHB2hTwQWBySRjOc04/e3Ft+5RjGVAxtGDjGNoK4J4JHUg7Q3KLnq3HTBAUcAdWxx1XJODlRnGRjzvVWtott9VHV+du7ultd6PbotX5627Xtq2r7db636mjfBVWwG5Wf7BEdq4JVjI+3JyQS4AOFwuCNgBPNDJyRyQON2w4AyuQpJ4BxjPUkkMCORavI/LWzAZZPMsoZAFIG3lvkIAAUggfKCc8HJHJqAkEkKQOARnGT8qtgnGScYBwTxgdq2ctdbpq3W/SOuqvd3Wv39LZ0o2hGzvq3p316LyfX1HLx5gJBBBCkj5g2BtOCSoIOAACcn7hU5zZuDlbL5cBbQbd2MHMzsWXlQB0KgKPm3dSTioApzgYKlsE5GQBjbuIDMO2ORkKDhuTavApSyXIJ+xoTtByuZXKsSeSQBk8Lhdp54Y0n+7ne9rQ1SV/iTv597X2Ttc6YpKMm/ndaaNeV9n9+nkVB0xkEgHbwSG5GSBwOOR8oLZPXJGZIwrS24YbR9oiVySi4BkTJyxIyCBknjGE2l+AwjJyynAwAflxn5QOS3U5wMDnABy2GEsKh5rdVG0m4hQHjB3OmSWI3YPqVXcCepwaz5k0mndNxV/mn8nprt2OdqylpZNO2qa1slZLWL11ael7aEuqbm1C9f5Rm5myQxI+WQAEsSGYMDweR25KkVWVgQrLgDAGAAecAEgZ9QRk/MCcZ5FT3gDXt2RuwLmflyCdwcAfNhd2WBxlApAPyggCq6rkYDAYJXDAAN93Iw3J5wAQORwSG5LfxXd73bta71tuk2rpaarr53dUtKdNdowV35JdOrV9nd6u/lNbHy7q0ZSoJuoGIGAQd6fKQAcEDClcnO0FcgHNu7GL69IHL3M+47VIYeYD8uMDcAPlKj5jgnByBTj5mt9rAZuIQcnAyHBJwBwoz1ALALjgVNdDN1dHO4/aJW3E5JPmHKhmwTuPBYDBIOwhqqDV3L+8lr5xW+1v+DdXsRb97F33i9Lq28U+/qun5kbOAxUDKgbOACSrDBIYABRwR948ncQCdtQnaABuweHAA5AHADYwBjLZ3EgkeuMvJLclMhQOWUsQMKSSSQSRklSF+UEhsnNMBIBwilSMDOGOcKScKVVcYxz0I6EZNW5X7Wdt73s7PRLXz00dl1u3ukrLpsrJ7a3Wr121t6LdXehppYzXQwGJ06+5ITC4j6jccc/dXgbydpwcbaKg9FwffGMnC8c45OOc5GOhyQRbsDIslwURiWsLxGCBXKoU5YqQQQUJLAEMRygwhxVwcgfdPykHK9DtAxn+9xggZJPQHORSSUVs7Pu+q3Sfda2v06aFQaTejb6v59fK9723V2m0KAXAPyhcDhlzkqVB9vm4HOM45IYAlkoykeVAw6dAQSoZRjdhc/MfYkDGcmnsQcNnLcBsHAz8uDnOd2RgDhcAY5PKFGk2oOTuV1Bz94BcKdx5LfdJHJbrkjNZybcWrXbWq0craJ/fa2t+3qNttbLVatXkvhvfRN+rd2rK999K0eGSG5s2kEUs7Qy27udkRkgMn7qdi6IglV22SsGQSKqsUQswoyCWMtHIjK6FhKHVso/BKbMAKT820g7Tn5Qc5proThhjDDdwc4LFiVyARlQWDDJxxyCQa0Vl+3JFBPIqXC7Vt7qZmUPCoJFtK5dck/KLeduUP7tysQBiuMm1GKvzLRX2a00dvtLVp7Lrox3aUdL2VvLpvqr2d396emqzujHKjgnjoFO4ArkY2nG3GM4JyOuKY2CvOcDJyQM5BHrt+Ue2Qx4Kgg1JJGYmaKZGjkRyJUfiRWU4dWUZKEMDzxwQN2ASWFlwv3fm9cA5UrgZ55HJ9SAST0ynOUrqNl3vptZ2d0l01W99G7vQTbael3Zttuz1VrN273+evUAwIGdoOCS2ADg4AyD8vy7ck44BG8Empm2/2dYqXVik16McfI2+FkRjk7WYBiowoYfMhBBIr43MMgDByfQ4wFwSMjceQeRxx6mzbXBgkLeSs0EwVby3OdsqgNyhLKIriIsZIZgQyOOSV3q0N+85u9nFRb6L4HzOy1Ss27aq63sRUi3yyim+WXPy6rmaXLba10ndXtrbzKpO4ANxhgFypAxuGMktySSMcYbkMA3FOAC5LKRnCFiuODypXAOQT94gggZJ4GKuXVqsTrLbMLizmVvs1zxulU5BilQFjHcR4PmJ1zhkzwKqxt8x5GThlDZGCAvIyeRkFe24YbK9Q03fVX2tZ6N+6/s2WqtZq67roVGfOouOz87NNcukr2at1vdu1xFVsY4JzuO1QM42nuRuPAKkcMoKkAEGn7VDBhluOmOM4XpgjbtzkYBwdxyeFCkHdg4zjdtyMYIBZSMsMHgBMDd27EGACq85IUgE8KuVOSWHBI6Y4xtwQcE3GVrN82i15Wra8q1s0pW6PpbdjjK2qvot0mrXslpt+bu9L3VlYBMkrnAx02nDbQNqqG9dxY42nAyAeGkgFQcbgoIKgDJO3arFioJGDjAwQAByKfhcggg4OMg4Zd21sAKfUEgN1yDyuCIwpPA6hgpO3ackKCTnkg46DocKCoJzaeys0rr0+zpqm1ulsrO3fSr2tdNXtZ2va1nrfuvz6bkgOQMnCngZO4EsQQctzwwAAI3c9cgLSb2GAy7sgr3x2zwoAB6Y4yWHzDcDlrDD9MEjgZ5OCAAxIPzcgHJBK4284w4BnBHy4AUElSckYJwT7ZwSc9c5ycaKWys4pW1tvblvtppey3bt6jtv/AJ9FbXe3W3d69hvJKksoygO4hfl5Q9MnB44yWxgYyM5YGJOTjtgEgBgNuACdq5zwAc4A7Gpt4255PcZ/4CM9AFyFyM4zweMYpD823gAgc8Z9DznJPIAGBggAtgjNCd5NvrZPmukrW1du9tVsvW5WtnZWvtu7q609O99HsluCgZOfTcSRjIYKMdOMHjpg/MFIIOGqSDwQo5xjB4OCck/LgjGAR1HPsuRu5BJDD7rEryABgn0JGCDg4wxzk0vQ9uu4nOQRxx0JxuznOQfbGKhzi9mu/wCXa3yXm92mK6XXp3aSvb8d7rrokr6AoC46sRyG4IXOOOB0AGMDsfQnDmUEAHaMcjcAD0GOuCPUHG36daNy8FARxhgR1z1BxzyeAMqQeD0JMeAe33cDnGQSQMDnH3sDt1HJ7ZyqL3eRXsla/MkttVd6tdNH/wBut6p6W3bu3f7ut91e/fe+yupGRkY+6DnqDgY4y2RwecAd1JzTcKoH+1yemM9Bzwc7l4GBn7voC7A656DYOp43DOTycjoSenzA/MeWE8c/MRgA5HzD5cdec+/JOAScsMTeU0tLfDqnqr8u1ktu+r7u1w0dl189rtqz2/p+jAe/zAjg9OcHPT0xxnrnHWnEHtjHJwAD15PPPJOMEge4xmoZpREFAQuT2ywGO2SVOc846k4Cjkc3vsGquQFsJBkAkbTuAIUgFS4w21gQPvKGxk9Cr8zajzTaSbSV3okley3e17aJLzBWuldN262vbRX1au+99L631uVwSCBgAMD8u0c8gkAg9iABzkYBGV4ICNpCgHnknHG3BIBzyOh4AKjj0JlNpqESgtZk8hPmUZ3KDwoLksQck8AnnO3AIFtdSIH+ikZQBegzyAOBjlQVDHbwMgZwMkua6ShJbS1jbX3dbJLRW+979mr7pWbt0tfVW206K1+/mMCgdxkgYGBgHjI2gEAjJ3HIBwPShvlOVAGQeWxgAYHyhSF4IYYzkg5B44kFrqB4+y8g5YgDA2YYrkvyyKemVOchTv4ItvqDBv8ARGPlttbK7cPwCCQxBXLFS4YqehPXAk7puEtZJW5XZuy7rW2l1s9fJA15Wtbp5K6e/wArrq+uhEwHp8xwRwMc/KVB9gAcngjgYA5RW5Y4HGFIO0jJwTnByOvViWHQcdJfsmoAAGyYYxkAjjLA4JzjJBGSSu0j+6QTLLZzWscE86x+VPyHSSJgsgO0wyhGYwyDa2EO4leQWUGqUZtOUYTlGGrbjrFXXdX7a6u1k20JwkldxlZWu77JpWe63dr3vo1Z7orbQeMgZOOgK7iU64HuMknntzyUA3BiCMqdjAADO0KT2JK4BG7IJIAYDjLWI8zGCPlwCfusWPy8HABBHDKD2zzwZMZJJDZK/ebOTweScc8HG4ZyD1DDmYt3VnrvfzfKt0/m22720vqC22Xa6Td3eKfnZaPbvp2RnUYG0MQVUhRtKjjAYnI5+UHkEcsc4ZgoLIWaJwvJ5HXBBVlIUklDlQwfcMHgBeaAJA27oCrDaNxyMgkkgZAODycuqjgZOKeVZuCuD8pYYI7LgHOQTxtwCRwQRnir956Wfq7Jt2i/J7p6bJa2WhVuZJWurLorNe7dq/drS+mm17sjl271mUBI5GG5IzsSFt3B++SY3C5Vj9zgBS2NySbW2qrqrEoykMFIHAwDjJJ4GVOGxng4q3HJJEUePblULbGQOjLtKsGTA+UbiFyRjO45JXFS9tbaSbzLXzbaFgXeMkOYpsksiEMZGiym1CxbpjLFgamUZQg3H3m3G8W7PVx+HdattNaWeqVtUuWSSu0720vraytq97XaXlZ6kAViMBsFnB2guSygqTgHAwCeD7EOQCGq4pkZVIAwFUMTliGIUN8xIbdj7rbQVYnLEhTUH2SQYk+0SlhEvOME42kBexxgAbsZA595VhYLuN3MGU7tpWPcpAQnIxnknO4EjA2nJ5JFTV7U5J2V3zxXWN/Jb6ed3pqCi9NN1o77Oy1b1+5t+TuWY0SEtl2yxyBlmGcgIq/dByegJwQMYxVmN9+Mgqy8EHccAsoOFUKWBI5Iwdw2gdSM9reSRhm5mZtuQQgC8biTkDock4PU/ewTmpBbTbgRdzkbl3HEZzygJ5A3HjuODlCASaHzxtaDaUWtXFN6Lpe197+i3sxq99r6Wbfnyrft6b3T6FHavHGV3Y7ZycDkKCckY5zjqCeTlM8MCGwwBDZxnAGMHklQMBWIyegCnIpQd2RkKu0HGQEBzuXcVGWHAADHjB+cYwWNyoJzgYGRkHoAQSTkuR0HBAAJwSCeFPa97abbr4U+XX4raPdPtpdeWk1Z9L2Xe65evmt0tG7Le7LpX7aqLn/S02pGznaLiMkgRlmIJuEG1YyfvJ8jEFFNZ+AAOCSCGIJ+Ygdc4wRyAcZ4A9asxou6MA7i0kYUrjAUFVwQATkbyAQPm7Kw5WJx8zjoRLIoBJxjeRgknJ4yCAD8oGQAcU5vmtKzu9OZ6c1rO7jayb662e7V7uWjlGUYylo0+VtLfSyun1vo9V27WbwMcEqTg8YZsbQCTneMjaC3pkkHqVA5HPUHbkjJ6YHIHB5ycEcBshsmgJghTz3BwBxgH5uT0OeARjBwTnAFBPLKM5JBHA5xjBJO4gndlQAw7ZHNQd1Zpaap9eit20utXbtvcUXJXaTslbmbdk7xfq3Za63t6OzRghlZA/BG0jcMdAcnGcF84AJOPmXcBl5RC2VRANnOEXA6ZxkDgZx1IXoATzUeAOWyG+XnPJAIyCTtOSeAcbs8fewS4kZ2qzHb6nGFGAMBskNztwThcd/vU+WLs7Jp33V1062t0v1b+Q0+11a125bfDqku1v8AF033ULGBhYkyc7QVGDkY+82O4GQxzsyD83UOWwDGgIXGSie/qeQc917bc8jLjwNzZCkbflBzx9QSTn5T0AUZIpBnpyoAGOck5ww5Jzkg84GMEDAcDLslHSKeml4ry1tbTXS+i9LMLttXfbfVfZ87uW2j7atJCCNcbQiE9T8oyAR83TBJHHTGMHBIGApRPuiNcZ4O0YAJPTcepJ3EDIPVeaC+CpIO1jjPXDEr0B5x3IOCBgg54pBvBO5RkElTkfPuHO0jIx/F8gUDBBHXEpQ50uVN9Wkmltv3vpZdUugno7t+e9tU1o9rONk27JXWj6i7AQFdI8Addi5OM4zk8jLdeT8uM7sUqoMMDGqj/dXlRjGWYtuHfIGCCVPzYw/kY5Iy2CcYznAI2jLELgnGcAZOSpJLQGJ5LZVgeCQuAR8o3bmAZt2Co+fgYBINVaKafLFLTXlWjsr6pW0XRLTu+r0adlfRdeq5fhV3rdrXXTa19HiIMAcRrzuYbNxGOp5Bz1B2npjnauGoGQQFYHHUDP8AeHG0HHHGCScZwOMAuDHgj5sMBj5mUj5Nxw2DjIxlSSMjmk5JAx0bj0xwOOQAM9x2BAwTy1FJ391NPVpPbS19Nb2v2flZEN3Sv29d/Oy07AVYrgHOD1HAyDySxCqM+4IPGME8qFONwViFIABLjJO0bycZOPvK3G3nOdvDBl/vEgjPKhgTyMfN94DAIGANwI3YbArWsLOOYG6vHaLTrYqtxKm4y3Ep24sbUhSTcSqAXLZWJGEjg7VR2tWopK7a3en2U+jS7tvb5aZzn7Nc0ns0mkm27uFkkl7zk3ZJaq+jd9I7e2Voft16zRWEbbAygiW7mVVJs7Y4DFjgCecjbEoJ5fy0Ne8vBezGSTZGqxBIIIzmO2hA/dwwgkEbVKlyT875YMXYkyaje/bJtwjSC3hURWVpGB5NrFnKRjfkGRiVMspyZnJYvkmswxLwRnnaWwXwQMEkkAkkgqoIwVI2kEHNN6q0U9HZt6OTfL+Cb206X1FCDup1NJNJwirNQT5eqSvKyvKUb3astL3kUGSVSxZB5bcFmG4ZIGCyjIbPsCFAJLVOqBjkfewGGMDO0DggsfmCglgR0O08DFQxgyNGqhiz74xkgA7tmACSQNox8xyrFfmKnAqykZGckAICu0PgbsDK5Cgbd3AwQMggncCBCerWurV/S0W0+n36Xs1trUm9EuZOySsr2WiW/fRX18t9WOSIpWxuG2JT1PBmQEg4zgcjg9znJwBXLBm2KdoXLMfvZAZQO7MpBGCRjIyOGUZtvkQzbs7tsYIGGyBNESck8sAuRzkbgGw2TVbAeQcYIB2/MoDcjnsSFJ44xuJXORR2trfR6aJ6W89FbRJ9Few6bvF7aSS122jbd20ae/rbtOCzW4yM7ZyQWXBG5NwPIU7cjcMDHAPBwwYMZyeMkFSDggALxj5iOhyvUjqvQ09VH2csHztnX+MsclAXGG6ZVV2nHbDbW6sRgAcggfMCMEnJIOeNvTBwSflIwd3GB+j2X429dtPv6a2mzd+W9uay3vdpOTVnZ300V1bba44n7xCtuxkAZwW2qSMNyMhcAjliAFPWmoONx3EnHK4GMBVKkDccjk98c5PalbB6AbtwIwqnb0B5/iHAwoPPTBBIoDoCQ5DLkhAEAJf5AoXeeVyfQkkH5icsaSvrayVuZ39NHZ7/AN1a28ildR93e61WrWi2s9/00tbeUsVzhSclQcKckfLgEkEn1GcEKAGG3kEa4ZiSCWJIAxwuFOcDDbsKo6ZGCTw2KZiMSbm3ZaMEYyVJBIDHaw4A5BCAZJOCCRS5fYAjbwAAN+T8pxk52nopxkEnfzkAHKWj+G7XyunZLo01FPTv9yJt0Wl0k3dNO/K9Pnu/O29k13x5CkFWdiOSQV6c7FBADD7uTkHGMqaJF82NgrgOhyhBZipTJBbaACGC4yDnIVWxjCtBMbh1DkkYLDChifmXKbiAAw5ZQSMjbuXNSjBKnIjbYSy/KdxOQACfm4UBSCO2C3AxUHd8rT20Svq9HdvVX3Tta6XkibWs1srO9r6rlv8AK7tuley06RBvMVXRtykbSRuxnC5U8cDkgnI54wQaRm2NwkSqVJdyytIWIXCKDhSBgburNk7STkEbbj7wC8tgAqN3GA2SAA5J4xkBem4gCLP3gwIO4AYPB2kDp97G4lMe+0/NtzVny2bXNpq+rfLbRxfk3tfZ9W7UV5u+mt9L2V+mqXXVLztq92JYqRkjHGSflyMDdjDAk5OO+M4xmm/Ozoc4EagInXc2fnMp6t0I6HB+7z1C2Tkglugck8gleSSc/Nn72MEcNyclgZi+0q2Dk7gQT1QEHceDnJB4cgnALFcq9ktFfRSbu9dHe9lZPf117opQ0tZ69tbvS6St1W73s9Eh6yxSOykYcAoVbIwwwGB3AgqMkE5yAMP/AA7iQwRgPszysYKK68gEblAOM4yc5VtvBBGKaqICTu4zgOcc529cqTnORkgjACsG4y6NEZWkPf5AhORuXaQ5C42k4yhZiQpA+6oWneTjF3V5aJtNJK6WvW95Xa2dk9nqWina8lFWVr6qTtfXzdvRed2JyzBjIrFQCcDcCG24DYAOQuPnYHdxxgGnKuASCCMMBkBsgDOG4O04247ZBIwDimM6ZU/Mr7QoSRf4C4VSjcq2Tn5NpAGRtGc09m+6AQAcZA6YBUg8bCQQTychcgjEamphbtfZdHp7qj16qzWm2t76Ctorpro9ulk15p7q2j01Q8najDIbJAG0AsJPkwCSRhRxlQBkcqQc0E7ECsmHba2QFAwqKW3SEnJY7fnGdwABIK5ojjWckEhUb5nPKhVyp3AAMu5eij5tzHcD1BjZlDAIDsCbVJUFioCkEN8pO8/NyBk4Bxk1SaUkrdIrmtd2vG75rXu1ZefbXQ5Vdqzb66WX2bJpJfc73366jMZDvfBOV7KMBeFXOMkgFSMD5u4yFamxqCxXBPOQ3rjGGLE5J6EHG0Y+Y7sGmKTnHOSD1wMHK5AIOOTwBgNw+MH5aesc1xLFZwbnnmwoI/uOOS/G9VC5Z3ONqoxIUjkvZXd229NG3eXKnp1ba2V9mtCrLl6JJWu1ZRUba/Lz8t7omtbdb+dhNIYLK3XzbufI3BF4MUeQoM05UJbxnli29ujNT7q5W6uGZEWCBEENpEuMRW6bREhJIDOcsZHx+9LMThiAFuHjjRLKEq0Fu7HzV2lrq453zscK3lKR5cSsW2RqCcOxqsUB2cgHAIBOCcdRnHDYxkAjgZIBO6pSer0vo27rZWtbyWt902pO2iEt77LVRVrWWnM3fW8tLrpdLS8rohEn3QAFX5hhcll2gYLH7oJ2scZyQhyTkWbK0+2zP5hMVpCnm3lwdxWGLIG0fIQJpThIExlmOOQCBFFHJcTRW0CPLPM4jjiCn5mfG3O5WO1OSxwNgUlt2Nw0r6SO1hXSbV45I7d2ku7ldri8vhwdrkKTbQAiOGNiykgyrln21Sat7yuo+qu1a0Vv876pdrtCm2uWEfikk5NfYirXk1ZJvVKPeW99WQ6jfC8lRIIxb2FqhjsrYZPlRF2O98AB7iZuZZSN5LbTlQorOUNvO0EqwIGcHaCAdwyY9p2kk7d20ZYFTSbjujODsJXIYsysRtGCDt+UgNtPTIA9MuLKWyASqMyA45K9CMo25FPzDAYBSSQuCQSPWT3bS1b302T20uttF16lRioxUYv3Urvq9Wru71bbs3dp819LNtoen3AVB2sVUKW24G47XGMd+gYMGOVYCrtrapNuuLovDawrh3VN7zNtVkt4SYm3O4Bcbm5QMWwyYqvb2/n3EdvE2x5pNil0BWMNtZidokLJHHlmHGMDblTkS3MiMq2keTFbF1jkKoDLMGYvJnajmM4GxXG9ExxuIyL3r6xtpfXd2j0unaK1ktfnoTLVxhFtXs5NqzjG6TtZy1eqTs7WulpYS7vXuZs+VHFDGBHBDHgLDCjsVXeNnmyYwrTMvmMxyxBDKKZIyTtJXdtBBGFyeOoVQeM4Hq3CkBQrAkBsHK4ORjuRjls7mYnqAc5wT0NG5SAOCe/BxkAZ5bccg5BGM4AzlxgJK7Tla91e+vRWST6Wsttm7pddEuWCjFNJJJJO1trXdnfTXe97LSwhVm2gEZXkqeRgMhOSQd2P4s4wuexBDMEBixY5GVHAxlV6cA84wB83I5w2KUllAaQk/MMAA9WAAO4lQSxPA6ZJYsD8tGQSpIJIIUdc4IAJ55bIyM8N0JXINNSV0u7TaXTSOm3pbbfS2rRq49LK9tN22k9e+n3ICR8u1cDIXnliRtPTBLD3bBIA3A8ZciKo5OeRyG3YOFOF2sSR2O7jOOgAIaSewwqlV4G0YG0bhzkhhhQ+Cccjklg6LBLYG7KsCpywYDG7aDhcgHjq3scihNe7dPe0W1a9kteqeq6aW0vqky2lu139/Lq29UnfTXR6WQ4YGMgli5QgbcdRgdT16HBBYfw4JJbktwq7QAQchQNnyj5csc5O4DoE3HC8YpSSCARywDEHHDEqAScbQQBnG77pG0gEkGSCQw+deN2QB0QZJPJySAGAw20rgEEKua71sunR9na66auz0s1fcLOya++2zVl2tfyu97tK4AEDAO4bhnk4GQpI4BC4I3AYxuAK+gMEKdw27v4eAoHGQQoOMYDkkcAggYJWlUBfugsWXOMkfOBkk7SVJPJUZJBxtJGRQH+X51wWUEgY24H3cAEL8xJx02tjtgGkkpJX21vvqrdV6Kyvbbbqr+S/D02289r/ADGsUVVZBuYDCgMCzEngEAY6Kc4PQfKWAJoDEgfIQ23lV+bDbCSpAbJ4XkEkknaATjCgjCkZJBByTlxjHULjAAPsATkYVitKSQCNpychVwCdnGeATk4wBkgk5PC43L3m3d2vZ3st3bRuyeva/bcFy2V1ezs99Vo2vnrf5P1YrbkVlXZhgGJCgZJAPy7mbDY3E5OGA2ggcOGB1XnbkEYBUEjYSSU4JBC8AZ6kMeWuASG2FtmUzvAGeCpAGQNoAAwCPu53ZzSr8yq2xwy5GWKhf4eN3Yk9FAOBjHzEEKL1d2t7Kz382rPVrdt9dPKpWaTiul7O6a0Sv0dm3ZXvtd6jskqQYyxLDgFskADgAABuvU4wxxzwGVVHKn5BjeCzAYVgAF4BI3A5GMZKgLjJIaWfcxbPGVwFbBGRku2dzA7RxgnpuOOinbtG4ED+6GO4klcnAAIxkEEkYJL4yDi1dpt3teyva+iT28v19CP6/r+v1FdiSv8AEdoyCASFXaMliPm7rn7yE987ihUEEA4DcjJOdpIIDDAAPGDkEcHB5AoJIc5B3ZBB3EjbuXIIGTx16jeCcAZOFZWI3A5AwCAQoAGAMjJOQDk8YVuD2IG7J2SVkoqyvfa1raa7Pv0eiHHSUX5p6+qfr/WupGqvtyuC6tkbsnOAuc5BU7QB0Bz/ABAYGQ7mVcjDKNxJGA33fvbhuzknJxjA+YAchc4x3BBHBbOeACcc5AOfmYMQMk/dwpBbkD+AbhxnOAQSAWIySORjjaOhNYXWut20r+t07Xe9r3vprbudCT0l0vouvRq6ut+ndXtsyzdSKyWagsxjs4UclWADhpCFy3ysF3nAA4PX5hlqu4nOQc5ABC4+UYznqRgHB4DYzkcVZuVQG32Y+a1gcqF2Dd8wJG4kndydwAVufQg1gQDyOvO0jngLyPmzxknccYxwDVNtaJq+krLtaNtPK26snva1rqk3ZWW7bbejV3drTZX6dhwyQC3I2k9MkjA5ZixBKHk+q4+UnFWLhnAs8/KpsoWVcNkL5j8cdTkZB5YBgrkfdNcYYYbIIIAbgDOQOBk7TzgEAsRkjGCat3TI8dgMHKWca5xnfmaRw2ZG+ckEgNhQzYRgXBYtS9yreySUEldWVpRe6SWzatbTZ+WibSa0ei6bWab20a82td10KZGM5JPOFBKkKcpycAkhQTkfxZyvCkVJAP8ASbUMG3i6tuQR93zIxw2cnG7JbIBIy5+UNTfmB6DDbQByACSjbdueMYPU7jnIHIFPifbc2uQB5dzbsSq5ICSIcrtyWxjABGOckcCp5mnFJJ+9BNq3M9ndr7K016X66a5S+GT62VtVfotu2q6bK19bkl+M398jgbvtVxna27B83nLfMWyBneTh/lJw216rbTtQLjKlVYjqSQOCOWz1JOeBjIPJqzfgi+vTuLYu5/mJXcWMhySFJUEHAZTkAjaM55qDJHpkc4zjgAk/lnGPu8H605NSd9nK7bWqS0bXfS6Wt7rVasVLSnDde7HvZNpX132voSQgedb/ACk4uIMAAtkCVDkBSMg7QQc5wTyGPFi85u7sqNrG5mJJYMD85xlsvksABlSVbAyQwwa8Kk3FsoIGbqDDEgAAug6HIAz0A4Izjk5Fi6BN5cZ3FvPlO4EHf8/XcMZ3H7xAVc8MAwJbSG7vZpyTT2W0VqtX7vne2m+wXtVVrOXI2k1du7jrrpvt62d+tclThvu4wD1yzALzgsWAyOQQu49QQBlsQ3OSTsBBJUk4JUDC4Jx16dcKM4J4ZwJ6lVYE5KhAWU7scKDklf8AeHGD16L8xAfGSWHIAGRgDkgkg45OAOc55BIb89Urbvoku7eqtZ32t6I0Wj0SXktVe6bu7a2trdWX52LScWswdU8yNkkideQGjmjYSIMbNr87kOfkcA8gUy4hSNo5IXD2shkMLgneMMR5M/UpOgA3gsQ42uu7cCIVCM2GyFB3Ho3IUEZLEYXJJxg84O4MCptQXZhVo2RZ7SQYmhYDDuFcB4gGQxzx+YTE4G5WIDEoGQvV2Sbs9O+rt73porpJ9LJ2JaafPHeyvF7NaWafRpO3V2081VGcfNnG7Cg9c/KMEt6HsSTjnI4CgL8ZzlcAMAd2AAS3QnGefYgA1ZubXyXVoGaa2kG6C4YgbkBG5JcMwEyFCsiA8kAjG5cVwfn4zkAA9cnG0jk4OScAHGOw+cUr/F1tpvrZ8trdk7XXV6XaSsqUlJJJbpNtXv8AZvp3VndJXW5MNjnCkqWLMYycL5uGKvHubGHAH7o4bzD8uQQqx43ENjBIJB+7n0CnaNpIbkZGCB3AyxcgcDYduVI45CkhkOAd2RhTkHoCwIBojZ5lEjjDSfPhRsBLNgYGeFyD0yGJ24BzWfMoyUVe7Skn2u0raW0bV9Hbysiua2sXdaN2t5W1ers1e9r7dTREiX6iOZgt5CoFtLI20Xcabm+zzuzr+/UKFtpSMPkQyMMQumdyAQ0RVsbCpLAqynady7AAUIyVZQ2QQO4p2CcsGyzY3FRzz8vHQscZCtkYIwzbsGrFzieCK7bcbgSPBK7RkiYALJG7tuJeZFHlMVOCqoSGKktV1a92pJJvVpvVJvo21f7SjdXYQ7PRWXoo6X+/e33NX0pKx+Y4OQQrN6rhRycZGccsAAWOMcgl+eF/hXAHOcjAGeQpOAB0PKqwILHihh9xi2PmAwMkqABliMBscDAYnb/FxzSZAOBk4HKnnk4GeWI4+8vTaOeR1j2nM7W7PR7bWv2XRLlvfS2iDm1SV+i8re7a7u/S9rO+hKlwbdvLl3mzuHjWeAZJR2+VLmDIULKpbLYzvBMbgggh0kJgmniOA0crxuQTnKELuxgNztIUkgc5OQcVWdgWTnP76BiBtOP3iDAUllBx2ztPX+Js6N8AL+9xlAby4wG46TMcEc+oJwNuODtIog3quicVGzdk73tve10nqk93u7uF7tRKP2oylbZtxcLPX11aSb0eiSKYIXG0Ag4IIxjHygqQpAPAOQTtJGcY6uwQQFUHnIBODtO04wMKONuFZjkgbARlaAp+UE992SRjjHHOAAM9ABuxnqMlR3+VcYC5x6EcjP3fu43AN82cgnIrVS30Sa/G9t31V09FbTpfQ0Ts0u1r72fwrqvNaabedk04JYDBAyy8gnI2kZwOoxhuCrY2g8kUgcHjIG1SVJOVLqVwSW6KCDlfu7sEnOKUnkk9N21WGMkDaAG/8cwQNwI+YE4AaWwBjA+YdichQAc/LjA79CFPzDOMNXvbRJ730W60a7abJefrXXazskrWXbe7do/frtpvKAD06kbiuQcEbc4UZ54PXnDAcjG04Gc4GRuHzYwTtJBAHUDGOo/iyQcBgI42lgdykctnGBwQBjB7jOT7gGgjbkbyRuHQYPAXCkKcgDsQR09M5uLsur12tq07K6aWut9H3300IrTum10u27rZpavzfq+lnAkcgAqWGACRzgbgSemfmIHU9VJ7GW3cAZPc4Py8YHUKeeQQCOcHJzTOvy9GJyOeOANp54IIJIxkEjOQRQR064UdevIwcZbBHOO2c4781HPNvdpvTlXvXvyq793u9l573Gpu+mn/AA0V29Lp7b21FBJ3AEjoQQQegGB94cYIzyM9ODS8A8nuMDHQDBIJIBbPOCTkgdMdTGedu5RgAjPzY6YLZwQRxnBOPmBIpMHJAxg/dPXJ4PI69QMkE5bO0ckUndp7a2+zppa91da6R6pu2t9RX79uz6NdNevzX3jwSVIBGAAcZBBAYZAzz83ygkcnkbuRTSVGOeNvPoTxnGcZyDjkYJBGSTTAflGSTjOTyOwwBgdAABnnAGCM5FN3qRnB49ecqSpbjB9QR35weNuFZ3stWvxT5VpreWrvo3f5JgtdLu9+m19NOr6fNPZvUfyWwQfugjAxnBGAxDYycdQMEjbgHq2RwgXjcXBOwHnoBubCkgDOc4yB1HIoZkiUO+WYgKox8xYY2gAn16gkcZxkjcbFpAkca311iSRxm0tiAFnKkBpJl5X7FE6ENg7rmUCNSEEkgmUnflgle6bdklFe6tdNL3Vld26icuVLmu76JLRyasrKyaV9220ktx8MSWYW5mCy3ciFreGRcCJSCEvZ1IIIXCtawkkuwE8gKBFkgILHJy7yZdyW3ZdyxZm5ZjkHcCQSvXhSpqRpPMZ5JSWlkJZ5BjLOTjauQoUDJQIAFAUIuAFUxKxA+6yn7jc/KNuwAclS2G43EHaegCjkj0SersnbeXw6y0e907X077tKEZRbcruUuW+9lezjGKS2treyvo99nbQBwBkgAhgSRnk9DwOThSeE5UsMgAUMwXIUsSxY+23KjlgWPQBQVLEZOcUjyKrAYYu4AVQep+UEuThVwS2ME/dwAOlNXEqhlU4Tn5sDfhUDIQMDg8DkZ2DAbOarm9299b6pt9eVvV30vo01dNK25e+t3rprddkla2i0vr6vznG0HKj7wIK5PKnnIwVHIJ5AJ4A5IpP3bjJAC8jdwB1I+YtjrkKcDA2lcbuSwhWIyp27s5IwHIK8DJzjJ7ccHGCBUmEb5lC/ezwTksdowCQQy57DCnoRxlRNyUdbrbR2T1jfXZ3burJ306JjWvRtPb7K3Xyv7tne+v4gAIB6cblGMAjAJDZXG7LAAcj5RkZxRHNJAH2APDJhpYZNzRS7M7A6AKEYFtySDDq2ACCMk+XPGWKKDuOQCxIwAWyeAOAOc8HJ5EbnhTg5446c/IDnd/EedoPUDnJO4Wm4tNSaez95tu3Km20nZd7u1330dJbre9tOtrrW6vZWTtr/AJjLjy03XFoSI0AEltOwaSInccROeZ4CUA3EB0Jwy5BcwrLdNsYJDtYKwO5hgYBGTk4JxnkEg85JxS3AJikLKy/KSASB1AGd2A3JJ2jpyVPOQZ7fmFDwp8tSM5IyQfXjnOdo4GQp+bOMHf2vLFuK5VK0Xs7paJ7K3TpbRPQiKsuVXaWqbbbWkey2TundNtJLXcbuuTu3JbgtgKC7ZGSB155P94c8ndgcALzhQSsBYALwzAK3BPXJUqQd/C4HI4Jp7uNykLlt2NvzEdEP3iOoYnBI+XK7jk5DgWB/veZgtkA7WPAUHfwANxwQxJbcuM1d5O7c2kktOba3Le/u2b6t921fVWaaS0ulZO7aevu2Wl3rpbW1+t2yDzLsEfu7cgu0eQ7c9cEgHIBIPzEfNz2Bp6rfTZXZaABjkSOVAI5wu5sAYPUEqpAAOduZPPRX8tSzHLDJBdQWK5J5Cg/NwFyFJATI2oRSrBgdyqI9rqdgYjKndyAQBnI4yzrgkc1cY8zT9rOVnF+7KKVm431tp38mlbca1aV300u9GuV9mrbvytZpbFd5L1CmUt2Lny1KEvyQCASpZckHJGAx6E5Ioxd5Qt9nUqQMb2Hz4O0HAK5YEkKSQduD8yLiSOTYVO1ny5ySASAdmFDpt2hC3zEjC7mK7eVLZZC4O5W3CVVGWCrtUY5yzcBcESAgg4yqnBMdH+8qNvZNrS/L9pR6J/O9ku7b0undvW121rZrWyulvtt6Wcq/bAeTa/MG+ZmcBTg8EgckbCT0JILAjLVIo1Ddy1mFVgCS7AkZUZBYHAbGcng5ORmoIc/OGZ2BYschhiMEYIyxAYAjC5bcAW6A1oLEPkdCcqqqoJbb1VmLAEcnq23JBBOSOKpLnTfNOyaaXOk7WWu2333v3TRK1vZa6Lfe1r2uuj3ta3UysnkbRklW3gZO0Y4Ugr8vZtoBI3Y5xhSuSQFxnlQPvfKSOvzdgpUPnaDg8nlSCyhlOSoQnBYgr0HTJ+8Ov8QUZ2kkDX0vS/tz+bMXS1jbZJtwr3ErLvWBJShSKNI1Z7i4YN5ESFtsk0kMcnJFNy5Y3fVvokrOUr7paNvptY81yUI3eyaWm7ataKtrdtq1+trbDdK0m51EzSxeVBaWfly3l5dOIbWBRJGfLLlTumYf6qNA0jYCKDwKyWZSzvjejO+Gx2diVY5A5IwOgOOGyK3NY1ZLhY9MsT5enWzHaIkZIrmcbQ0mDlpIV2jDSO8srZnmYuVVMDnhcHkcA5ycHkgnnGSwzxzgZx1mUk0op3tu+7srJN9ErWd7O99Nk0p8i5kk207JyulaPKptaN63dlZN2fcXOM4Ocj5hncdueCQMc8cn6k45pQqjOD8vPQ5I6AjAHTPJA64HTimAuVzyxJ2sQOOByMc+h5789yTTzu2hsHgDHOB1XOAcnJwDk8AYAHOaSaTvZ206ryvo97PXdeg7WtaMre6tuvbbS19ntf1sEfIAfmAYAH7xIPHzEkZ2jDHOGHfIGFNzgEkLu3c5I6HgnnO4jIIbIOQxIYc0nG8E7QSc8nI+XBII9ByO+cZBxklWIBJwCNuDjbgA4OR0AOMjknAwAME4pu9layeib087LR9l3Lu1ZqLvbdRWz5Fb4fRa3Wv3qoUoBuxyM9+cjqqngBc8ZwOowAcNKqMhQxZSGyNpUjgjkkckjg9G5X7y4pD8pXgheNwH3cHAUcYHOCAei8KBjFSNuXnB4wp+UDCtt55DcgAd8ADIyMkNSSvZtWs9dW1p+D8/wSsT0WmjSavopapJ/FpvZd3q7pWITlmBwWGCSGAzuG3OCdhwVG1Rk7chcnOaerAjcCAccg8YAAzkDIHLEkn7rA8bScptwmAGY53KCMgADKg8Z5IGT93AyvIp4BYbiuwYUbQMcDAJYtnIPqTjGVb7oahNOV05Xe6u2k9NXt16rW2l0gsvdSXW17Wtezt2enVprt1QIP7oYlhnGeBjaCCASABjIyRyVIwnyh3ykDJAHHPTBIXgjqMjj2wOo5pobHUkZ3DKk4HK5wF2kEMMYPTGDlcgAwAV9cnknv7gAYC8nPVhgbB0u9uu+33rVfchWdubXTd9trN+t9B52sAcEYG3GMkYI5w3OBnb0JGACM4wpG4hWyoILKcEtkBSFJ5O44IGAFxgMcgmmAMcDceQCVUnBA5yDtyzAKRnJGBjBAGL1hY/bGdpZFtbS1TzL27ZQVhiIAKocZe4mYFYI85djk7URmWl73Klve91ZaadV239Ltp6smpKMIuUtlo7Jvotr6ttv4Vd30S6BaWv2gme4c29lBxcXLZ+XcuRbxbgDJcygHylJGOHkKKpNPvb5bgx28KeVYwRutrb7gTGpYjzZCAvmTyghpptocsOG2BQkd/fJclLe0QwadalxZwZO7B6z3B+US3U2MySYO0AIuFVQaAwCvPGANucAhemM4xg5Az069BwnKOsY6qyTklvJct0v7t0rN7+82rWREYubjOcZJ2vCDWkVZavf397/wAqdlfWTAAckDAGGyT1BAYjHzZznORyQR8vQ1KQBsIAIXg5BIKttzkg4JxjG48Ej7xpB0GQvXnaODyN3GB3BO45xj7u0laYyE4GTnGRzgDBHUDg5AAOBgnptzlWnZbXu1rrbTWz09f6sbWbtp26+S6+d1bor+o1Vf5EQ4Y+Z1wAuQueApyM4GAfv55qwPMBKthcfxZJBYhcnJJJZs/dwQcgkgj5oRJsdGzkbXXdg4XcFA+YAFjuJ+8WHIU5IOHDIVuc4O453jHCnlcHaBnaRkgnGGxurNNXelnvokt+V3vprfTR7dHoQ+aTV0rJKy6p3Vtba72V276eVpGMhhkZtg4gBAwSN8ijc7bUJGVHIxluvY0hwcA8bckHhR98Ecghmycjjd1AyDgUTSBreYZOcW5X5skkSAMTgA4GMAk5G4AkscmDeSdxHzAEEYwcZAHOSc59SMgZJZsmmmr7bqL1vd7vp5fg93oON+W9t5fK1o2v5X/yLqyMYyrANC+GZBkMSA210kG3DLlcBiQWwHyMKGlVQZypiYFkkYZYspG0OAWZHG35lAO4fMuO8aEmMDJJ3bm7k4XCksSeQcnJHz8hsncC8S43g/NA5LNGyrtPAG9QduHHzFW+bB6kjNPmvZX0VrN3dtum7Tv2dnu97lnF6Xjon23tt12+XmmIsituYD5vusHAyGABJA4PXq3AGPmG4ikARlAZN3SQggAgoMbsKScDAyDuYA8epVlZjkEtFgnkHnaSQclcAqXKkrkZyM4JphMi42INuRvYggAMBk9FK7RuXOcAduhJ2TVkmntortW0u32to15hpZW3e+u6TWjae6s976rXRkwC5JByGOS3ykcgcHcrFeCCeQDyR3NREESkIcI2XZWXK7sjaULMMBsdABuUsACQAJEYK3y8qMcE4BwcgAgAZAPRcgHocEADZBwFPXIHTBJDdlB5AycAKCd3FHrbotdNdNfJ3+X6KKkntdJJbJX1ja6Xbvd6q6d2rr8xDDA6gkkA7skEc8YGSQBgkZwx3Eml3gHB5YnoMAg5Dc9S20kcnBwMsCqjEaklSSGDIyhlK/NkDGDkE8kkjcRj7rDODSdCxBwXjLY6AnGPlGMDGODglCWOQCRT5t12atd9bR6qz7Ja6K66sFDVcy7fZtrZemnX0a0tYJG5JGQMhskkLyFJwcMMDJA6kcsCQtRnBUnpyNvPBGFIGSSSrZwMcEcMR8u1AWb35ZfTKscE4U8tgsQ3AznnOaaFBBXOeBg8gj5VxggEjBJbA2qdu7gjFNSutLK9tdV1intsuX8Vfsi1FxS0e1u+jS+d02k+l/d02HnG5ckjPzj5Mhhlfk3NjH94A4BGD1bNKBk8gY59eNxTjoCQemCPfAfmmKxIOMAktnGTg4JOcrk9j8xJDAnBpyjoGODkjB+YkZXBxtDc84A44BHcEU0pW0TumrN3smnZ3etrLeyW62uHK0nrta6dra2289VfZ79mKDk7SGjZcYL7cYVUIKkAsRk9SOMDJJHAxKocSBcsFAZCynkEgADjH3ecFQSM7cALu3Oc4xg4Gc5XqfuqBkhsFzjkEEY6tGVLDOQQTkAggYUkcAjnpnqG54UMApSfKl5p67dFfS21nrft2uJLq1zNNaPaztbot9H06Wutlf5guSScqVYdFIyQBgEEDcBxleM8DcA5VJwqAlmVQc5AJ+UkFdrADGSNowCcA84qFiYiG8tzvIOck7VYg4GR8pyeDgYOCdykCpNzKoRAxZlBY7cYQqrBFwpbaCx35AyRkY4FClHWz6K+ttdLPptstHZ6aj95OLS19FopaSVtFt89Ve2lpJtgQRKfusC7rtOXBCggjB2DBzwD9D8xhbCgjbgbgQuOQTsJBJzwOrHOMnPQDLslmOOvyk455BGOqkBl5AIxwSDkkmhyUI+XOY888cgg424KjkjkHIJ4+UUKS1vZ6K13a3RXsrpva3bXzRGDvG190721e2t9tujemy7uFsoDnDbseWi/f3YGEKhQWLng9ycbTnON42y6NaPDIcazexobllKg6baFSy2pY4IubhfLMyhsLEPLIySaj0pI7GB9cuVEkkTvBpNqyllnu1Ul7kxkbWgsdwJwOZSBwwyMmSaSeSSWaSSSW4dnaRidzuzAu7HBI5JIGCBwB0zTuopNt87ScUn8MXy+89N3qo7csdXe6ahqUnZaQi1zvbnkuVqCe3LFtOXeVlqk+ZCpO1QASFViSQQACQSD8wYjtnr8wYEbSXqwAkZlJV920/MAQNu0gY46AFSMnPXAzQjPhSQCi4JZTjIO0gEhQc88jpjkgfNjXsFhtVfVrseYLclbG22BvtV5tG0yKQQ9tagBp24y4RcHc2HGzfe71+0o/C29eqs/+D1qbcIt2d9VGMdHKTaSS9bx10VlpZaqZ4/7Es1OF/ti+iywAO7S9PdfL2uoCtHe3K4LFWDwxZGBvesA8YJUjgoADtzuKgH7+G9ePmJyQRjFSTXM9zNLcTM0stwXaV2LH94zDsBwowNirjYoUZK8U2OOSeaKBV3SOyInAyWynJG3hAAS4P3QMnbyRLmm4WVoqyirvVtq9+7la7bsldW0QU6coxbm23JOU32dkopK1+WKsklq1va7EJbIAGSrADap35JUHBAcu3zZA/iB3cNgnattEuSyy30kWmwBQ++5aPzZF+Q/LDlWyc7jvO7BJXcw2mvNdQ6c/kaZIss6Bkn1FI1YOx4ZLT5SqRIYyFmVFkcnIIAbOaZJZpHeaSWSXYWLS+ZLI4xgEl8kkgrzjOBheSDV+4m0/fe7SsouyWjdtdNLeTtdMzXtZpOKVNacsmm56uNmk7cuzavd3esVubUs1ha27QadvuJ5wY57140jSOEg74LZXXfnCkGXIfaXzyx2YuNvVRlwFUDAyCE5K7juIPXoehHHVN5AH95kI+UscZbkcADCg/KcDOQGIywpMsACwGTzkZy2Au7qnAAz6EEZGAWFR7S7V0krJRWqtrrtd3bs73b3v0NIUXFXu25NXlJpyekdVorrV2Ssl080+Xhfu7WB3ZU5XjJ+9jkYKleDg/3clAOSE4ymQzEEnAAX584JJAwRgsvyZLZFLubJxjBB525IA2nAwvygde4VlDDjNGWxznjOD9TgkYQgdQWOQNuSCMgU1KzT+V+trK2mt9VeWq0v2uWqbenS199U9E9972tpfvu9WDBUDawIJOWx1XbgDI4U8Bs8juC3BeduAG53egGVJ2kFyxAOcgjqRxjO0UHcWXALK2Mr82Ccp6qxAGRgnOM5ORwoeMggL3wDjAwvYqcfKfmHcgkbcGlzNOL6rS6S2Vkrvfs+65d3reuRO19Fv53sumqjt6La17NhVCRkghcA4xzgqpGT045PCh2+UYYDDUyzuGHAwwJ5LDKKMO55XsCFGMbXOVpQclOCTgNnJLM3GBnHUYORgjkc5U09MkHjaehGCpAHblSScscFgA3cejUrtX0s7t2tpo72eultXe+/oRyOK28tLaO8fRrr+XdjDgAc9DuxglgAEYhlGCMAZ5yAxz93o3cRjJ2rgOD8pJPyrzjOCSuMEgYA254qUA4O3BaQMMbSwGNpyFxgBck5xuBAwSgambshSSWOAWY5ypIXA+ZfkPBzjAwRtANLnXM9NLK2junouybWmiurtX6BZvo73fWy1s9Xsu97AmMHg4zjJJkAChSQMYzgY3E7SDxg8ESBVBVNy4wrBl44PGCTzkjkEDB6HnBEaglg2A2MHHGCoIyCcZ+Ug7Ofl6MCcqVd2XdgAA7lBbAxnbuGAoxjuevPUAmndK90ndKK1tdfK7vbV6u1t0Nxfu8t1Z8176J+61v1utdFdaW0BAQG28lycAAlRkLwV5A4Gdudw5IOMgKSCVAwGwCQVyPlAOD1UjAzkklQDsGM0gQx4U4KkblBbLHptXGDwOMHBwTkMcsCqhsMDkZDcYxhQTg9OAWKk7gNzYYYG4B8/vW0taK8nyW6p7N2V7aJa7CcGk20te3S7irtLstOvkroNp3gY2jjCkjLcggA5Oe5O3Ab+HBxgUqqlSVLKMnBw2CEGWJGSBzyAvbcFAyF7qARgNuyGAwPlGB8vOMYwcAkAjBzUTAId4XJcFTknDcj5sbcDaDhjxnAVvlJATkk4yslpZ3aXRdFo7NJu1tdRxU2pLe6Stpe9423122SelvIVioC44b5eSOchlwG3MDu7gZIK/KF5GXjnkZLHOVwFzyCSBnI2kZA5xjkYYAsAIVQoyXYMuM4BGzOF2Y6nkZ4KgK2N5p6ZBIAzlCOQMZJXe2ApyBxjJxnqw4ASqW1dmumltLJ+m6v9yWugcq7a6J2S62Tfqlt976MdggYBBIXcckBT0yoAKhOh5ViTwV4zTPlwDjGAGUkxjIwrAAkcDsgKgYPODgB6OwAAIDDOSeWIxzglcIOCflHBwRjJww7ieQQVIIwW4AJ9uME5IGFJ9WJNDlokktk3zSbfS/Kk7W7a2SbVluUodXurWtazUbPW6u7eem9tEA5JYcDnAxljjG84wCB2GCduTnGOUO0LnAQEHgjPAwCQTx8owDxgAfLk/LScZyCcdeTlu/HXqCOeTg8DPBpxxtIOc4JDEDkYyeMHkAY9+4PBMdt+y+9b3S1fXsk7dTW2mi02durdtFy38muib+RcvCWNqxAG6zgbjB9T8zJxkKASP4BgtnJBpfMAANpDfMAQGODt4LAjBzknJJJxjdyKu3JJW1LjcUs4VIIJChS2AcgBuhG7Hyn5Tg1SdWyerEYK9QNuQOhUgAlR1GCdpG09Kk7Sdk7qyWiataDvs7bqzS2vbdGVO3Ik7LordNflokur/UUg5OSGZgXyqgYPOAQAdoC88ZACZUY6Xbxm2WBZAN1lFtPUsqySKSSzFi4wFzgEAJuyMkUlLH5MnbkgqAGIB5Cjr3UcgZC9Bls1evy7LYEhfksogNsYUYE0mSTt5KkgCQ8DpxjJpOLjPWzag42t9mUX8l10tbpob67PfS12u6bs72s21azS2trcpnnjBwNvvjBGeM9e/tjcuScVLEGa4tl+Vd1xbldwCoMyJt3MQRjJ4wuMDLbiaj4XgE4ZjgDgDGCSAFOCAABzkN22nhyq3mxvzvEsRVlByRvQ5DgE8EfeGAMdCSKlNLkvouZaab3ira22sr6p31er0yknyyd01Zr7krfldf5kl8MX13gnAu5sdSv+tAADYAI6hSOMdFyMmDG4MWAAODjBAK8DgANkA8dsdfunBkuVkM9yCp3C4lZsgk8SEkksMktty3AGOQFOQY9zKAwGV4zkEZJBHXOeR/FgkZwRSlrJtL3rybtor3WiVna6Wivt6jhG1ODTs+WKtuultFe/TTrp2FjTE1uNwGZ4iOQuG8xM52g4G3A9hyMDNTXfltc3ZyPlmkIAbf5hDLuYSEtu+YYAK/OcEnIIqujHzY2BI2yoxPJwFKkE5BCFVXHpt3E55p1xn7RcEkkGeTLEHJG5gWJOCTnscDIzwRk3CaW63lqrbXSbSSs2+vS70JtKNW6W0G767c0bvpe/wCXcaMKNqgDkBsMfmwV+VcYIGMjOQVznB5WlwuCD0IAB45OVxyxCEA4BOCvA5JGaFckkMoPUgejep6Akck8dATz92lKnADD51ywJGdqkLxkrgqeeOBxn5TnOkZK27V9E9Olne99H1V731LXNbRK3XR6PS2qel3ZaPTXysnPHy8KmS2BnACgbmJ6ggHAXGBzjqAsB83GGxtJKkZO3AycjOTwuSB94FhjIzAndnovQ5PQg5OcHcuWAJxx97BHEXQMrHhcqoG4HAVSGJGMgYx8w5z8pUEk5uprtrZJO1lq4797O7VmlZ2a6hZ6W8nov8L+fR9u3W2jFcCOIwzBpLeRlMkS5LRyIrsksDAqglQtyQCsykq6lGO2CWIRSFBIsijlXQkb1ZV2khvnVyDiRSSAwI3H5WauSwUvnPDbzkHI2knOejZJAbOQQM9MmV2JZcZJZIznkAfKAwUcLszw3I+b60lNPlu1pJJWbd1az3fR2s371rW1eqcWndL1W60tr6Pr+Ow1dwIHDFgcjltpxnDDGMAepG7jDdcRQbhFEuNpChskY/HAbPzAtzyh7YIBMhYAsQTkK2cjcGbbngcAE9hglSAAPmAqOMs8MSgH5VTICkHCk/KduMcbeVwpHOATUzkvaRadlytu/rBXtZ/dZPo+o7aaXV2r699VtrfW6te3Qn4ZA7YAAPOcjI2jAzzw2BnGSMBwCBmbepsQShwL7KM6gnJtgMAlgSOmcLwCuSBuqtkhSAxbBzjAII5yM8E4ORkgbhndzjMxLfZFxvwLwkBfl2/uCRuwvY+pZD9wg7sioS0aet4tRWitH3X21++3RLoVG6Tlu2krvRLbV79Pwu2yMqCOhIycckAbdpxwMEDIDYGfXKk5QHbwAV3DIHRT93AIzjnqMZGcFTg4oWQ5bd82QQcA7VOQQcAjBHzY/iUnnIypa33dpz1JAI4wMEg9iAc5Ix6jAOBC6tp2e2t1ry6evyW+pK3SaTu13vrZ6X0vtqlftto18jaQQw8yI8AjHzr1446rwD0wVwoNaWo5OpX4GM/a58hf+uuOxLHI6EnJztbPfMcsCpUZXzITk7mBwytnoBng9OMZwvODoaiSNRv9pJ/0u5YN0X/WOOwYZHOTk55xkGrpyScltdwWt9G1omvkr69dSbN1kv8Ap3Naa2XNSSvZ6vTv0a12IAVPAYDG3ceQQcLkkFcjGDkg4PPG35gnO4gEnG0hjgBgNhwTzu6Eg8A8dCA1NQ4AIJC5BIySDgjjGMYBX5fQhQCRTsnuD3xwQcDaOm3OQO4PBJPPbSL01vdNJ+ekfe8/lp69drW9E0vO+jWl7LW93bbpqAIYEMCGGSoJ+8x2dWcDg8dRtAyzEMDgGV24AbKgE7SRkgZLDJ6j5wTh8g8soyplmIPJOQRwRwAAV5U54xxgKVGG5FNzgd/nxgYwNvHI4K8YYZ5ZSBjI6NO+z7L3rLVtW9LdErXd1fW4WVrK99L2dmvxa2X/AAdbt/PzBcbeM/L1AKZK4xkA4IOQAeCOmEO1gMcKuOuOGG3HQ4wABkZIzjGCSTHuO4gnkgkAdlwAdoORuwWBYdCSR1OV2jDZLD0wMdQNp4GfXd06AjDcETaiuu2rSbesfLW/6eYJWtb0el9bLe2zst+l732ugA5JIOPU9CSvPIB5KDjOAAMjd0duGTkEg4OSQBxt7ksenQ4POMjI4bkgAnktlQCe4I9TxgAng5HUntSnKj+LdwwIHGMY5OMjscnAOCDk4xTsrbPyu7OV4tX0Tto7fpq3Wz+Wva+m3Zt+vl15l7kBiw6gkAkDaDggc5yOR6+hyaU9s4GACrcE9BjlsYBye2QeRtOKQktggELggAg847noM87eu7AIJI3GkwQCGPGTgY5BBAyQc9TknjBBJOMg0lLS29ml5p6Xey011009dCelnZ+vWzW/nfprf7x2QCBtBPoMNnpzksCAOhbtgZAYA00nABJGCOg43dBgAA9eODluhB6ilf5VDEEgYGB1bHQZ2tycN+GeM8l9vArg3N3vS1t9oZFBVp5GX5La3Lqy+bJhi8jBvJh3sB0WSHOz5YtKV3o0kkkl7zsr2UddGtk73bBtRjfte0dLtvlsla7bbdtbK+ut7qS3t4sC/vB/o4YxwwBgsl5KuPkT0iT/AJepgeAREhBOQTTPPM87r88hVdqLhEQAKscSAkRxRrhURchV67gOY55pLiYTsqqAuyOGIbYoIVwFhhX+BE9yWd2LuWkZiWrgEjOccjO3HHPBPygccEdPlO4litSnF8qTd2022nrJOO6T62aSez89Woxd3KVnKSWiS9xOzSXW90rt7tW2VhW3NjG3ccMoYDAVtuOckfP1UkrwQuSDkNkJ8lgrIsp2lQR8wVSucBxzhSAOTj5RnGCAuXYEHhVG8DgnkZIHHAA6knuWOOAuxVkaTncy7RhmwACSNqgEH7o3FvvHOMDgu900k9dG/djfSFmlo7paOzSeytoX6j1YbA8a7wFCqFXBz1C5IYEknLcYPQHoaZ+8VUZDuYkFo3KhVzjd5bAqqsmDxkgHOMYBKRFmfYRgAEou0DP8Od2ACwwx+7jGenadsjJxnBycDAAGFY/dA6kjnjGRtIyA0lJJpyVlZd9bbq+nmvK9+7aS2vq7bt32fLvfS99fuTvZcYwOg3EDGBg8YxxwuATtJHUEjdxQq4JxyMYGOw+U9wOBwDyRzkHPFMySAcEkncuB8pHPGAMYHfjcMdSM4TzXZgVjJUKu8kHGDtHBwAu3oScfeBycVXPGyvbVq127vSOis9XbtdbtvVi1T28tXy22av3Wi10t02YpLoOgbkYC4BOMYDKV4bAJOQB745DDJGCQxG5yMDgEElAcAjGDnBOecZHC5V77zygYgbd20EBhhTggKMEEnlSQCcjjGFMUbAO6MxCEAHcoJGGb5UAUYJySDgqGGAOjcm2orTWL1Sd7NNpPvpr0Gr93rbfRW92zuvzXR6FW62NDKSPmRBtKkEZ4wc8b9wGCccjuMKTPHHEYUBDAokbZD4yAAQM8nBJUDC7c9QGBNQXQIikUKTnJxgnhsEEnbnKqu3OegXCjAK3IsukZYAjYuMgjgAAnkEEgNwScYHK5GaiMo+0dusYqz3eui0ettHdNX0dr7tSa2T0S3trout7JOy6rpa17CRplfMYLvchT8pJWMFduQRuViFLODk9ccc0S+X5Z3uEGPlJO0DO3YeBuJ+YnaGGRgrggVI4B3ADfkYRVJHJA7EAYGSCpB7lWH3agKbiBgjEbDHzMR1LMhYHIDPuA2bguSHGNjU5RUfNpJJXX8uvTS7u3ey6pA2ttel012SdtfeV07LV6uXYdDEGVHfoEAQtxzlSG+YE7WzuB3E7iWG4kmopOfNJZRsIA52fNlAGJbJDZ5DDHAyw6sLoxCiquXY/NubJ8x9o5II2hQQSVxhcDbtGaqyfOpI6nknGB8xwxICnDIGIBByCn90EC01GMFF2utej2Sa/8C2stVq9VG9PRKy85bNXsul1e91tovuIkXbIwA3l13sMEhc4LIpc8ZO0qoIBOCpG3ChJ8yMBtuVC7W+UEsVOcrlSCCSMAvlMdAN0beYu9Vy/WQjBZthCtt5Bx8oKkbSucbQDwHQKwiLHLOCf73zDAKIAVI7KWAUAjBDKVBGN17sb/AN690o2TT0Sb3eu79EtoX5W3el7rrdLXpb7upahi8oERsWHyuwdVI+UDAVjgDdwB8wAAOcscm8rBiDhtxIycAqBkEKwQkhlwGOWBJC8nO0VLctKpYxuhUHeGwWYkLyWVCRkg4JxkqFx0JtIrLgje2MOAASQo2OcDbkHAYBAOCcgMcAaKyjdbW3lfy1T8lZ697baKkla+iWl7pt393Vdn1Ts9bdFd/wD/2Q==";
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    let _defaultBaseGeminiUrl = void 0;
    let _defaultBaseVertexUrl = void 0;
    function getDefaultBaseUrls() {
      return {
        geminiUrl: _defaultBaseGeminiUrl,
        vertexUrl: _defaultBaseVertexUrl
      };
    }
    function getBaseUrl(httpOptions, vertexai, vertexBaseUrlFromEnv, geminiBaseUrlFromEnv) {
      var _a, _b;
      if (!(httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.baseUrl)) {
        const defaultBaseUrls = getDefaultBaseUrls();
        if (vertexai) {
          return (_a = defaultBaseUrls.vertexUrl) !== null && _a !== void 0 ? _a : vertexBaseUrlFromEnv;
        } else {
          return (_b = defaultBaseUrls.geminiUrl) !== null && _b !== void 0 ? _b : geminiBaseUrlFromEnv;
        }
      }
      return httpOptions.baseUrl;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    class BaseModule {
    }
    function formatMap(templateString, valueMap) {
      const regex = /\{([^}]+)\}/g;
      return templateString.replace(regex, (match, key) => {
        if (Object.prototype.hasOwnProperty.call(valueMap, key)) {
          const value = valueMap[key];
          return value !== void 0 && value !== null ? String(value) : "";
        } else {
          throw new Error(`Key '${key}' not found in valueMap.`);
        }
      });
    }
    function setValueByPath(data, keys, value) {
      for (let i = 0; i < keys.length - 1; i++) {
        const key = keys[i];
        if (key.endsWith("[]")) {
          const keyName = key.slice(0, -2);
          if (!(keyName in data)) {
            if (Array.isArray(value)) {
              data[keyName] = Array.from({ length: value.length }, () => ({}));
            } else {
              throw new Error(`Value must be a list given an array path ${key}`);
            }
          }
          if (Array.isArray(data[keyName])) {
            const arrayData = data[keyName];
            if (Array.isArray(value)) {
              for (let j = 0; j < arrayData.length; j++) {
                const entry = arrayData[j];
                setValueByPath(entry, keys.slice(i + 1), value[j]);
              }
            } else {
              for (const d of arrayData) {
                setValueByPath(d, keys.slice(i + 1), value);
              }
            }
          }
          return;
        } else if (key.endsWith("[0]")) {
          const keyName = key.slice(0, -3);
          if (!(keyName in data)) {
            data[keyName] = [{}];
          }
          const arrayData = data[keyName];
          setValueByPath(arrayData[0], keys.slice(i + 1), value);
          return;
        }
        if (!data[key] || typeof data[key] !== "object") {
          data[key] = {};
        }
        data = data[key];
      }
      const keyToSet = keys[keys.length - 1];
      const existingData = data[keyToSet];
      if (existingData !== void 0) {
        if (!value || typeof value === "object" && Object.keys(value).length === 0) {
          return;
        }
        if (value === existingData) {
          return;
        }
        if (typeof existingData === "object" && typeof value === "object" && existingData !== null && value !== null) {
          Object.assign(existingData, value);
        } else {
          throw new Error(`Cannot set value for an existing key. Key: ${keyToSet}`);
        }
      } else {
        if (keyToSet === "_self" && typeof value === "object" && value !== null && !Array.isArray(value)) {
          const valueAsRecord = value;
          Object.assign(data, valueAsRecord);
        } else {
          data[keyToSet] = value;
        }
      }
    }
    function getValueByPath(data, keys, defaultValue = void 0) {
      try {
        if (keys.length === 1 && keys[0] === "_self") {
          return data;
        }
        for (let i = 0; i < keys.length; i++) {
          if (typeof data !== "object" || data === null) {
            return defaultValue;
          }
          const key = keys[i];
          if (key.endsWith("[]")) {
            const keyName = key.slice(0, -2);
            if (keyName in data) {
              const arrayData = data[keyName];
              if (!Array.isArray(arrayData)) {
                return defaultValue;
              }
              return arrayData.map((d) => getValueByPath(d, keys.slice(i + 1), defaultValue));
            } else {
              return defaultValue;
            }
          } else {
            data = data[key];
          }
        }
        return data;
      } catch (error) {
        if (error instanceof TypeError) {
          return defaultValue;
        }
        throw error;
      }
    }
    function moveValueByPath(data, paths) {
      for (const [sourcePath, destPath] of Object.entries(paths)) {
        const sourceKeys = sourcePath.split(".");
        const destKeys = destPath.split(".");
        const excludeKeys = /* @__PURE__ */ new Set();
        let wildcardIdx = -1;
        for (let i = 0; i < sourceKeys.length; i++) {
          if (sourceKeys[i] === "*") {
            wildcardIdx = i;
            break;
          }
        }
        if (wildcardIdx !== -1 && destKeys.length > wildcardIdx) {
          for (let i = wildcardIdx; i < destKeys.length; i++) {
            const key = destKeys[i];
            if (key !== "*" && !key.endsWith("[]") && !key.endsWith("[0]")) {
              excludeKeys.add(key);
            }
          }
        }
        _moveValueRecursive(data, sourceKeys, destKeys, 0, excludeKeys);
      }
    }
    function _moveValueRecursive(data, sourceKeys, destKeys, keyIdx, excludeKeys) {
      if (keyIdx >= sourceKeys.length) {
        return;
      }
      if (typeof data !== "object" || data === null) {
        return;
      }
      const key = sourceKeys[keyIdx];
      if (key.endsWith("[]")) {
        const keyName = key.slice(0, -2);
        const dataRecord = data;
        if (keyName in dataRecord && Array.isArray(dataRecord[keyName])) {
          for (const item of dataRecord[keyName]) {
            _moveValueRecursive(item, sourceKeys, destKeys, keyIdx + 1, excludeKeys);
          }
        }
      } else if (key === "*") {
        if (typeof data === "object" && data !== null && !Array.isArray(data)) {
          const dataRecord = data;
          const keysToMove = Object.keys(dataRecord).filter((k) => !k.startsWith("_") && !excludeKeys.has(k));
          const valuesToMove = {};
          for (const k of keysToMove) {
            valuesToMove[k] = dataRecord[k];
          }
          for (const [k, v] of Object.entries(valuesToMove)) {
            const newDestKeys = [];
            for (const dk of destKeys.slice(keyIdx)) {
              if (dk === "*") {
                newDestKeys.push(k);
              } else {
                newDestKeys.push(dk);
              }
            }
            setValueByPath(dataRecord, newDestKeys, v);
          }
          for (const k of keysToMove) {
            delete dataRecord[k];
          }
        }
      } else {
        const dataRecord = data;
        if (key in dataRecord) {
          _moveValueRecursive(dataRecord[key], sourceKeys, destKeys, keyIdx + 1, excludeKeys);
        }
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function tBytes$1(fromBytes) {
      if (typeof fromBytes !== "string") {
        throw new Error("fromImageBytes must be a string");
      }
      return fromBytes;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function fetchPredictOperationParametersToVertex(fromObject) {
      const toObject = {};
      const fromOperationName = getValueByPath(fromObject, [
        "operationName"
      ]);
      if (fromOperationName != null) {
        setValueByPath(toObject, ["operationName"], fromOperationName);
      }
      const fromResourceName = getValueByPath(fromObject, ["resourceName"]);
      if (fromResourceName != null) {
        setValueByPath(toObject, ["_url", "resourceName"], fromResourceName);
      }
      return toObject;
    }
    function generateVideosOperationFromMldev$1(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromMetadata = getValueByPath(fromObject, ["metadata"]);
      if (fromMetadata != null) {
        setValueByPath(toObject, ["metadata"], fromMetadata);
      }
      const fromDone = getValueByPath(fromObject, ["done"]);
      if (fromDone != null) {
        setValueByPath(toObject, ["done"], fromDone);
      }
      const fromError = getValueByPath(fromObject, ["error"]);
      if (fromError != null) {
        setValueByPath(toObject, ["error"], fromError);
      }
      const fromResponse = getValueByPath(fromObject, [
        "response",
        "generateVideoResponse"
      ]);
      if (fromResponse != null) {
        setValueByPath(toObject, ["response"], generateVideosResponseFromMldev$1(fromResponse));
      }
      return toObject;
    }
    function generateVideosOperationFromVertex$1(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromMetadata = getValueByPath(fromObject, ["metadata"]);
      if (fromMetadata != null) {
        setValueByPath(toObject, ["metadata"], fromMetadata);
      }
      const fromDone = getValueByPath(fromObject, ["done"]);
      if (fromDone != null) {
        setValueByPath(toObject, ["done"], fromDone);
      }
      const fromError = getValueByPath(fromObject, ["error"]);
      if (fromError != null) {
        setValueByPath(toObject, ["error"], fromError);
      }
      const fromResponse = getValueByPath(fromObject, ["response"]);
      if (fromResponse != null) {
        setValueByPath(toObject, ["response"], generateVideosResponseFromVertex$1(fromResponse));
      }
      return toObject;
    }
    function generateVideosResponseFromMldev$1(fromObject) {
      const toObject = {};
      const fromGeneratedVideos = getValueByPath(fromObject, [
        "generatedSamples"
      ]);
      if (fromGeneratedVideos != null) {
        let transformedList = fromGeneratedVideos;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return generatedVideoFromMldev$1(item);
          });
        }
        setValueByPath(toObject, ["generatedVideos"], transformedList);
      }
      const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
        "raiMediaFilteredCount"
      ]);
      if (fromRaiMediaFilteredCount != null) {
        setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
      }
      const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
        "raiMediaFilteredReasons"
      ]);
      if (fromRaiMediaFilteredReasons != null) {
        setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
      }
      return toObject;
    }
    function generateVideosResponseFromVertex$1(fromObject) {
      const toObject = {};
      const fromGeneratedVideos = getValueByPath(fromObject, ["videos"]);
      if (fromGeneratedVideos != null) {
        let transformedList = fromGeneratedVideos;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return generatedVideoFromVertex$1(item);
          });
        }
        setValueByPath(toObject, ["generatedVideos"], transformedList);
      }
      const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
        "raiMediaFilteredCount"
      ]);
      if (fromRaiMediaFilteredCount != null) {
        setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
      }
      const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
        "raiMediaFilteredReasons"
      ]);
      if (fromRaiMediaFilteredReasons != null) {
        setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
      }
      return toObject;
    }
    function generatedVideoFromMldev$1(fromObject) {
      const toObject = {};
      const fromVideo = getValueByPath(fromObject, ["video"]);
      if (fromVideo != null) {
        setValueByPath(toObject, ["video"], videoFromMldev$1(fromVideo));
      }
      return toObject;
    }
    function generatedVideoFromVertex$1(fromObject) {
      const toObject = {};
      const fromVideo = getValueByPath(fromObject, ["_self"]);
      if (fromVideo != null) {
        setValueByPath(toObject, ["video"], videoFromVertex$1(fromVideo));
      }
      return toObject;
    }
    function getOperationParametersToMldev(fromObject) {
      const toObject = {};
      const fromOperationName = getValueByPath(fromObject, [
        "operationName"
      ]);
      if (fromOperationName != null) {
        setValueByPath(toObject, ["_url", "operationName"], fromOperationName);
      }
      return toObject;
    }
    function getOperationParametersToVertex(fromObject) {
      const toObject = {};
      const fromOperationName = getValueByPath(fromObject, [
        "operationName"
      ]);
      if (fromOperationName != null) {
        setValueByPath(toObject, ["_url", "operationName"], fromOperationName);
      }
      return toObject;
    }
    function importFileOperationFromMldev$1(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromMetadata = getValueByPath(fromObject, ["metadata"]);
      if (fromMetadata != null) {
        setValueByPath(toObject, ["metadata"], fromMetadata);
      }
      const fromDone = getValueByPath(fromObject, ["done"]);
      if (fromDone != null) {
        setValueByPath(toObject, ["done"], fromDone);
      }
      const fromError = getValueByPath(fromObject, ["error"]);
      if (fromError != null) {
        setValueByPath(toObject, ["error"], fromError);
      }
      const fromResponse = getValueByPath(fromObject, ["response"]);
      if (fromResponse != null) {
        setValueByPath(toObject, ["response"], importFileResponseFromMldev$1(fromResponse));
      }
      return toObject;
    }
    function importFileResponseFromMldev$1(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromParent = getValueByPath(fromObject, ["parent"]);
      if (fromParent != null) {
        setValueByPath(toObject, ["parent"], fromParent);
      }
      const fromDocumentName = getValueByPath(fromObject, ["documentName"]);
      if (fromDocumentName != null) {
        setValueByPath(toObject, ["documentName"], fromDocumentName);
      }
      return toObject;
    }
    function uploadToFileSearchStoreOperationFromMldev(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromMetadata = getValueByPath(fromObject, ["metadata"]);
      if (fromMetadata != null) {
        setValueByPath(toObject, ["metadata"], fromMetadata);
      }
      const fromDone = getValueByPath(fromObject, ["done"]);
      if (fromDone != null) {
        setValueByPath(toObject, ["done"], fromDone);
      }
      const fromError = getValueByPath(fromObject, ["error"]);
      if (fromError != null) {
        setValueByPath(toObject, ["error"], fromError);
      }
      const fromResponse = getValueByPath(fromObject, ["response"]);
      if (fromResponse != null) {
        setValueByPath(toObject, ["response"], uploadToFileSearchStoreResponseFromMldev(fromResponse));
      }
      return toObject;
    }
    function uploadToFileSearchStoreResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromParent = getValueByPath(fromObject, ["parent"]);
      if (fromParent != null) {
        setValueByPath(toObject, ["parent"], fromParent);
      }
      const fromDocumentName = getValueByPath(fromObject, ["documentName"]);
      if (fromDocumentName != null) {
        setValueByPath(toObject, ["documentName"], fromDocumentName);
      }
      return toObject;
    }
    function videoFromMldev$1(fromObject) {
      const toObject = {};
      const fromUri = getValueByPath(fromObject, ["uri"]);
      if (fromUri != null) {
        setValueByPath(toObject, ["uri"], fromUri);
      }
      const fromVideoBytes = getValueByPath(fromObject, ["encodedVideo"]);
      if (fromVideoBytes != null) {
        setValueByPath(toObject, ["videoBytes"], tBytes$1(fromVideoBytes));
      }
      const fromMimeType = getValueByPath(fromObject, ["encoding"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function videoFromVertex$1(fromObject) {
      const toObject = {};
      const fromUri = getValueByPath(fromObject, ["gcsUri"]);
      if (fromUri != null) {
        setValueByPath(toObject, ["uri"], fromUri);
      }
      const fromVideoBytes = getValueByPath(fromObject, [
        "bytesBase64Encoded"
      ]);
      if (fromVideoBytes != null) {
        setValueByPath(toObject, ["videoBytes"], tBytes$1(fromVideoBytes));
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    var Outcome;
    (function(Outcome2) {
      Outcome2["OUTCOME_UNSPECIFIED"] = "OUTCOME_UNSPECIFIED";
      Outcome2["OUTCOME_OK"] = "OUTCOME_OK";
      Outcome2["OUTCOME_FAILED"] = "OUTCOME_FAILED";
      Outcome2["OUTCOME_DEADLINE_EXCEEDED"] = "OUTCOME_DEADLINE_EXCEEDED";
    })(Outcome || (Outcome = {}));
    var Language;
    (function(Language2) {
      Language2["LANGUAGE_UNSPECIFIED"] = "LANGUAGE_UNSPECIFIED";
      Language2["PYTHON"] = "PYTHON";
    })(Language || (Language = {}));
    var FunctionResponseScheduling;
    (function(FunctionResponseScheduling2) {
      FunctionResponseScheduling2["SCHEDULING_UNSPECIFIED"] = "SCHEDULING_UNSPECIFIED";
      FunctionResponseScheduling2["SILENT"] = "SILENT";
      FunctionResponseScheduling2["WHEN_IDLE"] = "WHEN_IDLE";
      FunctionResponseScheduling2["INTERRUPT"] = "INTERRUPT";
    })(FunctionResponseScheduling || (FunctionResponseScheduling = {}));
    var Type;
    (function(Type2) {
      Type2["TYPE_UNSPECIFIED"] = "TYPE_UNSPECIFIED";
      Type2["STRING"] = "STRING";
      Type2["NUMBER"] = "NUMBER";
      Type2["INTEGER"] = "INTEGER";
      Type2["BOOLEAN"] = "BOOLEAN";
      Type2["ARRAY"] = "ARRAY";
      Type2["OBJECT"] = "OBJECT";
      Type2["NULL"] = "NULL";
    })(Type || (Type = {}));
    var Mode;
    (function(Mode2) {
      Mode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
      Mode2["MODE_DYNAMIC"] = "MODE_DYNAMIC";
    })(Mode || (Mode = {}));
    var ApiSpec;
    (function(ApiSpec2) {
      ApiSpec2["API_SPEC_UNSPECIFIED"] = "API_SPEC_UNSPECIFIED";
      ApiSpec2["SIMPLE_SEARCH"] = "SIMPLE_SEARCH";
      ApiSpec2["ELASTIC_SEARCH"] = "ELASTIC_SEARCH";
    })(ApiSpec || (ApiSpec = {}));
    var AuthType;
    (function(AuthType2) {
      AuthType2["AUTH_TYPE_UNSPECIFIED"] = "AUTH_TYPE_UNSPECIFIED";
      AuthType2["NO_AUTH"] = "NO_AUTH";
      AuthType2["API_KEY_AUTH"] = "API_KEY_AUTH";
      AuthType2["HTTP_BASIC_AUTH"] = "HTTP_BASIC_AUTH";
      AuthType2["GOOGLE_SERVICE_ACCOUNT_AUTH"] = "GOOGLE_SERVICE_ACCOUNT_AUTH";
      AuthType2["OAUTH"] = "OAUTH";
      AuthType2["OIDC_AUTH"] = "OIDC_AUTH";
    })(AuthType || (AuthType = {}));
    var HttpElementLocation;
    (function(HttpElementLocation2) {
      HttpElementLocation2["HTTP_IN_UNSPECIFIED"] = "HTTP_IN_UNSPECIFIED";
      HttpElementLocation2["HTTP_IN_QUERY"] = "HTTP_IN_QUERY";
      HttpElementLocation2["HTTP_IN_HEADER"] = "HTTP_IN_HEADER";
      HttpElementLocation2["HTTP_IN_PATH"] = "HTTP_IN_PATH";
      HttpElementLocation2["HTTP_IN_BODY"] = "HTTP_IN_BODY";
      HttpElementLocation2["HTTP_IN_COOKIE"] = "HTTP_IN_COOKIE";
    })(HttpElementLocation || (HttpElementLocation = {}));
    var PhishBlockThreshold;
    (function(PhishBlockThreshold2) {
      PhishBlockThreshold2["PHISH_BLOCK_THRESHOLD_UNSPECIFIED"] = "PHISH_BLOCK_THRESHOLD_UNSPECIFIED";
      PhishBlockThreshold2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
      PhishBlockThreshold2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
      PhishBlockThreshold2["BLOCK_HIGH_AND_ABOVE"] = "BLOCK_HIGH_AND_ABOVE";
      PhishBlockThreshold2["BLOCK_HIGHER_AND_ABOVE"] = "BLOCK_HIGHER_AND_ABOVE";
      PhishBlockThreshold2["BLOCK_VERY_HIGH_AND_ABOVE"] = "BLOCK_VERY_HIGH_AND_ABOVE";
      PhishBlockThreshold2["BLOCK_ONLY_EXTREMELY_HIGH"] = "BLOCK_ONLY_EXTREMELY_HIGH";
    })(PhishBlockThreshold || (PhishBlockThreshold = {}));
    var ThinkingLevel;
    (function(ThinkingLevel2) {
      ThinkingLevel2["THINKING_LEVEL_UNSPECIFIED"] = "THINKING_LEVEL_UNSPECIFIED";
      ThinkingLevel2["LOW"] = "LOW";
      ThinkingLevel2["HIGH"] = "HIGH";
    })(ThinkingLevel || (ThinkingLevel = {}));
    var HarmCategory;
    (function(HarmCategory2) {
      HarmCategory2["HARM_CATEGORY_UNSPECIFIED"] = "HARM_CATEGORY_UNSPECIFIED";
      HarmCategory2["HARM_CATEGORY_HARASSMENT"] = "HARM_CATEGORY_HARASSMENT";
      HarmCategory2["HARM_CATEGORY_HATE_SPEECH"] = "HARM_CATEGORY_HATE_SPEECH";
      HarmCategory2["HARM_CATEGORY_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_SEXUALLY_EXPLICIT";
      HarmCategory2["HARM_CATEGORY_DANGEROUS_CONTENT"] = "HARM_CATEGORY_DANGEROUS_CONTENT";
      HarmCategory2["HARM_CATEGORY_CIVIC_INTEGRITY"] = "HARM_CATEGORY_CIVIC_INTEGRITY";
      HarmCategory2["HARM_CATEGORY_IMAGE_HATE"] = "HARM_CATEGORY_IMAGE_HATE";
      HarmCategory2["HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT"] = "HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT";
      HarmCategory2["HARM_CATEGORY_IMAGE_HARASSMENT"] = "HARM_CATEGORY_IMAGE_HARASSMENT";
      HarmCategory2["HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT";
      HarmCategory2["HARM_CATEGORY_JAILBREAK"] = "HARM_CATEGORY_JAILBREAK";
    })(HarmCategory || (HarmCategory = {}));
    var HarmBlockMethod;
    (function(HarmBlockMethod2) {
      HarmBlockMethod2["HARM_BLOCK_METHOD_UNSPECIFIED"] = "HARM_BLOCK_METHOD_UNSPECIFIED";
      HarmBlockMethod2["SEVERITY"] = "SEVERITY";
      HarmBlockMethod2["PROBABILITY"] = "PROBABILITY";
    })(HarmBlockMethod || (HarmBlockMethod = {}));
    var HarmBlockThreshold;
    (function(HarmBlockThreshold2) {
      HarmBlockThreshold2["HARM_BLOCK_THRESHOLD_UNSPECIFIED"] = "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
      HarmBlockThreshold2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
      HarmBlockThreshold2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
      HarmBlockThreshold2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
      HarmBlockThreshold2["BLOCK_NONE"] = "BLOCK_NONE";
      HarmBlockThreshold2["OFF"] = "OFF";
    })(HarmBlockThreshold || (HarmBlockThreshold = {}));
    var FinishReason;
    (function(FinishReason2) {
      FinishReason2["FINISH_REASON_UNSPECIFIED"] = "FINISH_REASON_UNSPECIFIED";
      FinishReason2["STOP"] = "STOP";
      FinishReason2["MAX_TOKENS"] = "MAX_TOKENS";
      FinishReason2["SAFETY"] = "SAFETY";
      FinishReason2["RECITATION"] = "RECITATION";
      FinishReason2["LANGUAGE"] = "LANGUAGE";
      FinishReason2["OTHER"] = "OTHER";
      FinishReason2["BLOCKLIST"] = "BLOCKLIST";
      FinishReason2["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
      FinishReason2["SPII"] = "SPII";
      FinishReason2["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
      FinishReason2["IMAGE_SAFETY"] = "IMAGE_SAFETY";
      FinishReason2["UNEXPECTED_TOOL_CALL"] = "UNEXPECTED_TOOL_CALL";
      FinishReason2["IMAGE_PROHIBITED_CONTENT"] = "IMAGE_PROHIBITED_CONTENT";
      FinishReason2["NO_IMAGE"] = "NO_IMAGE";
    })(FinishReason || (FinishReason = {}));
    var HarmProbability;
    (function(HarmProbability2) {
      HarmProbability2["HARM_PROBABILITY_UNSPECIFIED"] = "HARM_PROBABILITY_UNSPECIFIED";
      HarmProbability2["NEGLIGIBLE"] = "NEGLIGIBLE";
      HarmProbability2["LOW"] = "LOW";
      HarmProbability2["MEDIUM"] = "MEDIUM";
      HarmProbability2["HIGH"] = "HIGH";
    })(HarmProbability || (HarmProbability = {}));
    var HarmSeverity;
    (function(HarmSeverity2) {
      HarmSeverity2["HARM_SEVERITY_UNSPECIFIED"] = "HARM_SEVERITY_UNSPECIFIED";
      HarmSeverity2["HARM_SEVERITY_NEGLIGIBLE"] = "HARM_SEVERITY_NEGLIGIBLE";
      HarmSeverity2["HARM_SEVERITY_LOW"] = "HARM_SEVERITY_LOW";
      HarmSeverity2["HARM_SEVERITY_MEDIUM"] = "HARM_SEVERITY_MEDIUM";
      HarmSeverity2["HARM_SEVERITY_HIGH"] = "HARM_SEVERITY_HIGH";
    })(HarmSeverity || (HarmSeverity = {}));
    var UrlRetrievalStatus;
    (function(UrlRetrievalStatus2) {
      UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_UNSPECIFIED"] = "URL_RETRIEVAL_STATUS_UNSPECIFIED";
      UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_SUCCESS"] = "URL_RETRIEVAL_STATUS_SUCCESS";
      UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_ERROR"] = "URL_RETRIEVAL_STATUS_ERROR";
      UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_PAYWALL"] = "URL_RETRIEVAL_STATUS_PAYWALL";
      UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_UNSAFE"] = "URL_RETRIEVAL_STATUS_UNSAFE";
    })(UrlRetrievalStatus || (UrlRetrievalStatus = {}));
    var BlockedReason;
    (function(BlockedReason2) {
      BlockedReason2["BLOCKED_REASON_UNSPECIFIED"] = "BLOCKED_REASON_UNSPECIFIED";
      BlockedReason2["SAFETY"] = "SAFETY";
      BlockedReason2["OTHER"] = "OTHER";
      BlockedReason2["BLOCKLIST"] = "BLOCKLIST";
      BlockedReason2["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
      BlockedReason2["IMAGE_SAFETY"] = "IMAGE_SAFETY";
      BlockedReason2["MODEL_ARMOR"] = "MODEL_ARMOR";
      BlockedReason2["JAILBREAK"] = "JAILBREAK";
    })(BlockedReason || (BlockedReason = {}));
    var TrafficType;
    (function(TrafficType2) {
      TrafficType2["TRAFFIC_TYPE_UNSPECIFIED"] = "TRAFFIC_TYPE_UNSPECIFIED";
      TrafficType2["ON_DEMAND"] = "ON_DEMAND";
      TrafficType2["PROVISIONED_THROUGHPUT"] = "PROVISIONED_THROUGHPUT";
    })(TrafficType || (TrafficType = {}));
    var Modality;
    (function(Modality2) {
      Modality2["MODALITY_UNSPECIFIED"] = "MODALITY_UNSPECIFIED";
      Modality2["TEXT"] = "TEXT";
      Modality2["IMAGE"] = "IMAGE";
      Modality2["AUDIO"] = "AUDIO";
    })(Modality || (Modality = {}));
    var MediaResolution;
    (function(MediaResolution2) {
      MediaResolution2["MEDIA_RESOLUTION_UNSPECIFIED"] = "MEDIA_RESOLUTION_UNSPECIFIED";
      MediaResolution2["MEDIA_RESOLUTION_LOW"] = "MEDIA_RESOLUTION_LOW";
      MediaResolution2["MEDIA_RESOLUTION_MEDIUM"] = "MEDIA_RESOLUTION_MEDIUM";
      MediaResolution2["MEDIA_RESOLUTION_HIGH"] = "MEDIA_RESOLUTION_HIGH";
    })(MediaResolution || (MediaResolution = {}));
    var TuningMode;
    (function(TuningMode2) {
      TuningMode2["TUNING_MODE_UNSPECIFIED"] = "TUNING_MODE_UNSPECIFIED";
      TuningMode2["TUNING_MODE_FULL"] = "TUNING_MODE_FULL";
      TuningMode2["TUNING_MODE_PEFT_ADAPTER"] = "TUNING_MODE_PEFT_ADAPTER";
    })(TuningMode || (TuningMode = {}));
    var AdapterSize;
    (function(AdapterSize2) {
      AdapterSize2["ADAPTER_SIZE_UNSPECIFIED"] = "ADAPTER_SIZE_UNSPECIFIED";
      AdapterSize2["ADAPTER_SIZE_ONE"] = "ADAPTER_SIZE_ONE";
      AdapterSize2["ADAPTER_SIZE_TWO"] = "ADAPTER_SIZE_TWO";
      AdapterSize2["ADAPTER_SIZE_FOUR"] = "ADAPTER_SIZE_FOUR";
      AdapterSize2["ADAPTER_SIZE_EIGHT"] = "ADAPTER_SIZE_EIGHT";
      AdapterSize2["ADAPTER_SIZE_SIXTEEN"] = "ADAPTER_SIZE_SIXTEEN";
      AdapterSize2["ADAPTER_SIZE_THIRTY_TWO"] = "ADAPTER_SIZE_THIRTY_TWO";
    })(AdapterSize || (AdapterSize = {}));
    var JobState;
    (function(JobState2) {
      JobState2["JOB_STATE_UNSPECIFIED"] = "JOB_STATE_UNSPECIFIED";
      JobState2["JOB_STATE_QUEUED"] = "JOB_STATE_QUEUED";
      JobState2["JOB_STATE_PENDING"] = "JOB_STATE_PENDING";
      JobState2["JOB_STATE_RUNNING"] = "JOB_STATE_RUNNING";
      JobState2["JOB_STATE_SUCCEEDED"] = "JOB_STATE_SUCCEEDED";
      JobState2["JOB_STATE_FAILED"] = "JOB_STATE_FAILED";
      JobState2["JOB_STATE_CANCELLING"] = "JOB_STATE_CANCELLING";
      JobState2["JOB_STATE_CANCELLED"] = "JOB_STATE_CANCELLED";
      JobState2["JOB_STATE_PAUSED"] = "JOB_STATE_PAUSED";
      JobState2["JOB_STATE_EXPIRED"] = "JOB_STATE_EXPIRED";
      JobState2["JOB_STATE_UPDATING"] = "JOB_STATE_UPDATING";
      JobState2["JOB_STATE_PARTIALLY_SUCCEEDED"] = "JOB_STATE_PARTIALLY_SUCCEEDED";
    })(JobState || (JobState = {}));
    var TuningTask;
    (function(TuningTask2) {
      TuningTask2["TUNING_TASK_UNSPECIFIED"] = "TUNING_TASK_UNSPECIFIED";
      TuningTask2["TUNING_TASK_I2V"] = "TUNING_TASK_I2V";
      TuningTask2["TUNING_TASK_T2V"] = "TUNING_TASK_T2V";
      TuningTask2["TUNING_TASK_R2V"] = "TUNING_TASK_R2V";
    })(TuningTask || (TuningTask = {}));
    var PartMediaResolutionLevel;
    (function(PartMediaResolutionLevel2) {
      PartMediaResolutionLevel2["MEDIA_RESOLUTION_UNSPECIFIED"] = "MEDIA_RESOLUTION_UNSPECIFIED";
      PartMediaResolutionLevel2["MEDIA_RESOLUTION_LOW"] = "MEDIA_RESOLUTION_LOW";
      PartMediaResolutionLevel2["MEDIA_RESOLUTION_MEDIUM"] = "MEDIA_RESOLUTION_MEDIUM";
      PartMediaResolutionLevel2["MEDIA_RESOLUTION_HIGH"] = "MEDIA_RESOLUTION_HIGH";
    })(PartMediaResolutionLevel || (PartMediaResolutionLevel = {}));
    var FeatureSelectionPreference;
    (function(FeatureSelectionPreference2) {
      FeatureSelectionPreference2["FEATURE_SELECTION_PREFERENCE_UNSPECIFIED"] = "FEATURE_SELECTION_PREFERENCE_UNSPECIFIED";
      FeatureSelectionPreference2["PRIORITIZE_QUALITY"] = "PRIORITIZE_QUALITY";
      FeatureSelectionPreference2["BALANCED"] = "BALANCED";
      FeatureSelectionPreference2["PRIORITIZE_COST"] = "PRIORITIZE_COST";
    })(FeatureSelectionPreference || (FeatureSelectionPreference = {}));
    var Behavior;
    (function(Behavior2) {
      Behavior2["UNSPECIFIED"] = "UNSPECIFIED";
      Behavior2["BLOCKING"] = "BLOCKING";
      Behavior2["NON_BLOCKING"] = "NON_BLOCKING";
    })(Behavior || (Behavior = {}));
    var DynamicRetrievalConfigMode;
    (function(DynamicRetrievalConfigMode2) {
      DynamicRetrievalConfigMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
      DynamicRetrievalConfigMode2["MODE_DYNAMIC"] = "MODE_DYNAMIC";
    })(DynamicRetrievalConfigMode || (DynamicRetrievalConfigMode = {}));
    var Environment;
    (function(Environment2) {
      Environment2["ENVIRONMENT_UNSPECIFIED"] = "ENVIRONMENT_UNSPECIFIED";
      Environment2["ENVIRONMENT_BROWSER"] = "ENVIRONMENT_BROWSER";
    })(Environment || (Environment = {}));
    var FunctionCallingConfigMode;
    (function(FunctionCallingConfigMode2) {
      FunctionCallingConfigMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
      FunctionCallingConfigMode2["AUTO"] = "AUTO";
      FunctionCallingConfigMode2["ANY"] = "ANY";
      FunctionCallingConfigMode2["NONE"] = "NONE";
      FunctionCallingConfigMode2["VALIDATED"] = "VALIDATED";
    })(FunctionCallingConfigMode || (FunctionCallingConfigMode = {}));
    var SafetyFilterLevel;
    (function(SafetyFilterLevel2) {
      SafetyFilterLevel2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
      SafetyFilterLevel2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
      SafetyFilterLevel2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
      SafetyFilterLevel2["BLOCK_NONE"] = "BLOCK_NONE";
    })(SafetyFilterLevel || (SafetyFilterLevel = {}));
    var PersonGeneration;
    (function(PersonGeneration2) {
      PersonGeneration2["DONT_ALLOW"] = "DONT_ALLOW";
      PersonGeneration2["ALLOW_ADULT"] = "ALLOW_ADULT";
      PersonGeneration2["ALLOW_ALL"] = "ALLOW_ALL";
    })(PersonGeneration || (PersonGeneration = {}));
    var ImagePromptLanguage;
    (function(ImagePromptLanguage2) {
      ImagePromptLanguage2["auto"] = "auto";
      ImagePromptLanguage2["en"] = "en";
      ImagePromptLanguage2["ja"] = "ja";
      ImagePromptLanguage2["ko"] = "ko";
      ImagePromptLanguage2["hi"] = "hi";
      ImagePromptLanguage2["zh"] = "zh";
      ImagePromptLanguage2["pt"] = "pt";
      ImagePromptLanguage2["es"] = "es";
    })(ImagePromptLanguage || (ImagePromptLanguage = {}));
    var MaskReferenceMode;
    (function(MaskReferenceMode2) {
      MaskReferenceMode2["MASK_MODE_DEFAULT"] = "MASK_MODE_DEFAULT";
      MaskReferenceMode2["MASK_MODE_USER_PROVIDED"] = "MASK_MODE_USER_PROVIDED";
      MaskReferenceMode2["MASK_MODE_BACKGROUND"] = "MASK_MODE_BACKGROUND";
      MaskReferenceMode2["MASK_MODE_FOREGROUND"] = "MASK_MODE_FOREGROUND";
      MaskReferenceMode2["MASK_MODE_SEMANTIC"] = "MASK_MODE_SEMANTIC";
    })(MaskReferenceMode || (MaskReferenceMode = {}));
    var ControlReferenceType;
    (function(ControlReferenceType2) {
      ControlReferenceType2["CONTROL_TYPE_DEFAULT"] = "CONTROL_TYPE_DEFAULT";
      ControlReferenceType2["CONTROL_TYPE_CANNY"] = "CONTROL_TYPE_CANNY";
      ControlReferenceType2["CONTROL_TYPE_SCRIBBLE"] = "CONTROL_TYPE_SCRIBBLE";
      ControlReferenceType2["CONTROL_TYPE_FACE_MESH"] = "CONTROL_TYPE_FACE_MESH";
    })(ControlReferenceType || (ControlReferenceType = {}));
    var SubjectReferenceType;
    (function(SubjectReferenceType2) {
      SubjectReferenceType2["SUBJECT_TYPE_DEFAULT"] = "SUBJECT_TYPE_DEFAULT";
      SubjectReferenceType2["SUBJECT_TYPE_PERSON"] = "SUBJECT_TYPE_PERSON";
      SubjectReferenceType2["SUBJECT_TYPE_ANIMAL"] = "SUBJECT_TYPE_ANIMAL";
      SubjectReferenceType2["SUBJECT_TYPE_PRODUCT"] = "SUBJECT_TYPE_PRODUCT";
    })(SubjectReferenceType || (SubjectReferenceType = {}));
    var EditMode;
    (function(EditMode2) {
      EditMode2["EDIT_MODE_DEFAULT"] = "EDIT_MODE_DEFAULT";
      EditMode2["EDIT_MODE_INPAINT_REMOVAL"] = "EDIT_MODE_INPAINT_REMOVAL";
      EditMode2["EDIT_MODE_INPAINT_INSERTION"] = "EDIT_MODE_INPAINT_INSERTION";
      EditMode2["EDIT_MODE_OUTPAINT"] = "EDIT_MODE_OUTPAINT";
      EditMode2["EDIT_MODE_CONTROLLED_EDITING"] = "EDIT_MODE_CONTROLLED_EDITING";
      EditMode2["EDIT_MODE_STYLE"] = "EDIT_MODE_STYLE";
      EditMode2["EDIT_MODE_BGSWAP"] = "EDIT_MODE_BGSWAP";
      EditMode2["EDIT_MODE_PRODUCT_IMAGE"] = "EDIT_MODE_PRODUCT_IMAGE";
    })(EditMode || (EditMode = {}));
    var SegmentMode;
    (function(SegmentMode2) {
      SegmentMode2["FOREGROUND"] = "FOREGROUND";
      SegmentMode2["BACKGROUND"] = "BACKGROUND";
      SegmentMode2["PROMPT"] = "PROMPT";
      SegmentMode2["SEMANTIC"] = "SEMANTIC";
      SegmentMode2["INTERACTIVE"] = "INTERACTIVE";
    })(SegmentMode || (SegmentMode = {}));
    var VideoGenerationReferenceType;
    (function(VideoGenerationReferenceType2) {
      VideoGenerationReferenceType2["ASSET"] = "ASSET";
      VideoGenerationReferenceType2["STYLE"] = "STYLE";
    })(VideoGenerationReferenceType || (VideoGenerationReferenceType = {}));
    var VideoGenerationMaskMode;
    (function(VideoGenerationMaskMode2) {
      VideoGenerationMaskMode2["INSERT"] = "INSERT";
      VideoGenerationMaskMode2["REMOVE"] = "REMOVE";
      VideoGenerationMaskMode2["REMOVE_STATIC"] = "REMOVE_STATIC";
      VideoGenerationMaskMode2["OUTPAINT"] = "OUTPAINT";
    })(VideoGenerationMaskMode || (VideoGenerationMaskMode = {}));
    var VideoCompressionQuality;
    (function(VideoCompressionQuality2) {
      VideoCompressionQuality2["OPTIMIZED"] = "OPTIMIZED";
      VideoCompressionQuality2["LOSSLESS"] = "LOSSLESS";
    })(VideoCompressionQuality || (VideoCompressionQuality = {}));
    var TuningMethod;
    (function(TuningMethod2) {
      TuningMethod2["SUPERVISED_FINE_TUNING"] = "SUPERVISED_FINE_TUNING";
      TuningMethod2["PREFERENCE_TUNING"] = "PREFERENCE_TUNING";
    })(TuningMethod || (TuningMethod = {}));
    var DocumentState;
    (function(DocumentState2) {
      DocumentState2["STATE_UNSPECIFIED"] = "STATE_UNSPECIFIED";
      DocumentState2["STATE_PENDING"] = "STATE_PENDING";
      DocumentState2["STATE_ACTIVE"] = "STATE_ACTIVE";
      DocumentState2["STATE_FAILED"] = "STATE_FAILED";
    })(DocumentState || (DocumentState = {}));
    var FileState;
    (function(FileState2) {
      FileState2["STATE_UNSPECIFIED"] = "STATE_UNSPECIFIED";
      FileState2["PROCESSING"] = "PROCESSING";
      FileState2["ACTIVE"] = "ACTIVE";
      FileState2["FAILED"] = "FAILED";
    })(FileState || (FileState = {}));
    var FileSource;
    (function(FileSource2) {
      FileSource2["SOURCE_UNSPECIFIED"] = "SOURCE_UNSPECIFIED";
      FileSource2["UPLOADED"] = "UPLOADED";
      FileSource2["GENERATED"] = "GENERATED";
    })(FileSource || (FileSource = {}));
    var TurnCompleteReason;
    (function(TurnCompleteReason2) {
      TurnCompleteReason2["TURN_COMPLETE_REASON_UNSPECIFIED"] = "TURN_COMPLETE_REASON_UNSPECIFIED";
      TurnCompleteReason2["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
      TurnCompleteReason2["RESPONSE_REJECTED"] = "RESPONSE_REJECTED";
      TurnCompleteReason2["NEED_MORE_INPUT"] = "NEED_MORE_INPUT";
    })(TurnCompleteReason || (TurnCompleteReason = {}));
    var MediaModality;
    (function(MediaModality2) {
      MediaModality2["MODALITY_UNSPECIFIED"] = "MODALITY_UNSPECIFIED";
      MediaModality2["TEXT"] = "TEXT";
      MediaModality2["IMAGE"] = "IMAGE";
      MediaModality2["VIDEO"] = "VIDEO";
      MediaModality2["AUDIO"] = "AUDIO";
      MediaModality2["DOCUMENT"] = "DOCUMENT";
    })(MediaModality || (MediaModality = {}));
    var StartSensitivity;
    (function(StartSensitivity2) {
      StartSensitivity2["START_SENSITIVITY_UNSPECIFIED"] = "START_SENSITIVITY_UNSPECIFIED";
      StartSensitivity2["START_SENSITIVITY_HIGH"] = "START_SENSITIVITY_HIGH";
      StartSensitivity2["START_SENSITIVITY_LOW"] = "START_SENSITIVITY_LOW";
    })(StartSensitivity || (StartSensitivity = {}));
    var EndSensitivity;
    (function(EndSensitivity2) {
      EndSensitivity2["END_SENSITIVITY_UNSPECIFIED"] = "END_SENSITIVITY_UNSPECIFIED";
      EndSensitivity2["END_SENSITIVITY_HIGH"] = "END_SENSITIVITY_HIGH";
      EndSensitivity2["END_SENSITIVITY_LOW"] = "END_SENSITIVITY_LOW";
    })(EndSensitivity || (EndSensitivity = {}));
    var ActivityHandling;
    (function(ActivityHandling2) {
      ActivityHandling2["ACTIVITY_HANDLING_UNSPECIFIED"] = "ACTIVITY_HANDLING_UNSPECIFIED";
      ActivityHandling2["START_OF_ACTIVITY_INTERRUPTS"] = "START_OF_ACTIVITY_INTERRUPTS";
      ActivityHandling2["NO_INTERRUPTION"] = "NO_INTERRUPTION";
    })(ActivityHandling || (ActivityHandling = {}));
    var TurnCoverage;
    (function(TurnCoverage2) {
      TurnCoverage2["TURN_COVERAGE_UNSPECIFIED"] = "TURN_COVERAGE_UNSPECIFIED";
      TurnCoverage2["TURN_INCLUDES_ONLY_ACTIVITY"] = "TURN_INCLUDES_ONLY_ACTIVITY";
      TurnCoverage2["TURN_INCLUDES_ALL_INPUT"] = "TURN_INCLUDES_ALL_INPUT";
    })(TurnCoverage || (TurnCoverage = {}));
    var Scale;
    (function(Scale2) {
      Scale2["SCALE_UNSPECIFIED"] = "SCALE_UNSPECIFIED";
      Scale2["C_MAJOR_A_MINOR"] = "C_MAJOR_A_MINOR";
      Scale2["D_FLAT_MAJOR_B_FLAT_MINOR"] = "D_FLAT_MAJOR_B_FLAT_MINOR";
      Scale2["D_MAJOR_B_MINOR"] = "D_MAJOR_B_MINOR";
      Scale2["E_FLAT_MAJOR_C_MINOR"] = "E_FLAT_MAJOR_C_MINOR";
      Scale2["E_MAJOR_D_FLAT_MINOR"] = "E_MAJOR_D_FLAT_MINOR";
      Scale2["F_MAJOR_D_MINOR"] = "F_MAJOR_D_MINOR";
      Scale2["G_FLAT_MAJOR_E_FLAT_MINOR"] = "G_FLAT_MAJOR_E_FLAT_MINOR";
      Scale2["G_MAJOR_E_MINOR"] = "G_MAJOR_E_MINOR";
      Scale2["A_FLAT_MAJOR_F_MINOR"] = "A_FLAT_MAJOR_F_MINOR";
      Scale2["A_MAJOR_G_FLAT_MINOR"] = "A_MAJOR_G_FLAT_MINOR";
      Scale2["B_FLAT_MAJOR_G_MINOR"] = "B_FLAT_MAJOR_G_MINOR";
      Scale2["B_MAJOR_A_FLAT_MINOR"] = "B_MAJOR_A_FLAT_MINOR";
    })(Scale || (Scale = {}));
    var MusicGenerationMode;
    (function(MusicGenerationMode2) {
      MusicGenerationMode2["MUSIC_GENERATION_MODE_UNSPECIFIED"] = "MUSIC_GENERATION_MODE_UNSPECIFIED";
      MusicGenerationMode2["QUALITY"] = "QUALITY";
      MusicGenerationMode2["DIVERSITY"] = "DIVERSITY";
      MusicGenerationMode2["VOCALIZATION"] = "VOCALIZATION";
    })(MusicGenerationMode || (MusicGenerationMode = {}));
    var LiveMusicPlaybackControl;
    (function(LiveMusicPlaybackControl2) {
      LiveMusicPlaybackControl2["PLAYBACK_CONTROL_UNSPECIFIED"] = "PLAYBACK_CONTROL_UNSPECIFIED";
      LiveMusicPlaybackControl2["PLAY"] = "PLAY";
      LiveMusicPlaybackControl2["PAUSE"] = "PAUSE";
      LiveMusicPlaybackControl2["STOP"] = "STOP";
      LiveMusicPlaybackControl2["RESET_CONTEXT"] = "RESET_CONTEXT";
    })(LiveMusicPlaybackControl || (LiveMusicPlaybackControl = {}));
    class HttpResponse {
      constructor(response) {
        const headers = {};
        for (const pair of response.headers.entries()) {
          headers[pair[0]] = pair[1];
        }
        this.headers = headers;
        this.responseInternal = response;
      }
      json() {
        return this.responseInternal.json();
      }
    }
    class GenerateContentResponse {
      /**
       * Returns the concatenation of all text parts from the first candidate in the response.
       *
       * @remarks
       * If there are multiple candidates in the response, the text from the first
       * one will be returned.
       * If there are non-text parts in the response, the concatenation of all text
       * parts will be returned, and a warning will be logged.
       * If there are thought parts in the response, the concatenation of all text
       * parts excluding the thought parts will be returned.
       *
       * @example
       * ```ts
       * const response = await ai.models.generateContent({
       *   model: 'gemini-2.0-flash',
       *   contents:
       *     'Why is the sky blue?',
       * });
       *
       * console.debug(response.text);
       * ```
       */
      get text() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
          return void 0;
        }
        if (this.candidates && this.candidates.length > 1) {
          console.warn("there are multiple candidates in the response, returning text from the first one.");
        }
        let text = "";
        let anyTextPartText = false;
        const nonTextParts = [];
        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {
          for (const [fieldName, fieldValue] of Object.entries(part)) {
            if (fieldName !== "text" && fieldName !== "thought" && fieldName !== "thoughtSignature" && (fieldValue !== null || fieldValue !== void 0)) {
              nonTextParts.push(fieldName);
            }
          }
          if (typeof part.text === "string") {
            if (typeof part.thought === "boolean" && part.thought) {
              continue;
            }
            anyTextPartText = true;
            text += part.text;
          }
        }
        if (nonTextParts.length > 0) {
          console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);
        }
        return anyTextPartText ? text : void 0;
      }
      /**
       * Returns the concatenation of all inline data parts from the first candidate
       * in the response.
       *
       * @remarks
       * If there are multiple candidates in the response, the inline data from the
       * first one will be returned. If there are non-inline data parts in the
       * response, the concatenation of all inline data parts will be returned, and
       * a warning will be logged.
       */
      get data() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
          return void 0;
        }
        if (this.candidates && this.candidates.length > 1) {
          console.warn("there are multiple candidates in the response, returning data from the first one.");
        }
        let data = "";
        const nonDataParts = [];
        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {
          for (const [fieldName, fieldValue] of Object.entries(part)) {
            if (fieldName !== "inlineData" && (fieldValue !== null || fieldValue !== void 0)) {
              nonDataParts.push(fieldName);
            }
          }
          if (part.inlineData && typeof part.inlineData.data === "string") {
            data += atob(part.inlineData.data);
          }
        }
        if (nonDataParts.length > 0) {
          console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);
        }
        return data.length > 0 ? btoa(data) : void 0;
      }
      /**
       * Returns the function calls from the first candidate in the response.
       *
       * @remarks
       * If there are multiple candidates in the response, the function calls from
       * the first one will be returned.
       * If there are no function calls in the response, undefined will be returned.
       *
       * @example
       * ```ts
       * const controlLightFunctionDeclaration: FunctionDeclaration = {
       *   name: 'controlLight',
       *   parameters: {
       *   type: Type.OBJECT,
       *   description: 'Set the brightness and color temperature of a room light.',
       *   properties: {
       *     brightness: {
       *       type: Type.NUMBER,
       *       description:
       *         'Light level from 0 to 100. Zero is off and 100 is full brightness.',
       *     },
       *     colorTemperature: {
       *       type: Type.STRING,
       *       description:
       *         'Color temperature of the light fixture which can be `daylight`, `cool` or `warm`.',
       *     },
       *   },
       *   required: ['brightness', 'colorTemperature'],
       *  };
       *  const response = await ai.models.generateContent({
       *     model: 'gemini-2.0-flash',
       *     contents: 'Dim the lights so the room feels cozy and warm.',
       *     config: {
       *       tools: [{functionDeclarations: [controlLightFunctionDeclaration]}],
       *       toolConfig: {
       *         functionCallingConfig: {
       *           mode: FunctionCallingConfigMode.ANY,
       *           allowedFunctionNames: ['controlLight'],
       *         },
       *       },
       *     },
       *   });
       *  console.debug(JSON.stringify(response.functionCalls));
       * ```
       */
      get functionCalls() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
          return void 0;
        }
        if (this.candidates && this.candidates.length > 1) {
          console.warn("there are multiple candidates in the response, returning function calls from the first one.");
        }
        const functionCalls = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.functionCall).map((part) => part.functionCall).filter((functionCall) => functionCall !== void 0);
        if ((functionCalls === null || functionCalls === void 0 ? void 0 : functionCalls.length) === 0) {
          return void 0;
        }
        return functionCalls;
      }
      /**
       * Returns the first executable code from the first candidate in the response.
       *
       * @remarks
       * If there are multiple candidates in the response, the executable code from
       * the first one will be returned.
       * If there are no executable code in the response, undefined will be
       * returned.
       *
       * @example
       * ```ts
       * const response = await ai.models.generateContent({
       *   model: 'gemini-2.0-flash',
       *   contents:
       *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'
       *   config: {
       *     tools: [{codeExecution: {}}],
       *   },
       * });
       *
       * console.debug(response.executableCode);
       * ```
       */
      get executableCode() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
          return void 0;
        }
        if (this.candidates && this.candidates.length > 1) {
          console.warn("there are multiple candidates in the response, returning executable code from the first one.");
        }
        const executableCode = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.executableCode).map((part) => part.executableCode).filter((executableCode2) => executableCode2 !== void 0);
        if ((executableCode === null || executableCode === void 0 ? void 0 : executableCode.length) === 0) {
          return void 0;
        }
        return (_j = executableCode === null || executableCode === void 0 ? void 0 : executableCode[0]) === null || _j === void 0 ? void 0 : _j.code;
      }
      /**
       * Returns the first code execution result from the first candidate in the response.
       *
       * @remarks
       * If there are multiple candidates in the response, the code execution result from
       * the first one will be returned.
       * If there are no code execution result in the response, undefined will be returned.
       *
       * @example
       * ```ts
       * const response = await ai.models.generateContent({
       *   model: 'gemini-2.0-flash',
       *   contents:
       *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'
       *   config: {
       *     tools: [{codeExecution: {}}],
       *   },
       * });
       *
       * console.debug(response.codeExecutionResult);
       * ```
       */
      get codeExecutionResult() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
          return void 0;
        }
        if (this.candidates && this.candidates.length > 1) {
          console.warn("there are multiple candidates in the response, returning code execution result from the first one.");
        }
        const codeExecutionResult = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.codeExecutionResult).map((part) => part.codeExecutionResult).filter((codeExecutionResult2) => codeExecutionResult2 !== void 0);
        if ((codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult.length) === 0) {
          return void 0;
        }
        return (_j = codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult[0]) === null || _j === void 0 ? void 0 : _j.output;
      }
    }
    class EmbedContentResponse {
    }
    class GenerateImagesResponse {
    }
    class EditImageResponse {
    }
    class UpscaleImageResponse {
    }
    class RecontextImageResponse {
    }
    class SegmentImageResponse {
    }
    class ListModelsResponse {
    }
    class DeleteModelResponse {
    }
    class CountTokensResponse {
    }
    class ComputeTokensResponse {
    }
    class GenerateVideosOperation {
      /**
       * Instantiates an Operation of the same type as the one being called with the fields set from the API response.
       * @internal
       */
      _fromAPIResponse({ apiResponse, _isVertexAI }) {
        const operation = new GenerateVideosOperation();
        let response;
        const op = apiResponse;
        if (_isVertexAI) {
          response = generateVideosOperationFromVertex$1(op);
        } else {
          response = generateVideosOperationFromMldev$1(op);
        }
        Object.assign(operation, response);
        return operation;
      }
    }
    class ListTuningJobsResponse {
    }
    class DeleteCachedContentResponse {
    }
    class ListCachedContentsResponse {
    }
    class ListDocumentsResponse {
    }
    class ListFileSearchStoresResponse {
    }
    class UploadToFileSearchStoreResumableResponse {
    }
    class ImportFileOperation {
      /**
       * Instantiates an Operation of the same type as the one being called with the fields set from the API response.
       * @internal
       */
      _fromAPIResponse({ apiResponse, _isVertexAI }) {
        const operation = new ImportFileOperation();
        const op = apiResponse;
        const response = importFileOperationFromMldev$1(op);
        Object.assign(operation, response);
        return operation;
      }
    }
    class ListFilesResponse {
    }
    class CreateFileResponse {
    }
    class DeleteFileResponse {
    }
    class ListBatchJobsResponse {
    }
    class LiveServerMessage {
      /**
       * Returns the concatenation of all text parts from the server content if present.
       *
       * @remarks
       * If there are non-text parts in the response, the concatenation of all text
       * parts will be returned, and a warning will be logged.
       */
      get text() {
        var _a, _b, _c;
        let text = "";
        let anyTextPartFound = false;
        const nonTextParts = [];
        for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {
          for (const [fieldName, fieldValue] of Object.entries(part)) {
            if (fieldName !== "text" && fieldName !== "thought" && fieldValue !== null) {
              nonTextParts.push(fieldName);
            }
          }
          if (typeof part.text === "string") {
            if (typeof part.thought === "boolean" && part.thought) {
              continue;
            }
            anyTextPartFound = true;
            text += part.text;
          }
        }
        if (nonTextParts.length > 0) {
          console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);
        }
        return anyTextPartFound ? text : void 0;
      }
      /**
       * Returns the concatenation of all inline data parts from the server content if present.
       *
       * @remarks
       * If there are non-inline data parts in the
       * response, the concatenation of all inline data parts will be returned, and
       * a warning will be logged.
       */
      get data() {
        var _a, _b, _c;
        let data = "";
        const nonDataParts = [];
        for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {
          for (const [fieldName, fieldValue] of Object.entries(part)) {
            if (fieldName !== "inlineData" && fieldValue !== null) {
              nonDataParts.push(fieldName);
            }
          }
          if (part.inlineData && typeof part.inlineData.data === "string") {
            data += atob(part.inlineData.data);
          }
        }
        if (nonDataParts.length > 0) {
          console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);
        }
        return data.length > 0 ? btoa(data) : void 0;
      }
    }
    class LiveMusicServerMessage {
      /**
       * Returns the first audio chunk from the server content, if present.
       *
       * @remarks
       * If there are no audio chunks in the response, undefined will be returned.
       */
      get audioChunk() {
        if (this.serverContent && this.serverContent.audioChunks && this.serverContent.audioChunks.length > 0) {
          return this.serverContent.audioChunks[0];
        }
        return void 0;
      }
    }
    class UploadToFileSearchStoreOperation {
      /**
       * Instantiates an Operation of the same type as the one being called with the fields set from the API response.
       * @internal
       */
      _fromAPIResponse({ apiResponse, _isVertexAI }) {
        const operation = new UploadToFileSearchStoreOperation();
        const op = apiResponse;
        const response = uploadToFileSearchStoreOperationFromMldev(op);
        Object.assign(operation, response);
        return operation;
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function tModel(apiClient, model) {
      if (!model || typeof model !== "string") {
        throw new Error("model is required and must be a string");
      }
      if (model.includes("..") || model.includes("?") || model.includes("&")) {
        throw new Error("invalid model parameter");
      }
      if (apiClient.isVertexAI()) {
        if (model.startsWith("publishers/") || model.startsWith("projects/") || model.startsWith("models/")) {
          return model;
        } else if (model.indexOf("/") >= 0) {
          const parts = model.split("/", 2);
          return `publishers/${parts[0]}/models/${parts[1]}`;
        } else {
          return `publishers/google/models/${model}`;
        }
      } else {
        if (model.startsWith("models/") || model.startsWith("tunedModels/")) {
          return model;
        } else {
          return `models/${model}`;
        }
      }
    }
    function tCachesModel(apiClient, model) {
      const transformedModel = tModel(apiClient, model);
      if (!transformedModel) {
        return "";
      }
      if (transformedModel.startsWith("publishers/") && apiClient.isVertexAI()) {
        return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/${transformedModel}`;
      } else if (transformedModel.startsWith("models/") && apiClient.isVertexAI()) {
        return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/publishers/google/${transformedModel}`;
      } else {
        return transformedModel;
      }
    }
    function tBlobs(blobs) {
      if (Array.isArray(blobs)) {
        return blobs.map((blob) => tBlob(blob));
      } else {
        return [tBlob(blobs)];
      }
    }
    function tBlob(blob) {
      if (typeof blob === "object" && blob !== null) {
        return blob;
      }
      throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof blob}`);
    }
    function tImageBlob(blob) {
      const transformedBlob = tBlob(blob);
      if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith("image/")) {
        return transformedBlob;
      }
      throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);
    }
    function tAudioBlob(blob) {
      const transformedBlob = tBlob(blob);
      if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith("audio/")) {
        return transformedBlob;
      }
      throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);
    }
    function tPart(origin) {
      if (origin === null || origin === void 0) {
        throw new Error("PartUnion is required");
      }
      if (typeof origin === "object") {
        return origin;
      }
      if (typeof origin === "string") {
        return { text: origin };
      }
      throw new Error(`Unsupported part type: ${typeof origin}`);
    }
    function tParts(origin) {
      if (origin === null || origin === void 0 || Array.isArray(origin) && origin.length === 0) {
        throw new Error("PartListUnion is required");
      }
      if (Array.isArray(origin)) {
        return origin.map((item) => tPart(item));
      }
      return [tPart(origin)];
    }
    function _isContent(origin) {
      return origin !== null && origin !== void 0 && typeof origin === "object" && "parts" in origin && Array.isArray(origin.parts);
    }
    function _isFunctionCallPart(origin) {
      return origin !== null && origin !== void 0 && typeof origin === "object" && "functionCall" in origin;
    }
    function _isFunctionResponsePart(origin) {
      return origin !== null && origin !== void 0 && typeof origin === "object" && "functionResponse" in origin;
    }
    function tContent(origin) {
      if (origin === null || origin === void 0) {
        throw new Error("ContentUnion is required");
      }
      if (_isContent(origin)) {
        return origin;
      }
      return {
        role: "user",
        parts: tParts(origin)
      };
    }
    function tContentsForEmbed(apiClient, origin) {
      if (!origin) {
        return [];
      }
      if (apiClient.isVertexAI() && Array.isArray(origin)) {
        return origin.flatMap((item) => {
          const content = tContent(item);
          if (content.parts && content.parts.length > 0 && content.parts[0].text !== void 0) {
            return [content.parts[0].text];
          }
          return [];
        });
      } else if (apiClient.isVertexAI()) {
        const content = tContent(origin);
        if (content.parts && content.parts.length > 0 && content.parts[0].text !== void 0) {
          return [content.parts[0].text];
        }
        return [];
      }
      if (Array.isArray(origin)) {
        return origin.map((item) => tContent(item));
      }
      return [tContent(origin)];
    }
    function tContents(origin) {
      if (origin === null || origin === void 0 || Array.isArray(origin) && origin.length === 0) {
        throw new Error("contents are required");
      }
      if (!Array.isArray(origin)) {
        if (_isFunctionCallPart(origin) || _isFunctionResponsePart(origin)) {
          throw new Error("To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them");
        }
        return [tContent(origin)];
      }
      const result = [];
      const accumulatedParts = [];
      const isContentArray = _isContent(origin[0]);
      for (const item of origin) {
        const isContent = _isContent(item);
        if (isContent != isContentArray) {
          throw new Error("Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them");
        }
        if (isContent) {
          result.push(item);
        } else if (_isFunctionCallPart(item) || _isFunctionResponsePart(item)) {
          throw new Error("To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them");
        } else {
          accumulatedParts.push(item);
        }
      }
      if (!isContentArray) {
        result.push({ role: "user", parts: tParts(accumulatedParts) });
      }
      return result;
    }
    function flattenTypeArrayToAnyOf(typeList, resultingSchema) {
      if (typeList.includes("null")) {
        resultingSchema["nullable"] = true;
      }
      const listWithoutNull = typeList.filter((type) => type !== "null");
      if (listWithoutNull.length === 1) {
        resultingSchema["type"] = Object.values(Type).includes(listWithoutNull[0].toUpperCase()) ? listWithoutNull[0].toUpperCase() : Type.TYPE_UNSPECIFIED;
      } else {
        resultingSchema["anyOf"] = [];
        for (const i of listWithoutNull) {
          resultingSchema["anyOf"].push({
            "type": Object.values(Type).includes(i.toUpperCase()) ? i.toUpperCase() : Type.TYPE_UNSPECIFIED
          });
        }
      }
    }
    function processJsonSchema(_jsonSchema) {
      const genAISchema = {};
      const schemaFieldNames = ["items"];
      const listSchemaFieldNames = ["anyOf"];
      const dictSchemaFieldNames = ["properties"];
      if (_jsonSchema["type"] && _jsonSchema["anyOf"]) {
        throw new Error("type and anyOf cannot be both populated.");
      }
      const incomingAnyOf = _jsonSchema["anyOf"];
      if (incomingAnyOf != null && incomingAnyOf.length == 2) {
        if (incomingAnyOf[0]["type"] === "null") {
          genAISchema["nullable"] = true;
          _jsonSchema = incomingAnyOf[1];
        } else if (incomingAnyOf[1]["type"] === "null") {
          genAISchema["nullable"] = true;
          _jsonSchema = incomingAnyOf[0];
        }
      }
      if (_jsonSchema["type"] instanceof Array) {
        flattenTypeArrayToAnyOf(_jsonSchema["type"], genAISchema);
      }
      for (const [fieldName, fieldValue] of Object.entries(_jsonSchema)) {
        if (fieldValue == null) {
          continue;
        }
        if (fieldName == "type") {
          if (fieldValue === "null") {
            throw new Error("type: null can not be the only possible type for the field.");
          }
          if (fieldValue instanceof Array) {
            continue;
          }
          genAISchema["type"] = Object.values(Type).includes(fieldValue.toUpperCase()) ? fieldValue.toUpperCase() : Type.TYPE_UNSPECIFIED;
        } else if (schemaFieldNames.includes(fieldName)) {
          genAISchema[fieldName] = processJsonSchema(fieldValue);
        } else if (listSchemaFieldNames.includes(fieldName)) {
          const listSchemaFieldValue = [];
          for (const item of fieldValue) {
            if (item["type"] == "null") {
              genAISchema["nullable"] = true;
              continue;
            }
            listSchemaFieldValue.push(processJsonSchema(item));
          }
          genAISchema[fieldName] = listSchemaFieldValue;
        } else if (dictSchemaFieldNames.includes(fieldName)) {
          const dictSchemaFieldValue = {};
          for (const [key, value] of Object.entries(fieldValue)) {
            dictSchemaFieldValue[key] = processJsonSchema(value);
          }
          genAISchema[fieldName] = dictSchemaFieldValue;
        } else {
          if (fieldName === "additionalProperties") {
            continue;
          }
          genAISchema[fieldName] = fieldValue;
        }
      }
      return genAISchema;
    }
    function tSchema(schema) {
      return processJsonSchema(schema);
    }
    function tSpeechConfig(speechConfig) {
      if (typeof speechConfig === "object") {
        return speechConfig;
      } else if (typeof speechConfig === "string") {
        return {
          voiceConfig: {
            prebuiltVoiceConfig: {
              voiceName: speechConfig
            }
          }
        };
      } else {
        throw new Error(`Unsupported speechConfig type: ${typeof speechConfig}`);
      }
    }
    function tLiveSpeechConfig(speechConfig) {
      if ("multiSpeakerVoiceConfig" in speechConfig) {
        throw new Error("multiSpeakerVoiceConfig is not supported in the live API.");
      }
      return speechConfig;
    }
    function tTool(tool) {
      if (tool.functionDeclarations) {
        for (const functionDeclaration of tool.functionDeclarations) {
          if (functionDeclaration.parameters) {
            if (!Object.keys(functionDeclaration.parameters).includes("$schema")) {
              functionDeclaration.parameters = processJsonSchema(functionDeclaration.parameters);
            } else {
              if (!functionDeclaration.parametersJsonSchema) {
                functionDeclaration.parametersJsonSchema = functionDeclaration.parameters;
                delete functionDeclaration.parameters;
              }
            }
          }
          if (functionDeclaration.response) {
            if (!Object.keys(functionDeclaration.response).includes("$schema")) {
              functionDeclaration.response = processJsonSchema(functionDeclaration.response);
            } else {
              if (!functionDeclaration.responseJsonSchema) {
                functionDeclaration.responseJsonSchema = functionDeclaration.response;
                delete functionDeclaration.response;
              }
            }
          }
        }
      }
      return tool;
    }
    function tTools(tools) {
      if (tools === void 0 || tools === null) {
        throw new Error("tools is required");
      }
      if (!Array.isArray(tools)) {
        throw new Error("tools is required and must be an array of Tools");
      }
      const result = [];
      for (const tool of tools) {
        result.push(tool);
      }
      return result;
    }
    function resourceName(client2, resourceName2, resourcePrefix, splitsAfterPrefix = 1) {
      const shouldAppendPrefix = !resourceName2.startsWith(`${resourcePrefix}/`) && resourceName2.split("/").length === splitsAfterPrefix;
      if (client2.isVertexAI()) {
        if (resourceName2.startsWith("projects/")) {
          return resourceName2;
        } else if (resourceName2.startsWith("locations/")) {
          return `projects/${client2.getProject()}/${resourceName2}`;
        } else if (resourceName2.startsWith(`${resourcePrefix}/`)) {
          return `projects/${client2.getProject()}/locations/${client2.getLocation()}/${resourceName2}`;
        } else if (shouldAppendPrefix) {
          return `projects/${client2.getProject()}/locations/${client2.getLocation()}/${resourcePrefix}/${resourceName2}`;
        } else {
          return resourceName2;
        }
      }
      if (shouldAppendPrefix) {
        return `${resourcePrefix}/${resourceName2}`;
      }
      return resourceName2;
    }
    function tCachedContentName(apiClient, name) {
      if (typeof name !== "string") {
        throw new Error("name must be a string");
      }
      return resourceName(apiClient, name, "cachedContents");
    }
    function tTuningJobStatus(status) {
      switch (status) {
        case "STATE_UNSPECIFIED":
          return "JOB_STATE_UNSPECIFIED";
        case "CREATING":
          return "JOB_STATE_RUNNING";
        case "ACTIVE":
          return "JOB_STATE_SUCCEEDED";
        case "FAILED":
          return "JOB_STATE_FAILED";
        default:
          return status;
      }
    }
    function tBytes(fromImageBytes) {
      return tBytes$1(fromImageBytes);
    }
    function _isFile(origin) {
      return origin !== null && origin !== void 0 && typeof origin === "object" && "name" in origin;
    }
    function isGeneratedVideo(origin) {
      return origin !== null && origin !== void 0 && typeof origin === "object" && "video" in origin;
    }
    function isVideo(origin) {
      return origin !== null && origin !== void 0 && typeof origin === "object" && "uri" in origin;
    }
    function tFileName(fromName) {
      var _a;
      let name;
      if (_isFile(fromName)) {
        name = fromName.name;
      }
      if (isVideo(fromName)) {
        name = fromName.uri;
        if (name === void 0) {
          return void 0;
        }
      }
      if (isGeneratedVideo(fromName)) {
        name = (_a = fromName.video) === null || _a === void 0 ? void 0 : _a.uri;
        if (name === void 0) {
          return void 0;
        }
      }
      if (typeof fromName === "string") {
        name = fromName;
      }
      if (name === void 0) {
        throw new Error("Could not extract file name from the provided input.");
      }
      if (name.startsWith("https://")) {
        const suffix = name.split("files/")[1];
        const match = suffix.match(/[a-z0-9]+/);
        if (match === null) {
          throw new Error(`Could not extract file name from URI ${name}`);
        }
        name = match[0];
      } else if (name.startsWith("files/")) {
        name = name.split("files/")[1];
      }
      return name;
    }
    function tModelsUrl(apiClient, baseModels) {
      let res;
      if (apiClient.isVertexAI()) {
        res = baseModels ? "publishers/google/models" : "models";
      } else {
        res = baseModels ? "models" : "tunedModels";
      }
      return res;
    }
    function tExtractModels(response) {
      for (const key of ["models", "tunedModels", "publisherModels"]) {
        if (hasField(response, key)) {
          return response[key];
        }
      }
      return [];
    }
    function hasField(data, fieldName) {
      return data !== null && typeof data === "object" && fieldName in data;
    }
    function mcpToGeminiTool(mcpTool, config = {}) {
      const mcpToolSchema = mcpTool;
      const functionDeclaration = {
        name: mcpToolSchema["name"],
        description: mcpToolSchema["description"],
        parametersJsonSchema: mcpToolSchema["inputSchema"]
      };
      if (mcpToolSchema["outputSchema"]) {
        functionDeclaration["responseJsonSchema"] = mcpToolSchema["outputSchema"];
      }
      if (config.behavior) {
        functionDeclaration["behavior"] = config.behavior;
      }
      const geminiTool = {
        functionDeclarations: [
          functionDeclaration
        ]
      };
      return geminiTool;
    }
    function mcpToolsToGeminiTool(mcpTools, config = {}) {
      const functionDeclarations = [];
      const toolNames = /* @__PURE__ */ new Set();
      for (const mcpTool of mcpTools) {
        const mcpToolName = mcpTool.name;
        if (toolNames.has(mcpToolName)) {
          throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);
        }
        toolNames.add(mcpToolName);
        const geminiTool = mcpToGeminiTool(mcpTool, config);
        if (geminiTool.functionDeclarations) {
          functionDeclarations.push(...geminiTool.functionDeclarations);
        }
      }
      return { functionDeclarations };
    }
    function tBatchJobSource(client2, src) {
      let sourceObj;
      if (typeof src === "string") {
        if (client2.isVertexAI()) {
          if (src.startsWith("gs://")) {
            sourceObj = { format: "jsonl", gcsUri: [src] };
          } else if (src.startsWith("bq://")) {
            sourceObj = { format: "bigquery", bigqueryUri: src };
          } else {
            throw new Error(`Unsupported string source for Vertex AI: ${src}`);
          }
        } else {
          if (src.startsWith("files/")) {
            sourceObj = { fileName: src };
          } else {
            throw new Error(`Unsupported string source for Gemini API: ${src}`);
          }
        }
      } else if (Array.isArray(src)) {
        if (client2.isVertexAI()) {
          throw new Error("InlinedRequest[] is not supported in Vertex AI.");
        }
        sourceObj = { inlinedRequests: src };
      } else {
        sourceObj = src;
      }
      const vertexSourcesCount = [sourceObj.gcsUri, sourceObj.bigqueryUri].filter(Boolean).length;
      const mldevSourcesCount = [
        sourceObj.inlinedRequests,
        sourceObj.fileName
      ].filter(Boolean).length;
      if (client2.isVertexAI()) {
        if (mldevSourcesCount > 0 || vertexSourcesCount !== 1) {
          throw new Error("Exactly one of `gcsUri` or `bigqueryUri` must be set for Vertex AI.");
        }
      } else {
        if (vertexSourcesCount > 0 || mldevSourcesCount !== 1) {
          throw new Error("Exactly one of `inlinedRequests`, `fileName`, must be set for Gemini API.");
        }
      }
      return sourceObj;
    }
    function tBatchJobDestination(dest) {
      if (typeof dest !== "string") {
        return dest;
      }
      const destString = dest;
      if (destString.startsWith("gs://")) {
        return {
          format: "jsonl",
          gcsUri: destString
        };
      } else if (destString.startsWith("bq://")) {
        return {
          format: "bigquery",
          bigqueryUri: destString
        };
      } else {
        throw new Error(`Unsupported destination: ${destString}`);
      }
    }
    function tRecvBatchJobDestination(dest) {
      if (typeof dest !== "object" || dest === null) {
        return {};
      }
      const obj = dest;
      const inlineResponsesVal = obj["inlinedResponses"];
      if (typeof inlineResponsesVal !== "object" || inlineResponsesVal === null) {
        return dest;
      }
      const inlineResponsesObj = inlineResponsesVal;
      const responsesArray = inlineResponsesObj["inlinedResponses"];
      if (!Array.isArray(responsesArray) || responsesArray.length === 0) {
        return dest;
      }
      let hasEmbedding = false;
      for (const responseItem of responsesArray) {
        if (typeof responseItem !== "object" || responseItem === null) {
          continue;
        }
        const responseItemObj = responseItem;
        const responseVal = responseItemObj["response"];
        if (typeof responseVal !== "object" || responseVal === null) {
          continue;
        }
        const responseObj = responseVal;
        if (responseObj["embedding"] !== void 0) {
          hasEmbedding = true;
          break;
        }
      }
      if (hasEmbedding) {
        obj["inlinedEmbedContentResponses"] = obj["inlinedResponses"];
        delete obj["inlinedResponses"];
      }
      return dest;
    }
    function tBatchJobName(apiClient, name) {
      const nameString = name;
      if (!apiClient.isVertexAI()) {
        const mldevPattern = /batches\/[^/]+$/;
        if (mldevPattern.test(nameString)) {
          return nameString.split("/").pop();
        } else {
          throw new Error(`Invalid batch job name: ${nameString}.`);
        }
      }
      const vertexPattern = /^projects\/[^/]+\/locations\/[^/]+\/batchPredictionJobs\/[^/]+$/;
      if (vertexPattern.test(nameString)) {
        return nameString.split("/").pop();
      } else if (/^\d+$/.test(nameString)) {
        return nameString;
      } else {
        throw new Error(`Invalid batch job name: ${nameString}.`);
      }
    }
    function tJobState(state) {
      const stateString = state;
      if (stateString === "BATCH_STATE_UNSPECIFIED") {
        return "JOB_STATE_UNSPECIFIED";
      } else if (stateString === "BATCH_STATE_PENDING") {
        return "JOB_STATE_PENDING";
      } else if (stateString === "BATCH_STATE_RUNNING") {
        return "JOB_STATE_RUNNING";
      } else if (stateString === "BATCH_STATE_SUCCEEDED") {
        return "JOB_STATE_SUCCEEDED";
      } else if (stateString === "BATCH_STATE_FAILED") {
        return "JOB_STATE_FAILED";
      } else if (stateString === "BATCH_STATE_CANCELLED") {
        return "JOB_STATE_CANCELLED";
      } else if (stateString === "BATCH_STATE_EXPIRED") {
        return "JOB_STATE_EXPIRED";
      } else {
        return stateString;
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function batchJobDestinationFromMldev(fromObject) {
      const toObject = {};
      const fromFileName = getValueByPath(fromObject, ["responsesFile"]);
      if (fromFileName != null) {
        setValueByPath(toObject, ["fileName"], fromFileName);
      }
      const fromInlinedResponses = getValueByPath(fromObject, [
        "inlinedResponses",
        "inlinedResponses"
      ]);
      if (fromInlinedResponses != null) {
        let transformedList = fromInlinedResponses;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return inlinedResponseFromMldev(item);
          });
        }
        setValueByPath(toObject, ["inlinedResponses"], transformedList);
      }
      const fromInlinedEmbedContentResponses = getValueByPath(fromObject, [
        "inlinedEmbedContentResponses",
        "inlinedResponses"
      ]);
      if (fromInlinedEmbedContentResponses != null) {
        let transformedList = fromInlinedEmbedContentResponses;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["inlinedEmbedContentResponses"], transformedList);
      }
      return toObject;
    }
    function batchJobDestinationFromVertex(fromObject) {
      const toObject = {};
      const fromFormat = getValueByPath(fromObject, ["predictionsFormat"]);
      if (fromFormat != null) {
        setValueByPath(toObject, ["format"], fromFormat);
      }
      const fromGcsUri = getValueByPath(fromObject, [
        "gcsDestination",
        "outputUriPrefix"
      ]);
      if (fromGcsUri != null) {
        setValueByPath(toObject, ["gcsUri"], fromGcsUri);
      }
      const fromBigqueryUri = getValueByPath(fromObject, [
        "bigqueryDestination",
        "outputUri"
      ]);
      if (fromBigqueryUri != null) {
        setValueByPath(toObject, ["bigqueryUri"], fromBigqueryUri);
      }
      return toObject;
    }
    function batchJobDestinationToVertex(fromObject) {
      const toObject = {};
      const fromFormat = getValueByPath(fromObject, ["format"]);
      if (fromFormat != null) {
        setValueByPath(toObject, ["predictionsFormat"], fromFormat);
      }
      const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
      if (fromGcsUri != null) {
        setValueByPath(toObject, ["gcsDestination", "outputUriPrefix"], fromGcsUri);
      }
      const fromBigqueryUri = getValueByPath(fromObject, ["bigqueryUri"]);
      if (fromBigqueryUri != null) {
        setValueByPath(toObject, ["bigqueryDestination", "outputUri"], fromBigqueryUri);
      }
      if (getValueByPath(fromObject, ["fileName"]) !== void 0) {
        throw new Error("fileName parameter is not supported in Vertex AI.");
      }
      if (getValueByPath(fromObject, ["inlinedResponses"]) !== void 0) {
        throw new Error("inlinedResponses parameter is not supported in Vertex AI.");
      }
      if (getValueByPath(fromObject, ["inlinedEmbedContentResponses"]) !== void 0) {
        throw new Error("inlinedEmbedContentResponses parameter is not supported in Vertex AI.");
      }
      return toObject;
    }
    function batchJobFromMldev(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromDisplayName = getValueByPath(fromObject, [
        "metadata",
        "displayName"
      ]);
      if (fromDisplayName != null) {
        setValueByPath(toObject, ["displayName"], fromDisplayName);
      }
      const fromState = getValueByPath(fromObject, ["metadata", "state"]);
      if (fromState != null) {
        setValueByPath(toObject, ["state"], tJobState(fromState));
      }
      const fromCreateTime = getValueByPath(fromObject, [
        "metadata",
        "createTime"
      ]);
      if (fromCreateTime != null) {
        setValueByPath(toObject, ["createTime"], fromCreateTime);
      }
      const fromEndTime = getValueByPath(fromObject, [
        "metadata",
        "endTime"
      ]);
      if (fromEndTime != null) {
        setValueByPath(toObject, ["endTime"], fromEndTime);
      }
      const fromUpdateTime = getValueByPath(fromObject, [
        "metadata",
        "updateTime"
      ]);
      if (fromUpdateTime != null) {
        setValueByPath(toObject, ["updateTime"], fromUpdateTime);
      }
      const fromModel = getValueByPath(fromObject, ["metadata", "model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["model"], fromModel);
      }
      const fromDest = getValueByPath(fromObject, ["metadata", "output"]);
      if (fromDest != null) {
        setValueByPath(toObject, ["dest"], batchJobDestinationFromMldev(tRecvBatchJobDestination(fromDest)));
      }
      return toObject;
    }
    function batchJobFromVertex(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
      if (fromDisplayName != null) {
        setValueByPath(toObject, ["displayName"], fromDisplayName);
      }
      const fromState = getValueByPath(fromObject, ["state"]);
      if (fromState != null) {
        setValueByPath(toObject, ["state"], tJobState(fromState));
      }
      const fromError = getValueByPath(fromObject, ["error"]);
      if (fromError != null) {
        setValueByPath(toObject, ["error"], fromError);
      }
      const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
      if (fromCreateTime != null) {
        setValueByPath(toObject, ["createTime"], fromCreateTime);
      }
      const fromStartTime = getValueByPath(fromObject, ["startTime"]);
      if (fromStartTime != null) {
        setValueByPath(toObject, ["startTime"], fromStartTime);
      }
      const fromEndTime = getValueByPath(fromObject, ["endTime"]);
      if (fromEndTime != null) {
        setValueByPath(toObject, ["endTime"], fromEndTime);
      }
      const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
      if (fromUpdateTime != null) {
        setValueByPath(toObject, ["updateTime"], fromUpdateTime);
      }
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["model"], fromModel);
      }
      const fromSrc = getValueByPath(fromObject, ["inputConfig"]);
      if (fromSrc != null) {
        setValueByPath(toObject, ["src"], batchJobSourceFromVertex(fromSrc));
      }
      const fromDest = getValueByPath(fromObject, ["outputConfig"]);
      if (fromDest != null) {
        setValueByPath(toObject, ["dest"], batchJobDestinationFromVertex(tRecvBatchJobDestination(fromDest)));
      }
      const fromCompletionStats = getValueByPath(fromObject, [
        "completionStats"
      ]);
      if (fromCompletionStats != null) {
        setValueByPath(toObject, ["completionStats"], fromCompletionStats);
      }
      return toObject;
    }
    function batchJobSourceFromVertex(fromObject) {
      const toObject = {};
      const fromFormat = getValueByPath(fromObject, ["instancesFormat"]);
      if (fromFormat != null) {
        setValueByPath(toObject, ["format"], fromFormat);
      }
      const fromGcsUri = getValueByPath(fromObject, ["gcsSource", "uris"]);
      if (fromGcsUri != null) {
        setValueByPath(toObject, ["gcsUri"], fromGcsUri);
      }
      const fromBigqueryUri = getValueByPath(fromObject, [
        "bigquerySource",
        "inputUri"
      ]);
      if (fromBigqueryUri != null) {
        setValueByPath(toObject, ["bigqueryUri"], fromBigqueryUri);
      }
      return toObject;
    }
    function batchJobSourceToMldev(apiClient, fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["format"]) !== void 0) {
        throw new Error("format parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) {
        throw new Error("gcsUri parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["bigqueryUri"]) !== void 0) {
        throw new Error("bigqueryUri parameter is not supported in Gemini API.");
      }
      const fromFileName = getValueByPath(fromObject, ["fileName"]);
      if (fromFileName != null) {
        setValueByPath(toObject, ["fileName"], fromFileName);
      }
      const fromInlinedRequests = getValueByPath(fromObject, [
        "inlinedRequests"
      ]);
      if (fromInlinedRequests != null) {
        let transformedList = fromInlinedRequests;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return inlinedRequestToMldev(apiClient, item);
          });
        }
        setValueByPath(toObject, ["requests", "requests"], transformedList);
      }
      return toObject;
    }
    function batchJobSourceToVertex(fromObject) {
      const toObject = {};
      const fromFormat = getValueByPath(fromObject, ["format"]);
      if (fromFormat != null) {
        setValueByPath(toObject, ["instancesFormat"], fromFormat);
      }
      const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
      if (fromGcsUri != null) {
        setValueByPath(toObject, ["gcsSource", "uris"], fromGcsUri);
      }
      const fromBigqueryUri = getValueByPath(fromObject, ["bigqueryUri"]);
      if (fromBigqueryUri != null) {
        setValueByPath(toObject, ["bigquerySource", "inputUri"], fromBigqueryUri);
      }
      if (getValueByPath(fromObject, ["fileName"]) !== void 0) {
        throw new Error("fileName parameter is not supported in Vertex AI.");
      }
      if (getValueByPath(fromObject, ["inlinedRequests"]) !== void 0) {
        throw new Error("inlinedRequests parameter is not supported in Vertex AI.");
      }
      return toObject;
    }
    function blobToMldev$4(fromObject) {
      const toObject = {};
      const fromData = getValueByPath(fromObject, ["data"]);
      if (fromData != null) {
        setValueByPath(toObject, ["data"], fromData);
      }
      if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
        throw new Error("displayName parameter is not supported in Gemini API.");
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function cancelBatchJobParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
      }
      return toObject;
    }
    function cancelBatchJobParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
      }
      return toObject;
    }
    function candidateFromMldev$1(fromObject) {
      const toObject = {};
      const fromContent = getValueByPath(fromObject, ["content"]);
      if (fromContent != null) {
        setValueByPath(toObject, ["content"], fromContent);
      }
      const fromCitationMetadata = getValueByPath(fromObject, [
        "citationMetadata"
      ]);
      if (fromCitationMetadata != null) {
        setValueByPath(toObject, ["citationMetadata"], citationMetadataFromMldev$1(fromCitationMetadata));
      }
      const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
      if (fromTokenCount != null) {
        setValueByPath(toObject, ["tokenCount"], fromTokenCount);
      }
      const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
      if (fromFinishReason != null) {
        setValueByPath(toObject, ["finishReason"], fromFinishReason);
      }
      const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
      if (fromAvgLogprobs != null) {
        setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
      }
      const fromGroundingMetadata = getValueByPath(fromObject, [
        "groundingMetadata"
      ]);
      if (fromGroundingMetadata != null) {
        setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
      }
      const fromIndex = getValueByPath(fromObject, ["index"]);
      if (fromIndex != null) {
        setValueByPath(toObject, ["index"], fromIndex);
      }
      const fromLogprobsResult = getValueByPath(fromObject, [
        "logprobsResult"
      ]);
      if (fromLogprobsResult != null) {
        setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
      }
      const fromSafetyRatings = getValueByPath(fromObject, [
        "safetyRatings"
      ]);
      if (fromSafetyRatings != null) {
        let transformedList = fromSafetyRatings;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["safetyRatings"], transformedList);
      }
      const fromUrlContextMetadata = getValueByPath(fromObject, [
        "urlContextMetadata"
      ]);
      if (fromUrlContextMetadata != null) {
        setValueByPath(toObject, ["urlContextMetadata"], fromUrlContextMetadata);
      }
      return toObject;
    }
    function citationMetadataFromMldev$1(fromObject) {
      const toObject = {};
      const fromCitations = getValueByPath(fromObject, ["citationSources"]);
      if (fromCitations != null) {
        let transformedList = fromCitations;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["citations"], transformedList);
      }
      return toObject;
    }
    function contentToMldev$4(fromObject) {
      const toObject = {};
      const fromParts = getValueByPath(fromObject, ["parts"]);
      if (fromParts != null) {
        let transformedList = fromParts;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return partToMldev$4(item);
          });
        }
        setValueByPath(toObject, ["parts"], transformedList);
      }
      const fromRole = getValueByPath(fromObject, ["role"]);
      if (fromRole != null) {
        setValueByPath(toObject, ["role"], fromRole);
      }
      return toObject;
    }
    function createBatchJobConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
      if (parentObject !== void 0 && fromDisplayName != null) {
        setValueByPath(parentObject, ["batch", "displayName"], fromDisplayName);
      }
      if (getValueByPath(fromObject, ["dest"]) !== void 0) {
        throw new Error("dest parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function createBatchJobConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
      if (parentObject !== void 0 && fromDisplayName != null) {
        setValueByPath(parentObject, ["displayName"], fromDisplayName);
      }
      const fromDest = getValueByPath(fromObject, ["dest"]);
      if (parentObject !== void 0 && fromDest != null) {
        setValueByPath(parentObject, ["outputConfig"], batchJobDestinationToVertex(tBatchJobDestination(fromDest)));
      }
      return toObject;
    }
    function createBatchJobParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromSrc = getValueByPath(fromObject, ["src"]);
      if (fromSrc != null) {
        setValueByPath(toObject, ["batch", "inputConfig"], batchJobSourceToMldev(apiClient, tBatchJobSource(apiClient, fromSrc)));
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        createBatchJobConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function createBatchJobParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["model"], tModel(apiClient, fromModel));
      }
      const fromSrc = getValueByPath(fromObject, ["src"]);
      if (fromSrc != null) {
        setValueByPath(toObject, ["inputConfig"], batchJobSourceToVertex(tBatchJobSource(apiClient, fromSrc)));
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        createBatchJobConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function createEmbeddingsBatchJobConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
      if (parentObject !== void 0 && fromDisplayName != null) {
        setValueByPath(parentObject, ["batch", "displayName"], fromDisplayName);
      }
      return toObject;
    }
    function createEmbeddingsBatchJobParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromSrc = getValueByPath(fromObject, ["src"]);
      if (fromSrc != null) {
        setValueByPath(toObject, ["batch", "inputConfig"], embeddingsBatchJobSourceToMldev(apiClient, fromSrc));
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        createEmbeddingsBatchJobConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function deleteBatchJobParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
      }
      return toObject;
    }
    function deleteBatchJobParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
      }
      return toObject;
    }
    function deleteResourceJobFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromDone = getValueByPath(fromObject, ["done"]);
      if (fromDone != null) {
        setValueByPath(toObject, ["done"], fromDone);
      }
      const fromError = getValueByPath(fromObject, ["error"]);
      if (fromError != null) {
        setValueByPath(toObject, ["error"], fromError);
      }
      return toObject;
    }
    function deleteResourceJobFromVertex(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromDone = getValueByPath(fromObject, ["done"]);
      if (fromDone != null) {
        setValueByPath(toObject, ["done"], fromDone);
      }
      const fromError = getValueByPath(fromObject, ["error"]);
      if (fromError != null) {
        setValueByPath(toObject, ["error"], fromError);
      }
      return toObject;
    }
    function embedContentBatchToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromContents = getValueByPath(fromObject, ["contents"]);
      if (fromContents != null) {
        let transformedList = tContentsForEmbed(apiClient, fromContents);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["requests[]", "request", "content"], transformedList);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        setValueByPath(toObject, ["_self"], embedContentConfigToMldev$1(fromConfig, toObject));
        moveValueByPath(toObject, { "requests[].*": "requests[].request.*" });
      }
      return toObject;
    }
    function embedContentConfigToMldev$1(fromObject, parentObject) {
      const toObject = {};
      const fromTaskType = getValueByPath(fromObject, ["taskType"]);
      if (parentObject !== void 0 && fromTaskType != null) {
        setValueByPath(parentObject, ["requests[]", "taskType"], fromTaskType);
      }
      const fromTitle = getValueByPath(fromObject, ["title"]);
      if (parentObject !== void 0 && fromTitle != null) {
        setValueByPath(parentObject, ["requests[]", "title"], fromTitle);
      }
      const fromOutputDimensionality = getValueByPath(fromObject, [
        "outputDimensionality"
      ]);
      if (parentObject !== void 0 && fromOutputDimensionality != null) {
        setValueByPath(parentObject, ["requests[]", "outputDimensionality"], fromOutputDimensionality);
      }
      if (getValueByPath(fromObject, ["mimeType"]) !== void 0) {
        throw new Error("mimeType parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["autoTruncate"]) !== void 0) {
        throw new Error("autoTruncate parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function embeddingsBatchJobSourceToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromFileName = getValueByPath(fromObject, ["fileName"]);
      if (fromFileName != null) {
        setValueByPath(toObject, ["file_name"], fromFileName);
      }
      const fromInlinedRequests = getValueByPath(fromObject, [
        "inlinedRequests"
      ]);
      if (fromInlinedRequests != null) {
        setValueByPath(toObject, ["requests"], embedContentBatchToMldev(apiClient, fromInlinedRequests));
      }
      return toObject;
    }
    function fileDataToMldev$4(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
        throw new Error("displayName parameter is not supported in Gemini API.");
      }
      const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
      if (fromFileUri != null) {
        setValueByPath(toObject, ["fileUri"], fromFileUri);
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function functionCallToMldev$4(fromObject) {
      const toObject = {};
      const fromId = getValueByPath(fromObject, ["id"]);
      if (fromId != null) {
        setValueByPath(toObject, ["id"], fromId);
      }
      const fromArgs = getValueByPath(fromObject, ["args"]);
      if (fromArgs != null) {
        setValueByPath(toObject, ["args"], fromArgs);
      }
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
        throw new Error("partialArgs parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
        throw new Error("willContinue parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function functionCallingConfigToMldev$2(fromObject) {
      const toObject = {};
      const fromMode = getValueByPath(fromObject, ["mode"]);
      if (fromMode != null) {
        setValueByPath(toObject, ["mode"], fromMode);
      }
      const fromAllowedFunctionNames = getValueByPath(fromObject, [
        "allowedFunctionNames"
      ]);
      if (fromAllowedFunctionNames != null) {
        setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
      }
      if (getValueByPath(fromObject, ["streamFunctionCallArguments"]) !== void 0) {
        throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function generateContentConfigToMldev$1(apiClient, fromObject, parentObject) {
      const toObject = {};
      const fromSystemInstruction = getValueByPath(fromObject, [
        "systemInstruction"
      ]);
      if (parentObject !== void 0 && fromSystemInstruction != null) {
        setValueByPath(parentObject, ["systemInstruction"], contentToMldev$4(tContent(fromSystemInstruction)));
      }
      const fromTemperature = getValueByPath(fromObject, ["temperature"]);
      if (fromTemperature != null) {
        setValueByPath(toObject, ["temperature"], fromTemperature);
      }
      const fromTopP = getValueByPath(fromObject, ["topP"]);
      if (fromTopP != null) {
        setValueByPath(toObject, ["topP"], fromTopP);
      }
      const fromTopK = getValueByPath(fromObject, ["topK"]);
      if (fromTopK != null) {
        setValueByPath(toObject, ["topK"], fromTopK);
      }
      const fromCandidateCount = getValueByPath(fromObject, [
        "candidateCount"
      ]);
      if (fromCandidateCount != null) {
        setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
      }
      const fromMaxOutputTokens = getValueByPath(fromObject, [
        "maxOutputTokens"
      ]);
      if (fromMaxOutputTokens != null) {
        setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
      }
      const fromStopSequences = getValueByPath(fromObject, [
        "stopSequences"
      ]);
      if (fromStopSequences != null) {
        setValueByPath(toObject, ["stopSequences"], fromStopSequences);
      }
      const fromResponseLogprobs = getValueByPath(fromObject, [
        "responseLogprobs"
      ]);
      if (fromResponseLogprobs != null) {
        setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
      }
      const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
      if (fromLogprobs != null) {
        setValueByPath(toObject, ["logprobs"], fromLogprobs);
      }
      const fromPresencePenalty = getValueByPath(fromObject, [
        "presencePenalty"
      ]);
      if (fromPresencePenalty != null) {
        setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
      }
      const fromFrequencyPenalty = getValueByPath(fromObject, [
        "frequencyPenalty"
      ]);
      if (fromFrequencyPenalty != null) {
        setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
      }
      const fromSeed = getValueByPath(fromObject, ["seed"]);
      if (fromSeed != null) {
        setValueByPath(toObject, ["seed"], fromSeed);
      }
      const fromResponseMimeType = getValueByPath(fromObject, [
        "responseMimeType"
      ]);
      if (fromResponseMimeType != null) {
        setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
      }
      const fromResponseSchema = getValueByPath(fromObject, [
        "responseSchema"
      ]);
      if (fromResponseSchema != null) {
        setValueByPath(toObject, ["responseSchema"], tSchema(fromResponseSchema));
      }
      const fromResponseJsonSchema = getValueByPath(fromObject, [
        "responseJsonSchema"
      ]);
      if (fromResponseJsonSchema != null) {
        setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
      }
      if (getValueByPath(fromObject, ["routingConfig"]) !== void 0) {
        throw new Error("routingConfig parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["modelSelectionConfig"]) !== void 0) {
        throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
      }
      const fromSafetySettings = getValueByPath(fromObject, [
        "safetySettings"
      ]);
      if (parentObject !== void 0 && fromSafetySettings != null) {
        let transformedList = fromSafetySettings;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return safetySettingToMldev$1(item);
          });
        }
        setValueByPath(parentObject, ["safetySettings"], transformedList);
      }
      const fromTools = getValueByPath(fromObject, ["tools"]);
      if (parentObject !== void 0 && fromTools != null) {
        let transformedList = tTools(fromTools);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return toolToMldev$4(tTool(item));
          });
        }
        setValueByPath(parentObject, ["tools"], transformedList);
      }
      const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
      if (parentObject !== void 0 && fromToolConfig != null) {
        setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev$2(fromToolConfig));
      }
      if (getValueByPath(fromObject, ["labels"]) !== void 0) {
        throw new Error("labels parameter is not supported in Gemini API.");
      }
      const fromCachedContent = getValueByPath(fromObject, [
        "cachedContent"
      ]);
      if (parentObject !== void 0 && fromCachedContent != null) {
        setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
      }
      const fromResponseModalities = getValueByPath(fromObject, [
        "responseModalities"
      ]);
      if (fromResponseModalities != null) {
        setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
      }
      const fromMediaResolution = getValueByPath(fromObject, [
        "mediaResolution"
      ]);
      if (fromMediaResolution != null) {
        setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
      }
      const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
      if (fromSpeechConfig != null) {
        setValueByPath(toObject, ["speechConfig"], tSpeechConfig(fromSpeechConfig));
      }
      if (getValueByPath(fromObject, ["audioTimestamp"]) !== void 0) {
        throw new Error("audioTimestamp parameter is not supported in Gemini API.");
      }
      const fromThinkingConfig = getValueByPath(fromObject, [
        "thinkingConfig"
      ]);
      if (fromThinkingConfig != null) {
        setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
      }
      const fromImageConfig = getValueByPath(fromObject, ["imageConfig"]);
      if (fromImageConfig != null) {
        setValueByPath(toObject, ["imageConfig"], imageConfigToMldev$1(fromImageConfig));
      }
      return toObject;
    }
    function generateContentResponseFromMldev$1(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromCandidates = getValueByPath(fromObject, ["candidates"]);
      if (fromCandidates != null) {
        let transformedList = fromCandidates;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return candidateFromMldev$1(item);
          });
        }
        setValueByPath(toObject, ["candidates"], transformedList);
      }
      const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
      if (fromModelVersion != null) {
        setValueByPath(toObject, ["modelVersion"], fromModelVersion);
      }
      const fromPromptFeedback = getValueByPath(fromObject, [
        "promptFeedback"
      ]);
      if (fromPromptFeedback != null) {
        setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
      }
      const fromResponseId = getValueByPath(fromObject, ["responseId"]);
      if (fromResponseId != null) {
        setValueByPath(toObject, ["responseId"], fromResponseId);
      }
      const fromUsageMetadata = getValueByPath(fromObject, [
        "usageMetadata"
      ]);
      if (fromUsageMetadata != null) {
        setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
      }
      return toObject;
    }
    function getBatchJobParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
      }
      return toObject;
    }
    function getBatchJobParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
      }
      return toObject;
    }
    function googleMapsToMldev$4(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
        throw new Error("authConfig parameter is not supported in Gemini API.");
      }
      const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
      if (fromEnableWidget != null) {
        setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
      }
      return toObject;
    }
    function googleSearchToMldev$4(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
        throw new Error("excludeDomains parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
        throw new Error("blockingConfidence parameter is not supported in Gemini API.");
      }
      const fromTimeRangeFilter = getValueByPath(fromObject, [
        "timeRangeFilter"
      ]);
      if (fromTimeRangeFilter != null) {
        setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
      }
      return toObject;
    }
    function imageConfigToMldev$1(fromObject) {
      const toObject = {};
      const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
      if (fromAspectRatio != null) {
        setValueByPath(toObject, ["aspectRatio"], fromAspectRatio);
      }
      const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
      if (fromImageSize != null) {
        setValueByPath(toObject, ["imageSize"], fromImageSize);
      }
      if (getValueByPath(fromObject, ["outputMimeType"]) !== void 0) {
        throw new Error("outputMimeType parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["outputCompressionQuality"]) !== void 0) {
        throw new Error("outputCompressionQuality parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function inlinedRequestToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["request", "model"], tModel(apiClient, fromModel));
      }
      const fromContents = getValueByPath(fromObject, ["contents"]);
      if (fromContents != null) {
        let transformedList = tContents(fromContents);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return contentToMldev$4(item);
          });
        }
        setValueByPath(toObject, ["request", "contents"], transformedList);
      }
      const fromMetadata = getValueByPath(fromObject, ["metadata"]);
      if (fromMetadata != null) {
        setValueByPath(toObject, ["metadata"], fromMetadata);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        setValueByPath(toObject, ["request", "generationConfig"], generateContentConfigToMldev$1(apiClient, fromConfig, getValueByPath(toObject, ["request"], {})));
      }
      return toObject;
    }
    function inlinedResponseFromMldev(fromObject) {
      const toObject = {};
      const fromResponse = getValueByPath(fromObject, ["response"]);
      if (fromResponse != null) {
        setValueByPath(toObject, ["response"], generateContentResponseFromMldev$1(fromResponse));
      }
      const fromError = getValueByPath(fromObject, ["error"]);
      if (fromError != null) {
        setValueByPath(toObject, ["error"], fromError);
      }
      return toObject;
    }
    function listBatchJobsConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
      if (parentObject !== void 0 && fromPageSize != null) {
        setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
      }
      const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
      if (parentObject !== void 0 && fromPageToken != null) {
        setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
      }
      if (getValueByPath(fromObject, ["filter"]) !== void 0) {
        throw new Error("filter parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function listBatchJobsConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
      if (parentObject !== void 0 && fromPageSize != null) {
        setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
      }
      const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
      if (parentObject !== void 0 && fromPageToken != null) {
        setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
      }
      const fromFilter = getValueByPath(fromObject, ["filter"]);
      if (parentObject !== void 0 && fromFilter != null) {
        setValueByPath(parentObject, ["_query", "filter"], fromFilter);
      }
      return toObject;
    }
    function listBatchJobsParametersToMldev(fromObject) {
      const toObject = {};
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        listBatchJobsConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function listBatchJobsParametersToVertex(fromObject) {
      const toObject = {};
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        listBatchJobsConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function listBatchJobsResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromNextPageToken = getValueByPath(fromObject, [
        "nextPageToken"
      ]);
      if (fromNextPageToken != null) {
        setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
      }
      const fromBatchJobs = getValueByPath(fromObject, ["operations"]);
      if (fromBatchJobs != null) {
        let transformedList = fromBatchJobs;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return batchJobFromMldev(item);
          });
        }
        setValueByPath(toObject, ["batchJobs"], transformedList);
      }
      return toObject;
    }
    function listBatchJobsResponseFromVertex(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromNextPageToken = getValueByPath(fromObject, [
        "nextPageToken"
      ]);
      if (fromNextPageToken != null) {
        setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
      }
      const fromBatchJobs = getValueByPath(fromObject, [
        "batchPredictionJobs"
      ]);
      if (fromBatchJobs != null) {
        let transformedList = fromBatchJobs;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return batchJobFromVertex(item);
          });
        }
        setValueByPath(toObject, ["batchJobs"], transformedList);
      }
      return toObject;
    }
    function partToMldev$4(fromObject) {
      const toObject = {};
      const fromMediaResolution = getValueByPath(fromObject, [
        "mediaResolution"
      ]);
      if (fromMediaResolution != null) {
        setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
      }
      const fromCodeExecutionResult = getValueByPath(fromObject, [
        "codeExecutionResult"
      ]);
      if (fromCodeExecutionResult != null) {
        setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
      }
      const fromExecutableCode = getValueByPath(fromObject, [
        "executableCode"
      ]);
      if (fromExecutableCode != null) {
        setValueByPath(toObject, ["executableCode"], fromExecutableCode);
      }
      const fromFileData = getValueByPath(fromObject, ["fileData"]);
      if (fromFileData != null) {
        setValueByPath(toObject, ["fileData"], fileDataToMldev$4(fromFileData));
      }
      const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
      if (fromFunctionCall != null) {
        setValueByPath(toObject, ["functionCall"], functionCallToMldev$4(fromFunctionCall));
      }
      const fromFunctionResponse = getValueByPath(fromObject, [
        "functionResponse"
      ]);
      if (fromFunctionResponse != null) {
        setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
      }
      const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
      if (fromInlineData != null) {
        setValueByPath(toObject, ["inlineData"], blobToMldev$4(fromInlineData));
      }
      const fromText = getValueByPath(fromObject, ["text"]);
      if (fromText != null) {
        setValueByPath(toObject, ["text"], fromText);
      }
      const fromThought = getValueByPath(fromObject, ["thought"]);
      if (fromThought != null) {
        setValueByPath(toObject, ["thought"], fromThought);
      }
      const fromThoughtSignature = getValueByPath(fromObject, [
        "thoughtSignature"
      ]);
      if (fromThoughtSignature != null) {
        setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
      }
      const fromVideoMetadata = getValueByPath(fromObject, [
        "videoMetadata"
      ]);
      if (fromVideoMetadata != null) {
        setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
      }
      return toObject;
    }
    function safetySettingToMldev$1(fromObject) {
      const toObject = {};
      const fromCategory = getValueByPath(fromObject, ["category"]);
      if (fromCategory != null) {
        setValueByPath(toObject, ["category"], fromCategory);
      }
      if (getValueByPath(fromObject, ["method"]) !== void 0) {
        throw new Error("method parameter is not supported in Gemini API.");
      }
      const fromThreshold = getValueByPath(fromObject, ["threshold"]);
      if (fromThreshold != null) {
        setValueByPath(toObject, ["threshold"], fromThreshold);
      }
      return toObject;
    }
    function toolConfigToMldev$2(fromObject) {
      const toObject = {};
      const fromFunctionCallingConfig = getValueByPath(fromObject, [
        "functionCallingConfig"
      ]);
      if (fromFunctionCallingConfig != null) {
        setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev$2(fromFunctionCallingConfig));
      }
      const fromRetrievalConfig = getValueByPath(fromObject, [
        "retrievalConfig"
      ]);
      if (fromRetrievalConfig != null) {
        setValueByPath(toObject, ["retrievalConfig"], fromRetrievalConfig);
      }
      return toObject;
    }
    function toolToMldev$4(fromObject) {
      const toObject = {};
      const fromFunctionDeclarations = getValueByPath(fromObject, [
        "functionDeclarations"
      ]);
      if (fromFunctionDeclarations != null) {
        let transformedList = fromFunctionDeclarations;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["functionDeclarations"], transformedList);
      }
      if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
        throw new Error("retrieval parameter is not supported in Gemini API.");
      }
      const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
        "googleSearchRetrieval"
      ]);
      if (fromGoogleSearchRetrieval != null) {
        setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
      }
      const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
      if (fromComputerUse != null) {
        setValueByPath(toObject, ["computerUse"], fromComputerUse);
      }
      const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
      if (fromFileSearch != null) {
        setValueByPath(toObject, ["fileSearch"], fromFileSearch);
      }
      const fromCodeExecution = getValueByPath(fromObject, [
        "codeExecution"
      ]);
      if (fromCodeExecution != null) {
        setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
      }
      if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
        throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
      }
      const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
      if (fromGoogleMaps != null) {
        setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$4(fromGoogleMaps));
      }
      const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
      if (fromGoogleSearch != null) {
        setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$4(fromGoogleSearch));
      }
      const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
      if (fromUrlContext != null) {
        setValueByPath(toObject, ["urlContext"], fromUrlContext);
      }
      return toObject;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    var PagedItem;
    (function(PagedItem2) {
      PagedItem2["PAGED_ITEM_BATCH_JOBS"] = "batchJobs";
      PagedItem2["PAGED_ITEM_MODELS"] = "models";
      PagedItem2["PAGED_ITEM_TUNING_JOBS"] = "tuningJobs";
      PagedItem2["PAGED_ITEM_FILES"] = "files";
      PagedItem2["PAGED_ITEM_CACHED_CONTENTS"] = "cachedContents";
      PagedItem2["PAGED_ITEM_FILE_SEARCH_STORES"] = "fileSearchStores";
      PagedItem2["PAGED_ITEM_DOCUMENTS"] = "documents";
    })(PagedItem || (PagedItem = {}));
    class Pager {
      constructor(name, request, response, params) {
        this.pageInternal = [];
        this.paramsInternal = {};
        this.requestInternal = request;
        this.init(name, response, params);
      }
      init(name, response, params) {
        var _a, _b;
        this.nameInternal = name;
        this.pageInternal = response[this.nameInternal] || [];
        this.sdkHttpResponseInternal = response === null || response === void 0 ? void 0 : response.sdkHttpResponse;
        this.idxInternal = 0;
        let requestParams = { config: {} };
        if (!params || Object.keys(params).length === 0) {
          requestParams = { config: {} };
        } else if (typeof params === "object") {
          requestParams = Object.assign({}, params);
        } else {
          requestParams = params;
        }
        if (requestParams["config"]) {
          requestParams["config"]["pageToken"] = response["nextPageToken"];
        }
        this.paramsInternal = requestParams;
        this.pageInternalSize = (_b = (_a = requestParams["config"]) === null || _a === void 0 ? void 0 : _a["pageSize"]) !== null && _b !== void 0 ? _b : this.pageInternal.length;
      }
      initNextPage(response) {
        this.init(this.nameInternal, response, this.paramsInternal);
      }
      /**
       * Returns the current page, which is a list of items.
       *
       * @remarks
       * The first page is retrieved when the pager is created. The returned list of
       * items could be a subset of the entire list.
       */
      get page() {
        return this.pageInternal;
      }
      /**
       * Returns the type of paged item (for example, ``batch_jobs``).
       */
      get name() {
        return this.nameInternal;
      }
      /**
       * Returns the length of the page fetched each time by this pager.
       *
       * @remarks
       * The number of items in the page is less than or equal to the page length.
       */
      get pageSize() {
        return this.pageInternalSize;
      }
      /**
       * Returns the headers of the API response.
       */
      get sdkHttpResponse() {
        return this.sdkHttpResponseInternal;
      }
      /**
       * Returns the parameters when making the API request for the next page.
       *
       * @remarks
       * Parameters contain a set of optional configs that can be
       * used to customize the API request. For example, the `pageToken` parameter
       * contains the token to request the next page.
       */
      get params() {
        return this.paramsInternal;
      }
      /**
       * Returns the total number of items in the current page.
       */
      get pageLength() {
        return this.pageInternal.length;
      }
      /**
       * Returns the item at the given index.
       */
      getItem(index) {
        return this.pageInternal[index];
      }
      /**
       * Returns an async iterator that support iterating through all items
       * retrieved from the API.
       *
       * @remarks
       * The iterator will automatically fetch the next page if there are more items
       * to fetch from the API.
       *
       * @example
       *
       * ```ts
       * const pager = await ai.files.list({config: {pageSize: 10}});
       * for await (const file of pager) {
       *   console.log(file.name);
       * }
       * ```
       */
      [Symbol.asyncIterator]() {
        return {
          next: () => __async(this, null, function* () {
            if (this.idxInternal >= this.pageLength) {
              if (this.hasNextPage()) {
                yield this.nextPage();
              } else {
                return { value: void 0, done: true };
              }
            }
            const item = this.getItem(this.idxInternal);
            this.idxInternal += 1;
            return { value: item, done: false };
          }),
          return: () => __async(this, null, function* () {
            return { value: void 0, done: true };
          })
        };
      }
      /**
       * Fetches the next page of items. This makes a new API request.
       *
       * @throws {Error} If there are no more pages to fetch.
       *
       * @example
       *
       * ```ts
       * const pager = await ai.files.list({config: {pageSize: 10}});
       * let page = pager.page;
       * while (true) {
       *   for (const file of page) {
       *     console.log(file.name);
       *   }
       *   if (!pager.hasNextPage()) {
       *     break;
       *   }
       *   page = await pager.nextPage();
       * }
       * ```
       */
      nextPage() {
        return __async(this, null, function* () {
          if (!this.hasNextPage()) {
            throw new Error("No more pages to fetch.");
          }
          const response = yield this.requestInternal(this.params);
          this.initNextPage(response);
          return this.page;
        });
      }
      /**
       * Returns true if there are more pages to fetch from the API.
       */
      hasNextPage() {
        var _a;
        if (((_a = this.params["config"]) === null || _a === void 0 ? void 0 : _a["pageToken"]) !== void 0) {
          return true;
        }
        return false;
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    class Batches extends BaseModule {
      constructor(apiClient) {
        super();
        this.apiClient = apiClient;
        this.create = (params) => __async(this, null, function* () {
          if (this.apiClient.isVertexAI()) {
            params.config = this.formatDestination(params.src, params.config);
          }
          return this.createInternal(params);
        });
        this.createEmbeddings = (params) => __async(this, null, function* () {
          console.warn("batches.createEmbeddings() is experimental and may change without notice.");
          if (this.apiClient.isVertexAI()) {
            throw new Error("Vertex AI does not support batches.createEmbeddings.");
          }
          return this.createEmbeddingsInternal(params);
        });
        this.list = (..._0) => __async(this, [..._0], function* (params = {}) {
          return new Pager(PagedItem.PAGED_ITEM_BATCH_JOBS, (x) => this.listInternal(x), yield this.listInternal(params), params);
        });
      }
      // Helper function to handle inlined generate content requests
      createInlinedGenerateContentRequest(params) {
        const body = createBatchJobParametersToMldev(
          this.apiClient,
          // Use instance apiClient
          params
        );
        const urlParams = body["_url"];
        const path = formatMap("{model}:batchGenerateContent", urlParams);
        const batch = body["batch"];
        const inputConfig = batch["inputConfig"];
        const requestsWrapper = inputConfig["requests"];
        const requests = requestsWrapper["requests"];
        const newRequests = [];
        for (const request of requests) {
          const requestDict = Object.assign({}, request);
          if (requestDict["systemInstruction"]) {
            const systemInstructionValue = requestDict["systemInstruction"];
            delete requestDict["systemInstruction"];
            const requestContent = requestDict["request"];
            requestContent["systemInstruction"] = systemInstructionValue;
            requestDict["request"] = requestContent;
          }
          newRequests.push(requestDict);
        }
        requestsWrapper["requests"] = newRequests;
        delete body["config"];
        delete body["_url"];
        delete body["_query"];
        return { path, body };
      }
      // Helper function to get the first GCS URI
      getGcsUri(src) {
        if (typeof src === "string") {
          return src.startsWith("gs://") ? src : void 0;
        }
        if (!Array.isArray(src) && src.gcsUri && src.gcsUri.length > 0) {
          return src.gcsUri[0];
        }
        return void 0;
      }
      // Helper function to get the BigQuery URI
      getBigqueryUri(src) {
        if (typeof src === "string") {
          return src.startsWith("bq://") ? src : void 0;
        }
        if (!Array.isArray(src)) {
          return src.bigqueryUri;
        }
        return void 0;
      }
      // Function to format the destination configuration for Vertex AI
      formatDestination(src, config) {
        const newConfig = config ? Object.assign({}, config) : {};
        const timestampStr = Date.now().toString();
        if (!newConfig.displayName) {
          newConfig.displayName = `genaiBatchJob_${timestampStr}`;
        }
        if (newConfig.dest === void 0) {
          const gcsUri = this.getGcsUri(src);
          const bigqueryUri = this.getBigqueryUri(src);
          if (gcsUri) {
            if (gcsUri.endsWith(".jsonl")) {
              newConfig.dest = `${gcsUri.slice(0, -6)}/dest`;
            } else {
              newConfig.dest = `${gcsUri}_dest_${timestampStr}`;
            }
          } else if (bigqueryUri) {
            newConfig.dest = `${bigqueryUri}_dest_${timestampStr}`;
          } else {
            throw new Error("Unsupported source for Vertex AI: No GCS or BigQuery URI found.");
          }
        }
        return newConfig;
      }
      /**
       * Internal method to create batch job.
       *
       * @param params - The parameters for create batch job request.
       * @return The created batch job.
       *
       */
      createInternal(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = createBatchJobParametersToVertex(this.apiClient, params);
            path = formatMap("batchPredictionJobs", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = batchJobFromVertex(apiResponse);
              return resp;
            });
          } else {
            const body = createBatchJobParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:batchGenerateContent", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = batchJobFromMldev(apiResponse);
              return resp;
            });
          }
        });
      }
      /**
       * Internal method to create batch job.
       *
       * @param params - The parameters for create batch job request.
       * @return The created batch job.
       *
       */
      createEmbeddingsInternal(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = createEmbeddingsBatchJobParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:asyncBatchEmbedContent", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = batchJobFromMldev(apiResponse);
              return resp;
            });
          }
        });
      }
      /**
       * Gets batch job configurations.
       *
       * @param params - The parameters for the get request.
       * @return The batch job.
       *
       * @example
       * ```ts
       * await ai.batches.get({name: '...'}); // The server-generated resource name.
       * ```
       */
      get(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = getBatchJobParametersToVertex(this.apiClient, params);
            path = formatMap("batchPredictionJobs/{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = batchJobFromVertex(apiResponse);
              return resp;
            });
          } else {
            const body = getBatchJobParametersToMldev(this.apiClient, params);
            path = formatMap("batches/{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = batchJobFromMldev(apiResponse);
              return resp;
            });
          }
        });
      }
      /**
       * Cancels a batch job.
       *
       * @param params - The parameters for the cancel request.
       * @return The empty response returned by the API.
       *
       * @example
       * ```ts
       * await ai.batches.cancel({name: '...'}); // The server-generated resource name.
       * ```
       */
      cancel(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = cancelBatchJobParametersToVertex(this.apiClient, params);
            path = formatMap("batchPredictionJobs/{name}:cancel", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            yield this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            });
          } else {
            const body = cancelBatchJobParametersToMldev(this.apiClient, params);
            path = formatMap("batches/{name}:cancel", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            yield this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            });
          }
        });
      }
      listInternal(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = listBatchJobsParametersToVertex(params);
            path = formatMap("batchPredictionJobs", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listBatchJobsResponseFromVertex(apiResponse);
              const typedResp = new ListBatchJobsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = listBatchJobsParametersToMldev(params);
            path = formatMap("batches", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listBatchJobsResponseFromMldev(apiResponse);
              const typedResp = new ListBatchJobsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
      /**
       * Deletes a batch job.
       *
       * @param params - The parameters for the delete request.
       * @return The empty response returned by the API.
       *
       * @example
       * ```ts
       * await ai.batches.delete({name: '...'}); // The server-generated resource name.
       * ```
       */
      delete(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = deleteBatchJobParametersToVertex(this.apiClient, params);
            path = formatMap("batchPredictionJobs/{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = deleteResourceJobFromVertex(apiResponse);
              return resp;
            });
          } else {
            const body = deleteBatchJobParametersToMldev(this.apiClient, params);
            path = formatMap("batches/{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = deleteResourceJobFromMldev(apiResponse);
              return resp;
            });
          }
        });
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function blobToMldev$3(fromObject) {
      const toObject = {};
      const fromData = getValueByPath(fromObject, ["data"]);
      if (fromData != null) {
        setValueByPath(toObject, ["data"], fromData);
      }
      if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
        throw new Error("displayName parameter is not supported in Gemini API.");
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function contentToMldev$3(fromObject) {
      const toObject = {};
      const fromParts = getValueByPath(fromObject, ["parts"]);
      if (fromParts != null) {
        let transformedList = fromParts;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return partToMldev$3(item);
          });
        }
        setValueByPath(toObject, ["parts"], transformedList);
      }
      const fromRole = getValueByPath(fromObject, ["role"]);
      if (fromRole != null) {
        setValueByPath(toObject, ["role"], fromRole);
      }
      return toObject;
    }
    function createCachedContentConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromTtl = getValueByPath(fromObject, ["ttl"]);
      if (parentObject !== void 0 && fromTtl != null) {
        setValueByPath(parentObject, ["ttl"], fromTtl);
      }
      const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
      if (parentObject !== void 0 && fromExpireTime != null) {
        setValueByPath(parentObject, ["expireTime"], fromExpireTime);
      }
      const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
      if (parentObject !== void 0 && fromDisplayName != null) {
        setValueByPath(parentObject, ["displayName"], fromDisplayName);
      }
      const fromContents = getValueByPath(fromObject, ["contents"]);
      if (parentObject !== void 0 && fromContents != null) {
        let transformedList = tContents(fromContents);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return contentToMldev$3(item);
          });
        }
        setValueByPath(parentObject, ["contents"], transformedList);
      }
      const fromSystemInstruction = getValueByPath(fromObject, [
        "systemInstruction"
      ]);
      if (parentObject !== void 0 && fromSystemInstruction != null) {
        setValueByPath(parentObject, ["systemInstruction"], contentToMldev$3(tContent(fromSystemInstruction)));
      }
      const fromTools = getValueByPath(fromObject, ["tools"]);
      if (parentObject !== void 0 && fromTools != null) {
        let transformedList = fromTools;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return toolToMldev$3(item);
          });
        }
        setValueByPath(parentObject, ["tools"], transformedList);
      }
      const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
      if (parentObject !== void 0 && fromToolConfig != null) {
        setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev$1(fromToolConfig));
      }
      if (getValueByPath(fromObject, ["kmsKeyName"]) !== void 0) {
        throw new Error("kmsKeyName parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function createCachedContentConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromTtl = getValueByPath(fromObject, ["ttl"]);
      if (parentObject !== void 0 && fromTtl != null) {
        setValueByPath(parentObject, ["ttl"], fromTtl);
      }
      const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
      if (parentObject !== void 0 && fromExpireTime != null) {
        setValueByPath(parentObject, ["expireTime"], fromExpireTime);
      }
      const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
      if (parentObject !== void 0 && fromDisplayName != null) {
        setValueByPath(parentObject, ["displayName"], fromDisplayName);
      }
      const fromContents = getValueByPath(fromObject, ["contents"]);
      if (parentObject !== void 0 && fromContents != null) {
        let transformedList = tContents(fromContents);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(parentObject, ["contents"], transformedList);
      }
      const fromSystemInstruction = getValueByPath(fromObject, [
        "systemInstruction"
      ]);
      if (parentObject !== void 0 && fromSystemInstruction != null) {
        setValueByPath(parentObject, ["systemInstruction"], tContent(fromSystemInstruction));
      }
      const fromTools = getValueByPath(fromObject, ["tools"]);
      if (parentObject !== void 0 && fromTools != null) {
        let transformedList = fromTools;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return toolToVertex$2(item);
          });
        }
        setValueByPath(parentObject, ["tools"], transformedList);
      }
      const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
      if (parentObject !== void 0 && fromToolConfig != null) {
        setValueByPath(parentObject, ["toolConfig"], fromToolConfig);
      }
      const fromKmsKeyName = getValueByPath(fromObject, ["kmsKeyName"]);
      if (parentObject !== void 0 && fromKmsKeyName != null) {
        setValueByPath(parentObject, ["encryption_spec", "kmsKeyName"], fromKmsKeyName);
      }
      return toObject;
    }
    function createCachedContentParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["model"], tCachesModel(apiClient, fromModel));
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        createCachedContentConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function createCachedContentParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["model"], tCachesModel(apiClient, fromModel));
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        createCachedContentConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function deleteCachedContentParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
      }
      return toObject;
    }
    function deleteCachedContentParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
      }
      return toObject;
    }
    function deleteCachedContentResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      return toObject;
    }
    function deleteCachedContentResponseFromVertex(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      return toObject;
    }
    function fileDataToMldev$3(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
        throw new Error("displayName parameter is not supported in Gemini API.");
      }
      const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
      if (fromFileUri != null) {
        setValueByPath(toObject, ["fileUri"], fromFileUri);
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function functionCallToMldev$3(fromObject) {
      const toObject = {};
      const fromId = getValueByPath(fromObject, ["id"]);
      if (fromId != null) {
        setValueByPath(toObject, ["id"], fromId);
      }
      const fromArgs = getValueByPath(fromObject, ["args"]);
      if (fromArgs != null) {
        setValueByPath(toObject, ["args"], fromArgs);
      }
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
        throw new Error("partialArgs parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
        throw new Error("willContinue parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function functionCallingConfigToMldev$1(fromObject) {
      const toObject = {};
      const fromMode = getValueByPath(fromObject, ["mode"]);
      if (fromMode != null) {
        setValueByPath(toObject, ["mode"], fromMode);
      }
      const fromAllowedFunctionNames = getValueByPath(fromObject, [
        "allowedFunctionNames"
      ]);
      if (fromAllowedFunctionNames != null) {
        setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
      }
      if (getValueByPath(fromObject, ["streamFunctionCallArguments"]) !== void 0) {
        throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function functionDeclarationToVertex$2(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
        throw new Error("behavior parameter is not supported in Vertex AI.");
      }
      const fromDescription = getValueByPath(fromObject, ["description"]);
      if (fromDescription != null) {
        setValueByPath(toObject, ["description"], fromDescription);
      }
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromParameters = getValueByPath(fromObject, ["parameters"]);
      if (fromParameters != null) {
        setValueByPath(toObject, ["parameters"], fromParameters);
      }
      const fromParametersJsonSchema = getValueByPath(fromObject, [
        "parametersJsonSchema"
      ]);
      if (fromParametersJsonSchema != null) {
        setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
      }
      const fromResponse = getValueByPath(fromObject, ["response"]);
      if (fromResponse != null) {
        setValueByPath(toObject, ["response"], fromResponse);
      }
      const fromResponseJsonSchema = getValueByPath(fromObject, [
        "responseJsonSchema"
      ]);
      if (fromResponseJsonSchema != null) {
        setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
      }
      return toObject;
    }
    function getCachedContentParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
      }
      return toObject;
    }
    function getCachedContentParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
      }
      return toObject;
    }
    function googleMapsToMldev$3(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
        throw new Error("authConfig parameter is not supported in Gemini API.");
      }
      const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
      if (fromEnableWidget != null) {
        setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
      }
      return toObject;
    }
    function googleSearchToMldev$3(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
        throw new Error("excludeDomains parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
        throw new Error("blockingConfidence parameter is not supported in Gemini API.");
      }
      const fromTimeRangeFilter = getValueByPath(fromObject, [
        "timeRangeFilter"
      ]);
      if (fromTimeRangeFilter != null) {
        setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
      }
      return toObject;
    }
    function listCachedContentsConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
      if (parentObject !== void 0 && fromPageSize != null) {
        setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
      }
      const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
      if (parentObject !== void 0 && fromPageToken != null) {
        setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
      }
      return toObject;
    }
    function listCachedContentsConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
      if (parentObject !== void 0 && fromPageSize != null) {
        setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
      }
      const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
      if (parentObject !== void 0 && fromPageToken != null) {
        setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
      }
      return toObject;
    }
    function listCachedContentsParametersToMldev(fromObject) {
      const toObject = {};
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        listCachedContentsConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function listCachedContentsParametersToVertex(fromObject) {
      const toObject = {};
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        listCachedContentsConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function listCachedContentsResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromNextPageToken = getValueByPath(fromObject, [
        "nextPageToken"
      ]);
      if (fromNextPageToken != null) {
        setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
      }
      const fromCachedContents = getValueByPath(fromObject, [
        "cachedContents"
      ]);
      if (fromCachedContents != null) {
        let transformedList = fromCachedContents;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["cachedContents"], transformedList);
      }
      return toObject;
    }
    function listCachedContentsResponseFromVertex(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromNextPageToken = getValueByPath(fromObject, [
        "nextPageToken"
      ]);
      if (fromNextPageToken != null) {
        setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
      }
      const fromCachedContents = getValueByPath(fromObject, [
        "cachedContents"
      ]);
      if (fromCachedContents != null) {
        let transformedList = fromCachedContents;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["cachedContents"], transformedList);
      }
      return toObject;
    }
    function partToMldev$3(fromObject) {
      const toObject = {};
      const fromMediaResolution = getValueByPath(fromObject, [
        "mediaResolution"
      ]);
      if (fromMediaResolution != null) {
        setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
      }
      const fromCodeExecutionResult = getValueByPath(fromObject, [
        "codeExecutionResult"
      ]);
      if (fromCodeExecutionResult != null) {
        setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
      }
      const fromExecutableCode = getValueByPath(fromObject, [
        "executableCode"
      ]);
      if (fromExecutableCode != null) {
        setValueByPath(toObject, ["executableCode"], fromExecutableCode);
      }
      const fromFileData = getValueByPath(fromObject, ["fileData"]);
      if (fromFileData != null) {
        setValueByPath(toObject, ["fileData"], fileDataToMldev$3(fromFileData));
      }
      const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
      if (fromFunctionCall != null) {
        setValueByPath(toObject, ["functionCall"], functionCallToMldev$3(fromFunctionCall));
      }
      const fromFunctionResponse = getValueByPath(fromObject, [
        "functionResponse"
      ]);
      if (fromFunctionResponse != null) {
        setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
      }
      const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
      if (fromInlineData != null) {
        setValueByPath(toObject, ["inlineData"], blobToMldev$3(fromInlineData));
      }
      const fromText = getValueByPath(fromObject, ["text"]);
      if (fromText != null) {
        setValueByPath(toObject, ["text"], fromText);
      }
      const fromThought = getValueByPath(fromObject, ["thought"]);
      if (fromThought != null) {
        setValueByPath(toObject, ["thought"], fromThought);
      }
      const fromThoughtSignature = getValueByPath(fromObject, [
        "thoughtSignature"
      ]);
      if (fromThoughtSignature != null) {
        setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
      }
      const fromVideoMetadata = getValueByPath(fromObject, [
        "videoMetadata"
      ]);
      if (fromVideoMetadata != null) {
        setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
      }
      return toObject;
    }
    function toolConfigToMldev$1(fromObject) {
      const toObject = {};
      const fromFunctionCallingConfig = getValueByPath(fromObject, [
        "functionCallingConfig"
      ]);
      if (fromFunctionCallingConfig != null) {
        setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev$1(fromFunctionCallingConfig));
      }
      const fromRetrievalConfig = getValueByPath(fromObject, [
        "retrievalConfig"
      ]);
      if (fromRetrievalConfig != null) {
        setValueByPath(toObject, ["retrievalConfig"], fromRetrievalConfig);
      }
      return toObject;
    }
    function toolToMldev$3(fromObject) {
      const toObject = {};
      const fromFunctionDeclarations = getValueByPath(fromObject, [
        "functionDeclarations"
      ]);
      if (fromFunctionDeclarations != null) {
        let transformedList = fromFunctionDeclarations;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["functionDeclarations"], transformedList);
      }
      if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
        throw new Error("retrieval parameter is not supported in Gemini API.");
      }
      const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
        "googleSearchRetrieval"
      ]);
      if (fromGoogleSearchRetrieval != null) {
        setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
      }
      const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
      if (fromComputerUse != null) {
        setValueByPath(toObject, ["computerUse"], fromComputerUse);
      }
      const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
      if (fromFileSearch != null) {
        setValueByPath(toObject, ["fileSearch"], fromFileSearch);
      }
      const fromCodeExecution = getValueByPath(fromObject, [
        "codeExecution"
      ]);
      if (fromCodeExecution != null) {
        setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
      }
      if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
        throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
      }
      const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
      if (fromGoogleMaps != null) {
        setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$3(fromGoogleMaps));
      }
      const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
      if (fromGoogleSearch != null) {
        setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$3(fromGoogleSearch));
      }
      const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
      if (fromUrlContext != null) {
        setValueByPath(toObject, ["urlContext"], fromUrlContext);
      }
      return toObject;
    }
    function toolToVertex$2(fromObject) {
      const toObject = {};
      const fromFunctionDeclarations = getValueByPath(fromObject, [
        "functionDeclarations"
      ]);
      if (fromFunctionDeclarations != null) {
        let transformedList = fromFunctionDeclarations;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return functionDeclarationToVertex$2(item);
          });
        }
        setValueByPath(toObject, ["functionDeclarations"], transformedList);
      }
      const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
      if (fromRetrieval != null) {
        setValueByPath(toObject, ["retrieval"], fromRetrieval);
      }
      const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
        "googleSearchRetrieval"
      ]);
      if (fromGoogleSearchRetrieval != null) {
        setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
      }
      const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
      if (fromComputerUse != null) {
        setValueByPath(toObject, ["computerUse"], fromComputerUse);
      }
      if (getValueByPath(fromObject, ["fileSearch"]) !== void 0) {
        throw new Error("fileSearch parameter is not supported in Vertex AI.");
      }
      const fromCodeExecution = getValueByPath(fromObject, [
        "codeExecution"
      ]);
      if (fromCodeExecution != null) {
        setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
      }
      const fromEnterpriseWebSearch = getValueByPath(fromObject, [
        "enterpriseWebSearch"
      ]);
      if (fromEnterpriseWebSearch != null) {
        setValueByPath(toObject, ["enterpriseWebSearch"], fromEnterpriseWebSearch);
      }
      const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
      if (fromGoogleMaps != null) {
        setValueByPath(toObject, ["googleMaps"], fromGoogleMaps);
      }
      const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
      if (fromGoogleSearch != null) {
        setValueByPath(toObject, ["googleSearch"], fromGoogleSearch);
      }
      const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
      if (fromUrlContext != null) {
        setValueByPath(toObject, ["urlContext"], fromUrlContext);
      }
      return toObject;
    }
    function updateCachedContentConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromTtl = getValueByPath(fromObject, ["ttl"]);
      if (parentObject !== void 0 && fromTtl != null) {
        setValueByPath(parentObject, ["ttl"], fromTtl);
      }
      const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
      if (parentObject !== void 0 && fromExpireTime != null) {
        setValueByPath(parentObject, ["expireTime"], fromExpireTime);
      }
      return toObject;
    }
    function updateCachedContentConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromTtl = getValueByPath(fromObject, ["ttl"]);
      if (parentObject !== void 0 && fromTtl != null) {
        setValueByPath(parentObject, ["ttl"], fromTtl);
      }
      const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
      if (parentObject !== void 0 && fromExpireTime != null) {
        setValueByPath(parentObject, ["expireTime"], fromExpireTime);
      }
      return toObject;
    }
    function updateCachedContentParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        updateCachedContentConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function updateCachedContentParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        updateCachedContentConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    class Caches extends BaseModule {
      constructor(apiClient) {
        super();
        this.apiClient = apiClient;
        this.list = (..._0) => __async(this, [..._0], function* (params = {}) {
          return new Pager(PagedItem.PAGED_ITEM_CACHED_CONTENTS, (x) => this.listInternal(x), yield this.listInternal(params), params);
        });
      }
      /**
       * Creates a cached contents resource.
       *
       * @remarks
       * Context caching is only supported for specific models. See [Gemini
       * Developer API reference](https://ai.google.dev/gemini-api/docs/caching?lang=node/context-cac)
       * and [Vertex AI reference](https://cloud.google.com/vertex-ai/generative-ai/docs/context-cache/context-cache-overview#supported_models)
       * for more information.
       *
       * @param params - The parameters for the create request.
       * @return The created cached content.
       *
       * @example
       * ```ts
       * const contents = ...; // Initialize the content to cache.
       * const response = await ai.caches.create({
       *   model: 'gemini-2.0-flash-001',
       *   config: {
       *    'contents': contents,
       *    'displayName': 'test cache',
       *    'systemInstruction': 'What is the sum of the two pdfs?',
       *    'ttl': '86400s',
       *  }
       * });
       * ```
       */
      create(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = createCachedContentParametersToVertex(this.apiClient, params);
            path = formatMap("cachedContents", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          } else {
            const body = createCachedContentParametersToMldev(this.apiClient, params);
            path = formatMap("cachedContents", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          }
        });
      }
      /**
       * Gets cached content configurations.
       *
       * @param params - The parameters for the get request.
       * @return The cached content.
       *
       * @example
       * ```ts
       * await ai.caches.get({name: '...'}); // The server-generated resource name.
       * ```
       */
      get(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = getCachedContentParametersToVertex(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          } else {
            const body = getCachedContentParametersToMldev(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          }
        });
      }
      /**
       * Deletes cached content.
       *
       * @param params - The parameters for the delete request.
       * @return The empty response returned by the API.
       *
       * @example
       * ```ts
       * await ai.caches.delete({name: '...'}); // The server-generated resource name.
       * ```
       */
      delete(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = deleteCachedContentParametersToVertex(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = deleteCachedContentResponseFromVertex(apiResponse);
              const typedResp = new DeleteCachedContentResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = deleteCachedContentParametersToMldev(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = deleteCachedContentResponseFromMldev(apiResponse);
              const typedResp = new DeleteCachedContentResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
      /**
       * Updates cached content configurations.
       *
       * @param params - The parameters for the update request.
       * @return The updated cached content.
       *
       * @example
       * ```ts
       * const response = await ai.caches.update({
       *   name: '...',  // The server-generated resource name.
       *   config: {'ttl': '7600s'}
       * });
       * ```
       */
      update(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = updateCachedContentParametersToVertex(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "PATCH",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          } else {
            const body = updateCachedContentParametersToMldev(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "PATCH",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          }
        });
      }
      listInternal(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = listCachedContentsParametersToVertex(params);
            path = formatMap("cachedContents", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listCachedContentsResponseFromVertex(apiResponse);
              const typedResp = new ListCachedContentsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = listCachedContentsParametersToMldev(params);
            path = formatMap("cachedContents", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listCachedContentsResponseFromMldev(apiResponse);
              const typedResp = new ListCachedContentsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
    }
    function __values(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __await(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f) i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
      }
    }
    function __asyncValues(o) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    }
    typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function isValidResponse(response) {
      var _a;
      if (response.candidates == void 0 || response.candidates.length === 0) {
        return false;
      }
      const content = (_a = response.candidates[0]) === null || _a === void 0 ? void 0 : _a.content;
      if (content === void 0) {
        return false;
      }
      return isValidContent(content);
    }
    function isValidContent(content) {
      if (content.parts === void 0 || content.parts.length === 0) {
        return false;
      }
      for (const part of content.parts) {
        if (part === void 0 || Object.keys(part).length === 0) {
          return false;
        }
      }
      return true;
    }
    function validateHistory(history) {
      if (history.length === 0) {
        return;
      }
      for (const content of history) {
        if (content.role !== "user" && content.role !== "model") {
          throw new Error(`Role must be user or model, but got ${content.role}.`);
        }
      }
    }
    function extractCuratedHistory(comprehensiveHistory) {
      if (comprehensiveHistory === void 0 || comprehensiveHistory.length === 0) {
        return [];
      }
      const curatedHistory = [];
      const length = comprehensiveHistory.length;
      let i = 0;
      while (i < length) {
        if (comprehensiveHistory[i].role === "user") {
          curatedHistory.push(comprehensiveHistory[i]);
          i++;
        } else {
          const modelOutput = [];
          let isValid = true;
          while (i < length && comprehensiveHistory[i].role === "model") {
            modelOutput.push(comprehensiveHistory[i]);
            if (isValid && !isValidContent(comprehensiveHistory[i])) {
              isValid = false;
            }
            i++;
          }
          if (isValid) {
            curatedHistory.push(...modelOutput);
          } else {
            curatedHistory.pop();
          }
        }
      }
      return curatedHistory;
    }
    class Chats {
      constructor(modelsModule, apiClient) {
        this.modelsModule = modelsModule;
        this.apiClient = apiClient;
      }
      /**
       * Creates a new chat session.
       *
       * @remarks
       * The config in the params will be used for all requests within the chat
       * session unless overridden by a per-request `config` in
       * @see {@link types.SendMessageParameters#config}.
       *
       * @param params - Parameters for creating a chat session.
       * @returns A new chat session.
       *
       * @example
       * ```ts
       * const chat = ai.chats.create({
       *   model: 'gemini-2.0-flash'
       *   config: {
       *     temperature: 0.5,
       *     maxOutputTokens: 1024,
       *   }
       * });
       * ```
       */
      create(params) {
        return new Chat(
          this.apiClient,
          this.modelsModule,
          params.model,
          params.config,
          // Deep copy the history to avoid mutating the history outside of the
          // chat session.
          structuredClone(params.history)
        );
      }
    }
    class Chat {
      constructor(apiClient, modelsModule, model, config = {}, history = []) {
        this.apiClient = apiClient;
        this.modelsModule = modelsModule;
        this.model = model;
        this.config = config;
        this.history = history;
        this.sendPromise = Promise.resolve();
        validateHistory(history);
      }
      /**
       * Sends a message to the model and returns the response.
       *
       * @remarks
       * This method will wait for the previous message to be processed before
       * sending the next message.
       *
       * @see {@link Chat#sendMessageStream} for streaming method.
       * @param params - parameters for sending messages within a chat session.
       * @returns The model's response.
       *
       * @example
       * ```ts
       * const chat = ai.chats.create({model: 'gemini-2.0-flash'});
       * const response = await chat.sendMessage({
       *   message: 'Why is the sky blue?'
       * });
       * console.log(response.text);
       * ```
       */
      sendMessage(params) {
        return __async(this, null, function* () {
          var _a;
          yield this.sendPromise;
          const inputContent = tContent(params.message);
          const responsePromise = this.modelsModule.generateContent({
            model: this.model,
            contents: this.getHistory(true).concat(inputContent),
            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config
          });
          this.sendPromise = (() => __async(this, null, function* () {
            var _a2, _b, _c;
            const response = yield responsePromise;
            const outputContent = (_b = (_a2 = response.candidates) === null || _a2 === void 0 ? void 0 : _a2[0]) === null || _b === void 0 ? void 0 : _b.content;
            const fullAutomaticFunctionCallingHistory = response.automaticFunctionCallingHistory;
            const index = this.getHistory(true).length;
            let automaticFunctionCallingHistory = [];
            if (fullAutomaticFunctionCallingHistory != null) {
              automaticFunctionCallingHistory = (_c = fullAutomaticFunctionCallingHistory.slice(index)) !== null && _c !== void 0 ? _c : [];
            }
            const modelOutput = outputContent ? [outputContent] : [];
            this.recordHistory(inputContent, modelOutput, automaticFunctionCallingHistory);
            return;
          }))();
          yield this.sendPromise.catch(() => {
            this.sendPromise = Promise.resolve();
          });
          return responsePromise;
        });
      }
      /**
       * Sends a message to the model and returns the response in chunks.
       *
       * @remarks
       * This method will wait for the previous message to be processed before
       * sending the next message.
       *
       * @see {@link Chat#sendMessage} for non-streaming method.
       * @param params - parameters for sending the message.
       * @return The model's response.
       *
       * @example
       * ```ts
       * const chat = ai.chats.create({model: 'gemini-2.0-flash'});
       * const response = await chat.sendMessageStream({
       *   message: 'Why is the sky blue?'
       * });
       * for await (const chunk of response) {
       *   console.log(chunk.text);
       * }
       * ```
       */
      sendMessageStream(params) {
        return __async(this, null, function* () {
          var _a;
          yield this.sendPromise;
          const inputContent = tContent(params.message);
          const streamResponse = this.modelsModule.generateContentStream({
            model: this.model,
            contents: this.getHistory(true).concat(inputContent),
            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config
          });
          this.sendPromise = streamResponse.then(() => void 0).catch(() => void 0);
          const response = yield streamResponse;
          const result = this.processStreamResponse(response, inputContent);
          return result;
        });
      }
      /**
       * Returns the chat history.
       *
       * @remarks
       * The history is a list of contents alternating between user and model.
       *
       * There are two types of history:
       * - The `curated history` contains only the valid turns between user and
       * model, which will be included in the subsequent requests sent to the model.
       * - The `comprehensive history` contains all turns, including invalid or
       *   empty model outputs, providing a complete record of the history.
       *
       * The history is updated after receiving the response from the model,
       * for streaming response, it means receiving the last chunk of the response.
       *
       * The `comprehensive history` is returned by default. To get the `curated
       * history`, set the `curated` parameter to `true`.
       *
       * @param curated - whether to return the curated history or the comprehensive
       *     history.
       * @return History contents alternating between user and model for the entire
       *     chat session.
       */
      getHistory(curated = false) {
        const history = curated ? extractCuratedHistory(this.history) : this.history;
        return structuredClone(history);
      }
      processStreamResponse(streamResponse, inputContent) {
        var _a, _b;
        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {
          var _c, e_1, _d, _e;
          const outputContent = [];
          try {
            for (var _f = true, streamResponse_1 = __asyncValues(streamResponse), streamResponse_1_1; streamResponse_1_1 = yield __await(streamResponse_1.next()), _c = streamResponse_1_1.done, !_c; _f = true) {
              _e = streamResponse_1_1.value;
              _f = false;
              const chunk = _e;
              if (isValidResponse(chunk)) {
                const content = (_b = (_a = chunk.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content;
                if (content !== void 0) {
                  outputContent.push(content);
                }
              }
              yield yield __await(chunk);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_f && !_c && (_d = streamResponse_1.return)) yield __await(_d.call(streamResponse_1));
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          this.recordHistory(inputContent, outputContent);
        });
      }
      recordHistory(userInput, modelOutput, automaticFunctionCallingHistory) {
        let outputContents = [];
        if (modelOutput.length > 0 && modelOutput.every((content) => content.role !== void 0)) {
          outputContents = modelOutput;
        } else {
          outputContents.push({
            role: "model",
            parts: []
          });
        }
        if (automaticFunctionCallingHistory && automaticFunctionCallingHistory.length > 0) {
          this.history.push(...extractCuratedHistory(automaticFunctionCallingHistory));
        } else {
          this.history.push(userInput);
        }
        this.history.push(...outputContents);
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    class ApiError extends Error {
      constructor(options) {
        super(options.message);
        this.name = "ApiError";
        this.status = options.status;
        Object.setPrototypeOf(this, ApiError.prototype);
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function createFileParametersToMldev(fromObject) {
      const toObject = {};
      const fromFile = getValueByPath(fromObject, ["file"]);
      if (fromFile != null) {
        setValueByPath(toObject, ["file"], fromFile);
      }
      return toObject;
    }
    function createFileResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      return toObject;
    }
    function deleteFileParametersToMldev(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "file"], tFileName(fromName));
      }
      return toObject;
    }
    function deleteFileResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      return toObject;
    }
    function getFileParametersToMldev(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "file"], tFileName(fromName));
      }
      return toObject;
    }
    function listFilesConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
      if (parentObject !== void 0 && fromPageSize != null) {
        setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
      }
      const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
      if (parentObject !== void 0 && fromPageToken != null) {
        setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
      }
      return toObject;
    }
    function listFilesParametersToMldev(fromObject) {
      const toObject = {};
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        listFilesConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function listFilesResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromNextPageToken = getValueByPath(fromObject, [
        "nextPageToken"
      ]);
      if (fromNextPageToken != null) {
        setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
      }
      const fromFiles = getValueByPath(fromObject, ["files"]);
      if (fromFiles != null) {
        let transformedList = fromFiles;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["files"], transformedList);
      }
      return toObject;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    class Files extends BaseModule {
      constructor(apiClient) {
        super();
        this.apiClient = apiClient;
        this.list = (..._0) => __async(this, [..._0], function* (params = {}) {
          return new Pager(PagedItem.PAGED_ITEM_FILES, (x) => this.listInternal(x), yield this.listInternal(params), params);
        });
      }
      /**
       * Uploads a file asynchronously to the Gemini API.
       * This method is not available in Vertex AI.
       * Supported upload sources:
       * - Node.js: File path (string) or Blob object.
       * - Browser: Blob object (e.g., File).
       *
       * @remarks
       * The `mimeType` can be specified in the `config` parameter. If omitted:
       *  - For file path (string) inputs, the `mimeType` will be inferred from the
       *     file extension.
       *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`
       *     property.
       * Somex eamples for file extension to mimeType mapping:
       * .txt -> text/plain
       * .json -> application/json
       * .jpg  -> image/jpeg
       * .png -> image/png
       * .mp3 -> audio/mpeg
       * .mp4 -> video/mp4
       *
       * This section can contain multiple paragraphs and code examples.
       *
       * @param params - Optional parameters specified in the
       *        `types.UploadFileParameters` interface.
       *         @see {@link types.UploadFileParameters#config} for the optional
       *         config in the parameters.
       * @return A promise that resolves to a `types.File` object.
       * @throws An error if called on a Vertex AI client.
       * @throws An error if the `mimeType` is not provided and can not be inferred,
       * the `mimeType` can be provided in the `params.config` parameter.
       * @throws An error occurs if a suitable upload location cannot be established.
       *
       * @example
       * The following code uploads a file to Gemini API.
       *
       * ```ts
       * const file = await ai.files.upload({file: 'file.txt', config: {
       *   mimeType: 'text/plain',
       * }});
       * console.log(file.name);
       * ```
       */
      upload(params) {
        return __async(this, null, function* () {
          if (this.apiClient.isVertexAI()) {
            throw new Error("Vertex AI does not support uploading files. You can share files through a GCS bucket.");
          }
          return this.apiClient.uploadFile(params.file, params.config).then((resp) => {
            return resp;
          });
        });
      }
      /**
       * Downloads a remotely stored file asynchronously to a location specified in
       * the `params` object. This method only works on Node environment, to
       * download files in the browser, use a browser compliant method like an <a>
       * tag.
       *
       * @param params - The parameters for the download request.
       *
       * @example
       * The following code downloads an example file named "files/mehozpxf877d" as
       * "file.txt".
       *
       * ```ts
       * await ai.files.download({file: file.name, downloadPath: 'file.txt'});
       * ```
       */
      download(params) {
        return __async(this, null, function* () {
          yield this.apiClient.downloadFile(params);
        });
      }
      listInternal(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = listFilesParametersToMldev(params);
            path = formatMap("files", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listFilesResponseFromMldev(apiResponse);
              const typedResp = new ListFilesResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
      createInternal(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = createFileParametersToMldev(params);
            path = formatMap("upload/v1beta/files", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = createFileResponseFromMldev(apiResponse);
              const typedResp = new CreateFileResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
      /**
       * Retrieves the file information from the service.
       *
       * @param params - The parameters for the get request
       * @return The Promise that resolves to the types.File object requested.
       *
       * @example
       * ```ts
       * const config: GetFileParameters = {
       *   name: fileName,
       * };
       * file = await ai.files.get(config);
       * console.log(file.name);
       * ```
       */
      get(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = getFileParametersToMldev(params);
            path = formatMap("files/{file}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          }
        });
      }
      /**
       * Deletes a remotely stored file.
       *
       * @param params - The parameters for the delete request.
       * @return The DeleteFileResponse, the response for the delete method.
       *
       * @example
       * The following code deletes an example file named "files/mehozpxf877d".
       *
       * ```ts
       * await ai.files.delete({name: file.name});
       * ```
       */
      delete(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = deleteFileParametersToMldev(params);
            path = formatMap("files/{file}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = deleteFileResponseFromMldev(apiResponse);
              const typedResp = new DeleteFileResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function blobToMldev$2(fromObject) {
      const toObject = {};
      const fromData = getValueByPath(fromObject, ["data"]);
      if (fromData != null) {
        setValueByPath(toObject, ["data"], fromData);
      }
      if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
        throw new Error("displayName parameter is not supported in Gemini API.");
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function contentToMldev$2(fromObject) {
      const toObject = {};
      const fromParts = getValueByPath(fromObject, ["parts"]);
      if (fromParts != null) {
        let transformedList = fromParts;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return partToMldev$2(item);
          });
        }
        setValueByPath(toObject, ["parts"], transformedList);
      }
      const fromRole = getValueByPath(fromObject, ["role"]);
      if (fromRole != null) {
        setValueByPath(toObject, ["role"], fromRole);
      }
      return toObject;
    }
    function fileDataToMldev$2(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
        throw new Error("displayName parameter is not supported in Gemini API.");
      }
      const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
      if (fromFileUri != null) {
        setValueByPath(toObject, ["fileUri"], fromFileUri);
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function functionCallToMldev$2(fromObject) {
      const toObject = {};
      const fromId = getValueByPath(fromObject, ["id"]);
      if (fromId != null) {
        setValueByPath(toObject, ["id"], fromId);
      }
      const fromArgs = getValueByPath(fromObject, ["args"]);
      if (fromArgs != null) {
        setValueByPath(toObject, ["args"], fromArgs);
      }
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
        throw new Error("partialArgs parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
        throw new Error("willContinue parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function functionDeclarationToVertex$1(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
        throw new Error("behavior parameter is not supported in Vertex AI.");
      }
      const fromDescription = getValueByPath(fromObject, ["description"]);
      if (fromDescription != null) {
        setValueByPath(toObject, ["description"], fromDescription);
      }
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromParameters = getValueByPath(fromObject, ["parameters"]);
      if (fromParameters != null) {
        setValueByPath(toObject, ["parameters"], fromParameters);
      }
      const fromParametersJsonSchema = getValueByPath(fromObject, [
        "parametersJsonSchema"
      ]);
      if (fromParametersJsonSchema != null) {
        setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
      }
      const fromResponse = getValueByPath(fromObject, ["response"]);
      if (fromResponse != null) {
        setValueByPath(toObject, ["response"], fromResponse);
      }
      const fromResponseJsonSchema = getValueByPath(fromObject, [
        "responseJsonSchema"
      ]);
      if (fromResponseJsonSchema != null) {
        setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
      }
      return toObject;
    }
    function generationConfigToVertex$1(fromObject) {
      const toObject = {};
      const fromModelSelectionConfig = getValueByPath(fromObject, [
        "modelSelectionConfig"
      ]);
      if (fromModelSelectionConfig != null) {
        setValueByPath(toObject, ["modelConfig"], fromModelSelectionConfig);
      }
      const fromResponseJsonSchema = getValueByPath(fromObject, [
        "responseJsonSchema"
      ]);
      if (fromResponseJsonSchema != null) {
        setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
      }
      const fromAudioTimestamp = getValueByPath(fromObject, [
        "audioTimestamp"
      ]);
      if (fromAudioTimestamp != null) {
        setValueByPath(toObject, ["audioTimestamp"], fromAudioTimestamp);
      }
      const fromCandidateCount = getValueByPath(fromObject, [
        "candidateCount"
      ]);
      if (fromCandidateCount != null) {
        setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
      }
      const fromEnableAffectiveDialog = getValueByPath(fromObject, [
        "enableAffectiveDialog"
      ]);
      if (fromEnableAffectiveDialog != null) {
        setValueByPath(toObject, ["enableAffectiveDialog"], fromEnableAffectiveDialog);
      }
      const fromFrequencyPenalty = getValueByPath(fromObject, [
        "frequencyPenalty"
      ]);
      if (fromFrequencyPenalty != null) {
        setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
      }
      const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
      if (fromLogprobs != null) {
        setValueByPath(toObject, ["logprobs"], fromLogprobs);
      }
      const fromMaxOutputTokens = getValueByPath(fromObject, [
        "maxOutputTokens"
      ]);
      if (fromMaxOutputTokens != null) {
        setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
      }
      const fromMediaResolution = getValueByPath(fromObject, [
        "mediaResolution"
      ]);
      if (fromMediaResolution != null) {
        setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
      }
      const fromPresencePenalty = getValueByPath(fromObject, [
        "presencePenalty"
      ]);
      if (fromPresencePenalty != null) {
        setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
      }
      const fromResponseLogprobs = getValueByPath(fromObject, [
        "responseLogprobs"
      ]);
      if (fromResponseLogprobs != null) {
        setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
      }
      const fromResponseMimeType = getValueByPath(fromObject, [
        "responseMimeType"
      ]);
      if (fromResponseMimeType != null) {
        setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
      }
      const fromResponseModalities = getValueByPath(fromObject, [
        "responseModalities"
      ]);
      if (fromResponseModalities != null) {
        setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
      }
      const fromResponseSchema = getValueByPath(fromObject, [
        "responseSchema"
      ]);
      if (fromResponseSchema != null) {
        setValueByPath(toObject, ["responseSchema"], fromResponseSchema);
      }
      const fromRoutingConfig = getValueByPath(fromObject, [
        "routingConfig"
      ]);
      if (fromRoutingConfig != null) {
        setValueByPath(toObject, ["routingConfig"], fromRoutingConfig);
      }
      const fromSeed = getValueByPath(fromObject, ["seed"]);
      if (fromSeed != null) {
        setValueByPath(toObject, ["seed"], fromSeed);
      }
      const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
      if (fromSpeechConfig != null) {
        setValueByPath(toObject, ["speechConfig"], speechConfigToVertex$1(fromSpeechConfig));
      }
      const fromStopSequences = getValueByPath(fromObject, [
        "stopSequences"
      ]);
      if (fromStopSequences != null) {
        setValueByPath(toObject, ["stopSequences"], fromStopSequences);
      }
      const fromTemperature = getValueByPath(fromObject, ["temperature"]);
      if (fromTemperature != null) {
        setValueByPath(toObject, ["temperature"], fromTemperature);
      }
      const fromThinkingConfig = getValueByPath(fromObject, [
        "thinkingConfig"
      ]);
      if (fromThinkingConfig != null) {
        setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
      }
      const fromTopK = getValueByPath(fromObject, ["topK"]);
      if (fromTopK != null) {
        setValueByPath(toObject, ["topK"], fromTopK);
      }
      const fromTopP = getValueByPath(fromObject, ["topP"]);
      if (fromTopP != null) {
        setValueByPath(toObject, ["topP"], fromTopP);
      }
      if (getValueByPath(fromObject, ["enableEnhancedCivicAnswers"]) !== void 0) {
        throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI.");
      }
      return toObject;
    }
    function googleMapsToMldev$2(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
        throw new Error("authConfig parameter is not supported in Gemini API.");
      }
      const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
      if (fromEnableWidget != null) {
        setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
      }
      return toObject;
    }
    function googleSearchToMldev$2(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
        throw new Error("excludeDomains parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
        throw new Error("blockingConfidence parameter is not supported in Gemini API.");
      }
      const fromTimeRangeFilter = getValueByPath(fromObject, [
        "timeRangeFilter"
      ]);
      if (fromTimeRangeFilter != null) {
        setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
      }
      return toObject;
    }
    function liveConnectConfigToMldev$1(fromObject, parentObject) {
      const toObject = {};
      const fromGenerationConfig = getValueByPath(fromObject, [
        "generationConfig"
      ]);
      if (parentObject !== void 0 && fromGenerationConfig != null) {
        setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
      }
      const fromResponseModalities = getValueByPath(fromObject, [
        "responseModalities"
      ]);
      if (parentObject !== void 0 && fromResponseModalities != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
      }
      const fromTemperature = getValueByPath(fromObject, ["temperature"]);
      if (parentObject !== void 0 && fromTemperature != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
      }
      const fromTopP = getValueByPath(fromObject, ["topP"]);
      if (parentObject !== void 0 && fromTopP != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
      }
      const fromTopK = getValueByPath(fromObject, ["topK"]);
      if (parentObject !== void 0 && fromTopK != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
      }
      const fromMaxOutputTokens = getValueByPath(fromObject, [
        "maxOutputTokens"
      ]);
      if (parentObject !== void 0 && fromMaxOutputTokens != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
      }
      const fromMediaResolution = getValueByPath(fromObject, [
        "mediaResolution"
      ]);
      if (parentObject !== void 0 && fromMediaResolution != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
      }
      const fromSeed = getValueByPath(fromObject, ["seed"]);
      if (parentObject !== void 0 && fromSeed != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
      }
      const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
      if (parentObject !== void 0 && fromSpeechConfig != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], tLiveSpeechConfig(fromSpeechConfig));
      }
      const fromThinkingConfig = getValueByPath(fromObject, [
        "thinkingConfig"
      ]);
      if (parentObject !== void 0 && fromThinkingConfig != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "thinkingConfig"], fromThinkingConfig);
      }
      const fromEnableAffectiveDialog = getValueByPath(fromObject, [
        "enableAffectiveDialog"
      ]);
      if (parentObject !== void 0 && fromEnableAffectiveDialog != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
      }
      const fromSystemInstruction = getValueByPath(fromObject, [
        "systemInstruction"
      ]);
      if (parentObject !== void 0 && fromSystemInstruction != null) {
        setValueByPath(parentObject, ["setup", "systemInstruction"], contentToMldev$2(tContent(fromSystemInstruction)));
      }
      const fromTools = getValueByPath(fromObject, ["tools"]);
      if (parentObject !== void 0 && fromTools != null) {
        let transformedList = tTools(fromTools);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return toolToMldev$2(tTool(item));
          });
        }
        setValueByPath(parentObject, ["setup", "tools"], transformedList);
      }
      const fromSessionResumption = getValueByPath(fromObject, [
        "sessionResumption"
      ]);
      if (parentObject !== void 0 && fromSessionResumption != null) {
        setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToMldev$1(fromSessionResumption));
      }
      const fromInputAudioTranscription = getValueByPath(fromObject, [
        "inputAudioTranscription"
      ]);
      if (parentObject !== void 0 && fromInputAudioTranscription != null) {
        setValueByPath(parentObject, ["setup", "inputAudioTranscription"], fromInputAudioTranscription);
      }
      const fromOutputAudioTranscription = getValueByPath(fromObject, [
        "outputAudioTranscription"
      ]);
      if (parentObject !== void 0 && fromOutputAudioTranscription != null) {
        setValueByPath(parentObject, ["setup", "outputAudioTranscription"], fromOutputAudioTranscription);
      }
      const fromRealtimeInputConfig = getValueByPath(fromObject, [
        "realtimeInputConfig"
      ]);
      if (parentObject !== void 0 && fromRealtimeInputConfig != null) {
        setValueByPath(parentObject, ["setup", "realtimeInputConfig"], fromRealtimeInputConfig);
      }
      const fromContextWindowCompression = getValueByPath(fromObject, [
        "contextWindowCompression"
      ]);
      if (parentObject !== void 0 && fromContextWindowCompression != null) {
        setValueByPath(parentObject, ["setup", "contextWindowCompression"], fromContextWindowCompression);
      }
      const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
      if (parentObject !== void 0 && fromProactivity != null) {
        setValueByPath(parentObject, ["setup", "proactivity"], fromProactivity);
      }
      return toObject;
    }
    function liveConnectConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromGenerationConfig = getValueByPath(fromObject, [
        "generationConfig"
      ]);
      if (parentObject !== void 0 && fromGenerationConfig != null) {
        setValueByPath(parentObject, ["setup", "generationConfig"], generationConfigToVertex$1(fromGenerationConfig));
      }
      const fromResponseModalities = getValueByPath(fromObject, [
        "responseModalities"
      ]);
      if (parentObject !== void 0 && fromResponseModalities != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
      }
      const fromTemperature = getValueByPath(fromObject, ["temperature"]);
      if (parentObject !== void 0 && fromTemperature != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
      }
      const fromTopP = getValueByPath(fromObject, ["topP"]);
      if (parentObject !== void 0 && fromTopP != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
      }
      const fromTopK = getValueByPath(fromObject, ["topK"]);
      if (parentObject !== void 0 && fromTopK != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
      }
      const fromMaxOutputTokens = getValueByPath(fromObject, [
        "maxOutputTokens"
      ]);
      if (parentObject !== void 0 && fromMaxOutputTokens != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
      }
      const fromMediaResolution = getValueByPath(fromObject, [
        "mediaResolution"
      ]);
      if (parentObject !== void 0 && fromMediaResolution != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
      }
      const fromSeed = getValueByPath(fromObject, ["seed"]);
      if (parentObject !== void 0 && fromSeed != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
      }
      const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
      if (parentObject !== void 0 && fromSpeechConfig != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], speechConfigToVertex$1(tLiveSpeechConfig(fromSpeechConfig)));
      }
      const fromThinkingConfig = getValueByPath(fromObject, [
        "thinkingConfig"
      ]);
      if (parentObject !== void 0 && fromThinkingConfig != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "thinkingConfig"], fromThinkingConfig);
      }
      const fromEnableAffectiveDialog = getValueByPath(fromObject, [
        "enableAffectiveDialog"
      ]);
      if (parentObject !== void 0 && fromEnableAffectiveDialog != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
      }
      const fromSystemInstruction = getValueByPath(fromObject, [
        "systemInstruction"
      ]);
      if (parentObject !== void 0 && fromSystemInstruction != null) {
        setValueByPath(parentObject, ["setup", "systemInstruction"], tContent(fromSystemInstruction));
      }
      const fromTools = getValueByPath(fromObject, ["tools"]);
      if (parentObject !== void 0 && fromTools != null) {
        let transformedList = tTools(fromTools);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return toolToVertex$1(tTool(item));
          });
        }
        setValueByPath(parentObject, ["setup", "tools"], transformedList);
      }
      const fromSessionResumption = getValueByPath(fromObject, [
        "sessionResumption"
      ]);
      if (parentObject !== void 0 && fromSessionResumption != null) {
        setValueByPath(parentObject, ["setup", "sessionResumption"], fromSessionResumption);
      }
      const fromInputAudioTranscription = getValueByPath(fromObject, [
        "inputAudioTranscription"
      ]);
      if (parentObject !== void 0 && fromInputAudioTranscription != null) {
        setValueByPath(parentObject, ["setup", "inputAudioTranscription"], fromInputAudioTranscription);
      }
      const fromOutputAudioTranscription = getValueByPath(fromObject, [
        "outputAudioTranscription"
      ]);
      if (parentObject !== void 0 && fromOutputAudioTranscription != null) {
        setValueByPath(parentObject, ["setup", "outputAudioTranscription"], fromOutputAudioTranscription);
      }
      const fromRealtimeInputConfig = getValueByPath(fromObject, [
        "realtimeInputConfig"
      ]);
      if (parentObject !== void 0 && fromRealtimeInputConfig != null) {
        setValueByPath(parentObject, ["setup", "realtimeInputConfig"], fromRealtimeInputConfig);
      }
      const fromContextWindowCompression = getValueByPath(fromObject, [
        "contextWindowCompression"
      ]);
      if (parentObject !== void 0 && fromContextWindowCompression != null) {
        setValueByPath(parentObject, ["setup", "contextWindowCompression"], fromContextWindowCompression);
      }
      const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
      if (parentObject !== void 0 && fromProactivity != null) {
        setValueByPath(parentObject, ["setup", "proactivity"], fromProactivity);
      }
      return toObject;
    }
    function liveConnectParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        setValueByPath(toObject, ["config"], liveConnectConfigToMldev$1(fromConfig, toObject));
      }
      return toObject;
    }
    function liveConnectParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        setValueByPath(toObject, ["config"], liveConnectConfigToVertex(fromConfig, toObject));
      }
      return toObject;
    }
    function liveMusicSetConfigParametersToMldev(fromObject) {
      const toObject = {};
      const fromMusicGenerationConfig = getValueByPath(fromObject, [
        "musicGenerationConfig"
      ]);
      if (fromMusicGenerationConfig != null) {
        setValueByPath(toObject, ["musicGenerationConfig"], fromMusicGenerationConfig);
      }
      return toObject;
    }
    function liveMusicSetWeightedPromptsParametersToMldev(fromObject) {
      const toObject = {};
      const fromWeightedPrompts = getValueByPath(fromObject, [
        "weightedPrompts"
      ]);
      if (fromWeightedPrompts != null) {
        let transformedList = fromWeightedPrompts;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["weightedPrompts"], transformedList);
      }
      return toObject;
    }
    function liveSendRealtimeInputParametersToMldev(fromObject) {
      const toObject = {};
      const fromMedia = getValueByPath(fromObject, ["media"]);
      if (fromMedia != null) {
        let transformedList = tBlobs(fromMedia);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return blobToMldev$2(item);
          });
        }
        setValueByPath(toObject, ["mediaChunks"], transformedList);
      }
      const fromAudio = getValueByPath(fromObject, ["audio"]);
      if (fromAudio != null) {
        setValueByPath(toObject, ["audio"], blobToMldev$2(tAudioBlob(fromAudio)));
      }
      const fromAudioStreamEnd = getValueByPath(fromObject, [
        "audioStreamEnd"
      ]);
      if (fromAudioStreamEnd != null) {
        setValueByPath(toObject, ["audioStreamEnd"], fromAudioStreamEnd);
      }
      const fromVideo = getValueByPath(fromObject, ["video"]);
      if (fromVideo != null) {
        setValueByPath(toObject, ["video"], blobToMldev$2(tImageBlob(fromVideo)));
      }
      const fromText = getValueByPath(fromObject, ["text"]);
      if (fromText != null) {
        setValueByPath(toObject, ["text"], fromText);
      }
      const fromActivityStart = getValueByPath(fromObject, [
        "activityStart"
      ]);
      if (fromActivityStart != null) {
        setValueByPath(toObject, ["activityStart"], fromActivityStart);
      }
      const fromActivityEnd = getValueByPath(fromObject, ["activityEnd"]);
      if (fromActivityEnd != null) {
        setValueByPath(toObject, ["activityEnd"], fromActivityEnd);
      }
      return toObject;
    }
    function liveSendRealtimeInputParametersToVertex(fromObject) {
      const toObject = {};
      const fromMedia = getValueByPath(fromObject, ["media"]);
      if (fromMedia != null) {
        let transformedList = tBlobs(fromMedia);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["mediaChunks"], transformedList);
      }
      const fromAudio = getValueByPath(fromObject, ["audio"]);
      if (fromAudio != null) {
        setValueByPath(toObject, ["audio"], tAudioBlob(fromAudio));
      }
      const fromAudioStreamEnd = getValueByPath(fromObject, [
        "audioStreamEnd"
      ]);
      if (fromAudioStreamEnd != null) {
        setValueByPath(toObject, ["audioStreamEnd"], fromAudioStreamEnd);
      }
      const fromVideo = getValueByPath(fromObject, ["video"]);
      if (fromVideo != null) {
        setValueByPath(toObject, ["video"], tImageBlob(fromVideo));
      }
      const fromText = getValueByPath(fromObject, ["text"]);
      if (fromText != null) {
        setValueByPath(toObject, ["text"], fromText);
      }
      const fromActivityStart = getValueByPath(fromObject, [
        "activityStart"
      ]);
      if (fromActivityStart != null) {
        setValueByPath(toObject, ["activityStart"], fromActivityStart);
      }
      const fromActivityEnd = getValueByPath(fromObject, ["activityEnd"]);
      if (fromActivityEnd != null) {
        setValueByPath(toObject, ["activityEnd"], fromActivityEnd);
      }
      return toObject;
    }
    function liveServerMessageFromVertex(fromObject) {
      const toObject = {};
      const fromSetupComplete = getValueByPath(fromObject, [
        "setupComplete"
      ]);
      if (fromSetupComplete != null) {
        setValueByPath(toObject, ["setupComplete"], fromSetupComplete);
      }
      const fromServerContent = getValueByPath(fromObject, [
        "serverContent"
      ]);
      if (fromServerContent != null) {
        setValueByPath(toObject, ["serverContent"], fromServerContent);
      }
      const fromToolCall = getValueByPath(fromObject, ["toolCall"]);
      if (fromToolCall != null) {
        setValueByPath(toObject, ["toolCall"], fromToolCall);
      }
      const fromToolCallCancellation = getValueByPath(fromObject, [
        "toolCallCancellation"
      ]);
      if (fromToolCallCancellation != null) {
        setValueByPath(toObject, ["toolCallCancellation"], fromToolCallCancellation);
      }
      const fromUsageMetadata = getValueByPath(fromObject, [
        "usageMetadata"
      ]);
      if (fromUsageMetadata != null) {
        setValueByPath(toObject, ["usageMetadata"], usageMetadataFromVertex(fromUsageMetadata));
      }
      const fromGoAway = getValueByPath(fromObject, ["goAway"]);
      if (fromGoAway != null) {
        setValueByPath(toObject, ["goAway"], fromGoAway);
      }
      const fromSessionResumptionUpdate = getValueByPath(fromObject, [
        "sessionResumptionUpdate"
      ]);
      if (fromSessionResumptionUpdate != null) {
        setValueByPath(toObject, ["sessionResumptionUpdate"], fromSessionResumptionUpdate);
      }
      return toObject;
    }
    function partToMldev$2(fromObject) {
      const toObject = {};
      const fromMediaResolution = getValueByPath(fromObject, [
        "mediaResolution"
      ]);
      if (fromMediaResolution != null) {
        setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
      }
      const fromCodeExecutionResult = getValueByPath(fromObject, [
        "codeExecutionResult"
      ]);
      if (fromCodeExecutionResult != null) {
        setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
      }
      const fromExecutableCode = getValueByPath(fromObject, [
        "executableCode"
      ]);
      if (fromExecutableCode != null) {
        setValueByPath(toObject, ["executableCode"], fromExecutableCode);
      }
      const fromFileData = getValueByPath(fromObject, ["fileData"]);
      if (fromFileData != null) {
        setValueByPath(toObject, ["fileData"], fileDataToMldev$2(fromFileData));
      }
      const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
      if (fromFunctionCall != null) {
        setValueByPath(toObject, ["functionCall"], functionCallToMldev$2(fromFunctionCall));
      }
      const fromFunctionResponse = getValueByPath(fromObject, [
        "functionResponse"
      ]);
      if (fromFunctionResponse != null) {
        setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
      }
      const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
      if (fromInlineData != null) {
        setValueByPath(toObject, ["inlineData"], blobToMldev$2(fromInlineData));
      }
      const fromText = getValueByPath(fromObject, ["text"]);
      if (fromText != null) {
        setValueByPath(toObject, ["text"], fromText);
      }
      const fromThought = getValueByPath(fromObject, ["thought"]);
      if (fromThought != null) {
        setValueByPath(toObject, ["thought"], fromThought);
      }
      const fromThoughtSignature = getValueByPath(fromObject, [
        "thoughtSignature"
      ]);
      if (fromThoughtSignature != null) {
        setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
      }
      const fromVideoMetadata = getValueByPath(fromObject, [
        "videoMetadata"
      ]);
      if (fromVideoMetadata != null) {
        setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
      }
      return toObject;
    }
    function sessionResumptionConfigToMldev$1(fromObject) {
      const toObject = {};
      const fromHandle = getValueByPath(fromObject, ["handle"]);
      if (fromHandle != null) {
        setValueByPath(toObject, ["handle"], fromHandle);
      }
      if (getValueByPath(fromObject, ["transparent"]) !== void 0) {
        throw new Error("transparent parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function speechConfigToVertex$1(fromObject) {
      const toObject = {};
      const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
      if (fromLanguageCode != null) {
        setValueByPath(toObject, ["languageCode"], fromLanguageCode);
      }
      const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
      if (fromVoiceConfig != null) {
        setValueByPath(toObject, ["voiceConfig"], fromVoiceConfig);
      }
      if (getValueByPath(fromObject, ["multiSpeakerVoiceConfig"]) !== void 0) {
        throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI.");
      }
      return toObject;
    }
    function toolToMldev$2(fromObject) {
      const toObject = {};
      const fromFunctionDeclarations = getValueByPath(fromObject, [
        "functionDeclarations"
      ]);
      if (fromFunctionDeclarations != null) {
        let transformedList = fromFunctionDeclarations;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["functionDeclarations"], transformedList);
      }
      if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
        throw new Error("retrieval parameter is not supported in Gemini API.");
      }
      const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
        "googleSearchRetrieval"
      ]);
      if (fromGoogleSearchRetrieval != null) {
        setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
      }
      const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
      if (fromComputerUse != null) {
        setValueByPath(toObject, ["computerUse"], fromComputerUse);
      }
      const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
      if (fromFileSearch != null) {
        setValueByPath(toObject, ["fileSearch"], fromFileSearch);
      }
      const fromCodeExecution = getValueByPath(fromObject, [
        "codeExecution"
      ]);
      if (fromCodeExecution != null) {
        setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
      }
      if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
        throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
      }
      const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
      if (fromGoogleMaps != null) {
        setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$2(fromGoogleMaps));
      }
      const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
      if (fromGoogleSearch != null) {
        setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$2(fromGoogleSearch));
      }
      const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
      if (fromUrlContext != null) {
        setValueByPath(toObject, ["urlContext"], fromUrlContext);
      }
      return toObject;
    }
    function toolToVertex$1(fromObject) {
      const toObject = {};
      const fromFunctionDeclarations = getValueByPath(fromObject, [
        "functionDeclarations"
      ]);
      if (fromFunctionDeclarations != null) {
        let transformedList = fromFunctionDeclarations;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return functionDeclarationToVertex$1(item);
          });
        }
        setValueByPath(toObject, ["functionDeclarations"], transformedList);
      }
      const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
      if (fromRetrieval != null) {
        setValueByPath(toObject, ["retrieval"], fromRetrieval);
      }
      const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
        "googleSearchRetrieval"
      ]);
      if (fromGoogleSearchRetrieval != null) {
        setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
      }
      const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
      if (fromComputerUse != null) {
        setValueByPath(toObject, ["computerUse"], fromComputerUse);
      }
      if (getValueByPath(fromObject, ["fileSearch"]) !== void 0) {
        throw new Error("fileSearch parameter is not supported in Vertex AI.");
      }
      const fromCodeExecution = getValueByPath(fromObject, [
        "codeExecution"
      ]);
      if (fromCodeExecution != null) {
        setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
      }
      const fromEnterpriseWebSearch = getValueByPath(fromObject, [
        "enterpriseWebSearch"
      ]);
      if (fromEnterpriseWebSearch != null) {
        setValueByPath(toObject, ["enterpriseWebSearch"], fromEnterpriseWebSearch);
      }
      const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
      if (fromGoogleMaps != null) {
        setValueByPath(toObject, ["googleMaps"], fromGoogleMaps);
      }
      const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
      if (fromGoogleSearch != null) {
        setValueByPath(toObject, ["googleSearch"], fromGoogleSearch);
      }
      const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
      if (fromUrlContext != null) {
        setValueByPath(toObject, ["urlContext"], fromUrlContext);
      }
      return toObject;
    }
    function usageMetadataFromVertex(fromObject) {
      const toObject = {};
      const fromPromptTokenCount = getValueByPath(fromObject, [
        "promptTokenCount"
      ]);
      if (fromPromptTokenCount != null) {
        setValueByPath(toObject, ["promptTokenCount"], fromPromptTokenCount);
      }
      const fromCachedContentTokenCount = getValueByPath(fromObject, [
        "cachedContentTokenCount"
      ]);
      if (fromCachedContentTokenCount != null) {
        setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
      }
      const fromResponseTokenCount = getValueByPath(fromObject, [
        "candidatesTokenCount"
      ]);
      if (fromResponseTokenCount != null) {
        setValueByPath(toObject, ["responseTokenCount"], fromResponseTokenCount);
      }
      const fromToolUsePromptTokenCount = getValueByPath(fromObject, [
        "toolUsePromptTokenCount"
      ]);
      if (fromToolUsePromptTokenCount != null) {
        setValueByPath(toObject, ["toolUsePromptTokenCount"], fromToolUsePromptTokenCount);
      }
      const fromThoughtsTokenCount = getValueByPath(fromObject, [
        "thoughtsTokenCount"
      ]);
      if (fromThoughtsTokenCount != null) {
        setValueByPath(toObject, ["thoughtsTokenCount"], fromThoughtsTokenCount);
      }
      const fromTotalTokenCount = getValueByPath(fromObject, [
        "totalTokenCount"
      ]);
      if (fromTotalTokenCount != null) {
        setValueByPath(toObject, ["totalTokenCount"], fromTotalTokenCount);
      }
      const fromPromptTokensDetails = getValueByPath(fromObject, [
        "promptTokensDetails"
      ]);
      if (fromPromptTokensDetails != null) {
        let transformedList = fromPromptTokensDetails;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["promptTokensDetails"], transformedList);
      }
      const fromCacheTokensDetails = getValueByPath(fromObject, [
        "cacheTokensDetails"
      ]);
      if (fromCacheTokensDetails != null) {
        let transformedList = fromCacheTokensDetails;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["cacheTokensDetails"], transformedList);
      }
      const fromResponseTokensDetails = getValueByPath(fromObject, [
        "candidatesTokensDetails"
      ]);
      if (fromResponseTokensDetails != null) {
        let transformedList = fromResponseTokensDetails;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["responseTokensDetails"], transformedList);
      }
      const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [
        "toolUsePromptTokensDetails"
      ]);
      if (fromToolUsePromptTokensDetails != null) {
        let transformedList = fromToolUsePromptTokensDetails;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["toolUsePromptTokensDetails"], transformedList);
      }
      const fromTrafficType = getValueByPath(fromObject, ["trafficType"]);
      if (fromTrafficType != null) {
        setValueByPath(toObject, ["trafficType"], fromTrafficType);
      }
      return toObject;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function blobToMldev$1(fromObject) {
      const toObject = {};
      const fromData = getValueByPath(fromObject, ["data"]);
      if (fromData != null) {
        setValueByPath(toObject, ["data"], fromData);
      }
      if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
        throw new Error("displayName parameter is not supported in Gemini API.");
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function candidateFromMldev(fromObject) {
      const toObject = {};
      const fromContent = getValueByPath(fromObject, ["content"]);
      if (fromContent != null) {
        setValueByPath(toObject, ["content"], fromContent);
      }
      const fromCitationMetadata = getValueByPath(fromObject, [
        "citationMetadata"
      ]);
      if (fromCitationMetadata != null) {
        setValueByPath(toObject, ["citationMetadata"], citationMetadataFromMldev(fromCitationMetadata));
      }
      const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
      if (fromTokenCount != null) {
        setValueByPath(toObject, ["tokenCount"], fromTokenCount);
      }
      const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
      if (fromFinishReason != null) {
        setValueByPath(toObject, ["finishReason"], fromFinishReason);
      }
      const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
      if (fromAvgLogprobs != null) {
        setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
      }
      const fromGroundingMetadata = getValueByPath(fromObject, [
        "groundingMetadata"
      ]);
      if (fromGroundingMetadata != null) {
        setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
      }
      const fromIndex = getValueByPath(fromObject, ["index"]);
      if (fromIndex != null) {
        setValueByPath(toObject, ["index"], fromIndex);
      }
      const fromLogprobsResult = getValueByPath(fromObject, [
        "logprobsResult"
      ]);
      if (fromLogprobsResult != null) {
        setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
      }
      const fromSafetyRatings = getValueByPath(fromObject, [
        "safetyRatings"
      ]);
      if (fromSafetyRatings != null) {
        let transformedList = fromSafetyRatings;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["safetyRatings"], transformedList);
      }
      const fromUrlContextMetadata = getValueByPath(fromObject, [
        "urlContextMetadata"
      ]);
      if (fromUrlContextMetadata != null) {
        setValueByPath(toObject, ["urlContextMetadata"], fromUrlContextMetadata);
      }
      return toObject;
    }
    function citationMetadataFromMldev(fromObject) {
      const toObject = {};
      const fromCitations = getValueByPath(fromObject, ["citationSources"]);
      if (fromCitations != null) {
        let transformedList = fromCitations;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["citations"], transformedList);
      }
      return toObject;
    }
    function computeTokensParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromContents = getValueByPath(fromObject, ["contents"]);
      if (fromContents != null) {
        let transformedList = tContents(fromContents);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["contents"], transformedList);
      }
      return toObject;
    }
    function computeTokensResponseFromVertex(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromTokensInfo = getValueByPath(fromObject, ["tokensInfo"]);
      if (fromTokensInfo != null) {
        let transformedList = fromTokensInfo;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["tokensInfo"], transformedList);
      }
      return toObject;
    }
    function contentEmbeddingFromVertex(fromObject) {
      const toObject = {};
      const fromValues = getValueByPath(fromObject, ["values"]);
      if (fromValues != null) {
        setValueByPath(toObject, ["values"], fromValues);
      }
      const fromStatistics = getValueByPath(fromObject, ["statistics"]);
      if (fromStatistics != null) {
        setValueByPath(toObject, ["statistics"], contentEmbeddingStatisticsFromVertex(fromStatistics));
      }
      return toObject;
    }
    function contentEmbeddingStatisticsFromVertex(fromObject) {
      const toObject = {};
      const fromTruncated = getValueByPath(fromObject, ["truncated"]);
      if (fromTruncated != null) {
        setValueByPath(toObject, ["truncated"], fromTruncated);
      }
      const fromTokenCount = getValueByPath(fromObject, ["token_count"]);
      if (fromTokenCount != null) {
        setValueByPath(toObject, ["tokenCount"], fromTokenCount);
      }
      return toObject;
    }
    function contentToMldev$1(fromObject) {
      const toObject = {};
      const fromParts = getValueByPath(fromObject, ["parts"]);
      if (fromParts != null) {
        let transformedList = fromParts;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return partToMldev$1(item);
          });
        }
        setValueByPath(toObject, ["parts"], transformedList);
      }
      const fromRole = getValueByPath(fromObject, ["role"]);
      if (fromRole != null) {
        setValueByPath(toObject, ["role"], fromRole);
      }
      return toObject;
    }
    function controlReferenceConfigToVertex(fromObject) {
      const toObject = {};
      const fromControlType = getValueByPath(fromObject, ["controlType"]);
      if (fromControlType != null) {
        setValueByPath(toObject, ["controlType"], fromControlType);
      }
      const fromEnableControlImageComputation = getValueByPath(fromObject, [
        "enableControlImageComputation"
      ]);
      if (fromEnableControlImageComputation != null) {
        setValueByPath(toObject, ["computeControl"], fromEnableControlImageComputation);
      }
      return toObject;
    }
    function countTokensConfigToMldev(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["systemInstruction"]) !== void 0) {
        throw new Error("systemInstruction parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["tools"]) !== void 0) {
        throw new Error("tools parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["generationConfig"]) !== void 0) {
        throw new Error("generationConfig parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function countTokensConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromSystemInstruction = getValueByPath(fromObject, [
        "systemInstruction"
      ]);
      if (parentObject !== void 0 && fromSystemInstruction != null) {
        setValueByPath(parentObject, ["systemInstruction"], tContent(fromSystemInstruction));
      }
      const fromTools = getValueByPath(fromObject, ["tools"]);
      if (parentObject !== void 0 && fromTools != null) {
        let transformedList = fromTools;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return toolToVertex(item);
          });
        }
        setValueByPath(parentObject, ["tools"], transformedList);
      }
      const fromGenerationConfig = getValueByPath(fromObject, [
        "generationConfig"
      ]);
      if (parentObject !== void 0 && fromGenerationConfig != null) {
        setValueByPath(parentObject, ["generationConfig"], generationConfigToVertex(fromGenerationConfig));
      }
      return toObject;
    }
    function countTokensParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromContents = getValueByPath(fromObject, ["contents"]);
      if (fromContents != null) {
        let transformedList = tContents(fromContents);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return contentToMldev$1(item);
          });
        }
        setValueByPath(toObject, ["contents"], transformedList);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        countTokensConfigToMldev(fromConfig);
      }
      return toObject;
    }
    function countTokensParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromContents = getValueByPath(fromObject, ["contents"]);
      if (fromContents != null) {
        let transformedList = tContents(fromContents);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["contents"], transformedList);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        countTokensConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function countTokensResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromTotalTokens = getValueByPath(fromObject, ["totalTokens"]);
      if (fromTotalTokens != null) {
        setValueByPath(toObject, ["totalTokens"], fromTotalTokens);
      }
      const fromCachedContentTokenCount = getValueByPath(fromObject, [
        "cachedContentTokenCount"
      ]);
      if (fromCachedContentTokenCount != null) {
        setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
      }
      return toObject;
    }
    function countTokensResponseFromVertex(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromTotalTokens = getValueByPath(fromObject, ["totalTokens"]);
      if (fromTotalTokens != null) {
        setValueByPath(toObject, ["totalTokens"], fromTotalTokens);
      }
      return toObject;
    }
    function deleteModelParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
      }
      return toObject;
    }
    function deleteModelParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
      }
      return toObject;
    }
    function deleteModelResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      return toObject;
    }
    function deleteModelResponseFromVertex(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      return toObject;
    }
    function editImageConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
      if (parentObject !== void 0 && fromOutputGcsUri != null) {
        setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
      }
      const fromNegativePrompt = getValueByPath(fromObject, [
        "negativePrompt"
      ]);
      if (parentObject !== void 0 && fromNegativePrompt != null) {
        setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
      }
      const fromNumberOfImages = getValueByPath(fromObject, [
        "numberOfImages"
      ]);
      if (parentObject !== void 0 && fromNumberOfImages != null) {
        setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
      }
      const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
      if (parentObject !== void 0 && fromAspectRatio != null) {
        setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
      }
      const fromGuidanceScale = getValueByPath(fromObject, [
        "guidanceScale"
      ]);
      if (parentObject !== void 0 && fromGuidanceScale != null) {
        setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
      }
      const fromSeed = getValueByPath(fromObject, ["seed"]);
      if (parentObject !== void 0 && fromSeed != null) {
        setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
      }
      const fromSafetyFilterLevel = getValueByPath(fromObject, [
        "safetyFilterLevel"
      ]);
      if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
        setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
      }
      const fromPersonGeneration = getValueByPath(fromObject, [
        "personGeneration"
      ]);
      if (parentObject !== void 0 && fromPersonGeneration != null) {
        setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
      }
      const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
        "includeSafetyAttributes"
      ]);
      if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
        setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
      }
      const fromIncludeRaiReason = getValueByPath(fromObject, [
        "includeRaiReason"
      ]);
      if (parentObject !== void 0 && fromIncludeRaiReason != null) {
        setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
      }
      const fromLanguage = getValueByPath(fromObject, ["language"]);
      if (parentObject !== void 0 && fromLanguage != null) {
        setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
      }
      const fromOutputMimeType = getValueByPath(fromObject, [
        "outputMimeType"
      ]);
      if (parentObject !== void 0 && fromOutputMimeType != null) {
        setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
      }
      const fromOutputCompressionQuality = getValueByPath(fromObject, [
        "outputCompressionQuality"
      ]);
      if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
        setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
      }
      const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
      if (parentObject !== void 0 && fromAddWatermark != null) {
        setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
      }
      const fromLabels = getValueByPath(fromObject, ["labels"]);
      if (parentObject !== void 0 && fromLabels != null) {
        setValueByPath(parentObject, ["labels"], fromLabels);
      }
      const fromEditMode = getValueByPath(fromObject, ["editMode"]);
      if (parentObject !== void 0 && fromEditMode != null) {
        setValueByPath(parentObject, ["parameters", "editMode"], fromEditMode);
      }
      const fromBaseSteps = getValueByPath(fromObject, ["baseSteps"]);
      if (parentObject !== void 0 && fromBaseSteps != null) {
        setValueByPath(parentObject, ["parameters", "editConfig", "baseSteps"], fromBaseSteps);
      }
      return toObject;
    }
    function editImageParametersInternalToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromPrompt = getValueByPath(fromObject, ["prompt"]);
      if (fromPrompt != null) {
        setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
      }
      const fromReferenceImages = getValueByPath(fromObject, [
        "referenceImages"
      ]);
      if (fromReferenceImages != null) {
        let transformedList = fromReferenceImages;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return referenceImageAPIInternalToVertex(item);
          });
        }
        setValueByPath(toObject, ["instances[0]", "referenceImages"], transformedList);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        editImageConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function editImageResponseFromVertex(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromGeneratedImages = getValueByPath(fromObject, [
        "predictions"
      ]);
      if (fromGeneratedImages != null) {
        let transformedList = fromGeneratedImages;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return generatedImageFromVertex(item);
          });
        }
        setValueByPath(toObject, ["generatedImages"], transformedList);
      }
      return toObject;
    }
    function embedContentConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromTaskType = getValueByPath(fromObject, ["taskType"]);
      if (parentObject !== void 0 && fromTaskType != null) {
        setValueByPath(parentObject, ["requests[]", "taskType"], fromTaskType);
      }
      const fromTitle = getValueByPath(fromObject, ["title"]);
      if (parentObject !== void 0 && fromTitle != null) {
        setValueByPath(parentObject, ["requests[]", "title"], fromTitle);
      }
      const fromOutputDimensionality = getValueByPath(fromObject, [
        "outputDimensionality"
      ]);
      if (parentObject !== void 0 && fromOutputDimensionality != null) {
        setValueByPath(parentObject, ["requests[]", "outputDimensionality"], fromOutputDimensionality);
      }
      if (getValueByPath(fromObject, ["mimeType"]) !== void 0) {
        throw new Error("mimeType parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["autoTruncate"]) !== void 0) {
        throw new Error("autoTruncate parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function embedContentConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromTaskType = getValueByPath(fromObject, ["taskType"]);
      if (parentObject !== void 0 && fromTaskType != null) {
        setValueByPath(parentObject, ["instances[]", "task_type"], fromTaskType);
      }
      const fromTitle = getValueByPath(fromObject, ["title"]);
      if (parentObject !== void 0 && fromTitle != null) {
        setValueByPath(parentObject, ["instances[]", "title"], fromTitle);
      }
      const fromOutputDimensionality = getValueByPath(fromObject, [
        "outputDimensionality"
      ]);
      if (parentObject !== void 0 && fromOutputDimensionality != null) {
        setValueByPath(parentObject, ["parameters", "outputDimensionality"], fromOutputDimensionality);
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (parentObject !== void 0 && fromMimeType != null) {
        setValueByPath(parentObject, ["instances[]", "mimeType"], fromMimeType);
      }
      const fromAutoTruncate = getValueByPath(fromObject, ["autoTruncate"]);
      if (parentObject !== void 0 && fromAutoTruncate != null) {
        setValueByPath(parentObject, ["parameters", "autoTruncate"], fromAutoTruncate);
      }
      return toObject;
    }
    function embedContentParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromContents = getValueByPath(fromObject, ["contents"]);
      if (fromContents != null) {
        let transformedList = tContentsForEmbed(apiClient, fromContents);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["requests[]", "content"], transformedList);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        embedContentConfigToMldev(fromConfig, toObject);
      }
      const fromModelForEmbedContent = getValueByPath(fromObject, ["model"]);
      if (fromModelForEmbedContent !== void 0) {
        setValueByPath(toObject, ["requests[]", "model"], tModel(apiClient, fromModelForEmbedContent));
      }
      return toObject;
    }
    function embedContentParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromContents = getValueByPath(fromObject, ["contents"]);
      if (fromContents != null) {
        let transformedList = tContentsForEmbed(apiClient, fromContents);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["instances[]", "content"], transformedList);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        embedContentConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function embedContentResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromEmbeddings = getValueByPath(fromObject, ["embeddings"]);
      if (fromEmbeddings != null) {
        let transformedList = fromEmbeddings;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["embeddings"], transformedList);
      }
      const fromMetadata = getValueByPath(fromObject, ["metadata"]);
      if (fromMetadata != null) {
        setValueByPath(toObject, ["metadata"], fromMetadata);
      }
      return toObject;
    }
    function embedContentResponseFromVertex(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromEmbeddings = getValueByPath(fromObject, [
        "predictions[]",
        "embeddings"
      ]);
      if (fromEmbeddings != null) {
        let transformedList = fromEmbeddings;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return contentEmbeddingFromVertex(item);
          });
        }
        setValueByPath(toObject, ["embeddings"], transformedList);
      }
      const fromMetadata = getValueByPath(fromObject, ["metadata"]);
      if (fromMetadata != null) {
        setValueByPath(toObject, ["metadata"], fromMetadata);
      }
      return toObject;
    }
    function endpointFromVertex(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["endpoint"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromDeployedModelId = getValueByPath(fromObject, [
        "deployedModelId"
      ]);
      if (fromDeployedModelId != null) {
        setValueByPath(toObject, ["deployedModelId"], fromDeployedModelId);
      }
      return toObject;
    }
    function fileDataToMldev$1(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
        throw new Error("displayName parameter is not supported in Gemini API.");
      }
      const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
      if (fromFileUri != null) {
        setValueByPath(toObject, ["fileUri"], fromFileUri);
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function functionCallToMldev$1(fromObject) {
      const toObject = {};
      const fromId = getValueByPath(fromObject, ["id"]);
      if (fromId != null) {
        setValueByPath(toObject, ["id"], fromId);
      }
      const fromArgs = getValueByPath(fromObject, ["args"]);
      if (fromArgs != null) {
        setValueByPath(toObject, ["args"], fromArgs);
      }
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
        throw new Error("partialArgs parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
        throw new Error("willContinue parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function functionCallingConfigToMldev(fromObject) {
      const toObject = {};
      const fromMode = getValueByPath(fromObject, ["mode"]);
      if (fromMode != null) {
        setValueByPath(toObject, ["mode"], fromMode);
      }
      const fromAllowedFunctionNames = getValueByPath(fromObject, [
        "allowedFunctionNames"
      ]);
      if (fromAllowedFunctionNames != null) {
        setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
      }
      if (getValueByPath(fromObject, ["streamFunctionCallArguments"]) !== void 0) {
        throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function functionDeclarationToVertex(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
        throw new Error("behavior parameter is not supported in Vertex AI.");
      }
      const fromDescription = getValueByPath(fromObject, ["description"]);
      if (fromDescription != null) {
        setValueByPath(toObject, ["description"], fromDescription);
      }
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromParameters = getValueByPath(fromObject, ["parameters"]);
      if (fromParameters != null) {
        setValueByPath(toObject, ["parameters"], fromParameters);
      }
      const fromParametersJsonSchema = getValueByPath(fromObject, [
        "parametersJsonSchema"
      ]);
      if (fromParametersJsonSchema != null) {
        setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
      }
      const fromResponse = getValueByPath(fromObject, ["response"]);
      if (fromResponse != null) {
        setValueByPath(toObject, ["response"], fromResponse);
      }
      const fromResponseJsonSchema = getValueByPath(fromObject, [
        "responseJsonSchema"
      ]);
      if (fromResponseJsonSchema != null) {
        setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
      }
      return toObject;
    }
    function generateContentConfigToMldev(apiClient, fromObject, parentObject) {
      const toObject = {};
      const fromSystemInstruction = getValueByPath(fromObject, [
        "systemInstruction"
      ]);
      if (parentObject !== void 0 && fromSystemInstruction != null) {
        setValueByPath(parentObject, ["systemInstruction"], contentToMldev$1(tContent(fromSystemInstruction)));
      }
      const fromTemperature = getValueByPath(fromObject, ["temperature"]);
      if (fromTemperature != null) {
        setValueByPath(toObject, ["temperature"], fromTemperature);
      }
      const fromTopP = getValueByPath(fromObject, ["topP"]);
      if (fromTopP != null) {
        setValueByPath(toObject, ["topP"], fromTopP);
      }
      const fromTopK = getValueByPath(fromObject, ["topK"]);
      if (fromTopK != null) {
        setValueByPath(toObject, ["topK"], fromTopK);
      }
      const fromCandidateCount = getValueByPath(fromObject, [
        "candidateCount"
      ]);
      if (fromCandidateCount != null) {
        setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
      }
      const fromMaxOutputTokens = getValueByPath(fromObject, [
        "maxOutputTokens"
      ]);
      if (fromMaxOutputTokens != null) {
        setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
      }
      const fromStopSequences = getValueByPath(fromObject, [
        "stopSequences"
      ]);
      if (fromStopSequences != null) {
        setValueByPath(toObject, ["stopSequences"], fromStopSequences);
      }
      const fromResponseLogprobs = getValueByPath(fromObject, [
        "responseLogprobs"
      ]);
      if (fromResponseLogprobs != null) {
        setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
      }
      const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
      if (fromLogprobs != null) {
        setValueByPath(toObject, ["logprobs"], fromLogprobs);
      }
      const fromPresencePenalty = getValueByPath(fromObject, [
        "presencePenalty"
      ]);
      if (fromPresencePenalty != null) {
        setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
      }
      const fromFrequencyPenalty = getValueByPath(fromObject, [
        "frequencyPenalty"
      ]);
      if (fromFrequencyPenalty != null) {
        setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
      }
      const fromSeed = getValueByPath(fromObject, ["seed"]);
      if (fromSeed != null) {
        setValueByPath(toObject, ["seed"], fromSeed);
      }
      const fromResponseMimeType = getValueByPath(fromObject, [
        "responseMimeType"
      ]);
      if (fromResponseMimeType != null) {
        setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
      }
      const fromResponseSchema = getValueByPath(fromObject, [
        "responseSchema"
      ]);
      if (fromResponseSchema != null) {
        setValueByPath(toObject, ["responseSchema"], tSchema(fromResponseSchema));
      }
      const fromResponseJsonSchema = getValueByPath(fromObject, [
        "responseJsonSchema"
      ]);
      if (fromResponseJsonSchema != null) {
        setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
      }
      if (getValueByPath(fromObject, ["routingConfig"]) !== void 0) {
        throw new Error("routingConfig parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["modelSelectionConfig"]) !== void 0) {
        throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
      }
      const fromSafetySettings = getValueByPath(fromObject, [
        "safetySettings"
      ]);
      if (parentObject !== void 0 && fromSafetySettings != null) {
        let transformedList = fromSafetySettings;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return safetySettingToMldev(item);
          });
        }
        setValueByPath(parentObject, ["safetySettings"], transformedList);
      }
      const fromTools = getValueByPath(fromObject, ["tools"]);
      if (parentObject !== void 0 && fromTools != null) {
        let transformedList = tTools(fromTools);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return toolToMldev$1(tTool(item));
          });
        }
        setValueByPath(parentObject, ["tools"], transformedList);
      }
      const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
      if (parentObject !== void 0 && fromToolConfig != null) {
        setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev(fromToolConfig));
      }
      if (getValueByPath(fromObject, ["labels"]) !== void 0) {
        throw new Error("labels parameter is not supported in Gemini API.");
      }
      const fromCachedContent = getValueByPath(fromObject, [
        "cachedContent"
      ]);
      if (parentObject !== void 0 && fromCachedContent != null) {
        setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
      }
      const fromResponseModalities = getValueByPath(fromObject, [
        "responseModalities"
      ]);
      if (fromResponseModalities != null) {
        setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
      }
      const fromMediaResolution = getValueByPath(fromObject, [
        "mediaResolution"
      ]);
      if (fromMediaResolution != null) {
        setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
      }
      const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
      if (fromSpeechConfig != null) {
        setValueByPath(toObject, ["speechConfig"], tSpeechConfig(fromSpeechConfig));
      }
      if (getValueByPath(fromObject, ["audioTimestamp"]) !== void 0) {
        throw new Error("audioTimestamp parameter is not supported in Gemini API.");
      }
      const fromThinkingConfig = getValueByPath(fromObject, [
        "thinkingConfig"
      ]);
      if (fromThinkingConfig != null) {
        setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
      }
      const fromImageConfig = getValueByPath(fromObject, ["imageConfig"]);
      if (fromImageConfig != null) {
        setValueByPath(toObject, ["imageConfig"], imageConfigToMldev(fromImageConfig));
      }
      return toObject;
    }
    function generateContentConfigToVertex(apiClient, fromObject, parentObject) {
      const toObject = {};
      const fromSystemInstruction = getValueByPath(fromObject, [
        "systemInstruction"
      ]);
      if (parentObject !== void 0 && fromSystemInstruction != null) {
        setValueByPath(parentObject, ["systemInstruction"], tContent(fromSystemInstruction));
      }
      const fromTemperature = getValueByPath(fromObject, ["temperature"]);
      if (fromTemperature != null) {
        setValueByPath(toObject, ["temperature"], fromTemperature);
      }
      const fromTopP = getValueByPath(fromObject, ["topP"]);
      if (fromTopP != null) {
        setValueByPath(toObject, ["topP"], fromTopP);
      }
      const fromTopK = getValueByPath(fromObject, ["topK"]);
      if (fromTopK != null) {
        setValueByPath(toObject, ["topK"], fromTopK);
      }
      const fromCandidateCount = getValueByPath(fromObject, [
        "candidateCount"
      ]);
      if (fromCandidateCount != null) {
        setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
      }
      const fromMaxOutputTokens = getValueByPath(fromObject, [
        "maxOutputTokens"
      ]);
      if (fromMaxOutputTokens != null) {
        setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
      }
      const fromStopSequences = getValueByPath(fromObject, [
        "stopSequences"
      ]);
      if (fromStopSequences != null) {
        setValueByPath(toObject, ["stopSequences"], fromStopSequences);
      }
      const fromResponseLogprobs = getValueByPath(fromObject, [
        "responseLogprobs"
      ]);
      if (fromResponseLogprobs != null) {
        setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
      }
      const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
      if (fromLogprobs != null) {
        setValueByPath(toObject, ["logprobs"], fromLogprobs);
      }
      const fromPresencePenalty = getValueByPath(fromObject, [
        "presencePenalty"
      ]);
      if (fromPresencePenalty != null) {
        setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
      }
      const fromFrequencyPenalty = getValueByPath(fromObject, [
        "frequencyPenalty"
      ]);
      if (fromFrequencyPenalty != null) {
        setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
      }
      const fromSeed = getValueByPath(fromObject, ["seed"]);
      if (fromSeed != null) {
        setValueByPath(toObject, ["seed"], fromSeed);
      }
      const fromResponseMimeType = getValueByPath(fromObject, [
        "responseMimeType"
      ]);
      if (fromResponseMimeType != null) {
        setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
      }
      const fromResponseSchema = getValueByPath(fromObject, [
        "responseSchema"
      ]);
      if (fromResponseSchema != null) {
        setValueByPath(toObject, ["responseSchema"], tSchema(fromResponseSchema));
      }
      const fromResponseJsonSchema = getValueByPath(fromObject, [
        "responseJsonSchema"
      ]);
      if (fromResponseJsonSchema != null) {
        setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
      }
      const fromRoutingConfig = getValueByPath(fromObject, [
        "routingConfig"
      ]);
      if (fromRoutingConfig != null) {
        setValueByPath(toObject, ["routingConfig"], fromRoutingConfig);
      }
      const fromModelSelectionConfig = getValueByPath(fromObject, [
        "modelSelectionConfig"
      ]);
      if (fromModelSelectionConfig != null) {
        setValueByPath(toObject, ["modelConfig"], fromModelSelectionConfig);
      }
      const fromSafetySettings = getValueByPath(fromObject, [
        "safetySettings"
      ]);
      if (parentObject !== void 0 && fromSafetySettings != null) {
        let transformedList = fromSafetySettings;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(parentObject, ["safetySettings"], transformedList);
      }
      const fromTools = getValueByPath(fromObject, ["tools"]);
      if (parentObject !== void 0 && fromTools != null) {
        let transformedList = tTools(fromTools);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return toolToVertex(tTool(item));
          });
        }
        setValueByPath(parentObject, ["tools"], transformedList);
      }
      const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
      if (parentObject !== void 0 && fromToolConfig != null) {
        setValueByPath(parentObject, ["toolConfig"], fromToolConfig);
      }
      const fromLabels = getValueByPath(fromObject, ["labels"]);
      if (parentObject !== void 0 && fromLabels != null) {
        setValueByPath(parentObject, ["labels"], fromLabels);
      }
      const fromCachedContent = getValueByPath(fromObject, [
        "cachedContent"
      ]);
      if (parentObject !== void 0 && fromCachedContent != null) {
        setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
      }
      const fromResponseModalities = getValueByPath(fromObject, [
        "responseModalities"
      ]);
      if (fromResponseModalities != null) {
        setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
      }
      const fromMediaResolution = getValueByPath(fromObject, [
        "mediaResolution"
      ]);
      if (fromMediaResolution != null) {
        setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
      }
      const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
      if (fromSpeechConfig != null) {
        setValueByPath(toObject, ["speechConfig"], speechConfigToVertex(tSpeechConfig(fromSpeechConfig)));
      }
      const fromAudioTimestamp = getValueByPath(fromObject, [
        "audioTimestamp"
      ]);
      if (fromAudioTimestamp != null) {
        setValueByPath(toObject, ["audioTimestamp"], fromAudioTimestamp);
      }
      const fromThinkingConfig = getValueByPath(fromObject, [
        "thinkingConfig"
      ]);
      if (fromThinkingConfig != null) {
        setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
      }
      const fromImageConfig = getValueByPath(fromObject, ["imageConfig"]);
      if (fromImageConfig != null) {
        setValueByPath(toObject, ["imageConfig"], imageConfigToVertex(fromImageConfig));
      }
      return toObject;
    }
    function generateContentParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromContents = getValueByPath(fromObject, ["contents"]);
      if (fromContents != null) {
        let transformedList = tContents(fromContents);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return contentToMldev$1(item);
          });
        }
        setValueByPath(toObject, ["contents"], transformedList);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        setValueByPath(toObject, ["generationConfig"], generateContentConfigToMldev(apiClient, fromConfig, toObject));
      }
      return toObject;
    }
    function generateContentParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromContents = getValueByPath(fromObject, ["contents"]);
      if (fromContents != null) {
        let transformedList = tContents(fromContents);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["contents"], transformedList);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        setValueByPath(toObject, ["generationConfig"], generateContentConfigToVertex(apiClient, fromConfig, toObject));
      }
      return toObject;
    }
    function generateContentResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromCandidates = getValueByPath(fromObject, ["candidates"]);
      if (fromCandidates != null) {
        let transformedList = fromCandidates;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return candidateFromMldev(item);
          });
        }
        setValueByPath(toObject, ["candidates"], transformedList);
      }
      const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
      if (fromModelVersion != null) {
        setValueByPath(toObject, ["modelVersion"], fromModelVersion);
      }
      const fromPromptFeedback = getValueByPath(fromObject, [
        "promptFeedback"
      ]);
      if (fromPromptFeedback != null) {
        setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
      }
      const fromResponseId = getValueByPath(fromObject, ["responseId"]);
      if (fromResponseId != null) {
        setValueByPath(toObject, ["responseId"], fromResponseId);
      }
      const fromUsageMetadata = getValueByPath(fromObject, [
        "usageMetadata"
      ]);
      if (fromUsageMetadata != null) {
        setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
      }
      return toObject;
    }
    function generateContentResponseFromVertex(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromCandidates = getValueByPath(fromObject, ["candidates"]);
      if (fromCandidates != null) {
        let transformedList = fromCandidates;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["candidates"], transformedList);
      }
      const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
      if (fromCreateTime != null) {
        setValueByPath(toObject, ["createTime"], fromCreateTime);
      }
      const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
      if (fromModelVersion != null) {
        setValueByPath(toObject, ["modelVersion"], fromModelVersion);
      }
      const fromPromptFeedback = getValueByPath(fromObject, [
        "promptFeedback"
      ]);
      if (fromPromptFeedback != null) {
        setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
      }
      const fromResponseId = getValueByPath(fromObject, ["responseId"]);
      if (fromResponseId != null) {
        setValueByPath(toObject, ["responseId"], fromResponseId);
      }
      const fromUsageMetadata = getValueByPath(fromObject, [
        "usageMetadata"
      ]);
      if (fromUsageMetadata != null) {
        setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
      }
      return toObject;
    }
    function generateImagesConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["outputGcsUri"]) !== void 0) {
        throw new Error("outputGcsUri parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["negativePrompt"]) !== void 0) {
        throw new Error("negativePrompt parameter is not supported in Gemini API.");
      }
      const fromNumberOfImages = getValueByPath(fromObject, [
        "numberOfImages"
      ]);
      if (parentObject !== void 0 && fromNumberOfImages != null) {
        setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
      }
      const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
      if (parentObject !== void 0 && fromAspectRatio != null) {
        setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
      }
      const fromGuidanceScale = getValueByPath(fromObject, [
        "guidanceScale"
      ]);
      if (parentObject !== void 0 && fromGuidanceScale != null) {
        setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
      }
      if (getValueByPath(fromObject, ["seed"]) !== void 0) {
        throw new Error("seed parameter is not supported in Gemini API.");
      }
      const fromSafetyFilterLevel = getValueByPath(fromObject, [
        "safetyFilterLevel"
      ]);
      if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
        setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
      }
      const fromPersonGeneration = getValueByPath(fromObject, [
        "personGeneration"
      ]);
      if (parentObject !== void 0 && fromPersonGeneration != null) {
        setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
      }
      const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
        "includeSafetyAttributes"
      ]);
      if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
        setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
      }
      const fromIncludeRaiReason = getValueByPath(fromObject, [
        "includeRaiReason"
      ]);
      if (parentObject !== void 0 && fromIncludeRaiReason != null) {
        setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
      }
      const fromLanguage = getValueByPath(fromObject, ["language"]);
      if (parentObject !== void 0 && fromLanguage != null) {
        setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
      }
      const fromOutputMimeType = getValueByPath(fromObject, [
        "outputMimeType"
      ]);
      if (parentObject !== void 0 && fromOutputMimeType != null) {
        setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
      }
      const fromOutputCompressionQuality = getValueByPath(fromObject, [
        "outputCompressionQuality"
      ]);
      if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
        setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
      }
      if (getValueByPath(fromObject, ["addWatermark"]) !== void 0) {
        throw new Error("addWatermark parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["labels"]) !== void 0) {
        throw new Error("labels parameter is not supported in Gemini API.");
      }
      const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
      if (parentObject !== void 0 && fromImageSize != null) {
        setValueByPath(parentObject, ["parameters", "sampleImageSize"], fromImageSize);
      }
      if (getValueByPath(fromObject, ["enhancePrompt"]) !== void 0) {
        throw new Error("enhancePrompt parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function generateImagesConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
      if (parentObject !== void 0 && fromOutputGcsUri != null) {
        setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
      }
      const fromNegativePrompt = getValueByPath(fromObject, [
        "negativePrompt"
      ]);
      if (parentObject !== void 0 && fromNegativePrompt != null) {
        setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
      }
      const fromNumberOfImages = getValueByPath(fromObject, [
        "numberOfImages"
      ]);
      if (parentObject !== void 0 && fromNumberOfImages != null) {
        setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
      }
      const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
      if (parentObject !== void 0 && fromAspectRatio != null) {
        setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
      }
      const fromGuidanceScale = getValueByPath(fromObject, [
        "guidanceScale"
      ]);
      if (parentObject !== void 0 && fromGuidanceScale != null) {
        setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
      }
      const fromSeed = getValueByPath(fromObject, ["seed"]);
      if (parentObject !== void 0 && fromSeed != null) {
        setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
      }
      const fromSafetyFilterLevel = getValueByPath(fromObject, [
        "safetyFilterLevel"
      ]);
      if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
        setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
      }
      const fromPersonGeneration = getValueByPath(fromObject, [
        "personGeneration"
      ]);
      if (parentObject !== void 0 && fromPersonGeneration != null) {
        setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
      }
      const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
        "includeSafetyAttributes"
      ]);
      if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
        setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
      }
      const fromIncludeRaiReason = getValueByPath(fromObject, [
        "includeRaiReason"
      ]);
      if (parentObject !== void 0 && fromIncludeRaiReason != null) {
        setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
      }
      const fromLanguage = getValueByPath(fromObject, ["language"]);
      if (parentObject !== void 0 && fromLanguage != null) {
        setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
      }
      const fromOutputMimeType = getValueByPath(fromObject, [
        "outputMimeType"
      ]);
      if (parentObject !== void 0 && fromOutputMimeType != null) {
        setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
      }
      const fromOutputCompressionQuality = getValueByPath(fromObject, [
        "outputCompressionQuality"
      ]);
      if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
        setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
      }
      const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
      if (parentObject !== void 0 && fromAddWatermark != null) {
        setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
      }
      const fromLabels = getValueByPath(fromObject, ["labels"]);
      if (parentObject !== void 0 && fromLabels != null) {
        setValueByPath(parentObject, ["labels"], fromLabels);
      }
      const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
      if (parentObject !== void 0 && fromImageSize != null) {
        setValueByPath(parentObject, ["parameters", "sampleImageSize"], fromImageSize);
      }
      const fromEnhancePrompt = getValueByPath(fromObject, [
        "enhancePrompt"
      ]);
      if (parentObject !== void 0 && fromEnhancePrompt != null) {
        setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
      }
      return toObject;
    }
    function generateImagesParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromPrompt = getValueByPath(fromObject, ["prompt"]);
      if (fromPrompt != null) {
        setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        generateImagesConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function generateImagesParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromPrompt = getValueByPath(fromObject, ["prompt"]);
      if (fromPrompt != null) {
        setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        generateImagesConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function generateImagesResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromGeneratedImages = getValueByPath(fromObject, [
        "predictions"
      ]);
      if (fromGeneratedImages != null) {
        let transformedList = fromGeneratedImages;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return generatedImageFromMldev(item);
          });
        }
        setValueByPath(toObject, ["generatedImages"], transformedList);
      }
      const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [
        "positivePromptSafetyAttributes"
      ]);
      if (fromPositivePromptSafetyAttributes != null) {
        setValueByPath(toObject, ["positivePromptSafetyAttributes"], safetyAttributesFromMldev(fromPositivePromptSafetyAttributes));
      }
      return toObject;
    }
    function generateImagesResponseFromVertex(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromGeneratedImages = getValueByPath(fromObject, [
        "predictions"
      ]);
      if (fromGeneratedImages != null) {
        let transformedList = fromGeneratedImages;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return generatedImageFromVertex(item);
          });
        }
        setValueByPath(toObject, ["generatedImages"], transformedList);
      }
      const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [
        "positivePromptSafetyAttributes"
      ]);
      if (fromPositivePromptSafetyAttributes != null) {
        setValueByPath(toObject, ["positivePromptSafetyAttributes"], safetyAttributesFromVertex(fromPositivePromptSafetyAttributes));
      }
      return toObject;
    }
    function generateVideosConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromNumberOfVideos = getValueByPath(fromObject, [
        "numberOfVideos"
      ]);
      if (parentObject !== void 0 && fromNumberOfVideos != null) {
        setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfVideos);
      }
      if (getValueByPath(fromObject, ["outputGcsUri"]) !== void 0) {
        throw new Error("outputGcsUri parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["fps"]) !== void 0) {
        throw new Error("fps parameter is not supported in Gemini API.");
      }
      const fromDurationSeconds = getValueByPath(fromObject, [
        "durationSeconds"
      ]);
      if (parentObject !== void 0 && fromDurationSeconds != null) {
        setValueByPath(parentObject, ["parameters", "durationSeconds"], fromDurationSeconds);
      }
      if (getValueByPath(fromObject, ["seed"]) !== void 0) {
        throw new Error("seed parameter is not supported in Gemini API.");
      }
      const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
      if (parentObject !== void 0 && fromAspectRatio != null) {
        setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
      }
      const fromResolution = getValueByPath(fromObject, ["resolution"]);
      if (parentObject !== void 0 && fromResolution != null) {
        setValueByPath(parentObject, ["parameters", "resolution"], fromResolution);
      }
      const fromPersonGeneration = getValueByPath(fromObject, [
        "personGeneration"
      ]);
      if (parentObject !== void 0 && fromPersonGeneration != null) {
        setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
      }
      if (getValueByPath(fromObject, ["pubsubTopic"]) !== void 0) {
        throw new Error("pubsubTopic parameter is not supported in Gemini API.");
      }
      const fromNegativePrompt = getValueByPath(fromObject, [
        "negativePrompt"
      ]);
      if (parentObject !== void 0 && fromNegativePrompt != null) {
        setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
      }
      const fromEnhancePrompt = getValueByPath(fromObject, [
        "enhancePrompt"
      ]);
      if (parentObject !== void 0 && fromEnhancePrompt != null) {
        setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
      }
      if (getValueByPath(fromObject, ["generateAudio"]) !== void 0) {
        throw new Error("generateAudio parameter is not supported in Gemini API.");
      }
      const fromLastFrame = getValueByPath(fromObject, ["lastFrame"]);
      if (parentObject !== void 0 && fromLastFrame != null) {
        setValueByPath(parentObject, ["instances[0]", "lastFrame"], imageToMldev(fromLastFrame));
      }
      const fromReferenceImages = getValueByPath(fromObject, [
        "referenceImages"
      ]);
      if (parentObject !== void 0 && fromReferenceImages != null) {
        let transformedList = fromReferenceImages;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return videoGenerationReferenceImageToMldev(item);
          });
        }
        setValueByPath(parentObject, ["instances[0]", "referenceImages"], transformedList);
      }
      if (getValueByPath(fromObject, ["mask"]) !== void 0) {
        throw new Error("mask parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["compressionQuality"]) !== void 0) {
        throw new Error("compressionQuality parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function generateVideosConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromNumberOfVideos = getValueByPath(fromObject, [
        "numberOfVideos"
      ]);
      if (parentObject !== void 0 && fromNumberOfVideos != null) {
        setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfVideos);
      }
      const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
      if (parentObject !== void 0 && fromOutputGcsUri != null) {
        setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
      }
      const fromFps = getValueByPath(fromObject, ["fps"]);
      if (parentObject !== void 0 && fromFps != null) {
        setValueByPath(parentObject, ["parameters", "fps"], fromFps);
      }
      const fromDurationSeconds = getValueByPath(fromObject, [
        "durationSeconds"
      ]);
      if (parentObject !== void 0 && fromDurationSeconds != null) {
        setValueByPath(parentObject, ["parameters", "durationSeconds"], fromDurationSeconds);
      }
      const fromSeed = getValueByPath(fromObject, ["seed"]);
      if (parentObject !== void 0 && fromSeed != null) {
        setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
      }
      const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
      if (parentObject !== void 0 && fromAspectRatio != null) {
        setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
      }
      const fromResolution = getValueByPath(fromObject, ["resolution"]);
      if (parentObject !== void 0 && fromResolution != null) {
        setValueByPath(parentObject, ["parameters", "resolution"], fromResolution);
      }
      const fromPersonGeneration = getValueByPath(fromObject, [
        "personGeneration"
      ]);
      if (parentObject !== void 0 && fromPersonGeneration != null) {
        setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
      }
      const fromPubsubTopic = getValueByPath(fromObject, ["pubsubTopic"]);
      if (parentObject !== void 0 && fromPubsubTopic != null) {
        setValueByPath(parentObject, ["parameters", "pubsubTopic"], fromPubsubTopic);
      }
      const fromNegativePrompt = getValueByPath(fromObject, [
        "negativePrompt"
      ]);
      if (parentObject !== void 0 && fromNegativePrompt != null) {
        setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
      }
      const fromEnhancePrompt = getValueByPath(fromObject, [
        "enhancePrompt"
      ]);
      if (parentObject !== void 0 && fromEnhancePrompt != null) {
        setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
      }
      const fromGenerateAudio = getValueByPath(fromObject, [
        "generateAudio"
      ]);
      if (parentObject !== void 0 && fromGenerateAudio != null) {
        setValueByPath(parentObject, ["parameters", "generateAudio"], fromGenerateAudio);
      }
      const fromLastFrame = getValueByPath(fromObject, ["lastFrame"]);
      if (parentObject !== void 0 && fromLastFrame != null) {
        setValueByPath(parentObject, ["instances[0]", "lastFrame"], imageToVertex(fromLastFrame));
      }
      const fromReferenceImages = getValueByPath(fromObject, [
        "referenceImages"
      ]);
      if (parentObject !== void 0 && fromReferenceImages != null) {
        let transformedList = fromReferenceImages;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return videoGenerationReferenceImageToVertex(item);
          });
        }
        setValueByPath(parentObject, ["instances[0]", "referenceImages"], transformedList);
      }
      const fromMask = getValueByPath(fromObject, ["mask"]);
      if (parentObject !== void 0 && fromMask != null) {
        setValueByPath(parentObject, ["instances[0]", "mask"], videoGenerationMaskToVertex(fromMask));
      }
      const fromCompressionQuality = getValueByPath(fromObject, [
        "compressionQuality"
      ]);
      if (parentObject !== void 0 && fromCompressionQuality != null) {
        setValueByPath(parentObject, ["parameters", "compressionQuality"], fromCompressionQuality);
      }
      return toObject;
    }
    function generateVideosOperationFromMldev(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromMetadata = getValueByPath(fromObject, ["metadata"]);
      if (fromMetadata != null) {
        setValueByPath(toObject, ["metadata"], fromMetadata);
      }
      const fromDone = getValueByPath(fromObject, ["done"]);
      if (fromDone != null) {
        setValueByPath(toObject, ["done"], fromDone);
      }
      const fromError = getValueByPath(fromObject, ["error"]);
      if (fromError != null) {
        setValueByPath(toObject, ["error"], fromError);
      }
      const fromResponse = getValueByPath(fromObject, [
        "response",
        "generateVideoResponse"
      ]);
      if (fromResponse != null) {
        setValueByPath(toObject, ["response"], generateVideosResponseFromMldev(fromResponse));
      }
      return toObject;
    }
    function generateVideosOperationFromVertex(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromMetadata = getValueByPath(fromObject, ["metadata"]);
      if (fromMetadata != null) {
        setValueByPath(toObject, ["metadata"], fromMetadata);
      }
      const fromDone = getValueByPath(fromObject, ["done"]);
      if (fromDone != null) {
        setValueByPath(toObject, ["done"], fromDone);
      }
      const fromError = getValueByPath(fromObject, ["error"]);
      if (fromError != null) {
        setValueByPath(toObject, ["error"], fromError);
      }
      const fromResponse = getValueByPath(fromObject, ["response"]);
      if (fromResponse != null) {
        setValueByPath(toObject, ["response"], generateVideosResponseFromVertex(fromResponse));
      }
      return toObject;
    }
    function generateVideosParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromPrompt = getValueByPath(fromObject, ["prompt"]);
      if (fromPrompt != null) {
        setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
      }
      const fromImage = getValueByPath(fromObject, ["image"]);
      if (fromImage != null) {
        setValueByPath(toObject, ["instances[0]", "image"], imageToMldev(fromImage));
      }
      const fromVideo = getValueByPath(fromObject, ["video"]);
      if (fromVideo != null) {
        setValueByPath(toObject, ["instances[0]", "video"], videoToMldev(fromVideo));
      }
      const fromSource = getValueByPath(fromObject, ["source"]);
      if (fromSource != null) {
        generateVideosSourceToMldev(fromSource, toObject);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        generateVideosConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function generateVideosParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromPrompt = getValueByPath(fromObject, ["prompt"]);
      if (fromPrompt != null) {
        setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
      }
      const fromImage = getValueByPath(fromObject, ["image"]);
      if (fromImage != null) {
        setValueByPath(toObject, ["instances[0]", "image"], imageToVertex(fromImage));
      }
      const fromVideo = getValueByPath(fromObject, ["video"]);
      if (fromVideo != null) {
        setValueByPath(toObject, ["instances[0]", "video"], videoToVertex(fromVideo));
      }
      const fromSource = getValueByPath(fromObject, ["source"]);
      if (fromSource != null) {
        generateVideosSourceToVertex(fromSource, toObject);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        generateVideosConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function generateVideosResponseFromMldev(fromObject) {
      const toObject = {};
      const fromGeneratedVideos = getValueByPath(fromObject, [
        "generatedSamples"
      ]);
      if (fromGeneratedVideos != null) {
        let transformedList = fromGeneratedVideos;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return generatedVideoFromMldev(item);
          });
        }
        setValueByPath(toObject, ["generatedVideos"], transformedList);
      }
      const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
        "raiMediaFilteredCount"
      ]);
      if (fromRaiMediaFilteredCount != null) {
        setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
      }
      const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
        "raiMediaFilteredReasons"
      ]);
      if (fromRaiMediaFilteredReasons != null) {
        setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
      }
      return toObject;
    }
    function generateVideosResponseFromVertex(fromObject) {
      const toObject = {};
      const fromGeneratedVideos = getValueByPath(fromObject, ["videos"]);
      if (fromGeneratedVideos != null) {
        let transformedList = fromGeneratedVideos;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return generatedVideoFromVertex(item);
          });
        }
        setValueByPath(toObject, ["generatedVideos"], transformedList);
      }
      const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
        "raiMediaFilteredCount"
      ]);
      if (fromRaiMediaFilteredCount != null) {
        setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
      }
      const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
        "raiMediaFilteredReasons"
      ]);
      if (fromRaiMediaFilteredReasons != null) {
        setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
      }
      return toObject;
    }
    function generateVideosSourceToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromPrompt = getValueByPath(fromObject, ["prompt"]);
      if (parentObject !== void 0 && fromPrompt != null) {
        setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
      }
      const fromImage = getValueByPath(fromObject, ["image"]);
      if (parentObject !== void 0 && fromImage != null) {
        setValueByPath(parentObject, ["instances[0]", "image"], imageToMldev(fromImage));
      }
      const fromVideo = getValueByPath(fromObject, ["video"]);
      if (parentObject !== void 0 && fromVideo != null) {
        setValueByPath(parentObject, ["instances[0]", "video"], videoToMldev(fromVideo));
      }
      return toObject;
    }
    function generateVideosSourceToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromPrompt = getValueByPath(fromObject, ["prompt"]);
      if (parentObject !== void 0 && fromPrompt != null) {
        setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
      }
      const fromImage = getValueByPath(fromObject, ["image"]);
      if (parentObject !== void 0 && fromImage != null) {
        setValueByPath(parentObject, ["instances[0]", "image"], imageToVertex(fromImage));
      }
      const fromVideo = getValueByPath(fromObject, ["video"]);
      if (parentObject !== void 0 && fromVideo != null) {
        setValueByPath(parentObject, ["instances[0]", "video"], videoToVertex(fromVideo));
      }
      return toObject;
    }
    function generatedImageFromMldev(fromObject) {
      const toObject = {};
      const fromImage = getValueByPath(fromObject, ["_self"]);
      if (fromImage != null) {
        setValueByPath(toObject, ["image"], imageFromMldev(fromImage));
      }
      const fromRaiFilteredReason = getValueByPath(fromObject, [
        "raiFilteredReason"
      ]);
      if (fromRaiFilteredReason != null) {
        setValueByPath(toObject, ["raiFilteredReason"], fromRaiFilteredReason);
      }
      const fromSafetyAttributes = getValueByPath(fromObject, ["_self"]);
      if (fromSafetyAttributes != null) {
        setValueByPath(toObject, ["safetyAttributes"], safetyAttributesFromMldev(fromSafetyAttributes));
      }
      return toObject;
    }
    function generatedImageFromVertex(fromObject) {
      const toObject = {};
      const fromImage = getValueByPath(fromObject, ["_self"]);
      if (fromImage != null) {
        setValueByPath(toObject, ["image"], imageFromVertex(fromImage));
      }
      const fromRaiFilteredReason = getValueByPath(fromObject, [
        "raiFilteredReason"
      ]);
      if (fromRaiFilteredReason != null) {
        setValueByPath(toObject, ["raiFilteredReason"], fromRaiFilteredReason);
      }
      const fromSafetyAttributes = getValueByPath(fromObject, ["_self"]);
      if (fromSafetyAttributes != null) {
        setValueByPath(toObject, ["safetyAttributes"], safetyAttributesFromVertex(fromSafetyAttributes));
      }
      const fromEnhancedPrompt = getValueByPath(fromObject, ["prompt"]);
      if (fromEnhancedPrompt != null) {
        setValueByPath(toObject, ["enhancedPrompt"], fromEnhancedPrompt);
      }
      return toObject;
    }
    function generatedImageMaskFromVertex(fromObject) {
      const toObject = {};
      const fromMask = getValueByPath(fromObject, ["_self"]);
      if (fromMask != null) {
        setValueByPath(toObject, ["mask"], imageFromVertex(fromMask));
      }
      const fromLabels = getValueByPath(fromObject, ["labels"]);
      if (fromLabels != null) {
        let transformedList = fromLabels;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["labels"], transformedList);
      }
      return toObject;
    }
    function generatedVideoFromMldev(fromObject) {
      const toObject = {};
      const fromVideo = getValueByPath(fromObject, ["video"]);
      if (fromVideo != null) {
        setValueByPath(toObject, ["video"], videoFromMldev(fromVideo));
      }
      return toObject;
    }
    function generatedVideoFromVertex(fromObject) {
      const toObject = {};
      const fromVideo = getValueByPath(fromObject, ["_self"]);
      if (fromVideo != null) {
        setValueByPath(toObject, ["video"], videoFromVertex(fromVideo));
      }
      return toObject;
    }
    function generationConfigToVertex(fromObject) {
      const toObject = {};
      const fromModelSelectionConfig = getValueByPath(fromObject, [
        "modelSelectionConfig"
      ]);
      if (fromModelSelectionConfig != null) {
        setValueByPath(toObject, ["modelConfig"], fromModelSelectionConfig);
      }
      const fromResponseJsonSchema = getValueByPath(fromObject, [
        "responseJsonSchema"
      ]);
      if (fromResponseJsonSchema != null) {
        setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
      }
      const fromAudioTimestamp = getValueByPath(fromObject, [
        "audioTimestamp"
      ]);
      if (fromAudioTimestamp != null) {
        setValueByPath(toObject, ["audioTimestamp"], fromAudioTimestamp);
      }
      const fromCandidateCount = getValueByPath(fromObject, [
        "candidateCount"
      ]);
      if (fromCandidateCount != null) {
        setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
      }
      const fromEnableAffectiveDialog = getValueByPath(fromObject, [
        "enableAffectiveDialog"
      ]);
      if (fromEnableAffectiveDialog != null) {
        setValueByPath(toObject, ["enableAffectiveDialog"], fromEnableAffectiveDialog);
      }
      const fromFrequencyPenalty = getValueByPath(fromObject, [
        "frequencyPenalty"
      ]);
      if (fromFrequencyPenalty != null) {
        setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
      }
      const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
      if (fromLogprobs != null) {
        setValueByPath(toObject, ["logprobs"], fromLogprobs);
      }
      const fromMaxOutputTokens = getValueByPath(fromObject, [
        "maxOutputTokens"
      ]);
      if (fromMaxOutputTokens != null) {
        setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
      }
      const fromMediaResolution = getValueByPath(fromObject, [
        "mediaResolution"
      ]);
      if (fromMediaResolution != null) {
        setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
      }
      const fromPresencePenalty = getValueByPath(fromObject, [
        "presencePenalty"
      ]);
      if (fromPresencePenalty != null) {
        setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
      }
      const fromResponseLogprobs = getValueByPath(fromObject, [
        "responseLogprobs"
      ]);
      if (fromResponseLogprobs != null) {
        setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
      }
      const fromResponseMimeType = getValueByPath(fromObject, [
        "responseMimeType"
      ]);
      if (fromResponseMimeType != null) {
        setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
      }
      const fromResponseModalities = getValueByPath(fromObject, [
        "responseModalities"
      ]);
      if (fromResponseModalities != null) {
        setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
      }
      const fromResponseSchema = getValueByPath(fromObject, [
        "responseSchema"
      ]);
      if (fromResponseSchema != null) {
        setValueByPath(toObject, ["responseSchema"], fromResponseSchema);
      }
      const fromRoutingConfig = getValueByPath(fromObject, [
        "routingConfig"
      ]);
      if (fromRoutingConfig != null) {
        setValueByPath(toObject, ["routingConfig"], fromRoutingConfig);
      }
      const fromSeed = getValueByPath(fromObject, ["seed"]);
      if (fromSeed != null) {
        setValueByPath(toObject, ["seed"], fromSeed);
      }
      const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
      if (fromSpeechConfig != null) {
        setValueByPath(toObject, ["speechConfig"], speechConfigToVertex(fromSpeechConfig));
      }
      const fromStopSequences = getValueByPath(fromObject, [
        "stopSequences"
      ]);
      if (fromStopSequences != null) {
        setValueByPath(toObject, ["stopSequences"], fromStopSequences);
      }
      const fromTemperature = getValueByPath(fromObject, ["temperature"]);
      if (fromTemperature != null) {
        setValueByPath(toObject, ["temperature"], fromTemperature);
      }
      const fromThinkingConfig = getValueByPath(fromObject, [
        "thinkingConfig"
      ]);
      if (fromThinkingConfig != null) {
        setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
      }
      const fromTopK = getValueByPath(fromObject, ["topK"]);
      if (fromTopK != null) {
        setValueByPath(toObject, ["topK"], fromTopK);
      }
      const fromTopP = getValueByPath(fromObject, ["topP"]);
      if (fromTopP != null) {
        setValueByPath(toObject, ["topP"], fromTopP);
      }
      if (getValueByPath(fromObject, ["enableEnhancedCivicAnswers"]) !== void 0) {
        throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI.");
      }
      return toObject;
    }
    function getModelParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
      }
      return toObject;
    }
    function getModelParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
      }
      return toObject;
    }
    function googleMapsToMldev$1(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
        throw new Error("authConfig parameter is not supported in Gemini API.");
      }
      const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
      if (fromEnableWidget != null) {
        setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
      }
      return toObject;
    }
    function googleSearchToMldev$1(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
        throw new Error("excludeDomains parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
        throw new Error("blockingConfidence parameter is not supported in Gemini API.");
      }
      const fromTimeRangeFilter = getValueByPath(fromObject, [
        "timeRangeFilter"
      ]);
      if (fromTimeRangeFilter != null) {
        setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
      }
      return toObject;
    }
    function imageConfigToMldev(fromObject) {
      const toObject = {};
      const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
      if (fromAspectRatio != null) {
        setValueByPath(toObject, ["aspectRatio"], fromAspectRatio);
      }
      const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
      if (fromImageSize != null) {
        setValueByPath(toObject, ["imageSize"], fromImageSize);
      }
      if (getValueByPath(fromObject, ["outputMimeType"]) !== void 0) {
        throw new Error("outputMimeType parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["outputCompressionQuality"]) !== void 0) {
        throw new Error("outputCompressionQuality parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function imageConfigToVertex(fromObject) {
      const toObject = {};
      const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
      if (fromAspectRatio != null) {
        setValueByPath(toObject, ["aspectRatio"], fromAspectRatio);
      }
      const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
      if (fromImageSize != null) {
        setValueByPath(toObject, ["imageSize"], fromImageSize);
      }
      const fromOutputMimeType = getValueByPath(fromObject, [
        "outputMimeType"
      ]);
      if (fromOutputMimeType != null) {
        setValueByPath(toObject, ["imageOutputOptions", "mimeType"], fromOutputMimeType);
      }
      const fromOutputCompressionQuality = getValueByPath(fromObject, [
        "outputCompressionQuality"
      ]);
      if (fromOutputCompressionQuality != null) {
        setValueByPath(toObject, ["imageOutputOptions", "compressionQuality"], fromOutputCompressionQuality);
      }
      return toObject;
    }
    function imageFromMldev(fromObject) {
      const toObject = {};
      const fromImageBytes = getValueByPath(fromObject, [
        "bytesBase64Encoded"
      ]);
      if (fromImageBytes != null) {
        setValueByPath(toObject, ["imageBytes"], tBytes(fromImageBytes));
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function imageFromVertex(fromObject) {
      const toObject = {};
      const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
      if (fromGcsUri != null) {
        setValueByPath(toObject, ["gcsUri"], fromGcsUri);
      }
      const fromImageBytes = getValueByPath(fromObject, [
        "bytesBase64Encoded"
      ]);
      if (fromImageBytes != null) {
        setValueByPath(toObject, ["imageBytes"], tBytes(fromImageBytes));
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function imageToMldev(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) {
        throw new Error("gcsUri parameter is not supported in Gemini API.");
      }
      const fromImageBytes = getValueByPath(fromObject, ["imageBytes"]);
      if (fromImageBytes != null) {
        setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromImageBytes));
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function imageToVertex(fromObject) {
      const toObject = {};
      const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
      if (fromGcsUri != null) {
        setValueByPath(toObject, ["gcsUri"], fromGcsUri);
      }
      const fromImageBytes = getValueByPath(fromObject, ["imageBytes"]);
      if (fromImageBytes != null) {
        setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromImageBytes));
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function listModelsConfigToMldev(apiClient, fromObject, parentObject) {
      const toObject = {};
      const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
      if (parentObject !== void 0 && fromPageSize != null) {
        setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
      }
      const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
      if (parentObject !== void 0 && fromPageToken != null) {
        setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
      }
      const fromFilter = getValueByPath(fromObject, ["filter"]);
      if (parentObject !== void 0 && fromFilter != null) {
        setValueByPath(parentObject, ["_query", "filter"], fromFilter);
      }
      const fromQueryBase = getValueByPath(fromObject, ["queryBase"]);
      if (parentObject !== void 0 && fromQueryBase != null) {
        setValueByPath(parentObject, ["_url", "models_url"], tModelsUrl(apiClient, fromQueryBase));
      }
      return toObject;
    }
    function listModelsConfigToVertex(apiClient, fromObject, parentObject) {
      const toObject = {};
      const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
      if (parentObject !== void 0 && fromPageSize != null) {
        setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
      }
      const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
      if (parentObject !== void 0 && fromPageToken != null) {
        setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
      }
      const fromFilter = getValueByPath(fromObject, ["filter"]);
      if (parentObject !== void 0 && fromFilter != null) {
        setValueByPath(parentObject, ["_query", "filter"], fromFilter);
      }
      const fromQueryBase = getValueByPath(fromObject, ["queryBase"]);
      if (parentObject !== void 0 && fromQueryBase != null) {
        setValueByPath(parentObject, ["_url", "models_url"], tModelsUrl(apiClient, fromQueryBase));
      }
      return toObject;
    }
    function listModelsParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        listModelsConfigToMldev(apiClient, fromConfig, toObject);
      }
      return toObject;
    }
    function listModelsParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        listModelsConfigToVertex(apiClient, fromConfig, toObject);
      }
      return toObject;
    }
    function listModelsResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromNextPageToken = getValueByPath(fromObject, [
        "nextPageToken"
      ]);
      if (fromNextPageToken != null) {
        setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
      }
      const fromModels = getValueByPath(fromObject, ["_self"]);
      if (fromModels != null) {
        let transformedList = tExtractModels(fromModels);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return modelFromMldev(item);
          });
        }
        setValueByPath(toObject, ["models"], transformedList);
      }
      return toObject;
    }
    function listModelsResponseFromVertex(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromNextPageToken = getValueByPath(fromObject, [
        "nextPageToken"
      ]);
      if (fromNextPageToken != null) {
        setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
      }
      const fromModels = getValueByPath(fromObject, ["_self"]);
      if (fromModels != null) {
        let transformedList = tExtractModels(fromModels);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return modelFromVertex(item);
          });
        }
        setValueByPath(toObject, ["models"], transformedList);
      }
      return toObject;
    }
    function maskReferenceConfigToVertex(fromObject) {
      const toObject = {};
      const fromMaskMode = getValueByPath(fromObject, ["maskMode"]);
      if (fromMaskMode != null) {
        setValueByPath(toObject, ["maskMode"], fromMaskMode);
      }
      const fromSegmentationClasses = getValueByPath(fromObject, [
        "segmentationClasses"
      ]);
      if (fromSegmentationClasses != null) {
        setValueByPath(toObject, ["maskClasses"], fromSegmentationClasses);
      }
      const fromMaskDilation = getValueByPath(fromObject, ["maskDilation"]);
      if (fromMaskDilation != null) {
        setValueByPath(toObject, ["dilation"], fromMaskDilation);
      }
      return toObject;
    }
    function modelFromMldev(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
      if (fromDisplayName != null) {
        setValueByPath(toObject, ["displayName"], fromDisplayName);
      }
      const fromDescription = getValueByPath(fromObject, ["description"]);
      if (fromDescription != null) {
        setValueByPath(toObject, ["description"], fromDescription);
      }
      const fromVersion = getValueByPath(fromObject, ["version"]);
      if (fromVersion != null) {
        setValueByPath(toObject, ["version"], fromVersion);
      }
      const fromTunedModelInfo = getValueByPath(fromObject, ["_self"]);
      if (fromTunedModelInfo != null) {
        setValueByPath(toObject, ["tunedModelInfo"], tunedModelInfoFromMldev(fromTunedModelInfo));
      }
      const fromInputTokenLimit = getValueByPath(fromObject, [
        "inputTokenLimit"
      ]);
      if (fromInputTokenLimit != null) {
        setValueByPath(toObject, ["inputTokenLimit"], fromInputTokenLimit);
      }
      const fromOutputTokenLimit = getValueByPath(fromObject, [
        "outputTokenLimit"
      ]);
      if (fromOutputTokenLimit != null) {
        setValueByPath(toObject, ["outputTokenLimit"], fromOutputTokenLimit);
      }
      const fromSupportedActions = getValueByPath(fromObject, [
        "supportedGenerationMethods"
      ]);
      if (fromSupportedActions != null) {
        setValueByPath(toObject, ["supportedActions"], fromSupportedActions);
      }
      const fromTemperature = getValueByPath(fromObject, ["temperature"]);
      if (fromTemperature != null) {
        setValueByPath(toObject, ["temperature"], fromTemperature);
      }
      const fromMaxTemperature = getValueByPath(fromObject, [
        "maxTemperature"
      ]);
      if (fromMaxTemperature != null) {
        setValueByPath(toObject, ["maxTemperature"], fromMaxTemperature);
      }
      const fromTopP = getValueByPath(fromObject, ["topP"]);
      if (fromTopP != null) {
        setValueByPath(toObject, ["topP"], fromTopP);
      }
      const fromTopK = getValueByPath(fromObject, ["topK"]);
      if (fromTopK != null) {
        setValueByPath(toObject, ["topK"], fromTopK);
      }
      const fromThinking = getValueByPath(fromObject, ["thinking"]);
      if (fromThinking != null) {
        setValueByPath(toObject, ["thinking"], fromThinking);
      }
      return toObject;
    }
    function modelFromVertex(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
      if (fromDisplayName != null) {
        setValueByPath(toObject, ["displayName"], fromDisplayName);
      }
      const fromDescription = getValueByPath(fromObject, ["description"]);
      if (fromDescription != null) {
        setValueByPath(toObject, ["description"], fromDescription);
      }
      const fromVersion = getValueByPath(fromObject, ["versionId"]);
      if (fromVersion != null) {
        setValueByPath(toObject, ["version"], fromVersion);
      }
      const fromEndpoints = getValueByPath(fromObject, ["deployedModels"]);
      if (fromEndpoints != null) {
        let transformedList = fromEndpoints;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return endpointFromVertex(item);
          });
        }
        setValueByPath(toObject, ["endpoints"], transformedList);
      }
      const fromLabels = getValueByPath(fromObject, ["labels"]);
      if (fromLabels != null) {
        setValueByPath(toObject, ["labels"], fromLabels);
      }
      const fromTunedModelInfo = getValueByPath(fromObject, ["_self"]);
      if (fromTunedModelInfo != null) {
        setValueByPath(toObject, ["tunedModelInfo"], tunedModelInfoFromVertex(fromTunedModelInfo));
      }
      const fromDefaultCheckpointId = getValueByPath(fromObject, [
        "defaultCheckpointId"
      ]);
      if (fromDefaultCheckpointId != null) {
        setValueByPath(toObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
      }
      const fromCheckpoints = getValueByPath(fromObject, ["checkpoints"]);
      if (fromCheckpoints != null) {
        let transformedList = fromCheckpoints;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["checkpoints"], transformedList);
      }
      return toObject;
    }
    function partToMldev$1(fromObject) {
      const toObject = {};
      const fromMediaResolution = getValueByPath(fromObject, [
        "mediaResolution"
      ]);
      if (fromMediaResolution != null) {
        setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
      }
      const fromCodeExecutionResult = getValueByPath(fromObject, [
        "codeExecutionResult"
      ]);
      if (fromCodeExecutionResult != null) {
        setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
      }
      const fromExecutableCode = getValueByPath(fromObject, [
        "executableCode"
      ]);
      if (fromExecutableCode != null) {
        setValueByPath(toObject, ["executableCode"], fromExecutableCode);
      }
      const fromFileData = getValueByPath(fromObject, ["fileData"]);
      if (fromFileData != null) {
        setValueByPath(toObject, ["fileData"], fileDataToMldev$1(fromFileData));
      }
      const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
      if (fromFunctionCall != null) {
        setValueByPath(toObject, ["functionCall"], functionCallToMldev$1(fromFunctionCall));
      }
      const fromFunctionResponse = getValueByPath(fromObject, [
        "functionResponse"
      ]);
      if (fromFunctionResponse != null) {
        setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
      }
      const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
      if (fromInlineData != null) {
        setValueByPath(toObject, ["inlineData"], blobToMldev$1(fromInlineData));
      }
      const fromText = getValueByPath(fromObject, ["text"]);
      if (fromText != null) {
        setValueByPath(toObject, ["text"], fromText);
      }
      const fromThought = getValueByPath(fromObject, ["thought"]);
      if (fromThought != null) {
        setValueByPath(toObject, ["thought"], fromThought);
      }
      const fromThoughtSignature = getValueByPath(fromObject, [
        "thoughtSignature"
      ]);
      if (fromThoughtSignature != null) {
        setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
      }
      const fromVideoMetadata = getValueByPath(fromObject, [
        "videoMetadata"
      ]);
      if (fromVideoMetadata != null) {
        setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
      }
      return toObject;
    }
    function productImageToVertex(fromObject) {
      const toObject = {};
      const fromProductImage = getValueByPath(fromObject, ["productImage"]);
      if (fromProductImage != null) {
        setValueByPath(toObject, ["image"], imageToVertex(fromProductImage));
      }
      return toObject;
    }
    function recontextImageConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromNumberOfImages = getValueByPath(fromObject, [
        "numberOfImages"
      ]);
      if (parentObject !== void 0 && fromNumberOfImages != null) {
        setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
      }
      const fromBaseSteps = getValueByPath(fromObject, ["baseSteps"]);
      if (parentObject !== void 0 && fromBaseSteps != null) {
        setValueByPath(parentObject, ["parameters", "baseSteps"], fromBaseSteps);
      }
      const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
      if (parentObject !== void 0 && fromOutputGcsUri != null) {
        setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
      }
      const fromSeed = getValueByPath(fromObject, ["seed"]);
      if (parentObject !== void 0 && fromSeed != null) {
        setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
      }
      const fromSafetyFilterLevel = getValueByPath(fromObject, [
        "safetyFilterLevel"
      ]);
      if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
        setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
      }
      const fromPersonGeneration = getValueByPath(fromObject, [
        "personGeneration"
      ]);
      if (parentObject !== void 0 && fromPersonGeneration != null) {
        setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
      }
      const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
      if (parentObject !== void 0 && fromAddWatermark != null) {
        setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
      }
      const fromOutputMimeType = getValueByPath(fromObject, [
        "outputMimeType"
      ]);
      if (parentObject !== void 0 && fromOutputMimeType != null) {
        setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
      }
      const fromOutputCompressionQuality = getValueByPath(fromObject, [
        "outputCompressionQuality"
      ]);
      if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
        setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
      }
      const fromEnhancePrompt = getValueByPath(fromObject, [
        "enhancePrompt"
      ]);
      if (parentObject !== void 0 && fromEnhancePrompt != null) {
        setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
      }
      const fromLabels = getValueByPath(fromObject, ["labels"]);
      if (parentObject !== void 0 && fromLabels != null) {
        setValueByPath(parentObject, ["labels"], fromLabels);
      }
      return toObject;
    }
    function recontextImageParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromSource = getValueByPath(fromObject, ["source"]);
      if (fromSource != null) {
        recontextImageSourceToVertex(fromSource, toObject);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        recontextImageConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function recontextImageResponseFromVertex(fromObject) {
      const toObject = {};
      const fromGeneratedImages = getValueByPath(fromObject, [
        "predictions"
      ]);
      if (fromGeneratedImages != null) {
        let transformedList = fromGeneratedImages;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return generatedImageFromVertex(item);
          });
        }
        setValueByPath(toObject, ["generatedImages"], transformedList);
      }
      return toObject;
    }
    function recontextImageSourceToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromPrompt = getValueByPath(fromObject, ["prompt"]);
      if (parentObject !== void 0 && fromPrompt != null) {
        setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
      }
      const fromPersonImage = getValueByPath(fromObject, ["personImage"]);
      if (parentObject !== void 0 && fromPersonImage != null) {
        setValueByPath(parentObject, ["instances[0]", "personImage", "image"], imageToVertex(fromPersonImage));
      }
      const fromProductImages = getValueByPath(fromObject, [
        "productImages"
      ]);
      if (parentObject !== void 0 && fromProductImages != null) {
        let transformedList = fromProductImages;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return productImageToVertex(item);
          });
        }
        setValueByPath(parentObject, ["instances[0]", "productImages"], transformedList);
      }
      return toObject;
    }
    function referenceImageAPIInternalToVertex(fromObject) {
      const toObject = {};
      const fromReferenceImage = getValueByPath(fromObject, [
        "referenceImage"
      ]);
      if (fromReferenceImage != null) {
        setValueByPath(toObject, ["referenceImage"], imageToVertex(fromReferenceImage));
      }
      const fromReferenceId = getValueByPath(fromObject, ["referenceId"]);
      if (fromReferenceId != null) {
        setValueByPath(toObject, ["referenceId"], fromReferenceId);
      }
      const fromReferenceType = getValueByPath(fromObject, [
        "referenceType"
      ]);
      if (fromReferenceType != null) {
        setValueByPath(toObject, ["referenceType"], fromReferenceType);
      }
      const fromMaskImageConfig = getValueByPath(fromObject, [
        "maskImageConfig"
      ]);
      if (fromMaskImageConfig != null) {
        setValueByPath(toObject, ["maskImageConfig"], maskReferenceConfigToVertex(fromMaskImageConfig));
      }
      const fromControlImageConfig = getValueByPath(fromObject, [
        "controlImageConfig"
      ]);
      if (fromControlImageConfig != null) {
        setValueByPath(toObject, ["controlImageConfig"], controlReferenceConfigToVertex(fromControlImageConfig));
      }
      const fromStyleImageConfig = getValueByPath(fromObject, [
        "styleImageConfig"
      ]);
      if (fromStyleImageConfig != null) {
        setValueByPath(toObject, ["styleImageConfig"], fromStyleImageConfig);
      }
      const fromSubjectImageConfig = getValueByPath(fromObject, [
        "subjectImageConfig"
      ]);
      if (fromSubjectImageConfig != null) {
        setValueByPath(toObject, ["subjectImageConfig"], fromSubjectImageConfig);
      }
      return toObject;
    }
    function safetyAttributesFromMldev(fromObject) {
      const toObject = {};
      const fromCategories = getValueByPath(fromObject, [
        "safetyAttributes",
        "categories"
      ]);
      if (fromCategories != null) {
        setValueByPath(toObject, ["categories"], fromCategories);
      }
      const fromScores = getValueByPath(fromObject, [
        "safetyAttributes",
        "scores"
      ]);
      if (fromScores != null) {
        setValueByPath(toObject, ["scores"], fromScores);
      }
      const fromContentType = getValueByPath(fromObject, ["contentType"]);
      if (fromContentType != null) {
        setValueByPath(toObject, ["contentType"], fromContentType);
      }
      return toObject;
    }
    function safetyAttributesFromVertex(fromObject) {
      const toObject = {};
      const fromCategories = getValueByPath(fromObject, [
        "safetyAttributes",
        "categories"
      ]);
      if (fromCategories != null) {
        setValueByPath(toObject, ["categories"], fromCategories);
      }
      const fromScores = getValueByPath(fromObject, [
        "safetyAttributes",
        "scores"
      ]);
      if (fromScores != null) {
        setValueByPath(toObject, ["scores"], fromScores);
      }
      const fromContentType = getValueByPath(fromObject, ["contentType"]);
      if (fromContentType != null) {
        setValueByPath(toObject, ["contentType"], fromContentType);
      }
      return toObject;
    }
    function safetySettingToMldev(fromObject) {
      const toObject = {};
      const fromCategory = getValueByPath(fromObject, ["category"]);
      if (fromCategory != null) {
        setValueByPath(toObject, ["category"], fromCategory);
      }
      if (getValueByPath(fromObject, ["method"]) !== void 0) {
        throw new Error("method parameter is not supported in Gemini API.");
      }
      const fromThreshold = getValueByPath(fromObject, ["threshold"]);
      if (fromThreshold != null) {
        setValueByPath(toObject, ["threshold"], fromThreshold);
      }
      return toObject;
    }
    function scribbleImageToVertex(fromObject) {
      const toObject = {};
      const fromImage = getValueByPath(fromObject, ["image"]);
      if (fromImage != null) {
        setValueByPath(toObject, ["image"], imageToVertex(fromImage));
      }
      return toObject;
    }
    function segmentImageConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromMode = getValueByPath(fromObject, ["mode"]);
      if (parentObject !== void 0 && fromMode != null) {
        setValueByPath(parentObject, ["parameters", "mode"], fromMode);
      }
      const fromMaxPredictions = getValueByPath(fromObject, [
        "maxPredictions"
      ]);
      if (parentObject !== void 0 && fromMaxPredictions != null) {
        setValueByPath(parentObject, ["parameters", "maxPredictions"], fromMaxPredictions);
      }
      const fromConfidenceThreshold = getValueByPath(fromObject, [
        "confidenceThreshold"
      ]);
      if (parentObject !== void 0 && fromConfidenceThreshold != null) {
        setValueByPath(parentObject, ["parameters", "confidenceThreshold"], fromConfidenceThreshold);
      }
      const fromMaskDilation = getValueByPath(fromObject, ["maskDilation"]);
      if (parentObject !== void 0 && fromMaskDilation != null) {
        setValueByPath(parentObject, ["parameters", "maskDilation"], fromMaskDilation);
      }
      const fromBinaryColorThreshold = getValueByPath(fromObject, [
        "binaryColorThreshold"
      ]);
      if (parentObject !== void 0 && fromBinaryColorThreshold != null) {
        setValueByPath(parentObject, ["parameters", "binaryColorThreshold"], fromBinaryColorThreshold);
      }
      const fromLabels = getValueByPath(fromObject, ["labels"]);
      if (parentObject !== void 0 && fromLabels != null) {
        setValueByPath(parentObject, ["labels"], fromLabels);
      }
      return toObject;
    }
    function segmentImageParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromSource = getValueByPath(fromObject, ["source"]);
      if (fromSource != null) {
        segmentImageSourceToVertex(fromSource, toObject);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        segmentImageConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function segmentImageResponseFromVertex(fromObject) {
      const toObject = {};
      const fromGeneratedMasks = getValueByPath(fromObject, ["predictions"]);
      if (fromGeneratedMasks != null) {
        let transformedList = fromGeneratedMasks;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return generatedImageMaskFromVertex(item);
          });
        }
        setValueByPath(toObject, ["generatedMasks"], transformedList);
      }
      return toObject;
    }
    function segmentImageSourceToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromPrompt = getValueByPath(fromObject, ["prompt"]);
      if (parentObject !== void 0 && fromPrompt != null) {
        setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
      }
      const fromImage = getValueByPath(fromObject, ["image"]);
      if (parentObject !== void 0 && fromImage != null) {
        setValueByPath(parentObject, ["instances[0]", "image"], imageToVertex(fromImage));
      }
      const fromScribbleImage = getValueByPath(fromObject, [
        "scribbleImage"
      ]);
      if (parentObject !== void 0 && fromScribbleImage != null) {
        setValueByPath(parentObject, ["instances[0]", "scribble"], scribbleImageToVertex(fromScribbleImage));
      }
      return toObject;
    }
    function speechConfigToVertex(fromObject) {
      const toObject = {};
      const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
      if (fromLanguageCode != null) {
        setValueByPath(toObject, ["languageCode"], fromLanguageCode);
      }
      const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
      if (fromVoiceConfig != null) {
        setValueByPath(toObject, ["voiceConfig"], fromVoiceConfig);
      }
      if (getValueByPath(fromObject, ["multiSpeakerVoiceConfig"]) !== void 0) {
        throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI.");
      }
      return toObject;
    }
    function toolConfigToMldev(fromObject) {
      const toObject = {};
      const fromFunctionCallingConfig = getValueByPath(fromObject, [
        "functionCallingConfig"
      ]);
      if (fromFunctionCallingConfig != null) {
        setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev(fromFunctionCallingConfig));
      }
      const fromRetrievalConfig = getValueByPath(fromObject, [
        "retrievalConfig"
      ]);
      if (fromRetrievalConfig != null) {
        setValueByPath(toObject, ["retrievalConfig"], fromRetrievalConfig);
      }
      return toObject;
    }
    function toolToMldev$1(fromObject) {
      const toObject = {};
      const fromFunctionDeclarations = getValueByPath(fromObject, [
        "functionDeclarations"
      ]);
      if (fromFunctionDeclarations != null) {
        let transformedList = fromFunctionDeclarations;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["functionDeclarations"], transformedList);
      }
      if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
        throw new Error("retrieval parameter is not supported in Gemini API.");
      }
      const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
        "googleSearchRetrieval"
      ]);
      if (fromGoogleSearchRetrieval != null) {
        setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
      }
      const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
      if (fromComputerUse != null) {
        setValueByPath(toObject, ["computerUse"], fromComputerUse);
      }
      const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
      if (fromFileSearch != null) {
        setValueByPath(toObject, ["fileSearch"], fromFileSearch);
      }
      const fromCodeExecution = getValueByPath(fromObject, [
        "codeExecution"
      ]);
      if (fromCodeExecution != null) {
        setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
      }
      if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
        throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
      }
      const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
      if (fromGoogleMaps != null) {
        setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$1(fromGoogleMaps));
      }
      const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
      if (fromGoogleSearch != null) {
        setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$1(fromGoogleSearch));
      }
      const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
      if (fromUrlContext != null) {
        setValueByPath(toObject, ["urlContext"], fromUrlContext);
      }
      return toObject;
    }
    function toolToVertex(fromObject) {
      const toObject = {};
      const fromFunctionDeclarations = getValueByPath(fromObject, [
        "functionDeclarations"
      ]);
      if (fromFunctionDeclarations != null) {
        let transformedList = fromFunctionDeclarations;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return functionDeclarationToVertex(item);
          });
        }
        setValueByPath(toObject, ["functionDeclarations"], transformedList);
      }
      const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
      if (fromRetrieval != null) {
        setValueByPath(toObject, ["retrieval"], fromRetrieval);
      }
      const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
        "googleSearchRetrieval"
      ]);
      if (fromGoogleSearchRetrieval != null) {
        setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
      }
      const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
      if (fromComputerUse != null) {
        setValueByPath(toObject, ["computerUse"], fromComputerUse);
      }
      if (getValueByPath(fromObject, ["fileSearch"]) !== void 0) {
        throw new Error("fileSearch parameter is not supported in Vertex AI.");
      }
      const fromCodeExecution = getValueByPath(fromObject, [
        "codeExecution"
      ]);
      if (fromCodeExecution != null) {
        setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
      }
      const fromEnterpriseWebSearch = getValueByPath(fromObject, [
        "enterpriseWebSearch"
      ]);
      if (fromEnterpriseWebSearch != null) {
        setValueByPath(toObject, ["enterpriseWebSearch"], fromEnterpriseWebSearch);
      }
      const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
      if (fromGoogleMaps != null) {
        setValueByPath(toObject, ["googleMaps"], fromGoogleMaps);
      }
      const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
      if (fromGoogleSearch != null) {
        setValueByPath(toObject, ["googleSearch"], fromGoogleSearch);
      }
      const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
      if (fromUrlContext != null) {
        setValueByPath(toObject, ["urlContext"], fromUrlContext);
      }
      return toObject;
    }
    function tunedModelInfoFromMldev(fromObject) {
      const toObject = {};
      const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
      if (fromBaseModel != null) {
        setValueByPath(toObject, ["baseModel"], fromBaseModel);
      }
      const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
      if (fromCreateTime != null) {
        setValueByPath(toObject, ["createTime"], fromCreateTime);
      }
      const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
      if (fromUpdateTime != null) {
        setValueByPath(toObject, ["updateTime"], fromUpdateTime);
      }
      return toObject;
    }
    function tunedModelInfoFromVertex(fromObject) {
      const toObject = {};
      const fromBaseModel = getValueByPath(fromObject, [
        "labels",
        "google-vertex-llm-tuning-base-model-id"
      ]);
      if (fromBaseModel != null) {
        setValueByPath(toObject, ["baseModel"], fromBaseModel);
      }
      const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
      if (fromCreateTime != null) {
        setValueByPath(toObject, ["createTime"], fromCreateTime);
      }
      const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
      if (fromUpdateTime != null) {
        setValueByPath(toObject, ["updateTime"], fromUpdateTime);
      }
      return toObject;
    }
    function updateModelConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
      if (parentObject !== void 0 && fromDisplayName != null) {
        setValueByPath(parentObject, ["displayName"], fromDisplayName);
      }
      const fromDescription = getValueByPath(fromObject, ["description"]);
      if (parentObject !== void 0 && fromDescription != null) {
        setValueByPath(parentObject, ["description"], fromDescription);
      }
      const fromDefaultCheckpointId = getValueByPath(fromObject, [
        "defaultCheckpointId"
      ]);
      if (parentObject !== void 0 && fromDefaultCheckpointId != null) {
        setValueByPath(parentObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
      }
      return toObject;
    }
    function updateModelConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
      if (parentObject !== void 0 && fromDisplayName != null) {
        setValueByPath(parentObject, ["displayName"], fromDisplayName);
      }
      const fromDescription = getValueByPath(fromObject, ["description"]);
      if (parentObject !== void 0 && fromDescription != null) {
        setValueByPath(parentObject, ["description"], fromDescription);
      }
      const fromDefaultCheckpointId = getValueByPath(fromObject, [
        "defaultCheckpointId"
      ]);
      if (parentObject !== void 0 && fromDefaultCheckpointId != null) {
        setValueByPath(parentObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
      }
      return toObject;
    }
    function updateModelParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        updateModelConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function updateModelParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        updateModelConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function upscaleImageAPIConfigInternalToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
      if (parentObject !== void 0 && fromOutputGcsUri != null) {
        setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
      }
      const fromSafetyFilterLevel = getValueByPath(fromObject, [
        "safetyFilterLevel"
      ]);
      if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
        setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
      }
      const fromPersonGeneration = getValueByPath(fromObject, [
        "personGeneration"
      ]);
      if (parentObject !== void 0 && fromPersonGeneration != null) {
        setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
      }
      const fromIncludeRaiReason = getValueByPath(fromObject, [
        "includeRaiReason"
      ]);
      if (parentObject !== void 0 && fromIncludeRaiReason != null) {
        setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
      }
      const fromOutputMimeType = getValueByPath(fromObject, [
        "outputMimeType"
      ]);
      if (parentObject !== void 0 && fromOutputMimeType != null) {
        setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
      }
      const fromOutputCompressionQuality = getValueByPath(fromObject, [
        "outputCompressionQuality"
      ]);
      if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
        setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
      }
      const fromEnhanceInputImage = getValueByPath(fromObject, [
        "enhanceInputImage"
      ]);
      if (parentObject !== void 0 && fromEnhanceInputImage != null) {
        setValueByPath(parentObject, ["parameters", "upscaleConfig", "enhanceInputImage"], fromEnhanceInputImage);
      }
      const fromImagePreservationFactor = getValueByPath(fromObject, [
        "imagePreservationFactor"
      ]);
      if (parentObject !== void 0 && fromImagePreservationFactor != null) {
        setValueByPath(parentObject, ["parameters", "upscaleConfig", "imagePreservationFactor"], fromImagePreservationFactor);
      }
      const fromLabels = getValueByPath(fromObject, ["labels"]);
      if (parentObject !== void 0 && fromLabels != null) {
        setValueByPath(parentObject, ["labels"], fromLabels);
      }
      const fromNumberOfImages = getValueByPath(fromObject, [
        "numberOfImages"
      ]);
      if (parentObject !== void 0 && fromNumberOfImages != null) {
        setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
      }
      const fromMode = getValueByPath(fromObject, ["mode"]);
      if (parentObject !== void 0 && fromMode != null) {
        setValueByPath(parentObject, ["parameters", "mode"], fromMode);
      }
      return toObject;
    }
    function upscaleImageAPIParametersInternalToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromImage = getValueByPath(fromObject, ["image"]);
      if (fromImage != null) {
        setValueByPath(toObject, ["instances[0]", "image"], imageToVertex(fromImage));
      }
      const fromUpscaleFactor = getValueByPath(fromObject, [
        "upscaleFactor"
      ]);
      if (fromUpscaleFactor != null) {
        setValueByPath(toObject, ["parameters", "upscaleConfig", "upscaleFactor"], fromUpscaleFactor);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        upscaleImageAPIConfigInternalToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function upscaleImageResponseFromVertex(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromGeneratedImages = getValueByPath(fromObject, [
        "predictions"
      ]);
      if (fromGeneratedImages != null) {
        let transformedList = fromGeneratedImages;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return generatedImageFromVertex(item);
          });
        }
        setValueByPath(toObject, ["generatedImages"], transformedList);
      }
      return toObject;
    }
    function videoFromMldev(fromObject) {
      const toObject = {};
      const fromUri = getValueByPath(fromObject, ["uri"]);
      if (fromUri != null) {
        setValueByPath(toObject, ["uri"], fromUri);
      }
      const fromVideoBytes = getValueByPath(fromObject, ["encodedVideo"]);
      if (fromVideoBytes != null) {
        setValueByPath(toObject, ["videoBytes"], tBytes(fromVideoBytes));
      }
      const fromMimeType = getValueByPath(fromObject, ["encoding"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function videoFromVertex(fromObject) {
      const toObject = {};
      const fromUri = getValueByPath(fromObject, ["gcsUri"]);
      if (fromUri != null) {
        setValueByPath(toObject, ["uri"], fromUri);
      }
      const fromVideoBytes = getValueByPath(fromObject, [
        "bytesBase64Encoded"
      ]);
      if (fromVideoBytes != null) {
        setValueByPath(toObject, ["videoBytes"], tBytes(fromVideoBytes));
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function videoGenerationMaskToVertex(fromObject) {
      const toObject = {};
      const fromImage = getValueByPath(fromObject, ["image"]);
      if (fromImage != null) {
        setValueByPath(toObject, ["_self"], imageToVertex(fromImage));
      }
      const fromMaskMode = getValueByPath(fromObject, ["maskMode"]);
      if (fromMaskMode != null) {
        setValueByPath(toObject, ["maskMode"], fromMaskMode);
      }
      return toObject;
    }
    function videoGenerationReferenceImageToMldev(fromObject) {
      const toObject = {};
      const fromImage = getValueByPath(fromObject, ["image"]);
      if (fromImage != null) {
        setValueByPath(toObject, ["image"], imageToMldev(fromImage));
      }
      const fromReferenceType = getValueByPath(fromObject, [
        "referenceType"
      ]);
      if (fromReferenceType != null) {
        setValueByPath(toObject, ["referenceType"], fromReferenceType);
      }
      return toObject;
    }
    function videoGenerationReferenceImageToVertex(fromObject) {
      const toObject = {};
      const fromImage = getValueByPath(fromObject, ["image"]);
      if (fromImage != null) {
        setValueByPath(toObject, ["image"], imageToVertex(fromImage));
      }
      const fromReferenceType = getValueByPath(fromObject, [
        "referenceType"
      ]);
      if (fromReferenceType != null) {
        setValueByPath(toObject, ["referenceType"], fromReferenceType);
      }
      return toObject;
    }
    function videoToMldev(fromObject) {
      const toObject = {};
      const fromUri = getValueByPath(fromObject, ["uri"]);
      if (fromUri != null) {
        setValueByPath(toObject, ["uri"], fromUri);
      }
      const fromVideoBytes = getValueByPath(fromObject, ["videoBytes"]);
      if (fromVideoBytes != null) {
        setValueByPath(toObject, ["encodedVideo"], tBytes(fromVideoBytes));
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["encoding"], fromMimeType);
      }
      return toObject;
    }
    function videoToVertex(fromObject) {
      const toObject = {};
      const fromUri = getValueByPath(fromObject, ["uri"]);
      if (fromUri != null) {
        setValueByPath(toObject, ["gcsUri"], fromUri);
      }
      const fromVideoBytes = getValueByPath(fromObject, ["videoBytes"]);
      if (fromVideoBytes != null) {
        setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromVideoBytes));
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    const CONTENT_TYPE_HEADER = "Content-Type";
    const SERVER_TIMEOUT_HEADER = "X-Server-Timeout";
    const USER_AGENT_HEADER = "User-Agent";
    const GOOGLE_API_CLIENT_HEADER = "x-goog-api-client";
    const SDK_VERSION = "1.30.0";
    const LIBRARY_LABEL = `google-genai-sdk/${SDK_VERSION}`;
    const VERTEX_AI_API_DEFAULT_VERSION = "v1beta1";
    const GOOGLE_AI_API_DEFAULT_VERSION = "v1beta";
    const responseLineRE = /^\s*data: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
    class ApiClient {
      constructor(opts) {
        var _a, _b;
        this.clientOptions = Object.assign(Object.assign({}, opts), { project: opts.project, location: opts.location, apiKey: opts.apiKey, vertexai: opts.vertexai });
        const initHttpOptions = {};
        if (this.clientOptions.vertexai) {
          initHttpOptions.apiVersion = (_a = this.clientOptions.apiVersion) !== null && _a !== void 0 ? _a : VERTEX_AI_API_DEFAULT_VERSION;
          initHttpOptions.baseUrl = this.baseUrlFromProjectLocation();
          this.normalizeAuthParameters();
        } else {
          initHttpOptions.apiVersion = (_b = this.clientOptions.apiVersion) !== null && _b !== void 0 ? _b : GOOGLE_AI_API_DEFAULT_VERSION;
          initHttpOptions.baseUrl = `https://generativelanguage.googleapis.com/`;
        }
        initHttpOptions.headers = this.getDefaultHeaders();
        this.clientOptions.httpOptions = initHttpOptions;
        if (opts.httpOptions) {
          this.clientOptions.httpOptions = this.patchHttpOptions(initHttpOptions, opts.httpOptions);
        }
      }
      /**
       * Determines the base URL for Vertex AI based on project and location.
       * Uses the global endpoint if location is 'global' or if project/location
       * are not specified (implying API key usage).
       * @private
       */
      baseUrlFromProjectLocation() {
        if (this.clientOptions.project && this.clientOptions.location && this.clientOptions.location !== "global") {
          return `https://${this.clientOptions.location}-aiplatform.googleapis.com/`;
        }
        return `https://aiplatform.googleapis.com/`;
      }
      /**
       * Normalizes authentication parameters for Vertex AI.
       * If project and location are provided, API key is cleared.
       * If project and location are not provided (implying API key usage),
       * project and location are cleared.
       * @private
       */
      normalizeAuthParameters() {
        if (this.clientOptions.project && this.clientOptions.location) {
          this.clientOptions.apiKey = void 0;
          return;
        }
        this.clientOptions.project = void 0;
        this.clientOptions.location = void 0;
      }
      isVertexAI() {
        var _a;
        return (_a = this.clientOptions.vertexai) !== null && _a !== void 0 ? _a : false;
      }
      getProject() {
        return this.clientOptions.project;
      }
      getLocation() {
        return this.clientOptions.location;
      }
      getApiVersion() {
        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.apiVersion !== void 0) {
          return this.clientOptions.httpOptions.apiVersion;
        }
        throw new Error("API version is not set.");
      }
      getBaseUrl() {
        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.baseUrl !== void 0) {
          return this.clientOptions.httpOptions.baseUrl;
        }
        throw new Error("Base URL is not set.");
      }
      getRequestUrl() {
        return this.getRequestUrlInternal(this.clientOptions.httpOptions);
      }
      getHeaders() {
        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.headers !== void 0) {
          return this.clientOptions.httpOptions.headers;
        } else {
          throw new Error("Headers are not set.");
        }
      }
      getRequestUrlInternal(httpOptions) {
        if (!httpOptions || httpOptions.baseUrl === void 0 || httpOptions.apiVersion === void 0) {
          throw new Error("HTTP options are not correctly set.");
        }
        const baseUrl = httpOptions.baseUrl.endsWith("/") ? httpOptions.baseUrl.slice(0, -1) : httpOptions.baseUrl;
        const urlElement = [baseUrl];
        if (httpOptions.apiVersion && httpOptions.apiVersion !== "") {
          urlElement.push(httpOptions.apiVersion);
        }
        return urlElement.join("/");
      }
      getBaseResourcePath() {
        return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`;
      }
      getApiKey() {
        return this.clientOptions.apiKey;
      }
      getWebsocketBaseUrl() {
        const baseUrl = this.getBaseUrl();
        const urlParts = new URL(baseUrl);
        urlParts.protocol = urlParts.protocol == "http:" ? "ws" : "wss";
        return urlParts.toString();
      }
      setBaseUrl(url) {
        if (this.clientOptions.httpOptions) {
          this.clientOptions.httpOptions.baseUrl = url;
        } else {
          throw new Error("HTTP options are not correctly set.");
        }
      }
      constructUrl(path, httpOptions, prependProjectLocation) {
        const urlElement = [this.getRequestUrlInternal(httpOptions)];
        if (prependProjectLocation) {
          urlElement.push(this.getBaseResourcePath());
        }
        if (path !== "") {
          urlElement.push(path);
        }
        const url = new URL(`${urlElement.join("/")}`);
        return url;
      }
      shouldPrependVertexProjectPath(request) {
        if (this.clientOptions.apiKey) {
          return false;
        }
        if (!this.clientOptions.vertexai) {
          return false;
        }
        if (request.path.startsWith("projects/")) {
          return false;
        }
        if (request.httpMethod === "GET" && request.path.startsWith("publishers/google/models")) {
          return false;
        }
        return true;
      }
      request(request) {
        return __async(this, null, function* () {
          let patchedHttpOptions = this.clientOptions.httpOptions;
          if (request.httpOptions) {
            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);
          }
          const prependProjectLocation = this.shouldPrependVertexProjectPath(request);
          const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);
          if (request.queryParams) {
            for (const [key, value] of Object.entries(request.queryParams)) {
              url.searchParams.append(key, String(value));
            }
          }
          let requestInit = {};
          if (request.httpMethod === "GET") {
            if (request.body && request.body !== "{}") {
              throw new Error("Request body should be empty for GET request, but got non empty request body");
            }
          } else {
            requestInit.body = request.body;
          }
          requestInit = yield this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, url.toString(), request.abortSignal);
          return this.unaryApiCall(url, requestInit, request.httpMethod);
        });
      }
      patchHttpOptions(baseHttpOptions, requestHttpOptions) {
        const patchedHttpOptions = JSON.parse(JSON.stringify(baseHttpOptions));
        for (const [key, value] of Object.entries(requestHttpOptions)) {
          if (typeof value === "object") {
            patchedHttpOptions[key] = Object.assign(Object.assign({}, patchedHttpOptions[key]), value);
          } else if (value !== void 0) {
            patchedHttpOptions[key] = value;
          }
        }
        return patchedHttpOptions;
      }
      requestStream(request) {
        return __async(this, null, function* () {
          let patchedHttpOptions = this.clientOptions.httpOptions;
          if (request.httpOptions) {
            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);
          }
          const prependProjectLocation = this.shouldPrependVertexProjectPath(request);
          const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);
          if (!url.searchParams.has("alt") || url.searchParams.get("alt") !== "sse") {
            url.searchParams.set("alt", "sse");
          }
          let requestInit = {};
          requestInit.body = request.body;
          requestInit = yield this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, url.toString(), request.abortSignal);
          return this.streamApiCall(url, requestInit, request.httpMethod);
        });
      }
      includeExtraHttpOptionsToRequestInit(requestInit, httpOptions, url, abortSignal) {
        return __async(this, null, function* () {
          if (httpOptions && httpOptions.timeout || abortSignal) {
            const abortController = new AbortController();
            const signal = abortController.signal;
            if (httpOptions.timeout && (httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.timeout) > 0) {
              const timeoutHandle = setTimeout(() => abortController.abort(), httpOptions.timeout);
              if (timeoutHandle && typeof timeoutHandle.unref === "function") {
                timeoutHandle.unref();
              }
            }
            if (abortSignal) {
              abortSignal.addEventListener("abort", () => {
                abortController.abort();
              });
            }
            requestInit.signal = signal;
          }
          if (httpOptions && httpOptions.extraBody !== null) {
            includeExtraBodyToRequestInit(requestInit, httpOptions.extraBody);
          }
          requestInit.headers = yield this.getHeadersInternal(httpOptions, url);
          return requestInit;
        });
      }
      unaryApiCall(url, requestInit, httpMethod) {
        return __async(this, null, function* () {
          return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod })).then((response) => __async(this, null, function* () {
            yield throwErrorIfNotOK(response);
            return new HttpResponse(response);
          })).catch((e) => {
            if (e instanceof Error) {
              throw e;
            } else {
              throw new Error(JSON.stringify(e));
            }
          });
        });
      }
      streamApiCall(url, requestInit, httpMethod) {
        return __async(this, null, function* () {
          return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod })).then((response) => __async(this, null, function* () {
            yield throwErrorIfNotOK(response);
            return this.processStreamResponse(response);
          })).catch((e) => {
            if (e instanceof Error) {
              throw e;
            } else {
              throw new Error(JSON.stringify(e));
            }
          });
        });
      }
      processStreamResponse(response) {
        var _a;
        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {
          const reader = (_a = response === null || response === void 0 ? void 0 : response.body) === null || _a === void 0 ? void 0 : _a.getReader();
          const decoder = new TextDecoder("utf-8");
          if (!reader) {
            throw new Error("Response body is empty");
          }
          try {
            let buffer = "";
            while (true) {
              const { done, value } = yield __await(reader.read());
              if (done) {
                if (buffer.trim().length > 0) {
                  throw new Error("Incomplete JSON segment at the end");
                }
                break;
              }
              const chunkString = decoder.decode(value, { stream: true });
              try {
                const chunkJson = JSON.parse(chunkString);
                if ("error" in chunkJson) {
                  const errorJson = JSON.parse(JSON.stringify(chunkJson["error"]));
                  const status = errorJson["status"];
                  const code = errorJson["code"];
                  const errorMessage = `got status: ${status}. ${JSON.stringify(chunkJson)}`;
                  if (code >= 400 && code < 600) {
                    const apiError = new ApiError({
                      message: errorMessage,
                      status: code
                    });
                    throw apiError;
                  }
                }
              } catch (e) {
                const error = e;
                if (error.name === "ApiError") {
                  throw e;
                }
              }
              buffer += chunkString;
              let match = buffer.match(responseLineRE);
              while (match) {
                const processedChunkString = match[1];
                try {
                  const partialResponse = new Response(processedChunkString, {
                    headers: response === null || response === void 0 ? void 0 : response.headers,
                    status: response === null || response === void 0 ? void 0 : response.status,
                    statusText: response === null || response === void 0 ? void 0 : response.statusText
                  });
                  yield yield __await(new HttpResponse(partialResponse));
                  buffer = buffer.slice(match[0].length);
                  match = buffer.match(responseLineRE);
                } catch (e) {
                  throw new Error(`exception parsing stream chunk ${processedChunkString}. ${e}`);
                }
              }
            }
          } finally {
            reader.releaseLock();
          }
        });
      }
      apiCall(url, requestInit) {
        return __async(this, null, function* () {
          return fetch(url, requestInit).catch((e) => {
            throw new Error(`exception ${e} sending request`);
          });
        });
      }
      getDefaultHeaders() {
        const headers = {};
        const versionHeaderValue = LIBRARY_LABEL + " " + this.clientOptions.userAgentExtra;
        headers[USER_AGENT_HEADER] = versionHeaderValue;
        headers[GOOGLE_API_CLIENT_HEADER] = versionHeaderValue;
        headers[CONTENT_TYPE_HEADER] = "application/json";
        return headers;
      }
      getHeadersInternal(httpOptions, url) {
        return __async(this, null, function* () {
          const headers = new Headers();
          if (httpOptions && httpOptions.headers) {
            for (const [key, value] of Object.entries(httpOptions.headers)) {
              headers.append(key, value);
            }
            if (httpOptions.timeout && httpOptions.timeout > 0) {
              headers.append(SERVER_TIMEOUT_HEADER, String(Math.ceil(httpOptions.timeout / 1e3)));
            }
          }
          yield this.clientOptions.auth.addAuthHeaders(headers, url);
          return headers;
        });
      }
      getFileName(file) {
        var _a;
        let fileName = "";
        if (typeof file === "string") {
          fileName = file.replace(/[/\\]+$/, "");
          fileName = (_a = fileName.split(/[/\\]/).pop()) !== null && _a !== void 0 ? _a : "";
        }
        return fileName;
      }
      /**
       * Uploads a file asynchronously using Gemini API only, this is not supported
       * in Vertex AI.
       *
       * @param file The string path to the file to be uploaded or a Blob object.
       * @param config Optional parameters specified in the `UploadFileConfig`
       *     interface. @see {@link types.UploadFileConfig}
       * @return A promise that resolves to a `File` object.
       * @throws An error if called on a Vertex AI client.
       * @throws An error if the `mimeType` is not provided and can not be inferred,
       */
      uploadFile(file, config) {
        return __async(this, null, function* () {
          var _a;
          const fileToUpload = {};
          if (config != null) {
            fileToUpload.mimeType = config.mimeType;
            fileToUpload.name = config.name;
            fileToUpload.displayName = config.displayName;
          }
          if (fileToUpload.name && !fileToUpload.name.startsWith("files/")) {
            fileToUpload.name = `files/${fileToUpload.name}`;
          }
          const uploader = this.clientOptions.uploader;
          const fileStat = yield uploader.stat(file);
          fileToUpload.sizeBytes = String(fileStat.size);
          const mimeType = (_a = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a !== void 0 ? _a : fileStat.type;
          if (mimeType === void 0 || mimeType === "") {
            throw new Error("Can not determine mimeType. Please provide mimeType in the config.");
          }
          fileToUpload.mimeType = mimeType;
          const body = {
            file: fileToUpload
          };
          const fileName = this.getFileName(file);
          const path = formatMap("upload/v1beta/files", body["_url"]);
          const uploadUrl = yield this.fetchUploadUrl(path, fileToUpload.sizeBytes, fileToUpload.mimeType, fileName, body, config === null || config === void 0 ? void 0 : config.httpOptions);
          return uploader.upload(file, uploadUrl, this);
        });
      }
      /**
       * Uploads a file to a given file search store asynchronously using Gemini API only, this is not supported
       * in Vertex AI.
       *
       * @param fileSearchStoreName The name of the file search store to upload the file to.
       * @param file The string path to the file to be uploaded or a Blob object.
       * @param config Optional parameters specified in the `UploadFileConfig`
       *     interface. @see {@link UploadFileConfig}
       * @return A promise that resolves to a `File` object.
       * @throws An error if called on a Vertex AI client.
       * @throws An error if the `mimeType` is not provided and can not be inferred,
       */
      uploadFileToFileSearchStore(fileSearchStoreName, file, config) {
        return __async(this, null, function* () {
          var _a;
          const uploader = this.clientOptions.uploader;
          const fileStat = yield uploader.stat(file);
          const sizeBytes = String(fileStat.size);
          const mimeType = (_a = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a !== void 0 ? _a : fileStat.type;
          if (mimeType === void 0 || mimeType === "") {
            throw new Error("Can not determine mimeType. Please provide mimeType in the config.");
          }
          const path = `upload/v1beta/${fileSearchStoreName}:uploadToFileSearchStore`;
          const fileName = this.getFileName(file);
          const body = {};
          if (config === null || config === void 0 ? void 0 : config.customMetadata) {
            body["customMetadata"] = config.customMetadata;
          }
          if (config === null || config === void 0 ? void 0 : config.chunkingConfig) {
            body["chunkingConfig"] = config.chunkingConfig;
          }
          const uploadUrl = yield this.fetchUploadUrl(path, sizeBytes, mimeType, fileName, body, config === null || config === void 0 ? void 0 : config.httpOptions);
          return uploader.uploadToFileSearchStore(file, uploadUrl, this);
        });
      }
      /**
       * Downloads a file asynchronously to the specified path.
       *
       * @params params - The parameters for the download request, see {@link
       * types.DownloadFileParameters}
       */
      downloadFile(params) {
        return __async(this, null, function* () {
          const downloader = this.clientOptions.downloader;
          yield downloader.download(params, this);
        });
      }
      fetchUploadUrl(path, sizeBytes, mimeType, fileName, body, configHttpOptions) {
        return __async(this, null, function* () {
          var _a;
          let httpOptions = {};
          if (configHttpOptions) {
            httpOptions = configHttpOptions;
          } else {
            httpOptions = {
              apiVersion: "",
              headers: Object.assign({ "Content-Type": "application/json", "X-Goog-Upload-Protocol": "resumable", "X-Goog-Upload-Command": "start", "X-Goog-Upload-Header-Content-Length": `${sizeBytes}`, "X-Goog-Upload-Header-Content-Type": `${mimeType}` }, fileName ? { "X-Goog-Upload-File-Name": fileName } : {})
            };
          }
          const httpResponse = yield this.request({
            path,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions
          });
          if (!httpResponse || !(httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers)) {
            throw new Error("Server did not return an HttpResponse or the returned HttpResponse did not have headers.");
          }
          const uploadUrl = (_a = httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers) === null || _a === void 0 ? void 0 : _a["x-goog-upload-url"];
          if (uploadUrl === void 0) {
            throw new Error("Failed to get upload url. Server did not return the x-google-upload-url in the headers");
          }
          return uploadUrl;
        });
      }
    }
    function throwErrorIfNotOK(response) {
      return __async(this, null, function* () {
        var _a;
        if (response === void 0) {
          throw new Error("response is undefined");
        }
        if (!response.ok) {
          const status = response.status;
          let errorBody;
          if ((_a = response.headers.get("content-type")) === null || _a === void 0 ? void 0 : _a.includes("application/json")) {
            errorBody = yield response.json();
          } else {
            errorBody = {
              error: {
                message: yield response.text(),
                code: response.status,
                status: response.statusText
              }
            };
          }
          const errorMessage = JSON.stringify(errorBody);
          if (status >= 400 && status < 600) {
            const apiError = new ApiError({
              message: errorMessage,
              status
            });
            throw apiError;
          }
          throw new Error(errorMessage);
        }
      });
    }
    function includeExtraBodyToRequestInit(requestInit, extraBody) {
      if (!extraBody || Object.keys(extraBody).length === 0) {
        return;
      }
      if (requestInit.body instanceof Blob) {
        console.warn("includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies.");
        return;
      }
      let currentBodyObject = {};
      if (typeof requestInit.body === "string" && requestInit.body.length > 0) {
        try {
          const parsedBody = JSON.parse(requestInit.body);
          if (typeof parsedBody === "object" && parsedBody !== null && !Array.isArray(parsedBody)) {
            currentBodyObject = parsedBody;
          } else {
            console.warn("includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body.");
            return;
          }
        } catch (e) {
          console.warn("includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body.");
          return;
        }
      }
      function deepMerge(target, source) {
        const output = Object.assign({}, target);
        for (const key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            const sourceValue = source[key];
            const targetValue = output[key];
            if (sourceValue && typeof sourceValue === "object" && !Array.isArray(sourceValue) && targetValue && typeof targetValue === "object" && !Array.isArray(targetValue)) {
              output[key] = deepMerge(targetValue, sourceValue);
            } else {
              if (targetValue && sourceValue && typeof targetValue !== typeof sourceValue) {
                console.warn(`includeExtraBodyToRequestInit:deepMerge: Type mismatch for key "${key}". Original type: ${typeof targetValue}, New type: ${typeof sourceValue}. Overwriting.`);
              }
              output[key] = sourceValue;
            }
          }
        }
        return output;
      }
      const mergedBody = deepMerge(currentBodyObject, extraBody);
      requestInit.body = JSON.stringify(mergedBody);
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    const MCP_LABEL = "mcp_used/unknown";
    let hasMcpToolUsageFromMcpToTool = false;
    function hasMcpToolUsage(tools) {
      for (const tool of tools) {
        if (isMcpCallableTool(tool)) {
          return true;
        }
        if (typeof tool === "object" && "inputSchema" in tool) {
          return true;
        }
      }
      return hasMcpToolUsageFromMcpToTool;
    }
    function setMcpUsageHeader(headers) {
      var _a;
      const existingHeader = (_a = headers[GOOGLE_API_CLIENT_HEADER]) !== null && _a !== void 0 ? _a : "";
      headers[GOOGLE_API_CLIENT_HEADER] = (existingHeader + ` ${MCP_LABEL}`).trimStart();
    }
    function isMcpCallableTool(object) {
      return object !== null && typeof object === "object" && object instanceof McpCallableTool;
    }
    function listAllTools(mcpClient, maxTools = 100) {
      return __asyncGenerator(this, arguments, function* listAllTools_1() {
        let cursor = void 0;
        let numTools = 0;
        while (numTools < maxTools) {
          const t = yield __await(mcpClient.listTools({ cursor }));
          for (const tool of t.tools) {
            yield yield __await(tool);
            numTools++;
          }
          if (!t.nextCursor) {
            break;
          }
          cursor = t.nextCursor;
        }
      });
    }
    class McpCallableTool {
      constructor(mcpClients = [], config) {
        this.mcpTools = [];
        this.functionNameToMcpClient = {};
        this.mcpClients = mcpClients;
        this.config = config;
      }
      /**
       * Creates a McpCallableTool.
       */
      static create(mcpClients, config) {
        return new McpCallableTool(mcpClients, config);
      }
      /**
       * Validates the function names are not duplicate and initialize the function
       * name to MCP client mapping.
       *
       * @throws {Error} if the MCP tools from the MCP clients have duplicate tool
       *     names.
       */
      initialize() {
        return __async(this, null, function* () {
          var _a, e_1, _b, _c;
          if (this.mcpTools.length > 0) {
            return;
          }
          const functionMap = {};
          const mcpTools = [];
          for (const mcpClient of this.mcpClients) {
            try {
              for (var _d = true, _e = (e_1 = void 0, __asyncValues(listAllTools(mcpClient))), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
                _c = _f.value;
                _d = false;
                const mcpTool = _c;
                mcpTools.push(mcpTool);
                const mcpToolName = mcpTool.name;
                if (functionMap[mcpToolName]) {
                  throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);
                }
                functionMap[mcpToolName] = mcpClient;
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
          }
          this.mcpTools = mcpTools;
          this.functionNameToMcpClient = functionMap;
        });
      }
      tool() {
        return __async(this, null, function* () {
          yield this.initialize();
          return mcpToolsToGeminiTool(this.mcpTools, this.config);
        });
      }
      callTool(functionCalls) {
        return __async(this, null, function* () {
          yield this.initialize();
          const functionCallResponseParts = [];
          for (const functionCall of functionCalls) {
            if (functionCall.name in this.functionNameToMcpClient) {
              const mcpClient = this.functionNameToMcpClient[functionCall.name];
              let requestOptions = void 0;
              if (this.config.timeout) {
                requestOptions = {
                  timeout: this.config.timeout
                };
              }
              const callToolResponse = yield mcpClient.callTool(
                {
                  name: functionCall.name,
                  arguments: functionCall.args
                },
                // Set the result schema to undefined to allow MCP to rely on the
                // default schema.
                void 0,
                requestOptions
              );
              functionCallResponseParts.push({
                functionResponse: {
                  name: functionCall.name,
                  response: callToolResponse.isError ? { error: callToolResponse } : callToolResponse
                }
              });
            }
          }
          return functionCallResponseParts;
        });
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function handleWebSocketMessage$1(apiClient, onmessage, event) {
      return __async(this, null, function* () {
        const serverMessage = new LiveMusicServerMessage();
        let data;
        if (event.data instanceof Blob) {
          data = JSON.parse(yield event.data.text());
        } else {
          data = JSON.parse(event.data);
        }
        Object.assign(serverMessage, data);
        onmessage(serverMessage);
      });
    }
    class LiveMusic {
      constructor(apiClient, auth2, webSocketFactory) {
        this.apiClient = apiClient;
        this.auth = auth2;
        this.webSocketFactory = webSocketFactory;
      }
      /**
           Establishes a connection to the specified model and returns a
           LiveMusicSession object representing that connection.
      
           @experimental
      
           @remarks
      
           @param params - The parameters for establishing a connection to the model.
           @return A live session.
      
           @example
           ```ts
           let model = 'models/lyria-realtime-exp';
           const session = await ai.live.music.connect({
             model: model,
             callbacks: {
               onmessage: (e: MessageEvent) => {
                 console.log('Received message from the server: %s\n', debug(e.data));
               },
               onerror: (e: ErrorEvent) => {
                 console.log('Error occurred: %s\n', debug(e.error));
               },
               onclose: (e: CloseEvent) => {
                 console.log('Connection closed.');
               },
             },
           });
           ```
          */
      connect(params) {
        return __async(this, null, function* () {
          var _a, _b;
          if (this.apiClient.isVertexAI()) {
            throw new Error("Live music is not supported for Vertex AI.");
          }
          console.warn("Live music generation is experimental and may change in future versions.");
          const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();
          const apiVersion = this.apiClient.getApiVersion();
          const headers = mapToHeaders$1(this.apiClient.getDefaultHeaders());
          const apiKey2 = this.apiClient.getApiKey();
          const url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.BidiGenerateMusic?key=${apiKey2}`;
          let onopenResolve = () => {
          };
          const onopenPromise = new Promise((resolve) => {
            onopenResolve = resolve;
          });
          const callbacks = params.callbacks;
          const onopenAwaitedCallback = function() {
            onopenResolve({});
          };
          const apiClient = this.apiClient;
          const websocketCallbacks = {
            onopen: onopenAwaitedCallback,
            onmessage: (event) => {
              void handleWebSocketMessage$1(apiClient, callbacks.onmessage, event);
            },
            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function(e) {
            },
            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {
            }
          };
          const conn = this.webSocketFactory.create(url, headersToMap$1(headers), websocketCallbacks);
          conn.connect();
          yield onopenPromise;
          const model = tModel(this.apiClient, params.model);
          const setup = { model };
          const clientMessage = { setup };
          conn.send(JSON.stringify(clientMessage));
          return new LiveMusicSession(conn, this.apiClient);
        });
      }
    }
    class LiveMusicSession {
      constructor(conn, apiClient) {
        this.conn = conn;
        this.apiClient = apiClient;
      }
      /**
          Sets inputs to steer music generation. Updates the session's current
          weighted prompts.
      
          @param params - Contains one property, `weightedPrompts`.
      
            - `weightedPrompts` to send to the model; weights are normalized to
              sum to 1.0.
      
          @experimental
         */
      setWeightedPrompts(params) {
        return __async(this, null, function* () {
          if (!params.weightedPrompts || Object.keys(params.weightedPrompts).length === 0) {
            throw new Error("Weighted prompts must be set and contain at least one entry.");
          }
          const clientContent = liveMusicSetWeightedPromptsParametersToMldev(params);
          this.conn.send(JSON.stringify({ clientContent }));
        });
      }
      /**
          Sets a configuration to the model. Updates the session's current
          music generation config.
      
          @param params - Contains one property, `musicGenerationConfig`.
      
            - `musicGenerationConfig` to set in the model. Passing an empty or
          undefined config to the model will reset the config to defaults.
      
          @experimental
         */
      setMusicGenerationConfig(params) {
        return __async(this, null, function* () {
          if (!params.musicGenerationConfig) {
            params.musicGenerationConfig = {};
          }
          const setConfigParameters = liveMusicSetConfigParametersToMldev(params);
          this.conn.send(JSON.stringify(setConfigParameters));
        });
      }
      sendPlaybackControl(playbackControl) {
        const clientMessage = { playbackControl };
        this.conn.send(JSON.stringify(clientMessage));
      }
      /**
       * Start the music stream.
       *
       * @experimental
       */
      play() {
        this.sendPlaybackControl(LiveMusicPlaybackControl.PLAY);
      }
      /**
       * Temporarily halt the music stream. Use `play` to resume from the current
       * position.
       *
       * @experimental
       */
      pause() {
        this.sendPlaybackControl(LiveMusicPlaybackControl.PAUSE);
      }
      /**
       * Stop the music stream and reset the state. Retains the current prompts
       * and config.
       *
       * @experimental
       */
      stop() {
        this.sendPlaybackControl(LiveMusicPlaybackControl.STOP);
      }
      /**
       * Resets the context of the music generation without stopping it.
       * Retains the current prompts and config.
       *
       * @experimental
       */
      resetContext() {
        this.sendPlaybackControl(LiveMusicPlaybackControl.RESET_CONTEXT);
      }
      /**
           Terminates the WebSocket connection.
      
           @experimental
         */
      close() {
        this.conn.close();
      }
    }
    function headersToMap$1(headers) {
      const headerMap = {};
      headers.forEach((value, key) => {
        headerMap[key] = value;
      });
      return headerMap;
    }
    function mapToHeaders$1(map) {
      const headers = new Headers();
      for (const [key, value] of Object.entries(map)) {
        headers.append(key, value);
      }
      return headers;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    const FUNCTION_RESPONSE_REQUIRES_ID = "FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.";
    function handleWebSocketMessage(apiClient, onmessage, event) {
      return __async(this, null, function* () {
        const serverMessage = new LiveServerMessage();
        let jsonData;
        if (event.data instanceof Blob) {
          jsonData = yield event.data.text();
        } else if (event.data instanceof ArrayBuffer) {
          jsonData = new TextDecoder().decode(event.data);
        } else {
          jsonData = event.data;
        }
        const data = JSON.parse(jsonData);
        if (apiClient.isVertexAI()) {
          const resp = liveServerMessageFromVertex(data);
          Object.assign(serverMessage, resp);
        } else {
          const resp = data;
          Object.assign(serverMessage, resp);
        }
        onmessage(serverMessage);
      });
    }
    class Live {
      constructor(apiClient, auth2, webSocketFactory) {
        this.apiClient = apiClient;
        this.auth = auth2;
        this.webSocketFactory = webSocketFactory;
        this.music = new LiveMusic(this.apiClient, this.auth, this.webSocketFactory);
      }
      /**
           Establishes a connection to the specified model with the given
           configuration and returns a Session object representing that connection.
      
           @experimental Built-in MCP support is an experimental feature, may change in
           future versions.
      
           @remarks
      
           @param params - The parameters for establishing a connection to the model.
           @return A live session.
      
           @example
           ```ts
           let model: string;
           if (GOOGLE_GENAI_USE_VERTEXAI) {
             model = 'gemini-2.0-flash-live-preview-04-09';
           } else {
             model = 'gemini-live-2.5-flash-preview';
           }
           const session = await ai.live.connect({
             model: model,
             config: {
               responseModalities: [Modality.AUDIO],
             },
             callbacks: {
               onopen: () => {
                 console.log('Connected to the socket.');
               },
               onmessage: (e: MessageEvent) => {
                 console.log('Received message from the server: %s\n', debug(e.data));
               },
               onerror: (e: ErrorEvent) => {
                 console.log('Error occurred: %s\n', debug(e.error));
               },
               onclose: (e: CloseEvent) => {
                 console.log('Connection closed.');
               },
             },
           });
           ```
          */
      connect(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d, _e, _f;
          if (params.config && params.config.httpOptions) {
            throw new Error("The Live module does not support httpOptions at request-level in LiveConnectConfig yet. Please use the client-level httpOptions configuration instead.");
          }
          const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();
          const apiVersion = this.apiClient.getApiVersion();
          let url;
          const clientHeaders = this.apiClient.getHeaders();
          if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {
            setMcpUsageHeader(clientHeaders);
          }
          const headers = mapToHeaders(clientHeaders);
          if (this.apiClient.isVertexAI()) {
            url = `${websocketBaseUrl}/ws/google.cloud.aiplatform.${apiVersion}.LlmBidiService/BidiGenerateContent`;
            yield this.auth.addAuthHeaders(headers, url);
          } else {
            const apiKey2 = this.apiClient.getApiKey();
            let method = "BidiGenerateContent";
            let keyName = "key";
            if (apiKey2 === null || apiKey2 === void 0 ? void 0 : apiKey2.startsWith("auth_tokens/")) {
              console.warn("Warning: Ephemeral token support is experimental and may change in future versions.");
              if (apiVersion !== "v1alpha") {
                console.warn("Warning: The SDK's ephemeral token support is in v1alpha only. Please use const ai = new GoogleGenAI({apiKey: token.name, httpOptions: { apiVersion: 'v1alpha' }}); before session connection.");
              }
              method = "BidiGenerateContentConstrained";
              keyName = "access_token";
            }
            url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.${method}?${keyName}=${apiKey2}`;
          }
          let onopenResolve = () => {
          };
          const onopenPromise = new Promise((resolve) => {
            onopenResolve = resolve;
          });
          const callbacks = params.callbacks;
          const onopenAwaitedCallback = function() {
            var _a2;
            (_a2 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onopen) === null || _a2 === void 0 ? void 0 : _a2.call(callbacks);
            onopenResolve({});
          };
          const apiClient = this.apiClient;
          const websocketCallbacks = {
            onopen: onopenAwaitedCallback,
            onmessage: (event) => {
              void handleWebSocketMessage(apiClient, callbacks.onmessage, event);
            },
            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function(e) {
            },
            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {
            }
          };
          const conn = this.webSocketFactory.create(url, headersToMap(headers), websocketCallbacks);
          conn.connect();
          yield onopenPromise;
          let transformedModel = tModel(this.apiClient, params.model);
          if (this.apiClient.isVertexAI() && transformedModel.startsWith("publishers/")) {
            const project = this.apiClient.getProject();
            const location = this.apiClient.getLocation();
            transformedModel = `projects/${project}/locations/${location}/` + transformedModel;
          }
          let clientMessage = {};
          if (this.apiClient.isVertexAI() && ((_c = params.config) === null || _c === void 0 ? void 0 : _c.responseModalities) === void 0) {
            if (params.config === void 0) {
              params.config = { responseModalities: [Modality.AUDIO] };
            } else {
              params.config.responseModalities = [Modality.AUDIO];
            }
          }
          if ((_d = params.config) === null || _d === void 0 ? void 0 : _d.generationConfig) {
            console.warn("Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).");
          }
          const inputTools = (_f = (_e = params.config) === null || _e === void 0 ? void 0 : _e.tools) !== null && _f !== void 0 ? _f : [];
          const convertedTools = [];
          for (const tool of inputTools) {
            if (this.isCallableTool(tool)) {
              const callableTool = tool;
              convertedTools.push(yield callableTool.tool());
            } else {
              convertedTools.push(tool);
            }
          }
          if (convertedTools.length > 0) {
            params.config.tools = convertedTools;
          }
          const liveConnectParameters = {
            model: transformedModel,
            config: params.config,
            callbacks: params.callbacks
          };
          if (this.apiClient.isVertexAI()) {
            clientMessage = liveConnectParametersToVertex(this.apiClient, liveConnectParameters);
          } else {
            clientMessage = liveConnectParametersToMldev(this.apiClient, liveConnectParameters);
          }
          delete clientMessage["config"];
          conn.send(JSON.stringify(clientMessage));
          return new Session(conn, this.apiClient);
        });
      }
      // TODO: b/416041229 - Abstract this method to a common place.
      isCallableTool(tool) {
        return "callTool" in tool && typeof tool.callTool === "function";
      }
    }
    const defaultLiveSendClientContentParamerters = {
      turnComplete: true
    };
    class Session {
      constructor(conn, apiClient) {
        this.conn = conn;
        this.apiClient = apiClient;
      }
      tLiveClientContent(apiClient, params) {
        if (params.turns !== null && params.turns !== void 0) {
          let contents = [];
          try {
            contents = tContents(params.turns);
            if (!apiClient.isVertexAI()) {
              contents = contents.map((item) => contentToMldev$1(item));
            }
          } catch (_a) {
            throw new Error(`Failed to parse client content "turns", type: '${typeof params.turns}'`);
          }
          return {
            clientContent: { turns: contents, turnComplete: params.turnComplete }
          };
        }
        return {
          clientContent: { turnComplete: params.turnComplete }
        };
      }
      tLiveClienttToolResponse(apiClient, params) {
        let functionResponses = [];
        if (params.functionResponses == null) {
          throw new Error("functionResponses is required.");
        }
        if (!Array.isArray(params.functionResponses)) {
          functionResponses = [params.functionResponses];
        } else {
          functionResponses = params.functionResponses;
        }
        if (functionResponses.length === 0) {
          throw new Error("functionResponses is required.");
        }
        for (const functionResponse of functionResponses) {
          if (typeof functionResponse !== "object" || functionResponse === null || !("name" in functionResponse) || !("response" in functionResponse)) {
            throw new Error(`Could not parse function response, type '${typeof functionResponse}'.`);
          }
          if (!apiClient.isVertexAI() && !("id" in functionResponse)) {
            throw new Error(FUNCTION_RESPONSE_REQUIRES_ID);
          }
        }
        const clientMessage = {
          toolResponse: { functionResponses }
        };
        return clientMessage;
      }
      /**
          Send a message over the established connection.
      
          @param params - Contains two **optional** properties, `turns` and
              `turnComplete`.
      
            - `turns` will be converted to a `Content[]`
            - `turnComplete: true` [default] indicates that you are done sending
              content and expect a response. If `turnComplete: false`, the server
              will wait for additional messages before starting generation.
      
          @experimental
      
          @remarks
          There are two ways to send messages to the live API:
          `sendClientContent` and `sendRealtimeInput`.
      
          `sendClientContent` messages are added to the model context **in order**.
          Having a conversation using `sendClientContent` messages is roughly
          equivalent to using the `Chat.sendMessageStream`, except that the state of
          the `chat` history is stored on the API server instead of locally.
      
          Because of `sendClientContent`'s order guarantee, the model cannot respons
          as quickly to `sendClientContent` messages as to `sendRealtimeInput`
          messages. This makes the biggest difference when sending objects that have
          significant preprocessing time (typically images).
      
          The `sendClientContent` message sends a `Content[]`
          which has more options than the `Blob` sent by `sendRealtimeInput`.
      
          So the main use-cases for `sendClientContent` over `sendRealtimeInput` are:
      
          - Sending anything that can't be represented as a `Blob` (text,
          `sendClientContent({turns="Hello?"}`)).
          - Managing turns when not using audio input and voice activity detection.
            (`sendClientContent({turnComplete:true})` or the short form
          `sendClientContent()`)
          - Prefilling a conversation context
            ```
            sendClientContent({
                turns: [
                  Content({role:user, parts:...}),
                  Content({role:user, parts:...}),
                  ...
                ]
            })
            ```
          @experimental
         */
      sendClientContent(params) {
        params = Object.assign(Object.assign({}, defaultLiveSendClientContentParamerters), params);
        const clientMessage = this.tLiveClientContent(this.apiClient, params);
        this.conn.send(JSON.stringify(clientMessage));
      }
      /**
          Send a realtime message over the established connection.
      
          @param params - Contains one property, `media`.
      
            - `media` will be converted to a `Blob`
      
          @experimental
      
          @remarks
          Use `sendRealtimeInput` for realtime audio chunks and video frames (images).
      
          With `sendRealtimeInput` the api will respond to audio automatically
          based on voice activity detection (VAD).
      
          `sendRealtimeInput` is optimized for responsivness at the expense of
          deterministic ordering guarantees. Audio and video tokens are to the
          context when they become available.
      
          Note: The Call signature expects a `Blob` object, but only a subset
          of audio and image mimetypes are allowed.
         */
      sendRealtimeInput(params) {
        let clientMessage = {};
        if (this.apiClient.isVertexAI()) {
          clientMessage = {
            "realtimeInput": liveSendRealtimeInputParametersToVertex(params)
          };
        } else {
          clientMessage = {
            "realtimeInput": liveSendRealtimeInputParametersToMldev(params)
          };
        }
        this.conn.send(JSON.stringify(clientMessage));
      }
      /**
          Send a function response message over the established connection.
      
          @param params - Contains property `functionResponses`.
      
            - `functionResponses` will be converted to a `functionResponses[]`
      
          @remarks
          Use `sendFunctionResponse` to reply to `LiveServerToolCall` from the server.
      
          Use {@link types.LiveConnectConfig#tools} to configure the callable functions.
      
          @experimental
         */
      sendToolResponse(params) {
        if (params.functionResponses == null) {
          throw new Error("Tool response parameters are required.");
        }
        const clientMessage = this.tLiveClienttToolResponse(this.apiClient, params);
        this.conn.send(JSON.stringify(clientMessage));
      }
      /**
           Terminates the WebSocket connection.
      
           @experimental
      
           @example
           ```ts
           let model: string;
           if (GOOGLE_GENAI_USE_VERTEXAI) {
             model = 'gemini-2.0-flash-live-preview-04-09';
           } else {
             model = 'gemini-live-2.5-flash-preview';
           }
           const session = await ai.live.connect({
             model: model,
             config: {
               responseModalities: [Modality.AUDIO],
             }
           });
      
           session.close();
           ```
         */
      close() {
        this.conn.close();
      }
    }
    function headersToMap(headers) {
      const headerMap = {};
      headers.forEach((value, key) => {
        headerMap[key] = value;
      });
      return headerMap;
    }
    function mapToHeaders(map) {
      const headers = new Headers();
      for (const [key, value] of Object.entries(map)) {
        headers.append(key, value);
      }
      return headers;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    const DEFAULT_MAX_REMOTE_CALLS = 10;
    function shouldDisableAfc(config) {
      var _a, _b, _c;
      if ((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.disable) {
        return true;
      }
      let callableToolsPresent = false;
      for (const tool of (_b = config === null || config === void 0 ? void 0 : config.tools) !== null && _b !== void 0 ? _b : []) {
        if (isCallableTool(tool)) {
          callableToolsPresent = true;
          break;
        }
      }
      if (!callableToolsPresent) {
        return true;
      }
      const maxCalls = (_c = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _c === void 0 ? void 0 : _c.maximumRemoteCalls;
      if (maxCalls && (maxCalls < 0 || !Number.isInteger(maxCalls)) || maxCalls == 0) {
        console.warn("Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:", maxCalls);
        return true;
      }
      return false;
    }
    function isCallableTool(tool) {
      return "callTool" in tool && typeof tool.callTool === "function";
    }
    function hasCallableTools(params) {
      var _a, _b, _c;
      return (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) === null || _b === void 0 ? void 0 : _b.some((tool) => isCallableTool(tool))) !== null && _c !== void 0 ? _c : false;
    }
    function findAfcIncompatibleToolIndexes(params) {
      var _a;
      const afcIncompatibleToolIndexes = [];
      if (!((_a = params === null || params === void 0 ? void 0 : params.config) === null || _a === void 0 ? void 0 : _a.tools)) {
        return afcIncompatibleToolIndexes;
      }
      params.config.tools.forEach((tool, index) => {
        if (isCallableTool(tool)) {
          return;
        }
        const geminiTool = tool;
        if (geminiTool.functionDeclarations && geminiTool.functionDeclarations.length > 0) {
          afcIncompatibleToolIndexes.push(index);
        }
      });
      return afcIncompatibleToolIndexes;
    }
    function shouldAppendAfcHistory(config) {
      var _a;
      return !((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.ignoreCallHistory);
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    class Models extends BaseModule {
      constructor(apiClient) {
        super();
        this.apiClient = apiClient;
        this.generateContent = (params) => __async(this, null, function* () {
          var _a, _b, _c, _d, _e;
          const transformedParams = yield this.processParamsMaybeAddMcpUsage(params);
          this.maybeMoveToResponseJsonSchem(params);
          if (!hasCallableTools(params) || shouldDisableAfc(params.config)) {
            return yield this.generateContentInternal(transformedParams);
          }
          const incompatibleToolIndexes = findAfcIncompatibleToolIndexes(params);
          if (incompatibleToolIndexes.length > 0) {
            const formattedIndexes = incompatibleToolIndexes.map((index) => `tools[${index}]`).join(", ");
            throw new Error(`Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations is not yet supported. Incompatible tools found at ${formattedIndexes}.`);
          }
          let response;
          let functionResponseContent;
          const automaticFunctionCallingHistory = tContents(transformedParams.contents);
          const maxRemoteCalls = (_c = (_b = (_a = transformedParams.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;
          let remoteCalls = 0;
          while (remoteCalls < maxRemoteCalls) {
            response = yield this.generateContentInternal(transformedParams);
            if (!response.functionCalls || response.functionCalls.length === 0) {
              break;
            }
            const responseContent = response.candidates[0].content;
            const functionResponseParts = [];
            for (const tool of (_e = (_d = params.config) === null || _d === void 0 ? void 0 : _d.tools) !== null && _e !== void 0 ? _e : []) {
              if (isCallableTool(tool)) {
                const callableTool = tool;
                const parts = yield callableTool.callTool(response.functionCalls);
                functionResponseParts.push(...parts);
              }
            }
            remoteCalls++;
            functionResponseContent = {
              role: "user",
              parts: functionResponseParts
            };
            transformedParams.contents = tContents(transformedParams.contents);
            transformedParams.contents.push(responseContent);
            transformedParams.contents.push(functionResponseContent);
            if (shouldAppendAfcHistory(transformedParams.config)) {
              automaticFunctionCallingHistory.push(responseContent);
              automaticFunctionCallingHistory.push(functionResponseContent);
            }
          }
          if (shouldAppendAfcHistory(transformedParams.config)) {
            response.automaticFunctionCallingHistory = automaticFunctionCallingHistory;
          }
          return response;
        });
        this.generateContentStream = (params) => __async(this, null, function* () {
          var _a, _b, _c, _d, _e;
          this.maybeMoveToResponseJsonSchem(params);
          if (shouldDisableAfc(params.config)) {
            const transformedParams = yield this.processParamsMaybeAddMcpUsage(params);
            return yield this.generateContentStreamInternal(transformedParams);
          }
          const incompatibleToolIndexes = findAfcIncompatibleToolIndexes(params);
          if (incompatibleToolIndexes.length > 0) {
            const formattedIndexes = incompatibleToolIndexes.map((index) => `tools[${index}]`).join(", ");
            throw new Error(`Incompatible tools found at ${formattedIndexes}. Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations" is not yet supported.`);
          }
          const streamFunctionCall = (_c = (_b = (_a = params === null || params === void 0 ? void 0 : params.config) === null || _a === void 0 ? void 0 : _a.toolConfig) === null || _b === void 0 ? void 0 : _b.functionCallingConfig) === null || _c === void 0 ? void 0 : _c.streamFunctionCallArguments;
          const disableAfc = (_e = (_d = params === null || params === void 0 ? void 0 : params.config) === null || _d === void 0 ? void 0 : _d.automaticFunctionCalling) === null || _e === void 0 ? void 0 : _e.disable;
          if (streamFunctionCall && !disableAfc) {
            throw new Error("Running in streaming mode with 'streamFunctionCallArguments' enabled, this feature is not compatible with automatic function calling (AFC). Please set 'config.automaticFunctionCalling.disable' to true to disable AFC or leave 'config.toolConfig.functionCallingConfig.streamFunctionCallArguments' to be undefined or set to false to disable streaming function call arguments feature.");
          }
          return yield this.processAfcStream(params);
        });
        this.generateImages = (params) => __async(this, null, function* () {
          return yield this.generateImagesInternal(params).then((apiResponse) => {
            var _a;
            let positivePromptSafetyAttributes;
            const generatedImages = [];
            if (apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.generatedImages) {
              for (const generatedImage of apiResponse.generatedImages) {
                if (generatedImage && (generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) && ((_a = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) === null || _a === void 0 ? void 0 : _a.contentType) === "Positive Prompt") {
                  positivePromptSafetyAttributes = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes;
                } else {
                  generatedImages.push(generatedImage);
                }
              }
            }
            let response;
            if (positivePromptSafetyAttributes) {
              response = {
                generatedImages,
                positivePromptSafetyAttributes,
                sdkHttpResponse: apiResponse.sdkHttpResponse
              };
            } else {
              response = {
                generatedImages,
                sdkHttpResponse: apiResponse.sdkHttpResponse
              };
            }
            return response;
          });
        });
        this.list = (params) => __async(this, null, function* () {
          var _a;
          const defaultConfig = {
            queryBase: true
          };
          const actualConfig = Object.assign(Object.assign({}, defaultConfig), params === null || params === void 0 ? void 0 : params.config);
          const actualParams = {
            config: actualConfig
          };
          if (this.apiClient.isVertexAI()) {
            if (!actualParams.config.queryBase) {
              if ((_a = actualParams.config) === null || _a === void 0 ? void 0 : _a.filter) {
                throw new Error("Filtering tuned models list for Vertex AI is not currently supported");
              } else {
                actualParams.config.filter = "labels.tune-type:*";
              }
            }
          }
          return new Pager(PagedItem.PAGED_ITEM_MODELS, (x) => this.listInternal(x), yield this.listInternal(actualParams), actualParams);
        });
        this.editImage = (params) => __async(this, null, function* () {
          const paramsInternal = {
            model: params.model,
            prompt: params.prompt,
            referenceImages: [],
            config: params.config
          };
          if (params.referenceImages) {
            if (params.referenceImages) {
              paramsInternal.referenceImages = params.referenceImages.map((img) => img.toReferenceImageAPI());
            }
          }
          return yield this.editImageInternal(paramsInternal);
        });
        this.upscaleImage = (params) => __async(this, null, function* () {
          let apiConfig = {
            numberOfImages: 1,
            mode: "upscale"
          };
          if (params.config) {
            apiConfig = Object.assign(Object.assign({}, apiConfig), params.config);
          }
          const apiParams = {
            model: params.model,
            image: params.image,
            upscaleFactor: params.upscaleFactor,
            config: apiConfig
          };
          return yield this.upscaleImageInternal(apiParams);
        });
        this.generateVideos = (params) => __async(this, null, function* () {
          var _a, _b, _c, _d, _e, _f;
          if ((params.prompt || params.image || params.video) && params.source) {
            throw new Error("Source and prompt/image/video are mutually exclusive. Please only use source.");
          }
          if (!this.apiClient.isVertexAI()) {
            if (((_a = params.video) === null || _a === void 0 ? void 0 : _a.uri) && ((_b = params.video) === null || _b === void 0 ? void 0 : _b.videoBytes)) {
              params.video = {
                uri: params.video.uri,
                mimeType: params.video.mimeType
              };
            } else if (((_d = (_c = params.source) === null || _c === void 0 ? void 0 : _c.video) === null || _d === void 0 ? void 0 : _d.uri) && ((_f = (_e = params.source) === null || _e === void 0 ? void 0 : _e.video) === null || _f === void 0 ? void 0 : _f.videoBytes)) {
              params.source.video = {
                uri: params.source.video.uri,
                mimeType: params.source.video.mimeType
              };
            }
          }
          return yield this.generateVideosInternal(params);
        });
      }
      /**
       * This logic is needed for GenerateContentConfig only.
       * Previously we made GenerateContentConfig.responseSchema field to accept
       * unknown. Since v1.9.0, we switch to use backend JSON schema support.
       * To maintain backward compatibility, we move the data that was treated as
       * JSON schema from the responseSchema field to the responseJsonSchema field.
       */
      maybeMoveToResponseJsonSchem(params) {
        if (params.config && params.config.responseSchema) {
          if (!params.config.responseJsonSchema) {
            if (Object.keys(params.config.responseSchema).includes("$schema")) {
              params.config.responseJsonSchema = params.config.responseSchema;
              delete params.config.responseSchema;
            }
          }
        }
        return;
      }
      /**
       * Transforms the CallableTools in the parameters to be simply Tools, it
       * copies the params into a new object and replaces the tools, it does not
       * modify the original params. Also sets the MCP usage header if there are
       * MCP tools in the parameters.
       */
      processParamsMaybeAddMcpUsage(params) {
        return __async(this, null, function* () {
          var _a, _b, _c;
          const tools = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools;
          if (!tools) {
            return params;
          }
          const transformedTools = yield Promise.all(tools.map((tool) => __async(null, null, function* () {
            if (isCallableTool(tool)) {
              const callableTool = tool;
              return yield callableTool.tool();
            }
            return tool;
          })));
          const newParams = {
            model: params.model,
            contents: params.contents,
            config: Object.assign(Object.assign({}, params.config), { tools: transformedTools })
          };
          newParams.config.tools = transformedTools;
          if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {
            const headers = (_c = (_b = params.config.httpOptions) === null || _b === void 0 ? void 0 : _b.headers) !== null && _c !== void 0 ? _c : {};
            let newHeaders = Object.assign({}, headers);
            if (Object.keys(newHeaders).length === 0) {
              newHeaders = this.apiClient.getDefaultHeaders();
            }
            setMcpUsageHeader(newHeaders);
            newParams.config.httpOptions = Object.assign(Object.assign({}, params.config.httpOptions), { headers: newHeaders });
          }
          return newParams;
        });
      }
      initAfcToolsMap(params) {
        return __async(this, null, function* () {
          var _a, _b, _c;
          const afcTools = /* @__PURE__ */ new Map();
          for (const tool of (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) !== null && _b !== void 0 ? _b : []) {
            if (isCallableTool(tool)) {
              const callableTool = tool;
              const toolDeclaration = yield callableTool.tool();
              for (const declaration of (_c = toolDeclaration.functionDeclarations) !== null && _c !== void 0 ? _c : []) {
                if (!declaration.name) {
                  throw new Error("Function declaration name is required.");
                }
                if (afcTools.has(declaration.name)) {
                  throw new Error(`Duplicate tool declaration name: ${declaration.name}`);
                }
                afcTools.set(declaration.name, callableTool);
              }
            }
          }
          return afcTools;
        });
      }
      processAfcStream(params) {
        return __async(this, null, function* () {
          var _a, _b, _c;
          const maxRemoteCalls = (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;
          let wereFunctionsCalled = false;
          let remoteCallCount = 0;
          const afcToolsMap = yield this.initAfcToolsMap(params);
          return (function(models, afcTools, params2) {
            var _a2, _b2;
            return __asyncGenerator(this, arguments, function* () {
              var _c2, e_1, _d, _e;
              while (remoteCallCount < maxRemoteCalls) {
                if (wereFunctionsCalled) {
                  remoteCallCount++;
                  wereFunctionsCalled = false;
                }
                const transformedParams = yield __await(models.processParamsMaybeAddMcpUsage(params2));
                const response = yield __await(models.generateContentStreamInternal(transformedParams));
                const functionResponses = [];
                const responseContents = [];
                try {
                  for (var _f = true, response_1 = (e_1 = void 0, __asyncValues(response)), response_1_1; response_1_1 = yield __await(response_1.next()), _c2 = response_1_1.done, !_c2; _f = true) {
                    _e = response_1_1.value;
                    _f = false;
                    const chunk = _e;
                    yield yield __await(chunk);
                    if (chunk.candidates && ((_a2 = chunk.candidates[0]) === null || _a2 === void 0 ? void 0 : _a2.content)) {
                      responseContents.push(chunk.candidates[0].content);
                      for (const part of (_b2 = chunk.candidates[0].content.parts) !== null && _b2 !== void 0 ? _b2 : []) {
                        if (remoteCallCount < maxRemoteCalls && part.functionCall) {
                          if (!part.functionCall.name) {
                            throw new Error("Function call name was not returned by the model.");
                          }
                          if (!afcTools.has(part.functionCall.name)) {
                            throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${afcTools.keys()}, mising tool: ${part.functionCall.name}`);
                          } else {
                            const responseParts = yield __await(afcTools.get(part.functionCall.name).callTool([part.functionCall]));
                            functionResponses.push(...responseParts);
                          }
                        }
                      }
                    }
                  }
                } catch (e_1_1) {
                  e_1 = { error: e_1_1 };
                } finally {
                  try {
                    if (!_f && !_c2 && (_d = response_1.return)) yield __await(_d.call(response_1));
                  } finally {
                    if (e_1) throw e_1.error;
                  }
                }
                if (functionResponses.length > 0) {
                  wereFunctionsCalled = true;
                  const typedResponseChunk = new GenerateContentResponse();
                  typedResponseChunk.candidates = [
                    {
                      content: {
                        role: "user",
                        parts: functionResponses
                      }
                    }
                  ];
                  yield yield __await(typedResponseChunk);
                  const newContents = [];
                  newContents.push(...responseContents);
                  newContents.push({
                    role: "user",
                    parts: functionResponses
                  });
                  const updatedContents = tContents(params2.contents).concat(newContents);
                  params2.contents = updatedContents;
                } else {
                  break;
                }
              }
            });
          })(this, afcToolsMap, params);
        });
      }
      generateContentInternal(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = generateContentParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:generateContent", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = generateContentResponseFromVertex(apiResponse);
              const typedResp = new GenerateContentResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = generateContentParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:generateContent", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = generateContentResponseFromMldev(apiResponse);
              const typedResp = new GenerateContentResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
      generateContentStreamInternal(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = generateContentParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:streamGenerateContent?alt=sse", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            const apiClient = this.apiClient;
            response = apiClient.requestStream({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            });
            return response.then(function(apiResponse) {
              return __asyncGenerator(this, arguments, function* () {
                var _a2, e_2, _b2, _c2;
                try {
                  for (var _d2 = true, apiResponse_1 = __asyncValues(apiResponse), apiResponse_1_1; apiResponse_1_1 = yield __await(apiResponse_1.next()), _a2 = apiResponse_1_1.done, !_a2; _d2 = true) {
                    _c2 = apiResponse_1_1.value;
                    _d2 = false;
                    const chunk = _c2;
                    const resp = generateContentResponseFromVertex(yield __await(chunk.json()));
                    resp["sdkHttpResponse"] = {
                      headers: chunk.headers
                    };
                    const typedResp = new GenerateContentResponse();
                    Object.assign(typedResp, resp);
                    yield yield __await(typedResp);
                  }
                } catch (e_2_1) {
                  e_2 = { error: e_2_1 };
                } finally {
                  try {
                    if (!_d2 && !_a2 && (_b2 = apiResponse_1.return)) yield __await(_b2.call(apiResponse_1));
                  } finally {
                    if (e_2) throw e_2.error;
                  }
                }
              });
            });
          } else {
            const body = generateContentParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:streamGenerateContent?alt=sse", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            const apiClient = this.apiClient;
            response = apiClient.requestStream({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            });
            return response.then(function(apiResponse) {
              return __asyncGenerator(this, arguments, function* () {
                var _a2, e_3, _b2, _c2;
                try {
                  for (var _d2 = true, apiResponse_2 = __asyncValues(apiResponse), apiResponse_2_1; apiResponse_2_1 = yield __await(apiResponse_2.next()), _a2 = apiResponse_2_1.done, !_a2; _d2 = true) {
                    _c2 = apiResponse_2_1.value;
                    _d2 = false;
                    const chunk = _c2;
                    const resp = generateContentResponseFromMldev(yield __await(chunk.json()));
                    resp["sdkHttpResponse"] = {
                      headers: chunk.headers
                    };
                    const typedResp = new GenerateContentResponse();
                    Object.assign(typedResp, resp);
                    yield yield __await(typedResp);
                  }
                } catch (e_3_1) {
                  e_3 = { error: e_3_1 };
                } finally {
                  try {
                    if (!_d2 && !_a2 && (_b2 = apiResponse_2.return)) yield __await(_b2.call(apiResponse_2));
                  } finally {
                    if (e_3) throw e_3.error;
                  }
                }
              });
            });
          }
        });
      }
      /**
       * Calculates embeddings for the given contents. Only text is supported.
       *
       * @param params - The parameters for embedding contents.
       * @return The response from the API.
       *
       * @example
       * ```ts
       * const response = await ai.models.embedContent({
       *  model: 'text-embedding-004',
       *  contents: [
       *    'What is your name?',
       *    'What is your favorite color?',
       *  ],
       *  config: {
       *    outputDimensionality: 64,
       *  },
       * });
       * console.log(response);
       * ```
       */
      embedContent(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = embedContentParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:predict", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = embedContentResponseFromVertex(apiResponse);
              const typedResp = new EmbedContentResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = embedContentParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:batchEmbedContents", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = embedContentResponseFromMldev(apiResponse);
              const typedResp = new EmbedContentResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
      /**
       * Private method for generating images.
       */
      generateImagesInternal(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = generateImagesParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:predict", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = generateImagesResponseFromVertex(apiResponse);
              const typedResp = new GenerateImagesResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = generateImagesParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:predict", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = generateImagesResponseFromMldev(apiResponse);
              const typedResp = new GenerateImagesResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
      /**
       * Private method for editing an image.
       */
      editImageInternal(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = editImageParametersInternalToVertex(this.apiClient, params);
            path = formatMap("{model}:predict", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = editImageResponseFromVertex(apiResponse);
              const typedResp = new EditImageResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            throw new Error("This method is only supported by the Vertex AI.");
          }
        });
      }
      /**
       * Private method for upscaling an image.
       */
      upscaleImageInternal(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = upscaleImageAPIParametersInternalToVertex(this.apiClient, params);
            path = formatMap("{model}:predict", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = upscaleImageResponseFromVertex(apiResponse);
              const typedResp = new UpscaleImageResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            throw new Error("This method is only supported by the Vertex AI.");
          }
        });
      }
      /**
       * Recontextualizes an image.
       *
       * There are two types of recontextualization currently supported:
       * 1) Imagen Product Recontext - Generate images of products in new scenes
       *    and contexts.
       * 2) Virtual Try-On: Generate images of persons modeling fashion products.
       *
       * @param params - The parameters for recontextualizing an image.
       * @return The response from the API.
       *
       * @example
       * ```ts
       * const response1 = await ai.models.recontextImage({
       *  model: 'imagen-product-recontext-preview-06-30',
       *  source: {
       *    prompt: 'In a modern kitchen setting.',
       *    productImages: [productImage],
       *  },
       *  config: {
       *    numberOfImages: 1,
       *  },
       * });
       * console.log(response1?.generatedImages?.[0]?.image?.imageBytes);
       *
       * const response2 = await ai.models.recontextImage({
       *  model: 'virtual-try-on-preview-08-04',
       *  source: {
       *    personImage: personImage,
       *    productImages: [productImage],
       *  },
       *  config: {
       *    numberOfImages: 1,
       *  },
       * });
       * console.log(response2?.generatedImages?.[0]?.image?.imageBytes);
       * ```
       */
      recontextImage(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = recontextImageParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:predict", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = recontextImageResponseFromVertex(apiResponse);
              const typedResp = new RecontextImageResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            throw new Error("This method is only supported by the Vertex AI.");
          }
        });
      }
      /**
       * Segments an image, creating a mask of a specified area.
       *
       * @param params - The parameters for segmenting an image.
       * @return The response from the API.
       *
       * @example
       * ```ts
       * const response = await ai.models.segmentImage({
       *  model: 'image-segmentation-001',
       *  source: {
       *    image: image,
       *  },
       *  config: {
       *    mode: 'foreground',
       *  },
       * });
       * console.log(response?.generatedMasks?.[0]?.mask?.imageBytes);
       * ```
       */
      segmentImage(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = segmentImageParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:predict", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = segmentImageResponseFromVertex(apiResponse);
              const typedResp = new SegmentImageResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            throw new Error("This method is only supported by the Vertex AI.");
          }
        });
      }
      /**
       * Fetches information about a model by name.
       *
       * @example
       * ```ts
       * const modelInfo = await ai.models.get({model: 'gemini-2.0-flash'});
       * ```
       */
      get(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = getModelParametersToVertex(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = modelFromVertex(apiResponse);
              return resp;
            });
          } else {
            const body = getModelParametersToMldev(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = modelFromMldev(apiResponse);
              return resp;
            });
          }
        });
      }
      listInternal(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = listModelsParametersToVertex(this.apiClient, params);
            path = formatMap("{models_url}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listModelsResponseFromVertex(apiResponse);
              const typedResp = new ListModelsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = listModelsParametersToMldev(this.apiClient, params);
            path = formatMap("{models_url}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listModelsResponseFromMldev(apiResponse);
              const typedResp = new ListModelsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
      /**
       * Updates a tuned model by its name.
       *
       * @param params - The parameters for updating the model.
       * @return The response from the API.
       *
       * @example
       * ```ts
       * const response = await ai.models.update({
       *   model: 'tuned-model-name',
       *   config: {
       *     displayName: 'New display name',
       *     description: 'New description',
       *   },
       * });
       * ```
       */
      update(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = updateModelParametersToVertex(this.apiClient, params);
            path = formatMap("{model}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "PATCH",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = modelFromVertex(apiResponse);
              return resp;
            });
          } else {
            const body = updateModelParametersToMldev(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "PATCH",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = modelFromMldev(apiResponse);
              return resp;
            });
          }
        });
      }
      /**
       * Deletes a tuned model by its name.
       *
       * @param params - The parameters for deleting the model.
       * @return The response from the API.
       *
       * @example
       * ```ts
       * const response = await ai.models.delete({model: 'tuned-model-name'});
       * ```
       */
      delete(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = deleteModelParametersToVertex(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = deleteModelResponseFromVertex(apiResponse);
              const typedResp = new DeleteModelResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = deleteModelParametersToMldev(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = deleteModelResponseFromMldev(apiResponse);
              const typedResp = new DeleteModelResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
      /**
       * Counts the number of tokens in the given contents. Multimodal input is
       * supported for Gemini models.
       *
       * @param params - The parameters for counting tokens.
       * @return The response from the API.
       *
       * @example
       * ```ts
       * const response = await ai.models.countTokens({
       *  model: 'gemini-2.0-flash',
       *  contents: 'The quick brown fox jumps over the lazy dog.'
       * });
       * console.log(response);
       * ```
       */
      countTokens(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = countTokensParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:countTokens", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = countTokensResponseFromVertex(apiResponse);
              const typedResp = new CountTokensResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = countTokensParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:countTokens", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = countTokensResponseFromMldev(apiResponse);
              const typedResp = new CountTokensResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
      /**
       * Given a list of contents, returns a corresponding TokensInfo containing
       * the list of tokens and list of token ids.
       *
       * This method is not supported by the Gemini Developer API.
       *
       * @param params - The parameters for computing tokens.
       * @return The response from the API.
       *
       * @example
       * ```ts
       * const response = await ai.models.computeTokens({
       *  model: 'gemini-2.0-flash',
       *  contents: 'What is your name?'
       * });
       * console.log(response);
       * ```
       */
      computeTokens(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = computeTokensParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:computeTokens", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = computeTokensResponseFromVertex(apiResponse);
              const typedResp = new ComputeTokensResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            throw new Error("This method is only supported by the Vertex AI.");
          }
        });
      }
      /**
       * Private method for generating videos.
       */
      generateVideosInternal(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = generateVideosParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:predictLongRunning", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = generateVideosOperationFromVertex(apiResponse);
              const typedResp = new GenerateVideosOperation();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = generateVideosParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:predictLongRunning", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = generateVideosOperationFromMldev(apiResponse);
              const typedResp = new GenerateVideosOperation();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    class Operations extends BaseModule {
      constructor(apiClient) {
        super();
        this.apiClient = apiClient;
      }
      /**
       * Gets the status of a long-running operation.
       *
       * @param parameters The parameters for the get operation request.
       * @return The updated Operation object, with the latest status or result.
       */
      getVideosOperation(parameters) {
        return __async(this, null, function* () {
          const operation = parameters.operation;
          const config = parameters.config;
          if (operation.name === void 0 || operation.name === "") {
            throw new Error("Operation name is required.");
          }
          if (this.apiClient.isVertexAI()) {
            const resourceName2 = operation.name.split("/operations/")[0];
            let httpOptions = void 0;
            if (config && "httpOptions" in config) {
              httpOptions = config.httpOptions;
            }
            const rawOperation = yield this.fetchPredictVideosOperationInternal({
              operationName: operation.name,
              resourceName: resourceName2,
              config: { httpOptions }
            });
            return operation._fromAPIResponse({
              apiResponse: rawOperation,
              _isVertexAI: true
            });
          } else {
            const rawOperation = yield this.getVideosOperationInternal({
              operationName: operation.name,
              config
            });
            return operation._fromAPIResponse({
              apiResponse: rawOperation,
              _isVertexAI: false
            });
          }
        });
      }
      /**
       * Gets the status of a long-running operation.
       *
       * @param parameters The parameters for the get operation request.
       * @return The updated Operation object, with the latest status or result.
       */
      get(parameters) {
        return __async(this, null, function* () {
          const operation = parameters.operation;
          const config = parameters.config;
          if (operation.name === void 0 || operation.name === "") {
            throw new Error("Operation name is required.");
          }
          if (this.apiClient.isVertexAI()) {
            const resourceName2 = operation.name.split("/operations/")[0];
            let httpOptions = void 0;
            if (config && "httpOptions" in config) {
              httpOptions = config.httpOptions;
            }
            const rawOperation = yield this.fetchPredictVideosOperationInternal({
              operationName: operation.name,
              resourceName: resourceName2,
              config: { httpOptions }
            });
            return operation._fromAPIResponse({
              apiResponse: rawOperation,
              _isVertexAI: true
            });
          } else {
            const rawOperation = yield this.getVideosOperationInternal({
              operationName: operation.name,
              config
            });
            return operation._fromAPIResponse({
              apiResponse: rawOperation,
              _isVertexAI: false
            });
          }
        });
      }
      getVideosOperationInternal(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = getOperationParametersToVertex(params);
            path = formatMap("{operationName}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response;
          } else {
            const body = getOperationParametersToMldev(params);
            path = formatMap("{operationName}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response;
          }
        });
      }
      fetchPredictVideosOperationInternal(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = fetchPredictOperationParametersToVertex(params);
            path = formatMap("{resourceName}:fetchPredictOperation", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response;
          } else {
            throw new Error("This method is only supported by the Vertex AI.");
          }
        });
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function blobToMldev(fromObject) {
      const toObject = {};
      const fromData = getValueByPath(fromObject, ["data"]);
      if (fromData != null) {
        setValueByPath(toObject, ["data"], fromData);
      }
      if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
        throw new Error("displayName parameter is not supported in Gemini API.");
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function contentToMldev(fromObject) {
      const toObject = {};
      const fromParts = getValueByPath(fromObject, ["parts"]);
      if (fromParts != null) {
        let transformedList = fromParts;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return partToMldev(item);
          });
        }
        setValueByPath(toObject, ["parts"], transformedList);
      }
      const fromRole = getValueByPath(fromObject, ["role"]);
      if (fromRole != null) {
        setValueByPath(toObject, ["role"], fromRole);
      }
      return toObject;
    }
    function createAuthTokenConfigToMldev(apiClient, fromObject, parentObject) {
      const toObject = {};
      const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
      if (parentObject !== void 0 && fromExpireTime != null) {
        setValueByPath(parentObject, ["expireTime"], fromExpireTime);
      }
      const fromNewSessionExpireTime = getValueByPath(fromObject, [
        "newSessionExpireTime"
      ]);
      if (parentObject !== void 0 && fromNewSessionExpireTime != null) {
        setValueByPath(parentObject, ["newSessionExpireTime"], fromNewSessionExpireTime);
      }
      const fromUses = getValueByPath(fromObject, ["uses"]);
      if (parentObject !== void 0 && fromUses != null) {
        setValueByPath(parentObject, ["uses"], fromUses);
      }
      const fromLiveConnectConstraints = getValueByPath(fromObject, [
        "liveConnectConstraints"
      ]);
      if (parentObject !== void 0 && fromLiveConnectConstraints != null) {
        setValueByPath(parentObject, ["bidiGenerateContentSetup"], liveConnectConstraintsToMldev(apiClient, fromLiveConnectConstraints));
      }
      const fromLockAdditionalFields = getValueByPath(fromObject, [
        "lockAdditionalFields"
      ]);
      if (parentObject !== void 0 && fromLockAdditionalFields != null) {
        setValueByPath(parentObject, ["fieldMask"], fromLockAdditionalFields);
      }
      return toObject;
    }
    function createAuthTokenParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        setValueByPath(toObject, ["config"], createAuthTokenConfigToMldev(apiClient, fromConfig, toObject));
      }
      return toObject;
    }
    function fileDataToMldev(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
        throw new Error("displayName parameter is not supported in Gemini API.");
      }
      const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
      if (fromFileUri != null) {
        setValueByPath(toObject, ["fileUri"], fromFileUri);
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function functionCallToMldev(fromObject) {
      const toObject = {};
      const fromId = getValueByPath(fromObject, ["id"]);
      if (fromId != null) {
        setValueByPath(toObject, ["id"], fromId);
      }
      const fromArgs = getValueByPath(fromObject, ["args"]);
      if (fromArgs != null) {
        setValueByPath(toObject, ["args"], fromArgs);
      }
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
        throw new Error("partialArgs parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
        throw new Error("willContinue parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function googleMapsToMldev(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
        throw new Error("authConfig parameter is not supported in Gemini API.");
      }
      const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
      if (fromEnableWidget != null) {
        setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
      }
      return toObject;
    }
    function googleSearchToMldev(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
        throw new Error("excludeDomains parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
        throw new Error("blockingConfidence parameter is not supported in Gemini API.");
      }
      const fromTimeRangeFilter = getValueByPath(fromObject, [
        "timeRangeFilter"
      ]);
      if (fromTimeRangeFilter != null) {
        setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
      }
      return toObject;
    }
    function liveConnectConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromGenerationConfig = getValueByPath(fromObject, [
        "generationConfig"
      ]);
      if (parentObject !== void 0 && fromGenerationConfig != null) {
        setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
      }
      const fromResponseModalities = getValueByPath(fromObject, [
        "responseModalities"
      ]);
      if (parentObject !== void 0 && fromResponseModalities != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
      }
      const fromTemperature = getValueByPath(fromObject, ["temperature"]);
      if (parentObject !== void 0 && fromTemperature != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
      }
      const fromTopP = getValueByPath(fromObject, ["topP"]);
      if (parentObject !== void 0 && fromTopP != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
      }
      const fromTopK = getValueByPath(fromObject, ["topK"]);
      if (parentObject !== void 0 && fromTopK != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
      }
      const fromMaxOutputTokens = getValueByPath(fromObject, [
        "maxOutputTokens"
      ]);
      if (parentObject !== void 0 && fromMaxOutputTokens != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
      }
      const fromMediaResolution = getValueByPath(fromObject, [
        "mediaResolution"
      ]);
      if (parentObject !== void 0 && fromMediaResolution != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
      }
      const fromSeed = getValueByPath(fromObject, ["seed"]);
      if (parentObject !== void 0 && fromSeed != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
      }
      const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
      if (parentObject !== void 0 && fromSpeechConfig != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], tLiveSpeechConfig(fromSpeechConfig));
      }
      const fromThinkingConfig = getValueByPath(fromObject, [
        "thinkingConfig"
      ]);
      if (parentObject !== void 0 && fromThinkingConfig != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "thinkingConfig"], fromThinkingConfig);
      }
      const fromEnableAffectiveDialog = getValueByPath(fromObject, [
        "enableAffectiveDialog"
      ]);
      if (parentObject !== void 0 && fromEnableAffectiveDialog != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
      }
      const fromSystemInstruction = getValueByPath(fromObject, [
        "systemInstruction"
      ]);
      if (parentObject !== void 0 && fromSystemInstruction != null) {
        setValueByPath(parentObject, ["setup", "systemInstruction"], contentToMldev(tContent(fromSystemInstruction)));
      }
      const fromTools = getValueByPath(fromObject, ["tools"]);
      if (parentObject !== void 0 && fromTools != null) {
        let transformedList = tTools(fromTools);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return toolToMldev(tTool(item));
          });
        }
        setValueByPath(parentObject, ["setup", "tools"], transformedList);
      }
      const fromSessionResumption = getValueByPath(fromObject, [
        "sessionResumption"
      ]);
      if (parentObject !== void 0 && fromSessionResumption != null) {
        setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToMldev(fromSessionResumption));
      }
      const fromInputAudioTranscription = getValueByPath(fromObject, [
        "inputAudioTranscription"
      ]);
      if (parentObject !== void 0 && fromInputAudioTranscription != null) {
        setValueByPath(parentObject, ["setup", "inputAudioTranscription"], fromInputAudioTranscription);
      }
      const fromOutputAudioTranscription = getValueByPath(fromObject, [
        "outputAudioTranscription"
      ]);
      if (parentObject !== void 0 && fromOutputAudioTranscription != null) {
        setValueByPath(parentObject, ["setup", "outputAudioTranscription"], fromOutputAudioTranscription);
      }
      const fromRealtimeInputConfig = getValueByPath(fromObject, [
        "realtimeInputConfig"
      ]);
      if (parentObject !== void 0 && fromRealtimeInputConfig != null) {
        setValueByPath(parentObject, ["setup", "realtimeInputConfig"], fromRealtimeInputConfig);
      }
      const fromContextWindowCompression = getValueByPath(fromObject, [
        "contextWindowCompression"
      ]);
      if (parentObject !== void 0 && fromContextWindowCompression != null) {
        setValueByPath(parentObject, ["setup", "contextWindowCompression"], fromContextWindowCompression);
      }
      const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
      if (parentObject !== void 0 && fromProactivity != null) {
        setValueByPath(parentObject, ["setup", "proactivity"], fromProactivity);
      }
      return toObject;
    }
    function liveConnectConstraintsToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        setValueByPath(toObject, ["config"], liveConnectConfigToMldev(fromConfig, toObject));
      }
      return toObject;
    }
    function partToMldev(fromObject) {
      const toObject = {};
      const fromMediaResolution = getValueByPath(fromObject, [
        "mediaResolution"
      ]);
      if (fromMediaResolution != null) {
        setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
      }
      const fromCodeExecutionResult = getValueByPath(fromObject, [
        "codeExecutionResult"
      ]);
      if (fromCodeExecutionResult != null) {
        setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
      }
      const fromExecutableCode = getValueByPath(fromObject, [
        "executableCode"
      ]);
      if (fromExecutableCode != null) {
        setValueByPath(toObject, ["executableCode"], fromExecutableCode);
      }
      const fromFileData = getValueByPath(fromObject, ["fileData"]);
      if (fromFileData != null) {
        setValueByPath(toObject, ["fileData"], fileDataToMldev(fromFileData));
      }
      const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
      if (fromFunctionCall != null) {
        setValueByPath(toObject, ["functionCall"], functionCallToMldev(fromFunctionCall));
      }
      const fromFunctionResponse = getValueByPath(fromObject, [
        "functionResponse"
      ]);
      if (fromFunctionResponse != null) {
        setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
      }
      const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
      if (fromInlineData != null) {
        setValueByPath(toObject, ["inlineData"], blobToMldev(fromInlineData));
      }
      const fromText = getValueByPath(fromObject, ["text"]);
      if (fromText != null) {
        setValueByPath(toObject, ["text"], fromText);
      }
      const fromThought = getValueByPath(fromObject, ["thought"]);
      if (fromThought != null) {
        setValueByPath(toObject, ["thought"], fromThought);
      }
      const fromThoughtSignature = getValueByPath(fromObject, [
        "thoughtSignature"
      ]);
      if (fromThoughtSignature != null) {
        setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
      }
      const fromVideoMetadata = getValueByPath(fromObject, [
        "videoMetadata"
      ]);
      if (fromVideoMetadata != null) {
        setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
      }
      return toObject;
    }
    function sessionResumptionConfigToMldev(fromObject) {
      const toObject = {};
      const fromHandle = getValueByPath(fromObject, ["handle"]);
      if (fromHandle != null) {
        setValueByPath(toObject, ["handle"], fromHandle);
      }
      if (getValueByPath(fromObject, ["transparent"]) !== void 0) {
        throw new Error("transparent parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function toolToMldev(fromObject) {
      const toObject = {};
      const fromFunctionDeclarations = getValueByPath(fromObject, [
        "functionDeclarations"
      ]);
      if (fromFunctionDeclarations != null) {
        let transformedList = fromFunctionDeclarations;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["functionDeclarations"], transformedList);
      }
      if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
        throw new Error("retrieval parameter is not supported in Gemini API.");
      }
      const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
        "googleSearchRetrieval"
      ]);
      if (fromGoogleSearchRetrieval != null) {
        setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
      }
      const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
      if (fromComputerUse != null) {
        setValueByPath(toObject, ["computerUse"], fromComputerUse);
      }
      const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
      if (fromFileSearch != null) {
        setValueByPath(toObject, ["fileSearch"], fromFileSearch);
      }
      const fromCodeExecution = getValueByPath(fromObject, [
        "codeExecution"
      ]);
      if (fromCodeExecution != null) {
        setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
      }
      if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
        throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
      }
      const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
      if (fromGoogleMaps != null) {
        setValueByPath(toObject, ["googleMaps"], googleMapsToMldev(fromGoogleMaps));
      }
      const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
      if (fromGoogleSearch != null) {
        setValueByPath(toObject, ["googleSearch"], googleSearchToMldev(fromGoogleSearch));
      }
      const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
      if (fromUrlContext != null) {
        setValueByPath(toObject, ["urlContext"], fromUrlContext);
      }
      return toObject;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function getFieldMasks(setup) {
      const fields = [];
      for (const key in setup) {
        if (Object.prototype.hasOwnProperty.call(setup, key)) {
          const value = setup[key];
          if (typeof value === "object" && value != null && Object.keys(value).length > 0) {
            const field = Object.keys(value).map((kk) => `${key}.${kk}`);
            fields.push(...field);
          } else {
            fields.push(key);
          }
        }
      }
      return fields.join(",");
    }
    function convertBidiSetupToTokenSetup(requestDict, config) {
      let setupForMaskGeneration = null;
      const bidiGenerateContentSetupValue = requestDict["bidiGenerateContentSetup"];
      if (typeof bidiGenerateContentSetupValue === "object" && bidiGenerateContentSetupValue !== null && "setup" in bidiGenerateContentSetupValue) {
        const innerSetup = bidiGenerateContentSetupValue.setup;
        if (typeof innerSetup === "object" && innerSetup !== null) {
          requestDict["bidiGenerateContentSetup"] = innerSetup;
          setupForMaskGeneration = innerSetup;
        } else {
          delete requestDict["bidiGenerateContentSetup"];
        }
      } else if (bidiGenerateContentSetupValue !== void 0) {
        delete requestDict["bidiGenerateContentSetup"];
      }
      const preExistingFieldMask = requestDict["fieldMask"];
      if (setupForMaskGeneration) {
        const generatedMaskFromBidi = getFieldMasks(setupForMaskGeneration);
        if (Array.isArray(config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && (config === null || config === void 0 ? void 0 : config.lockAdditionalFields.length) === 0) {
          if (generatedMaskFromBidi) {
            requestDict["fieldMask"] = generatedMaskFromBidi;
          } else {
            delete requestDict["fieldMask"];
          }
        } else if ((config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && config.lockAdditionalFields.length > 0 && preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {
          const generationConfigFields = [
            "temperature",
            "topK",
            "topP",
            "maxOutputTokens",
            "responseModalities",
            "seed",
            "speechConfig"
          ];
          let mappedFieldsFromPreExisting = [];
          if (preExistingFieldMask.length > 0) {
            mappedFieldsFromPreExisting = preExistingFieldMask.map((field) => {
              if (generationConfigFields.includes(field)) {
                return `generationConfig.${field}`;
              }
              return field;
            });
          }
          const finalMaskParts = [];
          if (generatedMaskFromBidi) {
            finalMaskParts.push(generatedMaskFromBidi);
          }
          if (mappedFieldsFromPreExisting.length > 0) {
            finalMaskParts.push(...mappedFieldsFromPreExisting);
          }
          if (finalMaskParts.length > 0) {
            requestDict["fieldMask"] = finalMaskParts.join(",");
          } else {
            delete requestDict["fieldMask"];
          }
        } else {
          delete requestDict["fieldMask"];
        }
      } else {
        if (preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {
          requestDict["fieldMask"] = preExistingFieldMask.join(",");
        } else {
          delete requestDict["fieldMask"];
        }
      }
      return requestDict;
    }
    class Tokens extends BaseModule {
      constructor(apiClient) {
        super();
        this.apiClient = apiClient;
      }
      /**
       * Creates an ephemeral auth token resource.
       *
       * @experimental
       *
       * @remarks
       * Ephemeral auth tokens is only supported in the Gemini Developer API.
       * It can be used for the session connection to the Live constrained API.
       * Support in v1alpha only.
       *
       * @param params - The parameters for the create request.
       * @return The created auth token.
       *
       * @example
       * ```ts
       * const ai = new GoogleGenAI({
       *     apiKey: token.name,
       *     httpOptions: { apiVersion: 'v1alpha' }  // Support in v1alpha only.
       * });
       *
       * // Case 1: If LiveEphemeralParameters is unset, unlock LiveConnectConfig
       * // when using the token in Live API sessions. Each session connection can
       * // use a different configuration.
       * const config: CreateAuthTokenConfig = {
       *     uses: 3,
       *     expireTime: '2025-05-01T00:00:00Z',
       * }
       * const token = await ai.tokens.create(config);
       *
       * // Case 2: If LiveEphemeralParameters is set, lock all fields in
       * // LiveConnectConfig when using the token in Live API sessions. For
       * // example, changing `outputAudioTranscription` in the Live API
       * // connection will be ignored by the API.
       * const config: CreateAuthTokenConfig =
       *     uses: 3,
       *     expireTime: '2025-05-01T00:00:00Z',
       *     LiveEphemeralParameters: {
       *        model: 'gemini-2.0-flash-001',
       *        config: {
       *           'responseModalities': ['AUDIO'],
       *           'systemInstruction': 'Always answer in English.',
       *        }
       *     }
       * }
       * const token = await ai.tokens.create(config);
       *
       * // Case 3: If LiveEphemeralParameters is set and lockAdditionalFields is
       * // set, lock LiveConnectConfig with set and additional fields (e.g.
       * // responseModalities, systemInstruction, temperature in this example) when
       * // using the token in Live API sessions.
       * const config: CreateAuthTokenConfig =
       *     uses: 3,
       *     expireTime: '2025-05-01T00:00:00Z',
       *     LiveEphemeralParameters: {
       *        model: 'gemini-2.0-flash-001',
       *        config: {
       *           'responseModalities': ['AUDIO'],
       *           'systemInstruction': 'Always answer in English.',
       *        }
       *     },
       *     lockAdditionalFields: ['temperature'],
       * }
       * const token = await ai.tokens.create(config);
       *
       * // Case 4: If LiveEphemeralParameters is set and lockAdditionalFields is
       * // empty array, lock LiveConnectConfig with set fields (e.g.
       * // responseModalities, systemInstruction in this example) when using the
       * // token in Live API sessions.
       * const config: CreateAuthTokenConfig =
       *     uses: 3,
       *     expireTime: '2025-05-01T00:00:00Z',
       *     LiveEphemeralParameters: {
       *        model: 'gemini-2.0-flash-001',
       *        config: {
       *           'responseModalities': ['AUDIO'],
       *           'systemInstruction': 'Always answer in English.',
       *        }
       *     },
       *     lockAdditionalFields: [],
       * }
       * const token = await ai.tokens.create(config);
       * ```
       */
      create(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("The client.tokens.create method is only supported by the Gemini Developer API.");
          } else {
            const body = createAuthTokenParametersToMldev(this.apiClient, params);
            path = formatMap("auth_tokens", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            const transformedBody = convertBidiSetupToTokenSetup(body, params.config);
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(transformedBody),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          }
        });
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function createFileSearchStoreConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
      if (parentObject !== void 0 && fromDisplayName != null) {
        setValueByPath(parentObject, ["displayName"], fromDisplayName);
      }
      return toObject;
    }
    function createFileSearchStoreParametersToMldev(fromObject) {
      const toObject = {};
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        createFileSearchStoreConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function deleteFileSearchStoreConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromForce = getValueByPath(fromObject, ["force"]);
      if (parentObject !== void 0 && fromForce != null) {
        setValueByPath(parentObject, ["_query", "force"], fromForce);
      }
      return toObject;
    }
    function deleteFileSearchStoreParametersToMldev(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], fromName);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        deleteFileSearchStoreConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function getFileSearchStoreParametersToMldev(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], fromName);
      }
      return toObject;
    }
    function importFileConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromCustomMetadata = getValueByPath(fromObject, [
        "customMetadata"
      ]);
      if (parentObject !== void 0 && fromCustomMetadata != null) {
        let transformedList = fromCustomMetadata;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(parentObject, ["customMetadata"], transformedList);
      }
      const fromChunkingConfig = getValueByPath(fromObject, [
        "chunkingConfig"
      ]);
      if (parentObject !== void 0 && fromChunkingConfig != null) {
        setValueByPath(parentObject, ["chunkingConfig"], fromChunkingConfig);
      }
      return toObject;
    }
    function importFileOperationFromMldev(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromMetadata = getValueByPath(fromObject, ["metadata"]);
      if (fromMetadata != null) {
        setValueByPath(toObject, ["metadata"], fromMetadata);
      }
      const fromDone = getValueByPath(fromObject, ["done"]);
      if (fromDone != null) {
        setValueByPath(toObject, ["done"], fromDone);
      }
      const fromError = getValueByPath(fromObject, ["error"]);
      if (fromError != null) {
        setValueByPath(toObject, ["error"], fromError);
      }
      const fromResponse = getValueByPath(fromObject, ["response"]);
      if (fromResponse != null) {
        setValueByPath(toObject, ["response"], importFileResponseFromMldev(fromResponse));
      }
      return toObject;
    }
    function importFileParametersToMldev(fromObject) {
      const toObject = {};
      const fromFileSearchStoreName = getValueByPath(fromObject, [
        "fileSearchStoreName"
      ]);
      if (fromFileSearchStoreName != null) {
        setValueByPath(toObject, ["_url", "file_search_store_name"], fromFileSearchStoreName);
      }
      const fromFileName = getValueByPath(fromObject, ["fileName"]);
      if (fromFileName != null) {
        setValueByPath(toObject, ["fileName"], fromFileName);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        importFileConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function importFileResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromParent = getValueByPath(fromObject, ["parent"]);
      if (fromParent != null) {
        setValueByPath(toObject, ["parent"], fromParent);
      }
      const fromDocumentName = getValueByPath(fromObject, ["documentName"]);
      if (fromDocumentName != null) {
        setValueByPath(toObject, ["documentName"], fromDocumentName);
      }
      return toObject;
    }
    function listFileSearchStoresConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
      if (parentObject !== void 0 && fromPageSize != null) {
        setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
      }
      const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
      if (parentObject !== void 0 && fromPageToken != null) {
        setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
      }
      return toObject;
    }
    function listFileSearchStoresParametersToMldev(fromObject) {
      const toObject = {};
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        listFileSearchStoresConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function listFileSearchStoresResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromNextPageToken = getValueByPath(fromObject, [
        "nextPageToken"
      ]);
      if (fromNextPageToken != null) {
        setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
      }
      const fromFileSearchStores = getValueByPath(fromObject, [
        "fileSearchStores"
      ]);
      if (fromFileSearchStores != null) {
        let transformedList = fromFileSearchStores;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["fileSearchStores"], transformedList);
      }
      return toObject;
    }
    function uploadToFileSearchStoreConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (parentObject !== void 0 && fromMimeType != null) {
        setValueByPath(parentObject, ["mimeType"], fromMimeType);
      }
      const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
      if (parentObject !== void 0 && fromDisplayName != null) {
        setValueByPath(parentObject, ["displayName"], fromDisplayName);
      }
      const fromCustomMetadata = getValueByPath(fromObject, [
        "customMetadata"
      ]);
      if (parentObject !== void 0 && fromCustomMetadata != null) {
        let transformedList = fromCustomMetadata;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(parentObject, ["customMetadata"], transformedList);
      }
      const fromChunkingConfig = getValueByPath(fromObject, [
        "chunkingConfig"
      ]);
      if (parentObject !== void 0 && fromChunkingConfig != null) {
        setValueByPath(parentObject, ["chunkingConfig"], fromChunkingConfig);
      }
      return toObject;
    }
    function uploadToFileSearchStoreParametersToMldev(fromObject) {
      const toObject = {};
      const fromFileSearchStoreName = getValueByPath(fromObject, [
        "fileSearchStoreName"
      ]);
      if (fromFileSearchStoreName != null) {
        setValueByPath(toObject, ["_url", "file_search_store_name"], fromFileSearchStoreName);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        uploadToFileSearchStoreConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function uploadToFileSearchStoreResumableResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      return toObject;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function deleteDocumentConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromForce = getValueByPath(fromObject, ["force"]);
      if (parentObject !== void 0 && fromForce != null) {
        setValueByPath(parentObject, ["_query", "force"], fromForce);
      }
      return toObject;
    }
    function deleteDocumentParametersToMldev(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], fromName);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        deleteDocumentConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function getDocumentParametersToMldev(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], fromName);
      }
      return toObject;
    }
    function listDocumentsConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
      if (parentObject !== void 0 && fromPageSize != null) {
        setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
      }
      const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
      if (parentObject !== void 0 && fromPageToken != null) {
        setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
      }
      return toObject;
    }
    function listDocumentsParametersToMldev(fromObject) {
      const toObject = {};
      const fromParent = getValueByPath(fromObject, ["parent"]);
      if (fromParent != null) {
        setValueByPath(toObject, ["_url", "parent"], fromParent);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        listDocumentsConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function listDocumentsResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromNextPageToken = getValueByPath(fromObject, [
        "nextPageToken"
      ]);
      if (fromNextPageToken != null) {
        setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
      }
      const fromDocuments = getValueByPath(fromObject, ["documents"]);
      if (fromDocuments != null) {
        let transformedList = fromDocuments;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["documents"], transformedList);
      }
      return toObject;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    class Documents extends BaseModule {
      constructor(apiClient) {
        super();
        this.apiClient = apiClient;
        this.list = (params) => __async(this, null, function* () {
          return new Pager(PagedItem.PAGED_ITEM_DOCUMENTS, (x) => this.listInternal({
            parent: params.parent,
            config: x.config
          }), yield this.listInternal(params), params);
        });
      }
      /**
       * Gets a Document.
       *
       * @param params - The parameters for getting a document.
       * @return Document.
       */
      get(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = getDocumentParametersToMldev(params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          }
        });
      }
      /**
       * Deletes a Document.
       *
       * @param params - The parameters for deleting a document.
       */
      delete(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = deleteDocumentParametersToMldev(params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            yield this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            });
          }
        });
      }
      /**
       * Lists all Documents in a FileSearchStore.
       *
       * @param params - The parameters for listing documents.
       * @return ListDocumentsResponse.
       */
      listInternal(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = listDocumentsParametersToMldev(params);
            path = formatMap("{parent}/documents", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = listDocumentsResponseFromMldev(apiResponse);
              const typedResp = new ListDocumentsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    class FileSearchStores extends BaseModule {
      constructor(apiClient, documents = new Documents(apiClient)) {
        super();
        this.apiClient = apiClient;
        this.documents = documents;
        this.list = (..._0) => __async(this, [..._0], function* (params = {}) {
          return new Pager(PagedItem.PAGED_ITEM_FILE_SEARCH_STORES, (x) => this.listInternal(x), yield this.listInternal(params), params);
        });
      }
      /**
       * Uploads a file asynchronously to a given File Search Store.
       * This method is not available in Vertex AI.
       * Supported upload sources:
       * - Node.js: File path (string) or Blob object.
       * - Browser: Blob object (e.g., File).
       *
       * @remarks
       * The `mimeType` can be specified in the `config` parameter. If omitted:
       *  - For file path (string) inputs, the `mimeType` will be inferred from the
       *     file extension.
       *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`
       *     property.
       *
       * This section can contain multiple paragraphs and code examples.
       *
       * @param params - Optional parameters specified in the
       *        `types.UploadToFileSearchStoreParameters` interface.
       *         @see {@link types.UploadToFileSearchStoreParameters#config} for the optional
       *         config in the parameters.
       * @return A promise that resolves to a long running operation.
       * @throws An error if called on a Vertex AI client.
       * @throws An error if the `mimeType` is not provided and can not be inferred,
       * the `mimeType` can be provided in the `params.config` parameter.
       * @throws An error occurs if a suitable upload location cannot be established.
       *
       * @example
       * The following code uploads a file to a given file search store.
       *
       * ```ts
       * const operation = await ai.fileSearchStores.upload({fileSearchStoreName: 'fileSearchStores/foo-bar', file: 'file.txt', config: {
       *   mimeType: 'text/plain',
       * }});
       * console.log(operation.name);
       * ```
       */
      uploadToFileSearchStore(params) {
        return __async(this, null, function* () {
          if (this.apiClient.isVertexAI()) {
            throw new Error("Vertex AI does not support uploading files to a file search store.");
          }
          return this.apiClient.uploadFileToFileSearchStore(params.fileSearchStoreName, params.file, params.config);
        });
      }
      /**
       * Creates a File Search Store.
       *
       * @param params - The parameters for creating a File Search Store.
       * @return FileSearchStore.
       */
      create(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = createFileSearchStoreParametersToMldev(params);
            path = formatMap("fileSearchStores", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          }
        });
      }
      /**
       * Gets a File Search Store.
       *
       * @param params - The parameters for getting a File Search Store.
       * @return FileSearchStore.
       */
      get(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = getFileSearchStoreParametersToMldev(params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          }
        });
      }
      /**
       * Deletes a File Search Store.
       *
       * @param params - The parameters for deleting a File Search Store.
       */
      delete(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = deleteFileSearchStoreParametersToMldev(params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            yield this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            });
          }
        });
      }
      /**
       * Lists all FileSearchStore owned by the user.
       *
       * @param params - The parameters for listing file search stores.
       * @return ListFileSearchStoresResponse.
       */
      listInternal(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = listFileSearchStoresParametersToMldev(params);
            path = formatMap("fileSearchStores", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = listFileSearchStoresResponseFromMldev(apiResponse);
              const typedResp = new ListFileSearchStoresResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
      uploadToFileSearchStoreInternal(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = uploadToFileSearchStoreParametersToMldev(params);
            path = formatMap("upload/v1beta/{file_search_store_name}:uploadToFileSearchStore", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = uploadToFileSearchStoreResumableResponseFromMldev(apiResponse);
              const typedResp = new UploadToFileSearchStoreResumableResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
      /**
       * Imports a File from File Service to a FileSearchStore.
       *
       * This is a long-running operation, see aip.dev/151
       *
       * @param params - The parameters for importing a file to a file search store.
       * @return ImportFileOperation.
       */
      importFile(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = importFileParametersToMldev(params);
            path = formatMap("{file_search_store_name}:importFile", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = importFileOperationFromMldev(apiResponse);
              const typedResp = new ImportFileOperation();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function cancelTuningJobParametersToMldev(fromObject, _rootObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], fromName);
      }
      return toObject;
    }
    function cancelTuningJobParametersToVertex(fromObject, _rootObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], fromName);
      }
      return toObject;
    }
    function createTuningJobConfigToMldev(fromObject, parentObject, _rootObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["validationDataset"]) !== void 0) {
        throw new Error("validationDataset parameter is not supported in Gemini API.");
      }
      const fromTunedModelDisplayName = getValueByPath(fromObject, [
        "tunedModelDisplayName"
      ]);
      if (parentObject !== void 0 && fromTunedModelDisplayName != null) {
        setValueByPath(parentObject, ["displayName"], fromTunedModelDisplayName);
      }
      if (getValueByPath(fromObject, ["description"]) !== void 0) {
        throw new Error("description parameter is not supported in Gemini API.");
      }
      const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
      if (parentObject !== void 0 && fromEpochCount != null) {
        setValueByPath(parentObject, ["tuningTask", "hyperparameters", "epochCount"], fromEpochCount);
      }
      const fromLearningRateMultiplier = getValueByPath(fromObject, [
        "learningRateMultiplier"
      ]);
      if (fromLearningRateMultiplier != null) {
        setValueByPath(toObject, ["tuningTask", "hyperparameters", "learningRateMultiplier"], fromLearningRateMultiplier);
      }
      if (getValueByPath(fromObject, ["exportLastCheckpointOnly"]) !== void 0) {
        throw new Error("exportLastCheckpointOnly parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["preTunedModelCheckpointId"]) !== void 0) {
        throw new Error("preTunedModelCheckpointId parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["adapterSize"]) !== void 0) {
        throw new Error("adapterSize parameter is not supported in Gemini API.");
      }
      const fromBatchSize = getValueByPath(fromObject, ["batchSize"]);
      if (parentObject !== void 0 && fromBatchSize != null) {
        setValueByPath(parentObject, ["tuningTask", "hyperparameters", "batchSize"], fromBatchSize);
      }
      const fromLearningRate = getValueByPath(fromObject, ["learningRate"]);
      if (parentObject !== void 0 && fromLearningRate != null) {
        setValueByPath(parentObject, ["tuningTask", "hyperparameters", "learningRate"], fromLearningRate);
      }
      if (getValueByPath(fromObject, ["labels"]) !== void 0) {
        throw new Error("labels parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["beta"]) !== void 0) {
        throw new Error("beta parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function createTuningJobConfigToVertex(fromObject, parentObject, rootObject) {
      const toObject = {};
      let discriminatorValidationDataset = getValueByPath(rootObject, [
        "config",
        "method"
      ]);
      if (discriminatorValidationDataset === void 0) {
        discriminatorValidationDataset = "SUPERVISED_FINE_TUNING";
      }
      if (discriminatorValidationDataset === "SUPERVISED_FINE_TUNING") {
        const fromValidationDataset = getValueByPath(fromObject, [
          "validationDataset"
        ]);
        if (parentObject !== void 0 && fromValidationDataset != null) {
          setValueByPath(parentObject, ["supervisedTuningSpec"], tuningValidationDatasetToVertex(fromValidationDataset));
        }
      } else if (discriminatorValidationDataset === "PREFERENCE_TUNING") {
        const fromValidationDataset = getValueByPath(fromObject, [
          "validationDataset"
        ]);
        if (parentObject !== void 0 && fromValidationDataset != null) {
          setValueByPath(parentObject, ["preferenceOptimizationSpec"], tuningValidationDatasetToVertex(fromValidationDataset));
        }
      }
      const fromTunedModelDisplayName = getValueByPath(fromObject, [
        "tunedModelDisplayName"
      ]);
      if (parentObject !== void 0 && fromTunedModelDisplayName != null) {
        setValueByPath(parentObject, ["tunedModelDisplayName"], fromTunedModelDisplayName);
      }
      const fromDescription = getValueByPath(fromObject, ["description"]);
      if (parentObject !== void 0 && fromDescription != null) {
        setValueByPath(parentObject, ["description"], fromDescription);
      }
      let discriminatorEpochCount = getValueByPath(rootObject, [
        "config",
        "method"
      ]);
      if (discriminatorEpochCount === void 0) {
        discriminatorEpochCount = "SUPERVISED_FINE_TUNING";
      }
      if (discriminatorEpochCount === "SUPERVISED_FINE_TUNING") {
        const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
        if (parentObject !== void 0 && fromEpochCount != null) {
          setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "epochCount"], fromEpochCount);
        }
      } else if (discriminatorEpochCount === "PREFERENCE_TUNING") {
        const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
        if (parentObject !== void 0 && fromEpochCount != null) {
          setValueByPath(parentObject, ["preferenceOptimizationSpec", "hyperParameters", "epochCount"], fromEpochCount);
        }
      }
      let discriminatorLearningRateMultiplier = getValueByPath(rootObject, [
        "config",
        "method"
      ]);
      if (discriminatorLearningRateMultiplier === void 0) {
        discriminatorLearningRateMultiplier = "SUPERVISED_FINE_TUNING";
      }
      if (discriminatorLearningRateMultiplier === "SUPERVISED_FINE_TUNING") {
        const fromLearningRateMultiplier = getValueByPath(fromObject, [
          "learningRateMultiplier"
        ]);
        if (parentObject !== void 0 && fromLearningRateMultiplier != null) {
          setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "learningRateMultiplier"], fromLearningRateMultiplier);
        }
      } else if (discriminatorLearningRateMultiplier === "PREFERENCE_TUNING") {
        const fromLearningRateMultiplier = getValueByPath(fromObject, [
          "learningRateMultiplier"
        ]);
        if (parentObject !== void 0 && fromLearningRateMultiplier != null) {
          setValueByPath(parentObject, [
            "preferenceOptimizationSpec",
            "hyperParameters",
            "learningRateMultiplier"
          ], fromLearningRateMultiplier);
        }
      }
      let discriminatorExportLastCheckpointOnly = getValueByPath(rootObject, ["config", "method"]);
      if (discriminatorExportLastCheckpointOnly === void 0) {
        discriminatorExportLastCheckpointOnly = "SUPERVISED_FINE_TUNING";
      }
      if (discriminatorExportLastCheckpointOnly === "SUPERVISED_FINE_TUNING") {
        const fromExportLastCheckpointOnly = getValueByPath(fromObject, [
          "exportLastCheckpointOnly"
        ]);
        if (parentObject !== void 0 && fromExportLastCheckpointOnly != null) {
          setValueByPath(parentObject, ["supervisedTuningSpec", "exportLastCheckpointOnly"], fromExportLastCheckpointOnly);
        }
      } else if (discriminatorExportLastCheckpointOnly === "PREFERENCE_TUNING") {
        const fromExportLastCheckpointOnly = getValueByPath(fromObject, [
          "exportLastCheckpointOnly"
        ]);
        if (parentObject !== void 0 && fromExportLastCheckpointOnly != null) {
          setValueByPath(parentObject, ["preferenceOptimizationSpec", "exportLastCheckpointOnly"], fromExportLastCheckpointOnly);
        }
      }
      let discriminatorAdapterSize = getValueByPath(rootObject, [
        "config",
        "method"
      ]);
      if (discriminatorAdapterSize === void 0) {
        discriminatorAdapterSize = "SUPERVISED_FINE_TUNING";
      }
      if (discriminatorAdapterSize === "SUPERVISED_FINE_TUNING") {
        const fromAdapterSize = getValueByPath(fromObject, ["adapterSize"]);
        if (parentObject !== void 0 && fromAdapterSize != null) {
          setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "adapterSize"], fromAdapterSize);
        }
      } else if (discriminatorAdapterSize === "PREFERENCE_TUNING") {
        const fromAdapterSize = getValueByPath(fromObject, ["adapterSize"]);
        if (parentObject !== void 0 && fromAdapterSize != null) {
          setValueByPath(parentObject, ["preferenceOptimizationSpec", "hyperParameters", "adapterSize"], fromAdapterSize);
        }
      }
      if (getValueByPath(fromObject, ["batchSize"]) !== void 0) {
        throw new Error("batchSize parameter is not supported in Vertex AI.");
      }
      if (getValueByPath(fromObject, ["learningRate"]) !== void 0) {
        throw new Error("learningRate parameter is not supported in Vertex AI.");
      }
      const fromLabels = getValueByPath(fromObject, ["labels"]);
      if (parentObject !== void 0 && fromLabels != null) {
        setValueByPath(parentObject, ["labels"], fromLabels);
      }
      const fromBeta = getValueByPath(fromObject, ["beta"]);
      if (parentObject !== void 0 && fromBeta != null) {
        setValueByPath(parentObject, ["preferenceOptimizationSpec", "hyperParameters", "beta"], fromBeta);
      }
      return toObject;
    }
    function createTuningJobParametersPrivateToMldev(fromObject, rootObject) {
      const toObject = {};
      const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
      if (fromBaseModel != null) {
        setValueByPath(toObject, ["baseModel"], fromBaseModel);
      }
      const fromPreTunedModel = getValueByPath(fromObject, [
        "preTunedModel"
      ]);
      if (fromPreTunedModel != null) {
        setValueByPath(toObject, ["preTunedModel"], fromPreTunedModel);
      }
      const fromTrainingDataset = getValueByPath(fromObject, [
        "trainingDataset"
      ]);
      if (fromTrainingDataset != null) {
        tuningDatasetToMldev(fromTrainingDataset);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        createTuningJobConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function createTuningJobParametersPrivateToVertex(fromObject, rootObject) {
      const toObject = {};
      const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
      if (fromBaseModel != null) {
        setValueByPath(toObject, ["baseModel"], fromBaseModel);
      }
      const fromPreTunedModel = getValueByPath(fromObject, [
        "preTunedModel"
      ]);
      if (fromPreTunedModel != null) {
        setValueByPath(toObject, ["preTunedModel"], fromPreTunedModel);
      }
      const fromTrainingDataset = getValueByPath(fromObject, [
        "trainingDataset"
      ]);
      if (fromTrainingDataset != null) {
        tuningDatasetToVertex(fromTrainingDataset, toObject, rootObject);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        createTuningJobConfigToVertex(fromConfig, toObject, rootObject);
      }
      return toObject;
    }
    function getTuningJobParametersToMldev(fromObject, _rootObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], fromName);
      }
      return toObject;
    }
    function getTuningJobParametersToVertex(fromObject, _rootObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], fromName);
      }
      return toObject;
    }
    function listTuningJobsConfigToMldev(fromObject, parentObject, _rootObject) {
      const toObject = {};
      const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
      if (parentObject !== void 0 && fromPageSize != null) {
        setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
      }
      const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
      if (parentObject !== void 0 && fromPageToken != null) {
        setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
      }
      const fromFilter = getValueByPath(fromObject, ["filter"]);
      if (parentObject !== void 0 && fromFilter != null) {
        setValueByPath(parentObject, ["_query", "filter"], fromFilter);
      }
      return toObject;
    }
    function listTuningJobsConfigToVertex(fromObject, parentObject, _rootObject) {
      const toObject = {};
      const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
      if (parentObject !== void 0 && fromPageSize != null) {
        setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
      }
      const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
      if (parentObject !== void 0 && fromPageToken != null) {
        setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
      }
      const fromFilter = getValueByPath(fromObject, ["filter"]);
      if (parentObject !== void 0 && fromFilter != null) {
        setValueByPath(parentObject, ["_query", "filter"], fromFilter);
      }
      return toObject;
    }
    function listTuningJobsParametersToMldev(fromObject, rootObject) {
      const toObject = {};
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        listTuningJobsConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function listTuningJobsParametersToVertex(fromObject, rootObject) {
      const toObject = {};
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        listTuningJobsConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function listTuningJobsResponseFromMldev(fromObject, rootObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromNextPageToken = getValueByPath(fromObject, [
        "nextPageToken"
      ]);
      if (fromNextPageToken != null) {
        setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
      }
      const fromTuningJobs = getValueByPath(fromObject, ["tunedModels"]);
      if (fromTuningJobs != null) {
        let transformedList = fromTuningJobs;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return tuningJobFromMldev(item);
          });
        }
        setValueByPath(toObject, ["tuningJobs"], transformedList);
      }
      return toObject;
    }
    function listTuningJobsResponseFromVertex(fromObject, rootObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromNextPageToken = getValueByPath(fromObject, [
        "nextPageToken"
      ]);
      if (fromNextPageToken != null) {
        setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
      }
      const fromTuningJobs = getValueByPath(fromObject, ["tuningJobs"]);
      if (fromTuningJobs != null) {
        let transformedList = fromTuningJobs;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return tuningJobFromVertex(item);
          });
        }
        setValueByPath(toObject, ["tuningJobs"], transformedList);
      }
      return toObject;
    }
    function tunedModelFromMldev(fromObject, _rootObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["name"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["model"], fromModel);
      }
      const fromEndpoint = getValueByPath(fromObject, ["name"]);
      if (fromEndpoint != null) {
        setValueByPath(toObject, ["endpoint"], fromEndpoint);
      }
      return toObject;
    }
    function tuningDatasetToMldev(fromObject, _rootObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) {
        throw new Error("gcsUri parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["vertexDatasetResource"]) !== void 0) {
        throw new Error("vertexDatasetResource parameter is not supported in Gemini API.");
      }
      const fromExamples = getValueByPath(fromObject, ["examples"]);
      if (fromExamples != null) {
        let transformedList = fromExamples;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["examples", "examples"], transformedList);
      }
      return toObject;
    }
    function tuningDatasetToVertex(fromObject, parentObject, rootObject) {
      const toObject = {};
      let discriminatorGcsUri = getValueByPath(rootObject, [
        "config",
        "method"
      ]);
      if (discriminatorGcsUri === void 0) {
        discriminatorGcsUri = "SUPERVISED_FINE_TUNING";
      }
      if (discriminatorGcsUri === "SUPERVISED_FINE_TUNING") {
        const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
        if (parentObject !== void 0 && fromGcsUri != null) {
          setValueByPath(parentObject, ["supervisedTuningSpec", "trainingDatasetUri"], fromGcsUri);
        }
      } else if (discriminatorGcsUri === "PREFERENCE_TUNING") {
        const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
        if (parentObject !== void 0 && fromGcsUri != null) {
          setValueByPath(parentObject, ["preferenceOptimizationSpec", "trainingDatasetUri"], fromGcsUri);
        }
      }
      let discriminatorVertexDatasetResource = getValueByPath(rootObject, [
        "config",
        "method"
      ]);
      if (discriminatorVertexDatasetResource === void 0) {
        discriminatorVertexDatasetResource = "SUPERVISED_FINE_TUNING";
      }
      if (discriminatorVertexDatasetResource === "SUPERVISED_FINE_TUNING") {
        const fromVertexDatasetResource = getValueByPath(fromObject, [
          "vertexDatasetResource"
        ]);
        if (parentObject !== void 0 && fromVertexDatasetResource != null) {
          setValueByPath(parentObject, ["supervisedTuningSpec", "trainingDatasetUri"], fromVertexDatasetResource);
        }
      } else if (discriminatorVertexDatasetResource === "PREFERENCE_TUNING") {
        const fromVertexDatasetResource = getValueByPath(fromObject, [
          "vertexDatasetResource"
        ]);
        if (parentObject !== void 0 && fromVertexDatasetResource != null) {
          setValueByPath(parentObject, ["preferenceOptimizationSpec", "trainingDatasetUri"], fromVertexDatasetResource);
        }
      }
      if (getValueByPath(fromObject, ["examples"]) !== void 0) {
        throw new Error("examples parameter is not supported in Vertex AI.");
      }
      return toObject;
    }
    function tuningJobFromMldev(fromObject, rootObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromState = getValueByPath(fromObject, ["state"]);
      if (fromState != null) {
        setValueByPath(toObject, ["state"], tTuningJobStatus(fromState));
      }
      const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
      if (fromCreateTime != null) {
        setValueByPath(toObject, ["createTime"], fromCreateTime);
      }
      const fromStartTime = getValueByPath(fromObject, [
        "tuningTask",
        "startTime"
      ]);
      if (fromStartTime != null) {
        setValueByPath(toObject, ["startTime"], fromStartTime);
      }
      const fromEndTime = getValueByPath(fromObject, [
        "tuningTask",
        "completeTime"
      ]);
      if (fromEndTime != null) {
        setValueByPath(toObject, ["endTime"], fromEndTime);
      }
      const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
      if (fromUpdateTime != null) {
        setValueByPath(toObject, ["updateTime"], fromUpdateTime);
      }
      const fromDescription = getValueByPath(fromObject, ["description"]);
      if (fromDescription != null) {
        setValueByPath(toObject, ["description"], fromDescription);
      }
      const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
      if (fromBaseModel != null) {
        setValueByPath(toObject, ["baseModel"], fromBaseModel);
      }
      const fromTunedModel = getValueByPath(fromObject, ["_self"]);
      if (fromTunedModel != null) {
        setValueByPath(toObject, ["tunedModel"], tunedModelFromMldev(fromTunedModel));
      }
      return toObject;
    }
    function tuningJobFromVertex(fromObject, _rootObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromState = getValueByPath(fromObject, ["state"]);
      if (fromState != null) {
        setValueByPath(toObject, ["state"], tTuningJobStatus(fromState));
      }
      const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
      if (fromCreateTime != null) {
        setValueByPath(toObject, ["createTime"], fromCreateTime);
      }
      const fromStartTime = getValueByPath(fromObject, ["startTime"]);
      if (fromStartTime != null) {
        setValueByPath(toObject, ["startTime"], fromStartTime);
      }
      const fromEndTime = getValueByPath(fromObject, ["endTime"]);
      if (fromEndTime != null) {
        setValueByPath(toObject, ["endTime"], fromEndTime);
      }
      const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
      if (fromUpdateTime != null) {
        setValueByPath(toObject, ["updateTime"], fromUpdateTime);
      }
      const fromError = getValueByPath(fromObject, ["error"]);
      if (fromError != null) {
        setValueByPath(toObject, ["error"], fromError);
      }
      const fromDescription = getValueByPath(fromObject, ["description"]);
      if (fromDescription != null) {
        setValueByPath(toObject, ["description"], fromDescription);
      }
      const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
      if (fromBaseModel != null) {
        setValueByPath(toObject, ["baseModel"], fromBaseModel);
      }
      const fromTunedModel = getValueByPath(fromObject, ["tunedModel"]);
      if (fromTunedModel != null) {
        setValueByPath(toObject, ["tunedModel"], fromTunedModel);
      }
      const fromPreTunedModel = getValueByPath(fromObject, [
        "preTunedModel"
      ]);
      if (fromPreTunedModel != null) {
        setValueByPath(toObject, ["preTunedModel"], fromPreTunedModel);
      }
      const fromSupervisedTuningSpec = getValueByPath(fromObject, [
        "supervisedTuningSpec"
      ]);
      if (fromSupervisedTuningSpec != null) {
        setValueByPath(toObject, ["supervisedTuningSpec"], fromSupervisedTuningSpec);
      }
      const fromPreferenceOptimizationSpec = getValueByPath(fromObject, [
        "preferenceOptimizationSpec"
      ]);
      if (fromPreferenceOptimizationSpec != null) {
        setValueByPath(toObject, ["preferenceOptimizationSpec"], fromPreferenceOptimizationSpec);
      }
      const fromTuningDataStats = getValueByPath(fromObject, [
        "tuningDataStats"
      ]);
      if (fromTuningDataStats != null) {
        setValueByPath(toObject, ["tuningDataStats"], fromTuningDataStats);
      }
      const fromEncryptionSpec = getValueByPath(fromObject, [
        "encryptionSpec"
      ]);
      if (fromEncryptionSpec != null) {
        setValueByPath(toObject, ["encryptionSpec"], fromEncryptionSpec);
      }
      const fromPartnerModelTuningSpec = getValueByPath(fromObject, [
        "partnerModelTuningSpec"
      ]);
      if (fromPartnerModelTuningSpec != null) {
        setValueByPath(toObject, ["partnerModelTuningSpec"], fromPartnerModelTuningSpec);
      }
      const fromCustomBaseModel = getValueByPath(fromObject, [
        "customBaseModel"
      ]);
      if (fromCustomBaseModel != null) {
        setValueByPath(toObject, ["customBaseModel"], fromCustomBaseModel);
      }
      const fromExperiment = getValueByPath(fromObject, ["experiment"]);
      if (fromExperiment != null) {
        setValueByPath(toObject, ["experiment"], fromExperiment);
      }
      const fromLabels = getValueByPath(fromObject, ["labels"]);
      if (fromLabels != null) {
        setValueByPath(toObject, ["labels"], fromLabels);
      }
      const fromOutputUri = getValueByPath(fromObject, ["outputUri"]);
      if (fromOutputUri != null) {
        setValueByPath(toObject, ["outputUri"], fromOutputUri);
      }
      const fromPipelineJob = getValueByPath(fromObject, ["pipelineJob"]);
      if (fromPipelineJob != null) {
        setValueByPath(toObject, ["pipelineJob"], fromPipelineJob);
      }
      const fromServiceAccount = getValueByPath(fromObject, [
        "serviceAccount"
      ]);
      if (fromServiceAccount != null) {
        setValueByPath(toObject, ["serviceAccount"], fromServiceAccount);
      }
      const fromTunedModelDisplayName = getValueByPath(fromObject, [
        "tunedModelDisplayName"
      ]);
      if (fromTunedModelDisplayName != null) {
        setValueByPath(toObject, ["tunedModelDisplayName"], fromTunedModelDisplayName);
      }
      const fromVeoTuningSpec = getValueByPath(fromObject, [
        "veoTuningSpec"
      ]);
      if (fromVeoTuningSpec != null) {
        setValueByPath(toObject, ["veoTuningSpec"], fromVeoTuningSpec);
      }
      return toObject;
    }
    function tuningOperationFromMldev(fromObject, _rootObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromMetadata = getValueByPath(fromObject, ["metadata"]);
      if (fromMetadata != null) {
        setValueByPath(toObject, ["metadata"], fromMetadata);
      }
      const fromDone = getValueByPath(fromObject, ["done"]);
      if (fromDone != null) {
        setValueByPath(toObject, ["done"], fromDone);
      }
      const fromError = getValueByPath(fromObject, ["error"]);
      if (fromError != null) {
        setValueByPath(toObject, ["error"], fromError);
      }
      return toObject;
    }
    function tuningValidationDatasetToVertex(fromObject, _rootObject) {
      const toObject = {};
      const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
      if (fromGcsUri != null) {
        setValueByPath(toObject, ["validationDatasetUri"], fromGcsUri);
      }
      const fromVertexDatasetResource = getValueByPath(fromObject, [
        "vertexDatasetResource"
      ]);
      if (fromVertexDatasetResource != null) {
        setValueByPath(toObject, ["validationDatasetUri"], fromVertexDatasetResource);
      }
      return toObject;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    class Tunings extends BaseModule {
      constructor(apiClient) {
        super();
        this.apiClient = apiClient;
        this.get = (params) => __async(this, null, function* () {
          return yield this.getInternal(params);
        });
        this.list = (..._0) => __async(this, [..._0], function* (params = {}) {
          return new Pager(PagedItem.PAGED_ITEM_TUNING_JOBS, (x) => this.listInternal(x), yield this.listInternal(params), params);
        });
        this.tune = (params) => __async(this, null, function* () {
          var _a;
          if (this.apiClient.isVertexAI()) {
            if (params.baseModel.startsWith("projects/")) {
              const preTunedModel = {
                tunedModelName: params.baseModel
              };
              if ((_a = params.config) === null || _a === void 0 ? void 0 : _a.preTunedModelCheckpointId) {
                preTunedModel.checkpointId = params.config.preTunedModelCheckpointId;
              }
              const paramsPrivate = Object.assign(Object.assign({}, params), { preTunedModel });
              paramsPrivate.baseModel = void 0;
              return yield this.tuneInternal(paramsPrivate);
            } else {
              const paramsPrivate = Object.assign({}, params);
              return yield this.tuneInternal(paramsPrivate);
            }
          } else {
            const paramsPrivate = Object.assign({}, params);
            const operation = yield this.tuneMldevInternal(paramsPrivate);
            let tunedModelName = "";
            if (operation["metadata"] !== void 0 && operation["metadata"]["tunedModel"] !== void 0) {
              tunedModelName = operation["metadata"]["tunedModel"];
            } else if (operation["name"] !== void 0 && operation["name"].includes("/operations/")) {
              tunedModelName = operation["name"].split("/operations/")[0];
            }
            const tuningJob = {
              name: tunedModelName,
              state: JobState.JOB_STATE_QUEUED
            };
            return tuningJob;
          }
        });
      }
      getInternal(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = getTuningJobParametersToVertex(params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = tuningJobFromVertex(apiResponse);
              return resp;
            });
          } else {
            const body = getTuningJobParametersToMldev(params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = tuningJobFromMldev(apiResponse);
              return resp;
            });
          }
        });
      }
      listInternal(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = listTuningJobsParametersToVertex(params);
            path = formatMap("tuningJobs", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listTuningJobsResponseFromVertex(apiResponse);
              const typedResp = new ListTuningJobsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = listTuningJobsParametersToMldev(params);
            path = formatMap("tunedModels", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listTuningJobsResponseFromMldev(apiResponse);
              const typedResp = new ListTuningJobsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
      /**
       * Cancels a tuning job.
       *
       * @param params - The parameters for the cancel request.
       * @return The empty response returned by the API.
       *
       * @example
       * ```ts
       * await ai.tunings.cancel({name: '...'}); // The server-generated resource name.
       * ```
       */
      cancel(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = cancelTuningJobParametersToVertex(params);
            path = formatMap("{name}:cancel", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            yield this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            });
          } else {
            const body = cancelTuningJobParametersToMldev(params);
            path = formatMap("{name}:cancel", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            yield this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            });
          }
        });
      }
      tuneInternal(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = createTuningJobParametersPrivateToVertex(params, params);
            path = formatMap("tuningJobs", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = tuningJobFromVertex(apiResponse);
              return resp;
            });
          } else {
            throw new Error("This method is only supported by the Vertex AI.");
          }
        });
      }
      tuneMldevInternal(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = createTuningJobParametersPrivateToMldev(params);
            path = formatMap("tunedModels", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = tuningOperationFromMldev(apiResponse);
              return resp;
            });
          }
        });
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    class BrowserDownloader {
      download(_params, _apiClient) {
        return __async(this, null, function* () {
          throw new Error("Download to file is not supported in the browser, please use a browser compliant download like an <a> tag.");
        });
      }
    }
    const MAX_CHUNK_SIZE = 1024 * 1024 * 8;
    const MAX_RETRY_COUNT = 3;
    const INITIAL_RETRY_DELAY_MS = 1e3;
    const DELAY_MULTIPLIER = 2;
    const X_GOOG_UPLOAD_STATUS_HEADER_FIELD = "x-goog-upload-status";
    function uploadBlob(file, uploadUrl, apiClient) {
      return __async(this, null, function* () {
        var _a;
        const response = yield uploadBlobInternal(file, uploadUrl, apiClient);
        const responseJson = yield response === null || response === void 0 ? void 0 : response.json();
        if (((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "final") {
          throw new Error("Failed to upload file: Upload status is not finalized.");
        }
        return responseJson["file"];
      });
    }
    function uploadBlobToFileSearchStore(file, uploadUrl, apiClient) {
      return __async(this, null, function* () {
        var _a;
        const response = yield uploadBlobInternal(file, uploadUrl, apiClient);
        const responseJson = yield response === null || response === void 0 ? void 0 : response.json();
        if (((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "final") {
          throw new Error("Failed to upload file: Upload status is not finalized.");
        }
        const resp = uploadToFileSearchStoreOperationFromMldev(responseJson);
        const typedResp = new UploadToFileSearchStoreOperation();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
    function uploadBlobInternal(file, uploadUrl, apiClient) {
      return __async(this, null, function* () {
        var _a, _b;
        let fileSize = 0;
        let offset = 0;
        let response = new HttpResponse(new Response());
        let uploadCommand = "upload";
        fileSize = file.size;
        while (offset < fileSize) {
          const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);
          const chunk = file.slice(offset, offset + chunkSize);
          if (offset + chunkSize >= fileSize) {
            uploadCommand += ", finalize";
          }
          let retryCount = 0;
          let currentDelayMs = INITIAL_RETRY_DELAY_MS;
          while (retryCount < MAX_RETRY_COUNT) {
            response = yield apiClient.request({
              path: "",
              body: chunk,
              httpMethod: "POST",
              httpOptions: {
                apiVersion: "",
                baseUrl: uploadUrl,
                headers: {
                  "X-Goog-Upload-Command": uploadCommand,
                  "X-Goog-Upload-Offset": String(offset),
                  "Content-Length": String(chunkSize)
                }
              }
            });
            if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {
              break;
            }
            retryCount++;
            yield sleep(currentDelayMs);
            currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;
          }
          offset += chunkSize;
          if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "active") {
            break;
          }
          if (fileSize <= offset) {
            throw new Error("All content has been uploaded, but the upload status is not finalized.");
          }
        }
        return response;
      });
    }
    function getBlobStat(file) {
      return __async(this, null, function* () {
        const fileStat = { size: file.size, type: file.type };
        return fileStat;
      });
    }
    function sleep(ms) {
      return new Promise((resolvePromise) => setTimeout(resolvePromise, ms));
    }
    class BrowserUploader {
      upload(file, uploadUrl, apiClient) {
        return __async(this, null, function* () {
          if (typeof file === "string") {
            throw new Error("File path is not supported in browser uploader.");
          }
          return yield uploadBlob(file, uploadUrl, apiClient);
        });
      }
      uploadToFileSearchStore(file, uploadUrl, apiClient) {
        return __async(this, null, function* () {
          if (typeof file === "string") {
            throw new Error("File path is not supported in browser uploader.");
          }
          return yield uploadBlobToFileSearchStore(file, uploadUrl, apiClient);
        });
      }
      stat(file) {
        return __async(this, null, function* () {
          if (typeof file === "string") {
            throw new Error("File path is not supported in browser uploader.");
          } else {
            return yield getBlobStat(file);
          }
        });
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    class BrowserWebSocketFactory {
      create(url, headers, callbacks) {
        return new BrowserWebSocket(url, headers, callbacks);
      }
    }
    class BrowserWebSocket {
      constructor(url, headers, callbacks) {
        this.url = url;
        this.headers = headers;
        this.callbacks = callbacks;
      }
      connect() {
        this.ws = new WebSocket(this.url);
        this.ws.onopen = this.callbacks.onopen;
        this.ws.onerror = this.callbacks.onerror;
        this.ws.onclose = this.callbacks.onclose;
        this.ws.onmessage = this.callbacks.onmessage;
      }
      send(message) {
        if (this.ws === void 0) {
          throw new Error("WebSocket is not connected");
        }
        this.ws.send(message);
      }
      close() {
        if (this.ws === void 0) {
          throw new Error("WebSocket is not connected");
        }
        this.ws.close();
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    const GOOGLE_API_KEY_HEADER = "x-goog-api-key";
    class WebAuth {
      constructor(apiKey2) {
        this.apiKey = apiKey2;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      addAuthHeaders(headers, url) {
        return __async(this, null, function* () {
          if (headers.get(GOOGLE_API_KEY_HEADER) !== null) {
            return;
          }
          if (this.apiKey.startsWith("auth_tokens/")) {
            throw new Error("Ephemeral tokens are only supported by the live API.");
          }
          if (!this.apiKey) {
            throw new Error("API key is missing. Please provide a valid API key.");
          }
          headers.append(GOOGLE_API_KEY_HEADER, this.apiKey);
        });
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    const LANGUAGE_LABEL_PREFIX = "gl-node/";
    class GoogleGenAI {
      constructor(options) {
        var _a;
        if (options.apiKey == null) {
          throw new Error("An API Key must be set when running in a browser");
        }
        if (options.project || options.location) {
          throw new Error("Vertex AI project based authentication is not supported on browser runtimes. Please do not provide a project or location.");
        }
        this.vertexai = (_a = options.vertexai) !== null && _a !== void 0 ? _a : false;
        this.apiKey = options.apiKey;
        const baseUrl = getBaseUrl(
          options.httpOptions,
          options.vertexai,
          /*vertexBaseUrlFromEnv*/
          void 0,
          /*geminiBaseUrlFromEnv*/
          void 0
        );
        if (baseUrl) {
          if (options.httpOptions) {
            options.httpOptions.baseUrl = baseUrl;
          } else {
            options.httpOptions = { baseUrl };
          }
        }
        this.apiVersion = options.apiVersion;
        const auth2 = new WebAuth(this.apiKey);
        this.apiClient = new ApiClient({
          auth: auth2,
          apiVersion: this.apiVersion,
          apiKey: this.apiKey,
          vertexai: this.vertexai,
          httpOptions: options.httpOptions,
          userAgentExtra: LANGUAGE_LABEL_PREFIX + "web",
          uploader: new BrowserUploader(),
          downloader: new BrowserDownloader()
        });
        this.models = new Models(this.apiClient);
        this.live = new Live(this.apiClient, auth2, new BrowserWebSocketFactory());
        this.batches = new Batches(this.apiClient);
        this.chats = new Chats(this.models, this.apiClient);
        this.caches = new Caches(this.apiClient);
        this.files = new Files(this.apiClient);
        this.operations = new Operations(this.apiClient);
        this.authTokens = new Tokens(this.apiClient);
        this.tunings = new Tunings(this.apiClient);
        this.fileSearchStores = new FileSearchStores(this.apiClient);
      }
    }
    let apiKey = localStorage.getItem("gemini_api_key") || "";
    const setGeminiApiKey = (key) => {
      apiKey = key;
      localStorage.setItem("gemini_api_key", key);
    };
    const getClient = () => {
      if (!apiKey) throw new Error("API Key not set");
      return new GoogleGenAI({ apiKey });
    };
    const retryWithBackoff = (fn, retries = 3, delay = 1e3) => __async(null, null, function* () {
      var _a, _b;
      try {
        return yield fn();
      } catch (error) {
        if (retries > 0 && ((error == null ? void 0 : error.status) === 429 || ((_a = error == null ? void 0 : error.message) == null ? void 0 : _a.includes("429")) || ((_b = error == null ? void 0 : error.message) == null ? void 0 : _b.includes("quota")))) {
          console.warn(`Quota exceeded. Retrying in ${delay}ms... (${retries} retries left)`);
          yield new Promise((resolve) => setTimeout(resolve, delay));
          return retryWithBackoff(fn, retries - 1, delay * 2);
        }
        throw error;
      }
    });
    const generateJSON = (model, prompt, schema) => __async(null, null, function* () {
      const ai = getClient();
      return retryWithBackoff(() => __async(null, null, function* () {
        var _a, _b, _c;
        try {
          const config = { responseMimeType: "application/json" };
          if (schema) config.responseSchema = schema;
          const response = yield ai.models.generateContent({
            model,
            contents: prompt,
            config
          });
          if (!response || !response.candidates || response.candidates.length === 0) {
            console.error("Gemini API returned no candidates:", response);
            throw new Error("AI generation failed: No response candidates received.");
          }
          let text = "";
          try {
            if (typeof response.text === "function") {
              text = response.text();
            } else {
              text = response.text || "";
            }
          } catch (e) {
            if ((_c = (_b = (_a = response.candidates[0].content) == null ? void 0 : _a.parts) == null ? void 0 : _b[0]) == null ? void 0 : _c.text) {
              text = response.candidates[0].content.parts[0].text;
            } else {
              console.error("Failed to extract text from response:", response);
              throw new Error("AI generation failed: Could not extract text from response.");
            }
          }
          if (!text) throw new Error("No text returned from model");
          return JSON.parse(text);
        } catch (error) {
          console.error("Gemini JSON Error:", error);
          throw error;
        }
      }));
    });
    const generateListeningTest = (part = 1) => __async(null, null, function* () {
      let context = "";
      let topic = "";
      switch (part) {
        case 1:
          context = "Section 1: A conversation between two people set in an everyday social context (e.g., booking accommodation, inquiring about a gym membership).";
          topic = "Everyday Social Conversation";
          break;
        case 2:
          context = "Section 2: A monologue set in an everyday social context (e.g., a speech about local facilities, a guide giving a tour).";
          topic = "Social Monologue";
          break;
        case 3:
          context = "Section 3: A conversation between up to four people set in an educational or training context (e.g., a university tutor and a student discussing an assignment).";
          topic = "Educational Conversation";
          break;
        case 4:
          context = "Section 4: A monologue on an academic subject (e.g., a university lecture).";
          topic = "Academic Monologue";
          break;
        default:
          context = "Section 1: A conversation between two people set in an everyday social context.";
          topic = "General Listening";
      }
      const seed = Math.floor(Math.random() * 1e4);
      const prompt = `Generate an IELTS Listening Test ${context}.
  Topic: ${topic}
  Random Seed: ${seed}
  
  Requirements:
  1. Generate exactly 10 questions.
  2. Mix of Gap Fill (completion) and Multiple Choice.
  3. For Gap Fill, ensure the answer is a specific word or short phrase from the script.
  4. The script must be realistic and challenging, suitable for IELTS.
  5. Script length: Approx 400-500 words (concise but complete).
  6. The script should be formatted as plain text dialogue or monologue suitable for reading aloud.
  `;
      const schema = {
        type: Type.OBJECT,
        properties: {
          topic: { type: Type.STRING },
          script: { type: Type.STRING },
          questions: {
            type: Type.ARRAY,
            items: {
              type: Type.OBJECT,
              properties: {
                id: { type: Type.STRING },
                text: { type: Type.STRING },
                type: { type: Type.STRING, enum: ["mcq", "gap_fill"] },
                options: { type: Type.ARRAY, items: { type: Type.STRING } },
                correctAnswer: { type: Type.STRING },
                explanation: { type: Type.STRING }
              },
              required: ["id", "text", "type", "correctAnswer", "explanation"]
            }
          }
        },
        required: ["topic", "script", "questions"]
      };
      try {
        return yield generateJSON("gemini-2.5-flash-lite", prompt, schema);
      } catch (error) {
        console.error("Listening Gen Error:", error);
        return null;
      }
    });
    const concatenateAudioBuffers = (buffers) => {
      let totalLength = 0;
      for (const buffer of buffers) {
        totalLength += buffer.length;
      }
      const result = new Uint8Array(totalLength);
      let offset = 0;
      for (const buffer of buffers) {
        result.set(buffer, offset);
        offset += buffer.length;
      }
      return result;
    };
    const uint8ArrayToBase64 = (bytes) => {
      let binary = "";
      const len = bytes.byteLength;
      for (let i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return btoa(binary);
    };
    const generateTTS = (text) => __async(null, null, function* () {
      try {
        console.log("Generating TTS via Railway Backend with Chunking...");
        const TTS_API = "https://tts-backend-production-9d09.up.railway.app/tts";
        const MAX_CHUNK_SIZE2 = 800;
        const sentences = text.match(/[^.!?]+[.!?]+|[^.!?]+$/g) || [text];
        const chunks = [];
        let currentChunk = "";
        for (const sentence of sentences) {
          if ((currentChunk + sentence).length > MAX_CHUNK_SIZE2) {
            chunks.push(currentChunk);
            currentChunk = sentence;
          } else {
            currentChunk += sentence;
          }
        }
        if (currentChunk) chunks.push(currentChunk);
        console.log(`Split text into ${chunks.length} chunks for TTS.`);
        const audioBuffers = [];
        for (const chunk of chunks) {
          if (!chunk.trim()) continue;
          const response = yield fetch(TTS_API, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ text: chunk })
          });
          if (!response.ok) {
            const errorText = yield response.text();
            console.error("TTS Backend Error for chunk:", errorText);
            throw new Error(`TTS Error: ${errorText}`);
          }
          const arrayBuffer = yield response.arrayBuffer();
          audioBuffers.push(new Uint8Array(arrayBuffer));
        }
        if (audioBuffers.length === 0) {
          return { audio: null, error: "No audio generated" };
        }
        const combinedAudio = concatenateAudioBuffers(audioBuffers);
        const base64Audio = uint8ArrayToBase64(combinedAudio);
        return { audio: base64Audio };
      } catch (e) {
        console.error("TTS Generation Error", e);
        return { audio: null, error: e.message || "Unknown TTS error" };
      }
    });
    const generateReadingTest = (passageNum = 1) => __async(null, null, function* () {
      let topic = "";
      let difficulty = "";
      switch (passageNum) {
        case 1:
          topic = "Social Survival / General Interest";
          difficulty = "Moderate";
          break;
        case 2:
          topic = "Workplace / Training Context";
          difficulty = "Hard";
          break;
        case 3:
          topic = "General Academic / Complex Argument";
          difficulty = "Very Hard";
          break;
        default:
          topic = "General Interest";
          difficulty = "Moderate";
      }
      const prompt = `Generate an IELTS Reading Passage (Passage ${passageNum} of 3).
  Topic: ${topic}
  Difficulty: ${difficulty}
  
  Requirements:
  1. Passage Length: 700-900 words.
  2. Generate exactly 15 questions.
  3. Question Types: Mix of Multiple Choice, True/False/Not Given, and Matching Headings.
  4. The text must be academic and challenging, suitable for IELTS.
  5. IMPORTANT: The JSON key for the passage text must be "text", NOT "passage".
  `;
      const schema = {
        type: Type.OBJECT,
        properties: {
          title: { type: Type.STRING },
          text: { type: Type.STRING },
          questions: {
            type: Type.ARRAY,
            items: {
              type: Type.OBJECT,
              properties: {
                id: { type: Type.STRING },
                text: { type: Type.STRING },
                type: { type: Type.STRING, enum: ["mcq", "true_false", "matching"] },
                options: { type: Type.ARRAY, items: { type: Type.STRING } },
                correctAnswer: { type: Type.STRING },
                explanation: { type: Type.STRING }
              },
              required: ["id", "text", "type", "correctAnswer", "explanation"]
            }
          }
        },
        required: ["title", "text", "questions"]
      };
      return yield generateJSON("gemini-2.5-flash-lite", prompt, schema);
    });
    const generateWritingTask = (taskType) => __async(null, null, function* () {
      const prompt = `Generate an IELTS Writing ${taskType === "task1" ? "Task 1" : "Task 2"} prompt.
  
  Requirements:
  1. Return a JSON object.
  2. For Task 1: Include 'chartData' for a bar or line chart.
  3. For Task 2: 'chartData' should be null.
  4. 'promptText': The text description/question.
  
  Output JSON Schema:
  {
    "promptText": "string",
    "chartData": {
      "type": "bar" | "line",
      "title": "string",
      "labels": ["string"],
      "datasets": [
        { "label": "string", "data": [number] }
      ]
    } | null
  }
  `;
      const schema = {
        type: Type.OBJECT,
        properties: {
          promptText: { type: Type.STRING },
          chartData: {
            type: Type.OBJECT,
            properties: {
              type: { type: Type.STRING, enum: ["bar", "line"] },
              title: { type: Type.STRING },
              labels: { type: Type.ARRAY, items: { type: Type.STRING } },
              datasets: {
                type: Type.ARRAY,
                items: {
                  type: Type.OBJECT,
                  properties: {
                    label: { type: Type.STRING },
                    data: { type: Type.ARRAY, items: { type: Type.NUMBER } }
                  },
                  required: ["label", "data"]
                }
              }
            },
            required: ["type", "title", "labels", "datasets"],
            nullable: true
          }
        },
        required: ["promptText"]
      };
      return yield generateJSON("gemini-2.5-flash-lite", prompt, schema);
    });
    const evaluateWriting = (essay, taskType, promptText) => __async(null, null, function* () {
      const prompt = `
  Act as a Senior IELTS Examiner. Evaluate the following ${taskType} essay based on the prompt: "${promptText}".
  Strictly follow IELTS band descriptors.
  
  CRITICAL INSTRUCTIONS:
  1. WORD COUNT CHECK:
     - If Task 1 < 50 words OR Task 2 < 50 words: FORCE BAND 1.0.
     - If Task 1 < 100 words OR Task 2 < 150 words: MAX BAND 4.0.
     - If Task 1 < 150 words OR Task 2 < 250 words: MAX BAND 5.5 for Task Response.
  
  2. RELEVANCE CHECK:
     - If the essay is gibberish, random characters, or completely irrelevant to the prompt: FORCE BAND 0.
     - If the essay is copied from the prompt: FORCE BAND 0.
  
  3. STRICT GRADING:
     - Do NOT be generous. 
     - Band 7.0+ requires sophisticated vocabulary and perfect structure.
     - Band 8.0+ is near-native.
  
  Essay: "${essay}"
  
  Return JSON with:
  - band (0-9, 0.5 increments)
  - taskResponse (0-9)
  - coherence (0-9)
  - lexicalResource (0-9)
  - grammar (0-9)
  - feedback (string, max 100 words)
  - improvedVersion (string): A full rewrite of the user's essay to make it a perfect Band 9 answer.
  - strengths: string[]
  - weaknesses: string[]
  `;
      return generateJSON("gemini-2.5-flash-lite", prompt, {
        type: Type.OBJECT,
        properties: {
          band: { type: Type.NUMBER },
          taskResponse: { type: Type.NUMBER },
          coherence: { type: Type.NUMBER },
          lexicalResource: { type: Type.NUMBER },
          grammar: { type: Type.NUMBER },
          feedback: { type: Type.STRING },
          improvedVersion: { type: Type.STRING },
          strengths: { type: Type.ARRAY, items: { type: Type.STRING } },
          weaknesses: { type: Type.ARRAY, items: { type: Type.STRING } }
        },
        required: ["band", "taskResponse", "coherence", "lexicalResource", "grammar", "feedback", "improvedVersion", "strengths", "weaknesses"]
      });
    });
    const generateSpeakingCues = () => __async(null, null, function* () {
      const prompt = `Generate an IELTS Speaking test set.
  Output JSON:
  {
    "part1": ["3 questions about home/work/study"],
    "part2": { "topic": "Describe a...", "bullets": ["You should say...", "...", "..."] },
    "part3": ["3 abstract follow-up questions related to part 2"]
  }`;
      return generateJSON("gemini-2.5-flash-lite", prompt);
    });
    const evaluateSpeakingSession = (transcript) => __async(null, null, function* () {
      const prompt = `Act as an IELTS Speaking examiner. Grade this transcript of a candidate's test.
  Transcript: "${transcript}"
  
  Return JSON with:
  - band (0-9)
  - fluency (0-9)
  - lexicalResource (0-9)
  - grammar (0-9)
  - pronunciation (0-9)
  - feedback (concise actionable advice)
  - perfectResponseExample (string): Pick one question the user answered poorly and write a Band 9 model answer for it.
  `;
      return generateJSON("gemini-2.5-flash-lite", prompt, {
        type: Type.OBJECT,
        properties: {
          band: { type: Type.NUMBER },
          fluency: { type: Type.NUMBER },
          lexicalResource: { type: Type.NUMBER },
          grammar: { type: Type.NUMBER },
          pronunciation: { type: Type.NUMBER },
          feedback: { type: Type.STRING },
          perfectResponseExample: { type: Type.STRING }
        },
        required: ["band", "fluency", "lexicalResource", "grammar", "pronunciation", "feedback", "perfectResponseExample"]
      });
    });
    const generateVisualScenario = (imageBase64, prompt) => __async(null, null, function* () {
      var _a, _b, _c, _d;
      const ai = getClient();
      let operation = yield ai.models.generateVideos({
        model: "veo-3.1-fast-generate-preview",
        // Keeping this as it might be valid for video
        prompt,
        image: {
          imageBytes: imageBase64,
          mimeType: "image/jpeg"
        },
        config: {
          numberOfVideos: 1,
          resolution: "720p",
          aspectRatio: "16:9"
        }
      });
      while (!operation.done) {
        yield new Promise((resolve) => setTimeout(resolve, 5e3));
        operation = yield ai.operations.getVideosOperation({ operation });
      }
      const videoUri = (_d = (_c = (_b = (_a = operation.response) == null ? void 0 : _a.generatedVideos) == null ? void 0 : _b[0]) == null ? void 0 : _c.video) == null ? void 0 : _d.uri;
      if (videoUri) {
        return `${videoUri}&key=${apiKey}`;
      }
      throw new Error("Video generation failed");
    });
    const generateDiagnostic = () => __async(null, null, function* () {
      const prompt = `Generate a mini IELTS diagnostic test JSON.
   Includes:
   - 3 Listening questions (provide a short script approx 100 words)
   - 3 Reading questions (provide a short passage approx 150 words)
   - 5 Grammar MCQ questions to estimate writing/speaking level
   
   Format:
   {
      "listening": { "script": "...", "questions": [{ "id": "l1", "text": "...", "options": ["..."], "correctAnswer": "..." }] },
      "reading": { "passage": "...", "questions": [{ "id": "r1", "text": "...", "options": ["..."], "correctAnswer": "..." }] },
      "grammar": { "questions": [{ "id": "g1", "text": "...", "options": ["..."], "correctAnswer": "..." }] }
   }`;
      return generateJSON("gemini-2.5-flash-lite", prompt);
    });
    function base64ToUint8Array(base64) {
      const binaryString = atob(base64);
      const len = binaryString.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return bytes;
    }
    function pcmToWavBlob(pcmData, sampleRate = 24e3) {
      const numChannels = 1;
      const byteRate = sampleRate * numChannels * 2;
      const blockAlign = numChannels * 2;
      const dataSize = pcmData.byteLength;
      const buffer = new ArrayBuffer(44 + dataSize);
      const view = new DataView(buffer);
      writeString(view, 0, "RIFF");
      view.setUint32(4, 36 + dataSize, true);
      writeString(view, 8, "WAVE");
      writeString(view, 12, "fmt ");
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, byteRate, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, 16, true);
      writeString(view, 36, "data");
      view.setUint32(40, dataSize, true);
      const pcmView = new Uint8Array(buffer, 44);
      pcmView.set(pcmData);
      return new Blob([buffer], { type: "audio/wav" });
    }
    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }
    const LiveSpeaking = () => {
      var _a, _b, _c;
      const { addXP } = useXP();
      const [status, setStatus] = reactExports.useState("idle");
      const [transcript, setTranscript] = reactExports.useState([]);
      const [cues, setCues] = reactExports.useState(null);
      const [currentQIndex, setCurrentQIndex] = reactExports.useState(0);
      const [timeLeft, setTimeLeft] = reactExports.useState(0);
      const [feedback, setFeedback] = reactExports.useState(null);
      const [persona, setPersona] = reactExports.useState("neutral");
      const [isRecording, setIsRecording] = reactExports.useState(false);
      const [isPlaying, setIsPlaying] = reactExports.useState(false);
      const [audioUrl, setAudioUrl] = reactExports.useState(null);
      const mediaRecorderRef = reactExports.useRef(null);
      const audioChunksRef = reactExports.useRef([]);
      const audioRef = reactExports.useRef(new Audio());
      reactExports.useEffect(() => {
        return () => {
          if (audioUrl) URL.revokeObjectURL(audioUrl);
        };
      }, [audioUrl]);
      const startSession = () => __async(null, null, function* () {
        setStatus("generating");
        setTranscript([]);
        setFeedback(null);
        try {
          const data = yield generateSpeakingCues();
          setCues(data);
          setStatus("part1");
          setCurrentQIndex(0);
          let intro = "Good afternoon. Can you tell me your full name please?";
          if (persona === "strict") intro = "Good afternoon. I am your examiner. State your name clearly.";
          if (persona === "friendly") intro = "Hi there! Nice to meet you. Let's start with your name, shall we?";
          speak(intro);
          setTimeout(() => speak(data.part1[0]), 4e3);
        } catch (e) {
          console.error(e);
          setStatus("idle");
        }
      });
      const speak = (text) => __async(null, null, function* () {
        setTranscript((prev) => [...prev, { role: "examiner", text }]);
        setIsPlaying(true);
        try {
          const audioBase64 = yield generateTTS(text);
          if (audioBase64) {
            const pcmData = base64ToUint8Array(audioBase64);
            const wavBlob = pcmToWavBlob(pcmData, 24e3);
            const url = URL.createObjectURL(wavBlob);
            if (audioUrl) URL.revokeObjectURL(audioUrl);
            setAudioUrl(url);
            audioRef.current.src = url;
            audioRef.current.play();
            audioRef.current.onended = () => setIsPlaying(false);
          }
        } catch (e) {
          console.error(e);
          setIsPlaying(false);
        }
      });
      const startRecording = () => __async(null, null, function* () {
        try {
          const stream = yield navigator.mediaDevices.getUserMedia({ audio: true });
          const recorder = new MediaRecorder(stream);
          mediaRecorderRef.current = recorder;
          audioChunksRef.current = [];
          recorder.ondataavailable = (e) => {
            if (e.data.size > 0) audioChunksRef.current.push(e.data);
          };
          recorder.start();
          setIsRecording(true);
        } catch (e) {
          console.error("Mic error", e);
          alert("Microphone access denied.");
        }
      });
      const stopRecording = () => {
        if (mediaRecorderRef.current && isRecording) {
          mediaRecorderRef.current.stop();
          setIsRecording(false);
          mediaRecorderRef.current.onstop = () => {
            setTranscript((prev) => [...prev, { role: "candidate", text: "(Candidate Audio Response Recorded)" }]);
            handleTurnLogic();
          };
        }
      };
      const handleTurnLogic = () => {
        if (status === "part1") {
          if (currentQIndex < cues.part1.length - 1) {
            setCurrentQIndex((prev) => prev + 1);
            setTimeout(() => speak(cues.part1[currentQIndex + 1]), 1e3);
          } else {
            setStatus("part2_prep");
            setTimeLeft(60);
            speak("Now, I will give you a topic and you have one minute to prepare. Here is your topic.");
          }
        } else if (status === "part2_speak") {
          setStatus("part3");
          setCurrentQIndex(0);
          const transition = persona === "friendly" ? "Thanks! Now let's chat a bit more broadly." : "Thank you. We will now move to Part 3.";
          speak(transition + " " + cues.part3[0]);
        } else if (status === "part3") {
          if (currentQIndex < cues.part3.length - 1) {
            setCurrentQIndex((prev) => prev + 1);
            setTimeout(() => speak(cues.part3[currentQIndex + 1]), 1e3);
          } else {
            finishSession();
          }
        }
      };
      reactExports.useEffect(() => {
        let timer;
        if (status === "part2_prep" && timeLeft > 0) {
          timer = setInterval(() => setTimeLeft((t) => t - 1), 1e3);
        } else if (status === "part2_prep" && timeLeft === 0) {
          setStatus("part2_speak");
          speak("Your time is up. Please start speaking now. You have 2 minutes.");
        }
        return () => clearInterval(timer);
      }, [status, timeLeft]);
      const finishSession = () => __async(null, null, function* () {
        setStatus("grading");
        const fullText = transcript.map((t) => `${t.role}: ${t.text}`).join("\n");
        const result = yield evaluateSpeakingSession(fullText);
        setFeedback(result);
        addXP(350);
        setStatus("completed");
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-3xl mx-auto space-y-6 animate-in fade-in duration-500", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-black rounded-3xl shadow-sm border border-slate-200 dark:border-white/10 p-8 relative overflow-hidden", children: [
          status !== "idle" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `absolute top-0 left-0 w-full h-1 bg-gradient-to-r ${status === "part1" ? "from-cyan-500" : status === "part2_speak" ? "from-purple-500" : "from-rose-500"} to-transparent animate-pulse` }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-8", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "text-2xl font-bold text-slate-800 dark:text-white flex items-center gap-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Mic, { className: "text-rose-500" }),
              "IELTS Speaking"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-3", children: [
              status === "idle" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center bg-slate-100 dark:bg-white/5 rounded-lg p-1", children: ["neutral", "strict", "friendly"].map((p) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => setPersona(p),
                  className: `px-3 py-1 rounded-md text-xs font-bold capitalize transition-all ${persona === p ? "bg-white dark:bg-white/10 shadow-sm text-slate-900 dark:text-white" : "text-slate-400 hover:text-slate-600"}`,
                  children: p
                },
                p
              )) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-3 py-1 bg-slate-100 dark:bg-white/5 rounded-full text-xs font-bold uppercase tracking-wider text-slate-500 dark:text-slate-400 flex items-center gap-2", children: status === "idle" ? "Ready" : status.replace("_", " ") })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-[300px] flex flex-col items-center justify-center text-center space-y-8", children: [
            status === "idle" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-24 h-24 bg-gradient-to-tr from-rose-500 to-orange-400 rounded-full mx-auto mb-6 flex items-center justify-center shadow-xl shadow-rose-500/20", children: /* @__PURE__ */ jsxRuntimeExports.jsx(User, { size: 40, className: "text-white" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-slate-500 dark:text-slate-400 mb-6 max-w-md mx-auto", children: [
                "Practice with our ",
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-slate-700 dark:text-slate-200 capitalize", children: persona }),
                " AI examiner. Covers all 3 parts with real-time cues."
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: startSession, className: "px-8 py-4 bg-rose-600 hover:bg-rose-700 text-white rounded-full font-bold shadow-lg shadow-rose-500/30 transition-all hover:scale-105", children: "Start Interview" })
            ] }),
            status === "part2_prep" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full text-left bg-yellow-50 dark:bg-yellow-900/10 p-6 rounded-2xl border border-yellow-100 dark:border-yellow-900/30 animate-in zoom-in-95", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-start mb-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-bold text-slate-800 dark:text-white text-lg", children: "Cue Card" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-2xl font-mono font-bold text-yellow-600", children: [
                  timeLeft,
                  "s"
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-medium text-slate-800 dark:text-slate-200 mb-4", children: (_a = cues == null ? void 0 : cues.part2) == null ? void 0 : _a.topic }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "list-disc pl-5 text-slate-600 dark:text-slate-400 space-y-1", children: (_c = (_b = cues == null ? void 0 : cues.part2) == null ? void 0 : _b.bullets) == null ? void 0 : _c.map((b, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: b }, i)) })
            ] }),
            (status === "part1" || status === "part3" || status === "part2_speak") && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: isPlaying ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "animate-pulse", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-32 h-32 bg-cyan-100 dark:bg-cyan-900/20 rounded-full flex items-center justify-center text-cyan-600 mb-4 mx-auto border-4 border-cyan-200 dark:border-cyan-500/50 relative", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Cpu, { size: 48 }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 rounded-full border-2 border-cyan-400 animate-ping opacity-20" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-500 font-medium", children: "Examiner is speaking..." })
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onMouseDown: startRecording,
                  onMouseUp: stopRecording,
                  onTouchStart: startRecording,
                  onTouchEnd: stopRecording,
                  className: `w-32 h-32 rounded-full flex items-center justify-center transition-all ${isRecording ? "bg-rose-500 scale-110 shadow-2xl shadow-rose-500/40 ring-8 ring-rose-500/20" : "bg-slate-100 dark:bg-white/10 hover:bg-slate-200 dark:hover:bg-white/20"}`,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Mic, { size: 40, className: isRecording ? "text-white" : "text-slate-400" })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-6 text-sm font-bold text-slate-400 uppercase tracking-widest animate-pulse", children: isRecording ? "Recording..." : "Hold to Answer" })
            ] }) }),
            status === "completed" && feedback && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full text-left animate-in slide-in-from-bottom-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold text-slate-800 dark:text-white", children: "Speaking Result" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-rose-100 dark:bg-rose-900/50 text-rose-700 dark:text-rose-300 px-4 py-2 rounded-xl text-2xl font-black", children: [
                  "Band ",
                  feedback.band
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4 mb-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-3 bg-slate-50 dark:bg-white/5 rounded-lg text-center border border-slate-100 dark:border-white/10", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-slate-500 uppercase font-bold", children: "Fluency" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xl font-bold dark:text-white", children: feedback.fluency })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-3 bg-slate-50 dark:bg-white/5 rounded-lg text-center border border-slate-100 dark:border-white/10", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-slate-500 uppercase font-bold", children: "Lexical" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xl font-bold dark:text-white", children: feedback.lexicalResource })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-3 bg-slate-50 dark:bg-white/5 rounded-lg text-center border border-slate-100 dark:border-white/10", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-slate-500 uppercase font-bold", children: "Grammar" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xl font-bold dark:text-white", children: feedback.grammar })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-3 bg-slate-50 dark:bg-white/5 rounded-lg text-center border border-slate-100 dark:border-white/10", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-slate-500 uppercase font-bold", children: "Pronunciation" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xl font-bold dark:text-white", children: feedback.pronunciation })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-slate-600 dark:text-slate-300 bg-slate-50 dark:bg-white/5 p-4 rounded-xl leading-relaxed border border-slate-100 dark:border-white/10", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-xs font-bold text-slate-400 uppercase mb-2", children: "Feedback" }),
                  feedback.feedback
                ] }),
                feedback.perfectResponseExample && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gradient-to-r from-amber-50 to-orange-50 dark:from-amber-950/30 dark:to-orange-950/30 p-4 rounded-xl border border-amber-100 dark:border-amber-900/50", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { className: "text-sm font-bold text-amber-600 dark:text-amber-400 mb-2 flex items-center gap-2", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { size: 16 }),
                    " Band 9 Model Answer (Example)"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-slate-700 dark:text-slate-300 italic", children: [
                    '"',
                    feedback.perfectResponseExample,
                    '"'
                  ] })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: startSession, className: "mt-6 text-rose-600 font-bold hover:underline flex items-center gap-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(RotateCcw, { size: 16 }),
                " Restart Test"
              ] })
            ] })
          ] })
        ] }),
        transcript.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-slate-50 dark:bg-white/5 p-6 rounded-2xl border border-slate-100 dark:border-white/10 max-h-60 overflow-y-auto", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-xs font-bold text-slate-400 uppercase mb-4", children: "Session Transcript" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3 text-sm", children: transcript.map((t, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `flex gap-3 ${t.role === "candidate" ? "flex-row-reverse" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `p-3 rounded-xl max-w-[80%] leading-relaxed ${t.role === "candidate" ? "bg-rose-100 dark:bg-rose-900/30 text-rose-900 dark:text-rose-200" : "bg-white dark:bg-white/10 text-slate-700 dark:text-slate-300 shadow-sm"}`, children: t.text }) }, i)) })
        ] })
      ] });
    };
    const ChartRenderer = ({ data }) => {
      if (!data) return null;
      const { type, title, labels, datasets } = data;
      const colors = ["bg-blue-500", "bg-emerald-500", "bg-amber-500", "bg-purple-500"];
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-4 p-4 bg-slate-50 dark:bg-white/5 rounded-xl border border-slate-200 dark:border-white/10", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "text-xs font-bold uppercase text-slate-500 mb-4 text-center", children: title }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-end justify-between h-48 gap-2 pb-6 border-b border-slate-200 dark:border-white/10 relative", children: labels.map((label, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 flex flex-col justify-end gap-1 h-full group relative", children: [
          datasets.map((ds, j) => {
            const maxVal = Math.max(...datasets.flatMap((d) => d.data));
            const height = ds.data[i] / maxVal * 100;
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: `w-full rounded-t-sm transition-all hover:opacity-80 ${colors[j % colors.length]}`,
                style: { height: `${height}%` },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "opacity-0 group-hover:opacity-100 absolute -top-6 left-1/2 -translate-x-1/2 text-[10px] bg-black text-white px-1 rounded", children: ds.data[i] })
              },
              j
            );
          }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute -bottom-6 left-1/2 -translate-x-1/2 text-[10px] text-slate-500 whitespace-nowrap overflow-hidden text-ellipsis max-w-full text-center", children: label })
        ] }, i)) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap gap-4 mt-8 justify-center", children: datasets.map((ds, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 text-xs text-slate-600 dark:text-slate-400", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `w-3 h-3 rounded-full ${colors[i % colors.length]}` }),
          ds.label
        ] }, i)) })
      ] });
    };
    const WritingSection = () => {
      var _a, _b;
      const { updateScore } = useScore();
      const { writingTest, setWritingTest } = useTest();
      const [taskType, setTaskType] = reactExports.useState("task1");
      const [taskData, setTaskData] = reactExports.useState(null);
      const [response, setResponse] = reactExports.useState("");
      const [loading, setLoading] = reactExports.useState(false);
      const [evaluating, setEvaluating] = reactExports.useState(false);
      const [feedback, setFeedback] = reactExports.useState(null);
      const [timeLeft, setTimeLeft] = reactExports.useState(0);
      const [timerActive, setTimerActive] = reactExports.useState(false);
      const stateRef = React.useRef({
        taskType,
        taskData,
        response,
        feedback,
        timeLeft,
        timerActive
      });
      reactExports.useEffect(() => {
        stateRef.current = { taskType, taskData, response, feedback, timeLeft, timerActive };
      }, [taskType, taskData, response, feedback, timeLeft, timerActive]);
      reactExports.useEffect(() => {
        if (writingTest) {
          setTaskType(writingTest.taskType);
          setTaskData(writingTest.taskData);
          setResponse(writingTest.response);
          setFeedback(writingTest.feedback);
          setTimeLeft(writingTest.timeLeft);
          setTimerActive(false);
        } else {
          generatePrompt(taskType);
        }
        return () => {
          setWritingTest(stateRef.current);
        };
      }, []);
      const generatePrompt = (..._0) => __async(null, [..._0], function* (type = taskType) {
        setLoading(true);
        setFeedback(null);
        setResponse("");
        setTimerActive(false);
        setTimeLeft(type === "task1" ? 20 * 60 : 40 * 60);
        try {
          const data = yield generateWritingTask(type);
          setTaskData(data);
        } catch (error) {
          console.error("Failed to generate prompt", error);
        } finally {
          setLoading(false);
        }
      });
      const handleTaskTypeChange = (type) => {
        if (type !== taskType) {
          setTaskType(type);
          generatePrompt(type);
        }
      };
      reactExports.useEffect(() => {
        let interval;
        if (timerActive && timeLeft > 0) {
          interval = setInterval(() => {
            setTimeLeft((prev) => prev - 1);
          }, 1e3);
        }
        return () => clearInterval(interval);
      }, [timerActive, timeLeft]);
      const formatTime = (seconds) => {
        const m = Math.floor(seconds / 60);
        const s = seconds % 60;
        return `${m}:${s < 10 ? "0" : ""}${s}`;
      };
      const handleEvaluate = () => __async(null, null, function* () {
        if (!response.trim() || !taskData) return;
        setEvaluating(true);
        setTimerActive(false);
        try {
          const result = yield evaluateWriting(taskType, taskData.promptText, response);
          setFeedback(result);
          const historyItem = {
            id: Date.now(),
            date: (/* @__PURE__ */ new Date()).toLocaleDateString(),
            type: taskType,
            band: result.band,
            score: result.band
            // Normalize for dashboard
          };
          const savedHistory = localStorage.getItem("ielts_writing_history");
          const currentHistory = savedHistory ? JSON.parse(savedHistory) : [];
          const updatedHistory = [historyItem, ...currentHistory].slice(0, 10);
          localStorage.setItem("ielts_writing_history", JSON.stringify(updatedHistory));
          updateScore("writing", result.band);
        } catch (error) {
          console.error("Evaluation failed", error);
        } finally {
          setEvaluating(false);
        }
      });
      const wordCount = response.trim().split(/\s+/).filter((w) => w.length > 0).length;
      const minWords = taskType === "task1" ? 150 : 250;
      const targetWords = taskType === "task1" ? "160-190" : "270-300";
      const timeAlloc = taskType === "task1" ? "20 minutes" : "40 minutes";
      const structureGuide = taskType === "task1" ? "Introduction, Key Details, Summary/Overview (3 paragraphs)" : "Introduction, 2-3 Body Paragraphs, Conclusion (4-5 paragraphs)";
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-4xl mx-auto space-y-8 animate-in fade-in duration-500", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-8", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl font-black text-slate-900 dark:text-white mb-2", children: "IELTS Writing" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-600 dark:text-slate-400", children: "AI-Powered Assessment & Feedback" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex bg-slate-200 dark:bg-white/10 p-1 rounded-xl", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => handleTaskTypeChange("task1"),
                className: `px-6 py-2 rounded-lg text-sm font-bold transition-all ${taskType === "task1" ? "bg-white dark:bg-black text-violet-600 shadow-sm" : "text-slate-500 hover:text-slate-800 dark:hover:text-white"}`,
                children: "Task 1"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => handleTaskTypeChange("task2"),
                className: `px-6 py-2 rounded-lg text-sm font-bold transition-all ${taskType === "task2" ? "bg-white dark:bg-black text-violet-600 shadow-sm" : "text-slate-500 hover:text-slate-800 dark:hover:text-white"}`,
                children: "Task 2"
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-3 gap-8", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lg:col-span-1 space-y-6", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-white/5 p-6 rounded-2xl border border-slate-200 dark:border-white/10 shadow-sm", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-start mb-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "font-bold text-slate-800 dark:text-white flex items-center gap-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(PenTool, { size: 18, className: "text-violet-500" }),
                  "Current Task"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => generatePrompt(taskType), disabled: loading, className: "text-slate-400 hover:text-violet-500 transition-colors", children: /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCw, { size: 16, className: loading ? "animate-spin" : "" }) })
              ] }),
              loading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "py-8 text-center", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { className: "animate-spin mx-auto text-violet-500 mb-2" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-slate-500", children: "Generating prompt..." })
              ] }) : taskData ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-slate-600 dark:text-slate-300 leading-relaxed", children: taskData.promptText }),
                taskData.chartData && /* @__PURE__ */ jsxRuntimeExports.jsx(ChartRenderer, { data: taskData.chartData })
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-slate-500 italic", children: "Failed to load task." })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-blue-50 dark:bg-blue-900/10 p-6 rounded-2xl border border-blue-100 dark:border-blue-900/30", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { className: "font-bold text-blue-700 dark:text-blue-400 mb-3 flex items-center gap-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { size: 16 }),
                " Task Guidelines"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "space-y-3 text-xs text-blue-800 dark:text-blue-300", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex gap-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold min-w-[80px]", children: "Time:" }),
                  timeAlloc
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex gap-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold min-w-[80px]", children: "Min Words:" }),
                  minWords,
                  " words (Target: ",
                  targetWords,
                  ")"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex gap-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold min-w-[80px]", children: "Structure:" }),
                  structureGuide
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "pt-2 border-t border-blue-200 dark:border-blue-800/50 italic opacity-80", children: [
                  "Writing fewer than ",
                  minWords,
                  " words results in penalties."
                ] })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lg:col-span-2 space-y-6", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-white/5 p-6 rounded-2xl border border-slate-200 dark:border-white/10 shadow-sm relative", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `text-sm font-bold ${wordCount < minWords ? "text-red-500" : "text-green-500"}`, children: [
                  wordCount,
                  " words"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-center gap-2 font-mono font-bold ${timeLeft < 300 && timerActive ? "text-red-500 animate-pulse" : "text-slate-500"}`, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Timer, { size: 16 }),
                    " ",
                    formatTime(timeLeft)
                  ] }),
                  !timerActive && timeLeft > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => setTimerActive(true), className: "text-xs bg-violet-100 dark:bg-violet-900/30 text-violet-600 dark:text-violet-300 px-3 py-1 rounded-full font-bold hover:bg-violet-200 transition-colors", children: "Start Timer" })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "textarea",
                {
                  value: response,
                  onChange: (e) => setResponse(e.target.value),
                  placeholder: "Start writing your response here...",
                  className: "w-full h-96 bg-transparent border-0 focus:ring-0 p-0 text-slate-800 dark:text-slate-200 leading-relaxed resize-none"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-6 right-6", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  onClick: handleEvaluate,
                  disabled: evaluating || !response.trim(),
                  className: "bg-violet-600 hover:bg-violet-700 text-white px-6 py-3 rounded-xl font-bold flex items-center gap-2 shadow-lg shadow-violet-500/30 transition-all disabled:opacity-50 disabled:cursor-not-allowed",
                  children: [
                    evaluating ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { className: "animate-spin" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Send, { size: 18 }),
                    "Evaluate"
                  ]
                }
              ) })
            ] }),
            feedback && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-white/5 p-8 rounded-2xl border border-slate-200 dark:border-white/10 animate-in slide-in-from-bottom-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-2xl font-black text-slate-900 dark:text-white", children: "Assessment Result" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-violet-500 text-white px-4 py-1 rounded-full font-black text-xl", children: [
                  "Band ",
                  feedback.band
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-6 mb-8", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 bg-green-50 dark:bg-green-900/10 rounded-xl border border-green-100 dark:border-green-900/30", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { className: "font-bold text-green-700 dark:text-green-400 mb-2 flex items-center gap-2", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheck, { size: 18 }),
                    " Strengths"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "list-disc list-inside text-sm text-green-800 dark:text-green-300 space-y-1", children: ((_a = feedback.strengths) == null ? void 0 : _a.map((s, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: s }, i))) || /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "No specific strengths noted." }) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 bg-amber-50 dark:bg-amber-900/10 rounded-xl border border-amber-100 dark:border-amber-900/30", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { className: "font-bold text-amber-700 dark:text-amber-400 mb-2 flex items-center gap-2", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { size: 18 }),
                    " Improvements"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "list-disc list-inside text-sm text-amber-800 dark:text-amber-300 space-y-1", children: ((_b = feedback.weaknesses) == null ? void 0 : _b.map((w, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: w }, i))) || /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "No specific improvements noted." }) })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-slate-50 dark:bg-black/20 p-6 rounded-xl", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-bold text-slate-800 dark:text-white mb-2", children: "Detailed Feedback" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-600 dark:text-slate-400 text-sm leading-relaxed", children: feedback.detailed_feedback || feedback.feedback })
              ] })
            ] })
          ] })
        ] })
      ] });
    };
    const Listening = () => {
      const { updateScore } = useScore();
      const { listeningTest, setListeningTest } = useTest();
      const [currentPart, setCurrentPart] = reactExports.useState(1);
      const [testData, setTestData] = reactExports.useState({});
      const [audioUrls, setAudioUrls] = reactExports.useState({});
      const [loading, setLoading] = reactExports.useState(false);
      const [audioLoading, setAudioLoading] = reactExports.useState(false);
      const [error, setError] = reactExports.useState(null);
      const [answers, setAnswers] = reactExports.useState({});
      const [submitted, setSubmitted] = reactExports.useState(false);
      const [finalScore, setFinalScore] = reactExports.useState(0);
      const [showHistory, setShowHistory] = reactExports.useState(false);
      const [history, setHistory] = reactExports.useState([]);
      const stateRef = React.useRef({
        currentPart,
        testData,
        audioUrls,
        answers,
        submitted,
        finalScore
      });
      reactExports.useEffect(() => {
        stateRef.current = { currentPart, testData, audioUrls, answers, submitted, finalScore };
      }, [currentPart, testData, audioUrls, answers, submitted, finalScore]);
      reactExports.useEffect(() => {
        const saved = localStorage.getItem("ielts_listening_history");
        if (saved) {
          try {
            setHistory(JSON.parse(saved));
          } catch (e) {
            console.error("Failed to parse history", e);
          }
        }
      }, []);
      const saveToHistory = (score, band) => {
        const newResult = {
          id: Date.now().toString(),
          date: (/* @__PURE__ */ new Date()).toLocaleDateString(),
          score,
          band,
          answers,
          testData
        };
        const updated = [newResult, ...history].slice(0, 10);
        setHistory(updated);
        localStorage.setItem("ielts_listening_history", JSON.stringify(updated));
      };
      const clearHistory = () => {
        if (confirm("Are you sure you want to clear your test history?")) {
          setHistory([]);
          localStorage.removeItem("ielts_listening_history");
        }
      };
      const loadPart = (part) => __async(null, null, function* () {
        setLoading(true);
        setAudioLoading(false);
        setError(null);
        try {
          const result = yield generateListeningTest(part);
          const data = result;
          if (!data || !data.questions || !data.script) {
            throw new Error("Invalid test data received from AI. Please try again.");
          }
          const fixedQuestions = data.questions.map((q) => __spreadProps(__spreadValues({}, q), {
            id: `p${part}_${q.id}`
          }));
          const fixedData = __spreadProps(__spreadValues({}, data), { questions: fixedQuestions });
          setTestData((prev) => __spreadProps(__spreadValues({}, prev), { [part]: fixedData }));
          setLoading(false);
          setAudioLoading(true);
          try {
            const ttsResult = yield generateTTS(data.script);
            if (ttsResult && ttsResult.audio) {
              const byteCharacters = atob(ttsResult.audio);
              const byteNumbers = new Array(byteCharacters.length);
              for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
              }
              const byteArray = new Uint8Array(byteNumbers);
              const audioBlob = new Blob([byteArray], { type: "audio/mp3" });
              const url = URL.createObjectURL(audioBlob);
              setAudioUrls((prev) => __spreadProps(__spreadValues({}, prev), { [part]: url }));
            } else {
              console.warn("TTS returned no audio:", ttsResult == null ? void 0 : ttsResult.error);
              if (ttsResult == null ? void 0 : ttsResult.error) {
                console.error("Audio Generation Error:", ttsResult.error);
              }
            }
          } catch (audioErr) {
            console.error("Audio generation failed:", audioErr);
          } finally {
            setAudioLoading(false);
          }
        } catch (err) {
          console.error("Error loading part:", err);
          setError(err.message || "Failed to load listening test part.");
          setLoading(false);
          setAudioLoading(false);
        }
      });
      reactExports.useEffect(() => {
        if (listeningTest) {
          setCurrentPart(listeningTest.currentPart);
          setTestData(listeningTest.testData);
          setAudioUrls(listeningTest.audioUrls);
          setAnswers(listeningTest.answers);
          setSubmitted(listeningTest.submitted);
          setFinalScore(listeningTest.finalScore);
        } else {
          loadPart(1);
        }
        return () => {
          setListeningTest(stateRef.current);
        };
      }, []);
      const handleNextPart = () => {
        if (currentPart < 4) {
          const nextPart = currentPart + 1;
          setCurrentPart(nextPart);
          if (!testData[nextPart]) {
            loadPart(nextPart);
          }
        } else {
          calculateScore();
        }
      };
      const normalizeAnswer = (text) => {
        return text.toLowerCase().replace(/[.,/#!$%^&*;:{}=\-_`~()]/g, "").trim();
      };
      const calculateScore = () => {
        let correct = 0;
        let totalQuestions = 0;
        Object.values(testData).forEach((part) => {
          part.questions.forEach((q) => {
            totalQuestions++;
            const userAns = normalizeAnswer(answers[q.id] || "");
            const correctAns = q.correctAnswer;
            let isCorrect = false;
            if (Array.isArray(correctAns)) {
              isCorrect = correctAns.some((a) => normalizeAnswer(a) === userAns);
            } else {
              isCorrect = normalizeAnswer(correctAns) === userAns;
            }
            if (isCorrect) correct++;
          });
        });
        setFinalScore(correct);
        setSubmitted(true);
        const accuracy = totalQuestions > 0 ? correct / totalQuestions : 0;
        let band = 0;
        if (accuracy >= 0.97) band = 9;
        else if (accuracy >= 0.92) band = 8.5;
        else if (accuracy >= 0.87) band = 8;
        else if (accuracy >= 0.8) band = 7.5;
        else if (accuracy >= 0.75) band = 7;
        else if (accuracy >= 0.65) band = 6.5;
        else if (accuracy >= 0.57) band = 6;
        else if (accuracy >= 0.45) band = 5.5;
        else if (accuracy >= 0.4) band = 5;
        else if (accuracy >= 0.32) band = 4.5;
        else if (accuracy >= 0.25) band = 4;
        else band = 3.5;
        saveToHistory(correct, band);
        updateScore("listening", band);
      };
      const resetTest = () => {
        setSubmitted(false);
        setAnswers({});
        setTestData({});
        Object.values(audioUrls).forEach((url) => URL.revokeObjectURL(url));
        setAudioUrls({});
        setCurrentPart(1);
        setFinalScore(0);
        setListeningTest(null);
        loadPart(1);
      };
      const loadHistoricalTest = (result) => {
        setTestData(result.testData);
        setAnswers(result.answers);
        setFinalScore(result.score);
        setSubmitted(true);
        setShowHistory(false);
      };
      const playBrowserTTS = (text) => {
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 0.9;
        utterance.pitch = 1;
        const voices = window.speechSynthesis.getVoices();
        const englishVoice = voices.find((v) => v.name.includes("Google US English")) || voices.find((v) => v.lang.startsWith("en"));
        if (englishVoice) utterance.voice = englishVoice;
        window.speechSynthesis.speak(utterance);
      };
      const currentTest = testData[currentPart];
      if (showHistory) {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-4xl mx-auto space-y-8 animate-in fade-in duration-500", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-8", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl font-black text-slate-900 dark:text-white", children: "Test History" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => setShowHistory(false), className: "text-cyan-600 font-bold hover:underline", children: "Back to Practice" })
          ] }),
          history.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-20 text-slate-500", children: "No tests taken yet." }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: history.map((res) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: () => loadHistoricalTest(res), className: "p-6 bg-white dark:bg-white/5 rounded-2xl border border-slate-200 dark:border-white/10 hover:border-cyan-500 cursor-pointer transition-all flex items-center justify-between group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-slate-500 font-bold mb-1", children: res.date }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xl font-bold text-slate-800 dark:text-white", children: [
                "Band Score: ",
                res.band
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-sm text-slate-600 dark:text-slate-400", children: [
                res.score,
                " / 40 Correct"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, { className: "text-slate-300 group-hover:text-cyan-500 transition-colors" })
          ] }, res.id)) }),
          history.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: clearHistory, className: "flex items-center gap-2 text-red-500 font-bold hover:text-red-600 mt-8", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { size: 16 }),
            " Clear History"
          ] })
        ] });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-4xl mx-auto space-y-8 animate-in fade-in duration-500 pt-16 md:pt-0", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-8", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl font-black text-slate-900 dark:text-white mb-2", children: "IELTS Listening Practice" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-slate-600 dark:text-slate-400", children: [
              "Part ",
              currentPart,
              " of 4  10 Questions"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => setShowHistory(true), className: "p-2 rounded-full hover:bg-slate-100 dark:hover:bg-white/10 text-slate-600 dark:text-slate-300 transition-colors", title: "History", children: /* @__PURE__ */ jsxRuntimeExports.jsx(History, { size: 20 }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-2 items-center", children: [1, 2, 3, 4].map((p) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `h-2 w-12 rounded-full transition-colors ${p <= currentPart ? "bg-cyan-500" : "bg-slate-200 dark:bg-white/10"}` }, p)) })
          ] })
        ] }),
        error && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 bg-red-50 dark:bg-red-900/20 text-red-600 dark:text-red-400 rounded-xl border border-red-200 dark:border-red-900/30 flex items-center gap-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { size: 20 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm", children: error }),
          !testData[currentPart] && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => loadPart(currentPart), className: "underline font-bold hover:text-red-700 ml-auto", children: "Retry" })
        ] }),
        loading && !testData[currentPart] ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center justify-center py-20 space-y-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { className: "animate-spin text-cyan-500", size: 48 }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-slate-500 font-medium animate-pulse", children: [
            "Generating Test Content Part ",
            currentPart,
            "..."
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => loadPart(currentPart), className: "mt-4 text-xs text-slate-400 hover:text-cyan-500 underline", children: "Stuck? Refresh Questions" })
        ] }) : currentTest ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          !submitted && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed top-0 left-0 md:left-64 right-0 z-50 bg-white/90 dark:bg-neutral-900/90 backdrop-blur-xl border-b border-slate-200 dark:border-white/10 shadow-lg animate-in slide-in-from-top-full duration-500", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-4xl mx-auto p-3 flex items-center gap-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hidden md:flex flex-col items-center gap-1 text-[10px] font-bold uppercase text-slate-400 tracking-widest shrink-0", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Volume2, { size: 16 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Audio" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: audioLoading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full h-10 bg-slate-100 dark:bg-white/5 rounded-lg flex items-center justify-center gap-2 text-xs text-slate-500 animate-pulse border border-slate-200 dark:border-white/10", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { size: 14, className: "animate-spin text-cyan-500" }),
              " Generating Audio..."
            ] }) : audioUrls[currentPart] ? /* @__PURE__ */ jsxRuntimeExports.jsx("audio", { controls: true, src: audioUrls[currentPart], className: "w-full h-10 invert dark:invert-0" }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full flex gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hidden sm:flex items-center gap-2 text-[10px] text-red-500 bg-red-50 dark:bg-red-900/20 px-3 rounded border border-red-100 dark:border-red-900/30 whitespace-nowrap", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(TriangleAlert, { size: 12 }),
                "Generation Failed"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: () => playBrowserTTS(currentTest.script), className: "flex-1 flex items-center justify-center gap-2 px-3 py-2 bg-slate-200 hover:bg-slate-300 dark:bg-white/10 dark:hover:bg-white/20 text-slate-700 dark:text-slate-200 rounded-lg text-xs font-bold transition-colors", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Play, { size: 14 }),
                " Play Browser TTS"
              ] })
            ] }) }),
            audioUrls[currentPart] && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hidden sm:flex text-[10px] text-cyan-500 items-center gap-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(WandSparkles, { size: 12 }),
              " Gemini 2.5 Flash"
            ] })
          ] }) }),
          !submitted ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-8", children: currentTest.questions.map((q, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6 rounded-xl border border-slate-100 dark:border-white/10 bg-slate-50 dark:bg-white/5", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "font-medium text-slate-800 dark:text-slate-200 mb-4 text-lg", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-bold text-cyan-500 mr-2", children: [
                  i + 1,
                  "."
                ] }),
                q.text
              ] }),
              q.type === "mcq" && q.options ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3", children: q.options.map((opt) => /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: `flex items-center gap-3 p-3 rounded-lg cursor-pointer transition-all border ${answers[q.id] === opt ? "bg-cyan-500/20 border-cyan-400" : "border-transparent hover:bg-white/10"}`, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "radio",
                    name: q.id,
                    value: opt,
                    onChange: (e) => setAnswers(__spreadProps(__spreadValues({}, answers), { [q.id]: e.target.value })),
                    checked: answers[q.id] === opt,
                    className: "w-5 h-5 text-cyan-500 accent-cyan-500"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-slate-700 dark:text-slate-300", children: opt })
              ] }, opt)) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  className: "w-full p-4 rounded-xl border border-slate-300 dark:border-white/10 bg-white dark:bg-black text-slate-900 dark:text-white focus:ring-2 focus:ring-cyan-500 outline-none transition-all",
                  placeholder: "Type answer here...",
                  value: answers[q.id] || "",
                  onChange: (e) => setAnswers(__spreadProps(__spreadValues({}, answers), { [q.id]: e.target.value }))
                }
              )
            ] }, q.id)) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: handleNextPart,
                className: "mt-8 w-full bg-cyan-600 hover:bg-cyan-700 text-white py-4 rounded-xl font-bold flex items-center justify-center gap-2 shadow-lg shadow-cyan-500/30 transition-all transform active:scale-[0.98]",
                children: currentPart < 4 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  "Next Part ",
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Play, { size: 20 })
                ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheckBig, { size: 20 }),
                  " Finish Test"
                ] })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                onClick: () => {
                  if (confirm("Are you sure you want to finish early? You will be scored on what you have completed so far.")) calculateScore();
                },
                className: "mt-4 w-full bg-slate-200 hover:bg-slate-300 dark:bg-white/10 dark:hover:bg-white/20 text-slate-700 dark:text-slate-300 py-3 rounded-xl font-bold flex items-center justify-center gap-2 transition-colors",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(TriangleAlert, { size: 18 }),
                  " Finish Early & Get Score"
                ]
              }
            )
          ] }) : (
            /* Results View */
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-8 space-y-6", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6 bg-blue-50 dark:bg-white/5 rounded-2xl text-center border border-blue-100 dark:border-white/10", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-slate-500 font-bold uppercase tracking-wider mb-1", children: "Overall Band Score" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-5xl font-black text-blue-600 dark:text-cyan-400 mb-2", children: (() => {
                  let total = 0;
                  Object.values(testData).forEach((p) => total += p.questions.length);
                  const acc = total > 0 ? finalScore / total : 0;
                  let band = 0;
                  if (acc >= 0.97) band = 9;
                  else if (acc >= 0.92) band = 8.5;
                  else if (acc >= 0.87) band = 8;
                  else if (acc >= 0.8) band = 7.5;
                  else if (acc >= 0.75) band = 7;
                  else if (acc >= 0.65) band = 6.5;
                  else if (acc >= 0.57) band = 6;
                  else if (acc >= 0.45) band = 5.5;
                  else if (acc >= 0.4) band = 5;
                  else if (acc >= 0.32) band = 4.5;
                  else if (acc >= 0.25) band = 4;
                  else band = 3.5;
                  return band;
                })() }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-block bg-white dark:bg-black px-4 py-1 rounded-full text-sm font-bold shadow-sm border border-white/10", children: [
                  "Score: ",
                  finalScore,
                  " / 40"
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-8", children: Object.entries(testData).map(([part, data]) => {
                const testPart = data;
                return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border-t border-slate-200 dark:border-white/10 pt-8 first:border-0 first:pt-0", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "font-bold text-xl mb-4 text-slate-800 dark:text-white", children: [
                    "Part ",
                    part,
                    ": ",
                    testPart.topic
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-slate-50 dark:bg-white/5 p-4 rounded-xl mb-4 text-sm text-slate-600 dark:text-slate-400 max-h-40 overflow-y-auto border border-slate-200 dark:border-white/10", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-bold mb-2 text-xs uppercase", children: "Audio Script" }),
                    testPart.script
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: testPart.questions.map((q, i) => {
                    const userAns = normalizeAnswer(answers[q.id] || "");
                    const correctAns = q.correctAnswer;
                    let isCorrect = false;
                    if (Array.isArray(correctAns)) {
                      isCorrect = correctAns.some((a) => normalizeAnswer(a) === userAns);
                    } else {
                      isCorrect = normalizeAnswer(correctAns) === userAns;
                    }
                    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `p-4 rounded-xl border ${isCorrect ? "border-green-500/30 bg-green-500/10" : "border-red-500/30 bg-red-500/10"}`, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between mb-2", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-bold text-slate-700 dark:text-slate-200", children: [
                          "Q",
                          i + 1,
                          ". ",
                          q.text
                        ] }),
                        isCorrect ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheckBig, { size: 16, className: "text-green-500" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { size: 16, className: "text-red-500" })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-sm grid grid-cols-2 gap-4", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-slate-500 uppercase block", children: "Your Answer" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: isCorrect ? "text-green-600 dark:text-green-400" : "text-red-600 dark:text-red-400", children: answers[q.id] || "(No Answer)" })
                        ] }),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-slate-500 uppercase block", children: "Correct Answer" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-slate-800 dark:text-white font-medium", children: Array.isArray(q.correctAnswer) ? q.correctAnswer.join(" / ") : q.correctAnswer })
                        ] })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2 text-xs text-slate-500 italic border-t border-black/5 dark:border-white/5 pt-2", children: q.explanation })
                    ] }, q.id);
                  }) })
                ] }, part);
              }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: resetTest, className: "w-full py-4 text-cyan-500 font-bold hover:bg-cyan-500/10 rounded-xl transition-colors border border-transparent hover:border-cyan-500/30", children: "Start New Full Test" })
            ] })
          )
        ] }) : null
      ] });
    };
    const IELTSReading = () => {
      const { readingTest, setReadingTest } = useTest();
      const [currentPassage, setCurrentPassage] = reactExports.useState(1);
      const [testData, setTestData] = reactExports.useState({});
      const [loading, setLoading] = reactExports.useState(false);
      const [error, setError] = reactExports.useState(null);
      const [answers, setAnswers] = reactExports.useState({});
      const [submitted, setSubmitted] = reactExports.useState(false);
      const [finalScore, setFinalScore] = reactExports.useState(0);
      const [timeLeft, setTimeLeft] = reactExports.useState(60 * 60);
      const [timerActive, setTimerActive] = reactExports.useState(false);
      const [showHistory, setShowHistory] = reactExports.useState(false);
      const [history, setHistory] = reactExports.useState([]);
      const stateRef = React.useRef({
        currentPassage,
        testData,
        answers,
        submitted,
        finalScore,
        timeLeft,
        timerActive
      });
      reactExports.useEffect(() => {
        stateRef.current = { currentPassage, testData, answers, submitted, finalScore, timeLeft, timerActive };
      }, [currentPassage, testData, answers, submitted, finalScore, timeLeft, timerActive]);
      reactExports.useEffect(() => {
        const saved = localStorage.getItem("ielts_reading_history");
        if (saved) {
          try {
            setHistory(JSON.parse(saved));
          } catch (e) {
            console.error("Failed to parse history", e);
          }
        }
      }, []);
      const saveToHistory = (score, band) => {
        const newResult = {
          id: Date.now().toString(),
          date: (/* @__PURE__ */ new Date()).toLocaleDateString(),
          score,
          band,
          answers,
          testData
        };
        const updated = [newResult, ...history].slice(0, 10);
        setHistory(updated);
        localStorage.setItem("ielts_reading_history", JSON.stringify(updated));
      };
      const clearHistory = () => {
        if (confirm("Are you sure you want to clear your test history?")) {
          setHistory([]);
          localStorage.removeItem("ielts_reading_history");
        }
      };
      const formatTime = (seconds) => {
        const m = Math.floor(seconds / 60);
        const s = seconds % 60;
        return `${m}:${s < 10 ? "0" : ""}${s}`;
      };
      const loadPassage = (passageNum) => __async(null, null, function* () {
        setLoading(true);
        setError(null);
        try {
          const result = yield generateReadingTest(passageNum);
          const data = result;
          if (!data || !data.questions || !data.text) {
            throw new Error("Invalid reading data received. Please try again.");
          }
          const fixedQuestions = data.questions.map((q) => __spreadProps(__spreadValues({}, q), {
            id: `p${passageNum}_${q.id}`
          }));
          const fixedData = __spreadProps(__spreadValues({}, data), { questions: fixedQuestions });
          setTestData((prev) => __spreadProps(__spreadValues({}, prev), { [passageNum]: fixedData }));
          setTimerActive(true);
        } catch (err) {
          console.error("Error loading passage:", err);
          setError(err.message || "Failed to load reading passage.");
        } finally {
          setLoading(false);
        }
      });
      reactExports.useEffect(() => {
        if (readingTest) {
          setCurrentPassage(readingTest.currentPassage);
          setTestData(readingTest.testData);
          setAnswers(readingTest.answers);
          setSubmitted(readingTest.submitted);
          setFinalScore(readingTest.finalScore);
          setTimeLeft(readingTest.timeLeft);
          setTimerActive(false);
        } else {
          loadPassage(1);
        }
        return () => {
          setReadingTest(stateRef.current);
        };
      }, []);
      const handleNextPassage = () => {
        if (currentPassage < 3) {
          const nextPassage = currentPassage + 1;
          setCurrentPassage(nextPassage);
          if (!testData[nextPassage]) {
            loadPassage(nextPassage);
          }
        } else {
          calculateScore();
        }
      };
      const normalizeAnswer = (text) => {
        return text.toLowerCase().replace(/[.,/#!$%^&*;:{}=\-_`~()]/g, "").trim();
      };
      const calculateScore = () => {
        let correct = 0;
        let totalQuestions = 0;
        Object.values(testData).forEach((part) => {
          part.questions.forEach((q) => {
            totalQuestions++;
            const userAns = normalizeAnswer(answers[q.id] || "");
            const correctAns = normalizeAnswer(q.correctAnswer);
            if (userAns === correctAns) correct++;
          });
        });
        const accuracy = totalQuestions > 0 ? correct / totalQuestions : 0;
        let band = 0;
        if (accuracy >= 0.97) band = 9;
        else if (accuracy >= 0.92) band = 8.5;
        else if (accuracy >= 0.87) band = 8;
        else if (accuracy >= 0.8) band = 7.5;
        else if (accuracy >= 0.75) band = 7;
        else if (accuracy >= 0.65) band = 6.5;
        else if (accuracy >= 0.57) band = 6;
        else if (accuracy >= 0.45) band = 5.5;
        else if (accuracy >= 0.37) band = 5;
        else if (accuracy >= 0.32) band = 4.5;
        else if (accuracy >= 0.25) band = 4;
        else band = 3.5;
        setFinalScore(correct);
        setSubmitted(true);
        setTimerActive(false);
        saveToHistory(correct, band);
      };
      const currentTest = testData[currentPassage];
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-4xl mx-auto space-y-8 animate-in fade-in duration-500", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-8", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl font-black text-slate-900 dark:text-white mb-2", children: "IELTS Reading" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-600 dark:text-slate-400", children: "Academic Reading Practice" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => setShowHistory(!showHistory),
                className: "px-4 py-2 rounded-lg bg-slate-200 dark:bg-white/10 text-slate-700 dark:text-white font-bold text-sm hover:bg-slate-300 dark:hover:bg-white/20 transition-colors",
                children: showHistory ? "Back to Test" : "History"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-slate-200 dark:bg-white/10 px-4 py-2 rounded-lg font-mono font-bold text-slate-700 dark:text-white flex items-center gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Timer, { size: 16, className: timeLeft < 300 ? "text-red-500 animate-pulse" : "" }),
              formatTime(timeLeft)
            ] })
          ] })
        ] }),
        showHistory ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-white/5 p-6 rounded-2xl border border-slate-200 dark:border-white/10", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-6", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold text-slate-900 dark:text-white", children: "Test History" }),
            history.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: clearHistory, className: "text-xs text-red-500 hover:text-red-400 flex items-center gap-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(TriangleAlert, { size: 12 }),
              " Clear History"
            ] })
          ] }),
          history.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-12 text-slate-500", children: "No test history available yet." }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: history.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-4 bg-slate-50 dark:bg-black/20 rounded-xl border border-slate-100 dark:border-white/5", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-bold text-slate-800 dark:text-white", children: item.date }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-slate-500", children: [
                "Score: ",
                item.score,
                " / 40"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-2xl font-black text-emerald-500", children: [
              "Band ",
              item.band
            ] })
          ] }, item.id)) })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-2 justify-end mb-6", children: [1, 2, 3].map((p) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `h-2 w-8 rounded-full transition-colors ${p <= currentPassage ? "bg-emerald-500" : "bg-slate-200 dark:bg-white/10"}` }, p)) }),
          error && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 bg-red-50 dark:bg-red-900/20 text-red-600 dark:text-red-400 rounded-xl border border-red-200 dark:border-red-900/30 flex items-center gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { size: 20 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm", children: error }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => loadPassage(currentPassage), className: "underline font-bold hover:text-red-700 ml-auto", children: "Retry" })
          ] }),
          loading && !testData[currentPassage] ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center justify-center py-20 space-y-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { className: "animate-spin text-emerald-500", size: 48 }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-slate-500 font-medium animate-pulse", children: [
              "Generating Reading Passage ",
              currentPassage,
              "..."
            ] })
          ] }) : currentTest ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: !submitted ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-2 gap-8", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-white/5 p-8 rounded-2xl border border-slate-200 dark:border-white/10 h-[80vh] overflow-y-auto shadow-inner", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-2xl font-bold mb-6 text-slate-900 dark:text-white sticky top-0 bg-white dark:bg-[#121212] py-2 border-b border-slate-100 dark:border-white/10", children: currentTest.title }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "prose dark:prose-invert max-w-none text-slate-700 dark:text-slate-300 leading-relaxed font-serif text-lg", children: currentTest.text.split("\n").map((para, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-4", children: para }, i)) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6 h-[80vh] overflow-y-auto pr-2", children: [
              currentTest.questions.map((q, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6 rounded-xl border border-slate-200 dark:border-white/10 bg-slate-50 dark:bg-white/5", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "font-medium text-slate-800 dark:text-slate-200 mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-bold text-emerald-500 mr-2", children: [
                    i + 1,
                    "."
                  ] }),
                  q.text
                ] }),
                q.type === "mcq" && q.options ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3", children: q.options.map((opt) => /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: `flex items-center gap-3 p-3 rounded-lg cursor-pointer transition-all border ${answers[q.id] === opt ? "bg-emerald-500/20 border-emerald-400" : "border-transparent hover:bg-white/10"}`, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "radio",
                      name: q.id,
                      value: opt,
                      onChange: (e) => setAnswers(__spreadProps(__spreadValues({}, answers), { [q.id]: e.target.value })),
                      checked: answers[q.id] === opt,
                      className: "w-5 h-5 text-emerald-500 accent-emerald-500"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-slate-700 dark:text-slate-300", children: opt })
                ] }, opt)) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "text",
                    className: "w-full p-4 rounded-xl border border-slate-300 dark:border-white/10 bg-white dark:bg-black text-slate-900 dark:text-white focus:ring-2 focus:ring-emerald-500 outline-none transition-all",
                    placeholder: "Type answer here...",
                    value: answers[q.id] || "",
                    onChange: (e) => setAnswers(__spreadProps(__spreadValues({}, answers), { [q.id]: e.target.value }))
                  }
                )
              ] }, q.id)),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-4 pt-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: handleNextPassage,
                    className: "w-full bg-emerald-600 hover:bg-emerald-700 text-white py-4 rounded-xl font-bold flex items-center justify-center gap-2 shadow-lg shadow-emerald-500/30 transition-all transform active:scale-[0.98]",
                    children: currentPassage < 3 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                      "Next Passage ",
                      /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowRight, { size: 20 })
                    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheckBig, { size: 20 }),
                      " Finish Test"
                    ] })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "button",
                  {
                    onClick: () => {
                      if (confirm("Are you sure you want to finish early? You will be scored on what you have completed so far.")) calculateScore();
                    },
                    className: "w-full bg-slate-200 hover:bg-slate-300 dark:bg-white/10 dark:hover:bg-white/20 text-slate-700 dark:text-slate-300 py-3 rounded-xl font-bold flex items-center justify-center gap-2 transition-colors",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(TriangleAlert, { size: 18 }),
                      " Finish Early & Get Score"
                    ]
                  }
                )
              ] })
            ] })
          ] }) : (
            /* Results View */
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-8 space-y-6 max-w-3xl mx-auto", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-8 bg-emerald-50 dark:bg-white/5 rounded-3xl text-center border border-emerald-100 dark:border-white/10 shadow-xl", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-slate-500 font-bold uppercase tracking-wider mb-2", children: "Projected Band Score" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-6xl font-black text-emerald-600 dark:text-emerald-400 mb-4", children: (() => {
                  let correct = 0;
                  let total = 0;
                  Object.values(testData).forEach((part) => {
                    part.questions.forEach((q) => {
                      total++;
                      if (normalizeAnswer(answers[q.id] || "") === normalizeAnswer(q.correctAnswer)) correct++;
                    });
                  });
                  const accuracy = total > 0 ? correct / total : 0;
                  let band = 0;
                  if (accuracy >= 0.97) band = 9;
                  else if (accuracy >= 0.92) band = 8.5;
                  else if (accuracy >= 0.87) band = 8;
                  else if (accuracy >= 0.8) band = 7.5;
                  else if (accuracy >= 0.75) band = 7;
                  else if (accuracy >= 0.65) band = 6.5;
                  else if (accuracy >= 0.57) band = 6;
                  else if (accuracy >= 0.45) band = 5.5;
                  else if (accuracy >= 0.37) band = 5;
                  else if (accuracy >= 0.32) band = 4.5;
                  else if (accuracy >= 0.25) band = 4;
                  else band = 3.5;
                  return band;
                })() }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-block bg-white dark:bg-black px-6 py-2 rounded-full text-sm font-bold shadow-sm border border-white/10", children: [
                  "Raw Score: ",
                  finalScore,
                  " Correct"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "mt-4 text-slate-500 text-sm", children: [
                  "Based on ",
                  Object.keys(testData).length,
                  " passage(s) completed."
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-8", children: Object.entries(testData).map(([part, data]) => {
                const testPart = data;
                return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border-t border-slate-200 dark:border-white/10 pt-8 first:border-0 first:pt-0", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "font-bold text-xl mb-4 text-slate-800 dark:text-white", children: [
                    "Passage ",
                    part,
                    ": ",
                    testPart.title
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: testPart.questions.map((q, i) => {
                    const userAns = normalizeAnswer(answers[q.id] || "");
                    const correctAns = normalizeAnswer(q.correctAnswer);
                    const isCorrect = userAns === correctAns;
                    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `p-4 rounded-xl border ${isCorrect ? "border-green-500/30 bg-green-500/10" : "border-red-500/30 bg-red-500/10"}`, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between mb-2", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-bold text-slate-700 dark:text-slate-200", children: [
                          "Q",
                          i + 1,
                          ". ",
                          q.text
                        ] }),
                        isCorrect ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheckBig, { size: 16, className: "text-green-500" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { size: 16, className: "text-red-500" })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-sm grid grid-cols-2 gap-4", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-slate-500 uppercase block", children: "Your Answer" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: isCorrect ? "text-green-600 dark:text-green-400" : "text-red-600 dark:text-red-400", children: answers[q.id] || "(No Answer)" })
                        ] }),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-slate-500 uppercase block", children: "Correct Answer" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-slate-800 dark:text-white font-medium", children: q.correctAnswer })
                        ] })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2 text-xs text-slate-500 italic border-t border-black/5 dark:border-white/5 pt-2", children: q.explanation })
                    ] }, q.id);
                  }) })
                ] }, part);
              }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => {
                setSubmitted(false);
                setAnswers({});
                setTestData({});
                setCurrentPassage(1);
                setFinalScore(0);
                setTimeLeft(60 * 60);
                setReadingTest(null);
                loadPassage(1);
              }, className: "w-full py-4 text-emerald-500 font-bold hover:bg-emerald-500/10 rounded-xl transition-colors border border-transparent hover:border-emerald-500/30", children: "Start New Reading Test" })
            ] })
          ) }) : null
        ] })
      ] });
    };
    const VeoVisuals = () => {
      const [image, setImage] = reactExports.useState(null);
      const [videoUrl, setVideoUrl] = reactExports.useState(null);
      const [loading, setLoading] = reactExports.useState(false);
      const [prompt, setPrompt] = reactExports.useState("A cinematic slow pan of this environment with ambient movement");
      const handleImageUpload = (e) => {
        var _a;
        const file = (_a = e.target.files) == null ? void 0 : _a[0];
        if (file) {
          const reader = new FileReader();
          reader.onloadend = () => {
            setImage(reader.result);
          };
          reader.readAsDataURL(file);
        }
      };
      const handleGenerate = () => __async(null, null, function* () {
        if (!image) return;
        setLoading(true);
        try {
          const base64Data = image.split(",")[1];
          const url = yield generateVisualScenario(base64Data, prompt);
          setVideoUrl(url);
        } catch (error) {
          console.error(error);
          alert("Video generation failed. Ensure you have access to Veo.");
        } finally {
          setLoading(false);
        }
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-3xl mx-auto bg-white dark:bg-slate-900 rounded-3xl shadow-lg border border-slate-200 dark:border-slate-800 overflow-hidden animate-in fade-in slide-in-from-bottom-8 duration-500", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-8 border-b border-slate-100 dark:border-slate-800 bg-gradient-to-r from-pink-50 to-white dark:from-slate-900 dark:to-slate-900", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "text-2xl font-bold text-slate-800 dark:text-white flex items-center gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-2 bg-pink-100 dark:bg-pink-900/50 rounded-xl text-pink-600 dark:text-pink-400", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Video, { size: 24 }) }),
            "Visual Vocabulary Builder"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-slate-500 dark:text-slate-400 mt-2 max-w-xl", children: "Upload a static image of a place or object. Veo will animate it into a 720p video scenario to help you practice describing moving scenes in Speaking Part 2." })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-8 space-y-8", children: [
          !image ? /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "group block w-full h-64 border-2 border-dashed border-slate-300 dark:border-slate-700 rounded-3xl hover:bg-slate-50 dark:hover:bg-slate-800/50 hover:border-pink-400 dark:hover:border-pink-500 transition-all cursor-pointer flex flex-col items-center justify-center text-slate-400 dark:text-slate-500", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-16 h-16 rounded-full bg-slate-100 dark:bg-slate-800 flex items-center justify-center mb-4 group-hover:scale-110 transition-transform", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Upload, { className: "text-slate-400 dark:text-slate-500 group-hover:text-pink-500", size: 24 }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Click to upload reference image" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "file", accept: "image/*", className: "hidden", onChange: handleImageUpload })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative rounded-2xl overflow-hidden bg-black h-80 flex items-center justify-center group border border-slate-200 dark:border-slate-700 shadow-md", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: image, alt: "Source", className: "h-full w-full object-cover opacity-80 group-hover:opacity-100 transition-opacity" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => setImage(null),
                className: "absolute top-4 right-4 bg-black/60 text-white p-2 rounded-full hover:bg-black/80 backdrop-blur-md transition-colors",
                children: ""
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-4 left-4 bg-black/60 text-white px-3 py-1 rounded-lg text-xs font-bold backdrop-blur-md", children: "Reference Image" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-bold text-slate-500 dark:text-slate-400 uppercase tracking-wide", children: "Prompt" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { size: 16, className: "absolute left-4 top-1/2 -translate-y-1/2 text-pink-400" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  value: prompt,
                  onChange: (e) => setPrompt(e.target.value),
                  className: "w-full pl-10 p-4 border border-slate-300 dark:border-slate-700 bg-slate-50 dark:bg-slate-950 text-slate-900 dark:text-white rounded-xl text-sm focus:ring-2 focus:ring-pink-500 focus:border-transparent transition-all",
                  placeholder: "Describe how you want the video to look..."
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: handleGenerate,
              disabled: !image || loading,
              className: "w-full bg-pink-600 hover:bg-pink-700 text-white py-4 rounded-xl font-bold flex items-center justify-center gap-2 disabled:opacity-50 shadow-lg shadow-pink-500/30 transition-all hover:scale-[1.02]",
              children: [
                loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { className: "animate-spin" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Video, { size: 20 }),
                loading ? "Generating with Veo 3.1..." : "Generate Video Scenario"
              ]
            }
          ),
          videoUrl && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-8 animate-in fade-in slide-in-from-bottom-8", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-bold text-slate-800 dark:text-white", children: "Generated Scenario" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs font-bold bg-pink-100 dark:bg-pink-900/50 text-pink-700 dark:text-pink-300 px-2 py-1 rounded", children: "Veo 3.1" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "video",
              {
                src: videoUrl,
                controls: true,
                className: "w-full rounded-2xl shadow-2xl border border-slate-200 dark:border-slate-800",
                autoPlay: true,
                loop: true
              }
            )
          ] })
        ] })
      ] });
    };
    const DiagnosticTest = ({ onComplete }) => {
      const [test, setTest] = reactExports.useState(null);
      const [answers, setAnswers] = reactExports.useState({});
      const [step, setStep] = reactExports.useState(0);
      reactExports.useEffect(() => {
        const load = () => __async(null, null, function* () {
          const data = yield generateDiagnostic();
          setTest(data);
        });
        load();
      }, []);
      if (!test) return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center justify-center h-96 space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { className: "animate-spin text-blue-600", size: 40 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold text-slate-700 dark:text-slate-200", children: "Preparing your diagnostic assessment..." })
      ] });
      const sections = ["listening", "reading", "grammar"];
      const currentSection = sections[step - 1];
      const currentQuestions = step > 0 && step <= 3 ? test[currentSection].questions : [];
      const handleNext = () => {
        if (step < 3) setStep(step + 1);
        else {
          let scores = { listening: 0, reading: 0, grammar: 0 };
          ["listening", "reading", "grammar"].forEach((sec) => {
            test[sec].questions.forEach((q) => {
              if (answers[q.id] === q.correctAnswer) scores[sec]++;
            });
          });
          onComplete(scores);
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "max-w-2xl mx-auto bg-white dark:bg-slate-900 p-4 md:p-8 rounded-3xl shadow-xl border border-slate-200 dark:border-slate-800 mt-4 md:mt-8", children: step === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center space-y-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-16 h-16 bg-slate-900 dark:bg-white rounded-2xl flex items-center justify-center mx-auto text-white dark:text-black shadow-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Activity, { size: 32 }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-slate-800 dark:text-white", children: "IELTS Diagnostic Test" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-600 dark:text-slate-300", children: "Take this quick 5-minute assessment to determine your current estimated band level and get a personalized study plan." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => setStep(1), className: "w-full bg-slate-900 hover:bg-black dark:bg-white dark:hover:bg-slate-200 text-white dark:text-black py-4 rounded-xl font-bold text-lg shadow-lg transition-all", children: "Start Assessment" })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-bold uppercase tracking-wider text-slate-500 dark:text-slate-400", children: currentSection }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-xs font-bold bg-slate-100 dark:bg-slate-800 px-2 py-1 rounded", children: [
            "Step ",
            step,
            " of 3"
          ] })
        ] }),
        test[currentSection].script && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-slate-50 dark:bg-slate-800/50 p-4 rounded-xl text-sm italic text-slate-600 dark:text-slate-400 border-l-4 border-slate-900 dark:border-white", children: [
          '" ',
          test[currentSection].script,
          ' "'
        ] }),
        test[currentSection].passage && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-slate-50 dark:bg-slate-800/50 p-4 rounded-xl text-sm text-slate-700 dark:text-slate-300 max-h-40 overflow-y-auto border border-slate-200 dark:border-slate-700", children: test[currentSection].passage }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: currentQuestions.map((q, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 rounded-xl border border-slate-100 dark:border-slate-800", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "font-medium mb-3 text-sm", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-bold mr-2", children: [
              i + 1,
              "."
            ] }),
            q.text
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 gap-2", children: q.options.map((opt) => /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: `flex items-center gap-3 p-2.5 rounded-lg cursor-pointer text-sm transition-colors ${answers[q.id] === opt ? "bg-slate-100 dark:bg-white/10 border border-slate-300 dark:border-white/30" : "hover:bg-slate-50 dark:hover:bg-slate-800"}`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "radio",
                name: q.id,
                value: opt,
                checked: answers[q.id] === opt,
                onChange: () => setAnswers(__spreadProps(__spreadValues({}, answers), { [q.id]: opt })),
                className: "text-slate-900 dark:text-white accent-black dark:accent-white"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-slate-700 dark:text-slate-300", children: opt })
          ] }, opt)) })
        ] }, q.id)) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: handleNext, className: "w-full bg-slate-900 hover:bg-black dark:bg-white dark:hover:bg-slate-200 text-white dark:text-black py-3 rounded-xl font-bold flex items-center justify-center gap-2", children: [
          step === 3 ? "Finish" : "Next Section",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowRight, { size: 16 })
        ] })
      ] }) });
    };
    const ScrollToTop = () => {
      const { pathname } = useLocation();
      reactExports.useEffect(() => {
        window.scrollTo(0, 0);
      }, [pathname]);
      return null;
    };
    const ThemeContext = reactExports.createContext({
      isDark: false,
      toggleTheme: () => {
      }
    });
    const XPContext = reactExports.createContext({
      xp: 0,
      addXP: () => {
      },
      level: 1
    });
    const useXP = () => reactExports.useContext(XPContext);
    const ScoreContext = reactExports.createContext({
      scores: null,
      updateScore: () => {
      }
    });
    const useScore = () => reactExports.useContext(ScoreContext);
    const NavItem = ({ to, icon: Icon2, label }) => {
      const location = useLocation();
      const active = location.pathname === to;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Link,
        {
          to,
          className: `flex flex-col items-center gap-1 p-2 rounded-xl transition-all ${active ? "text-cyan-400 bg-white/10" : "text-slate-400 hover:text-slate-200"}`,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Icon2, { size: 20, strokeWidth: active ? 2.5 : 2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-[10px] font-medium uppercase tracking-wide", children: label })
          ]
        }
      );
    };
    const SidebarItem = ({ to, icon: Icon2, label }) => {
      const location = useLocation();
      const active = location.pathname === to;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Link,
        {
          to,
          className: `flex items-center gap-3 px-4 py-3 rounded-xl transition-all font-medium ${active ? "bg-white/10 text-cyan-400 border-r-2 border-cyan-400" : "text-slate-400 hover:bg-white/5 hover:text-white"}`,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Icon2, { size: 20, strokeWidth: active ? 2.5 : 2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: label })
          ]
        }
      );
    };
    const Dashboard = ({ scores }) => {
      const { xp, level } = useXP();
      const [listeningDone, setListeningDone] = reactExports.useState(false);
      const [writingDone, setWritingDone] = reactExports.useState(false);
      reactExports.useEffect(() => {
        const uid = localStorage.getItem("ielts_uid");
        if (!uid) return;
        const lHistory = localStorage.getItem(`ielts_listening_history_${uid}`) || localStorage.getItem("ielts_listening_history");
        if (lHistory && JSON.parse(lHistory).length > 0) setListeningDone(true);
        const wHistory = localStorage.getItem(`ielts_writing_history_${uid}`) || localStorage.getItem("ielts_writing_history");
        if (wHistory && JSON.parse(wHistory).length > 0) setWritingDone(true);
      }, []);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6 md:space-y-8 animate-in fade-in slide-in-from-bottom-4 duration-700", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { className: "relative overflow-hidden bg-gradient-to-br from-neutral-900 via-neutral-900 to-black p-6 md:p-8 rounded-3xl text-white shadow-2xl border border-white/10 group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-0 right-0 -mt-10 -mr-10 w-64 h-64 bg-cyan-500/10 rounded-full blur-3xl group-hover:bg-cyan-500/20 transition-all duration-1000" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative z-10", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-start mb-2 md:mb-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-2xl md:text-4xl font-black mb-2 tracking-tight", children: "NEURAL DASHBOARD" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-cyan-200/80 font-mono text-xs md:text-sm", children: "SYSTEM ONLINE // READY FOR TRAINING" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-right", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-[10px] md:text-xs font-bold text-cyan-300 uppercase tracking-widest mb-1", children: [
                  "Level ",
                  level
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xl md:text-3xl font-black text-white", children: [
                  xp,
                  " ",
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs md:text-sm text-cyan-400", children: "XP" })
                ] })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-4 mt-6 md:mt-8", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white/5 backdrop-blur-md px-4 py-3 md:px-6 md:py-4 rounded-2xl border border-white/10 hover:bg-white/10 transition-all", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-[10px] text-cyan-300 uppercase font-bold block tracking-wider mb-1", children: "Projected Band" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-3xl md:text-4xl font-black bg-clip-text text-transparent bg-gradient-to-r from-white to-cyan-200", children: scores ? (() => {
                const sections = ["listening", "reading", "writing", "speaking"];
                let total = 0;
                let count = 0;
                sections.forEach((section) => {
                  if (scores[section]) {
                    total += scores[section];
                    count++;
                  }
                });
                if (count === 0 && scores.grammar) {
                  return ((scores.listening + scores.reading + scores.grammar) / 3 + 4).toFixed(1);
                }
                return count > 0 ? (total / count).toFixed(1) : "N/A";
              })() : "N/A" })
            ] }) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ModuleCard, { to: "/listening", icon: Volume2, title: "Listening", color: "cyan", desc: "Neural Audio Analysis" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ModuleCard, { to: "/reading", icon: BookOpen, title: "Reading", color: "emerald", desc: "Semantic Processing" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ModuleCard, { to: "/writing", icon: PenTool, title: "Writing", color: "violet", desc: "Generative Grading" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ModuleCard, { to: "/speaking", icon: Mic, title: "Speaking", color: "rose", desc: "Live Conversational AI" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-black p-5 md:p-8 rounded-3xl border border-slate-200 dark:border-white/10 shadow-sm", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "font-bold text-slate-800 dark:text-white mb-4 md:mb-6 flex items-center gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Activity, { className: "text-cyan-500" }),
            "Neural Optimization Plan"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { to: "/listening", className: `flex items-center gap-4 p-4 rounded-2xl border transition-all ${listeningDone ? "bg-green-500/10 border-green-500/20 cursor-default" : "bg-slate-50 dark:bg-white/5 border-slate-100 dark:border-white/5 hover:scale-[1.01] cursor-pointer"}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `w-10 h-10 rounded-full flex items-center justify-center ${listeningDone ? "bg-green-500 text-white" : "bg-cyan-500/10 text-cyan-600 dark:text-cyan-400"}`, children: listeningDone ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheck, { size: 20 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Volume2, { size: 20 }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: `font-bold ${listeningDone ? "text-green-600 dark:text-green-400" : "text-slate-800 dark:text-white"}`, children: listeningDone ? "Listening Simulation Complete" : "Listening: Part 3 Simulation" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-slate-500 dark:text-slate-400", children: listeningDone ? "Neural pathway optimized." : "Improve multi-speaker tracking (+150 XP)" })
              ] }),
              !listeningDone && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2 h-2 rounded-full bg-cyan-500 animate-pulse" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { to: "/writing", className: `flex items-center gap-4 p-4 rounded-2xl border transition-all ${writingDone ? "bg-green-500/10 border-green-500/20 cursor-default" : "bg-slate-50 dark:bg-white/5 border-slate-100 dark:border-white/5 hover:scale-[1.01] cursor-pointer"}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `w-10 h-10 rounded-full flex items-center justify-center ${writingDone ? "bg-green-500 text-white" : "bg-violet-500/10 text-violet-600 dark:text-violet-400"}`, children: writingDone ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheck, { size: 20 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(PenTool, { size: 20 }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: `font-bold ${writingDone ? "text-green-600 dark:text-green-400" : "text-slate-800 dark:text-white"}`, children: writingDone ? "Writing Task Complete" : "Writing: Task 2 Outline" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-slate-500 dark:text-slate-400", children: writingDone ? "Structure logic reinforced." : "Structure your argument logic (+200 XP)" })
              ] }),
              !writingDone && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2 h-2 rounded-full bg-violet-500 animate-pulse" })
            ] })
          ] })
        ] })
      ] });
    };
    const ModuleCard = ({ to, icon: Icon2, title, color, desc }) => {
      const colors = {
        cyan: "from-cyan-500 to-blue-500",
        emerald: "from-emerald-500 to-green-500",
        violet: "from-violet-500 to-purple-500",
        rose: "from-rose-500 to-pink-500"
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { to, className: "relative group bg-white dark:bg-black p-6 rounded-2xl shadow-sm border border-slate-200 dark:border-white/10 hover:-translate-y-1 transition-all overflow-hidden", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `absolute top-0 left-0 w-1 h-full bg-gradient-to-b ${colors[color]}` }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-4 inline-flex p-3 rounded-xl bg-slate-50 dark:bg-white/5 group-hover:scale-110 transition-transform", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon2, { size: 24, className: `text-${color}-500` }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-black text-slate-800 dark:text-white text-xl mb-1", children: title }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs font-medium text-slate-400 dark:text-slate-500 uppercase tracking-wide", children: desc }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-0 right-0 p-2 opacity-0 group-hover:opacity-100 transition-opacity", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon2, { className: `w-24 h-24 text-${color}-500/5 -rotate-12` }) })
      ] });
    };
    const TestContext = reactExports.createContext({
      listeningTest: null,
      setListeningTest: () => {
      },
      readingTest: null,
      setReadingTest: () => {
      },
      writingTest: null,
      setWritingTest: () => {
      }
    });
    const useTest = () => reactExports.useContext(TestContext);
    const App = () => {
      const [isDark, setIsDark] = reactExports.useState(true);
      const [user, setUser] = reactExports.useState(null);
      const [onboarded, setOnboarded] = reactExports.useState(false);
      const [scores, setScores] = reactExports.useState(null);
      const [hasKey, setHasKey] = reactExports.useState(false);
      const [xp, setXp] = reactExports.useState(0);
      const [level, setLevel] = reactExports.useState(1);
      const [mousePos, setMousePos] = reactExports.useState({ x: 0, y: 0 });
      const handleMouseMove = (e) => {
        const { clientX, clientY } = e;
        const { innerWidth, innerHeight } = window;
        const x = (clientX - innerWidth / 2) / (innerWidth / 2);
        const y = (clientY - innerHeight / 2) / (innerHeight / 2);
        setMousePos({ x, y });
      };
      const [listeningTest, setListeningTest] = reactExports.useState(null);
      const [readingTest, setReadingTest] = reactExports.useState(null);
      const [writingTest, setWritingTest] = reactExports.useState(null);
      const [apiKeyInput, setApiKeyInput] = reactExports.useState("");
      reactExports.useEffect(() => {
        const checkAuth = () => {
          const uid = localStorage.getItem("ielts_uid");
          const email = localStorage.getItem("ielts_email");
          const isGuest = localStorage.getItem("ielts_guest") === "true";
          if (uid) {
            setUser({ uid, email, isGuest });
            const savedScores = localStorage.getItem(`ielts_scores_${uid}`) || localStorage.getItem("ielts_scores");
            setScores(savedScores ? JSON.parse(savedScores) : null);
            const savedOnboarded = localStorage.getItem(`ielts_ace_onboarded_${uid}`) === "true";
            setOnboarded(savedOnboarded);
            const storedKey = localStorage.getItem(`gemini_api_key_${uid}`);
            if (storedKey) {
              setGeminiApiKey(storedKey);
              setHasKey(true);
            } else {
              setHasKey(false);
              setGeminiApiKey("");
            }
          } else {
            setUser(null);
            setScores(null);
            setOnboarded(false);
            setHasKey(false);
            setGeminiApiKey("");
          }
        };
        checkAuth();
        const handleAuthChange = () => checkAuth();
        window.addEventListener("auth-change", handleAuthChange);
        return () => window.removeEventListener("auth-change", handleAuthChange);
      }, []);
      const addXP = (amount) => {
        const newXp = xp + amount;
        setXp(newXp);
        if (newXp >= level * 100) {
          setLevel((l) => l + 1);
        }
      };
      reactExports.useEffect(() => {
        if (isDark) document.documentElement.classList.add("dark");
        else document.documentElement.classList.remove("dark");
      }, [isDark]);
      const handleKeySubmit = (e) => {
        e.preventDefault();
        if (apiKeyInput.trim().length > 10 && user) {
          const key = apiKeyInput.trim();
          setGeminiApiKey(key);
          localStorage.setItem(`gemini_api_key_${user.uid}`, key);
          setHasKey(true);
        }
      };
      const clearKey = () => {
        if (user) {
          localStorage.removeItem(`gemini_api_key_${user.uid}`);
          setHasKey(false);
          setGeminiApiKey("");
        }
      };
      const toggleTheme = () => setIsDark(!isDark);
      const handleDiagnosticComplete = (results) => {
        if (!user) return;
        setScores(results);
        localStorage.setItem(`ielts_scores_${user.uid}`, JSON.stringify(results));
        addXP(500);
        setOnboarded(true);
        localStorage.setItem(`ielts_ace_onboarded_${user.uid}`, "true");
      };
      const updateScore = (section, score) => {
        if (!user) return;
        const newScores = __spreadProps(__spreadValues({}, scores), { [section]: score });
        setScores(newScores);
        localStorage.setItem(`ielts_scores_${user.uid}`, JSON.stringify(newScores));
      };
      if (!user) {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            onMouseMove: handleMouseMove,
            className: "min-h-screen w-full flex items-center justify-center bg-[#050505] text-white relative overflow-hidden font-sans selection:bg-cyan-500/30 perspective-1000",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute top-0 left-0 w-full h-full overflow-hidden z-0 pointer-events-none", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-[-10%] left-[-10%] w-[40%] h-[40%] bg-purple-600/20 rounded-full blur-[120px] animate-blob mix-blend-screen" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-[20%] right-[-10%] w-[35%] h-[35%] bg-cyan-500/20 rounded-full blur-[120px] animate-blob animation-delay-2000 mix-blend-screen" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-[-10%] left-[20%] w-[45%] h-[45%] bg-blue-600/20 rounded-full blur-[120px] animate-blob animation-delay-4000 mix-blend-screen" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-[url('https://grainy-gradients.vercel.app/noise.svg')] opacity-20 brightness-100 contrast-150" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative z-10 w-full max-w-5xl mx-auto grid grid-cols-1 lg:grid-cols-2 gap-12 p-6 items-center", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-8 text-center lg:text-left", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex items-center gap-2 px-3 py-1 rounded-full bg-white/5 border border-white/10 backdrop-blur-md text-xs font-medium text-cyan-300 tracking-wide", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "relative flex h-2 w-2", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "animate-ping absolute inline-flex h-full w-full rounded-full bg-cyan-400 opacity-75" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "relative inline-flex rounded-full h-2 w-2 bg-cyan-500" })
                    ] }),
                    "AI-POWERED PREPARATION"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6 perspective-1000", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "div",
                      {
                        className: "w-48 h-48 mx-auto lg:mx-0 relative transition-transform duration-100 ease-out",
                        style: {
                          transform: `
                                        perspective(1000px)
                                        rotateX(${-mousePos.y * 20}deg)
                                        rotateY(${mousePos.x * 20}deg)
                                        scale3d(1.1, 1.1, 1.1)
                                    `
                        },
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-cyan-500/20 blur-[60px] rounded-full animate-pulse" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            "img",
                            {
                              src: logo3d,
                              alt: "IELTS ACE 3D Logo",
                              className: "w-full h-full object-contain relative z-10 mix-blend-screen drop-shadow-[0_0_30px_rgba(6,182,212,0.6)] contrast-125 brightness-90",
                              style: {
                                maskImage: "radial-gradient(circle at center, black 30%, transparent 70%)",
                                WebkitMaskImage: "radial-gradient(circle at center, black 30%, transparent 70%)"
                              }
                            }
                          ),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            "div",
                            {
                              className: "absolute inset-0 bg-gradient-to-tr from-transparent via-white/10 to-transparent z-20 rounded-full pointer-events-none",
                              style: {
                                transform: `translate(${mousePos.x * 20}px, ${mousePos.y * 20}px)`
                              }
                            }
                          )
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("h1", { className: "text-6xl md:text-8xl font-black tracking-tighter leading-[0.9] py-2", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bg-clip-text text-transparent bg-gradient-to-r from-white via-slate-400 to-white bg-[length:200%_auto] animate-shimmer", children: "IELTS" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bg-clip-text text-transparent bg-gradient-to-r from-cyan-400 via-purple-500 to-cyan-400 bg-[length:200%_auto] animate-shimmer", children: "ACE" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-lg text-slate-400 max-w-md mx-auto lg:mx-0 leading-relaxed", children: [
                      "The world's most advanced ",
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-white font-semibold", children: "Neural Preparation System" }),
                      ". Real-time feedback, generative grading, and adaptive learning paths."
                    ] })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hidden lg:flex gap-6 text-sm font-medium text-slate-500", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-1.5 rounded-lg bg-white/5 text-cyan-400", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Zap, { size: 16 }) }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Instant Analysis" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-1.5 rounded-lg bg-white/5 text-purple-400", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Activity, { size: 16 }) }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Band 9.0 Logic" })
                    ] })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute -inset-1 bg-gradient-to-r from-cyan-500 to-purple-600 rounded-3xl blur opacity-20 group-hover:opacity-40 transition duration-1000" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative bg-black/40 backdrop-blur-xl border border-white/10 p-8 md:p-10 rounded-3xl shadow-2xl", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-6", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center space-y-2 mb-2", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-2xl font-bold text-white", children: "Get Started" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-slate-400", children: "Join the elite preparation network" })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        "button",
                        {
                          onClick: () => window.loginWithGoogle(),
                          className: "group/btn relative w-full py-4 bg-white text-black rounded-xl font-bold text-lg overflow-hidden transition-all hover:scale-[1.02] hover:shadow-xl hover:shadow-cyan-500/20",
                          children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-gradient-to-r from-slate-100 to-white opacity-100 group-hover/btn:opacity-90 transition-opacity" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "relative flex items-center justify-center gap-3", children: [
                              /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "w-5 h-5", viewBox: "0 0 24 24", children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z", fill: "#4285F4" }),
                                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z", fill: "#34A853" }),
                                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5.84 14.11c-.22-.66-.35-1.36-.35-2.11s.13-1.45.35-2.11V7.05H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.95l3.66-2.84z", fill: "#FBBC05" }),
                                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.05l3.66 2.84c.87-2.6 3.3-4.51 6.16-4.51z", fill: "#EA4335" })
                              ] }),
                              "Continue with Google"
                            ] })
                          ]
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative flex items-center gap-4 py-2", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-px bg-white/10 flex-1" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-slate-500 font-medium uppercase tracking-wider", children: "or" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-px bg-white/10 flex-1" })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        "button",
                        {
                          onClick: () => window.startAsGuest(),
                          className: "w-full py-4 bg-white/5 border border-white/10 text-slate-300 rounded-xl font-bold text-sm hover:bg-white/10 hover:text-white hover:border-white/20 transition-all flex items-center justify-center gap-2 group/guest",
                          children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Continue as Guest" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "group-hover/guest:translate-x-1 transition-transform", children: "" })
                          ]
                        }
                      )
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-8 pt-6 border-t border-white/5 text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-slate-500", children: [
                      "By continuing, you agree to our ",
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-slate-400 hover:text-white cursor-pointer transition-colors", children: "Terms" }),
                      " and ",
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-slate-400 hover:text-white cursor-pointer transition-colors", children: "Privacy Policy" }),
                      "."
                    ] }) })
                  ] })
                ] })
              ] })
            ]
          }
        );
      }
      if (!hasKey) {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `min-h-screen w-full flex flex-col items-center justify-center bg-black text-white relative overflow-hidden font-sans ${isDark ? "dark" : ""}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-[url('https://grainy-gradients.vercel.app/noise.svg')] opacity-10" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "z-10 text-center space-y-8 p-8 max-w-md w-full", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center gap-2 text-sm text-slate-400 mb-8", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(User, { size: 16 }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                "Logged in as ",
                user.isGuest ? "Guest" : user.email
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white/5 border border-white/10 rounded-2xl p-6 text-left space-y-4 backdrop-blur-sm", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "text-white font-bold flex items-center gap-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Key, { size: 16, className: "text-cyan-400" }),
                "Initialize System"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "text-sm text-slate-400 space-y-2 list-decimal list-inside", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                  "Go to ",
                  /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "https://aistudio.google.com/app/api-keys", target: "_blank", rel: "noopener noreferrer", className: "text-cyan-400 hover:underline hover:text-cyan-300 transition-colors", children: "Google AI Studio" }),
                  "."
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: `Click "Create API key" (it's free).` }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Copy the key and paste it below." })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleKeySubmit, className: "space-y-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative group", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute -inset-0.5 bg-gradient-to-r from-cyan-500 to-blue-500 rounded-xl blur opacity-30 group-hover:opacity-75 transition duration-1000 group-hover:duration-200" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "password",
                    value: apiKeyInput,
                    onChange: (e) => setApiKeyInput(e.target.value),
                    placeholder: "Enter your Gemini API Key",
                    className: "relative w-full bg-black border border-white/10 rounded-xl px-6 py-4 text-white placeholder:text-slate-600 focus:outline-none focus:ring-2 focus:ring-cyan-500/50 font-mono text-center"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  type: "submit",
                  disabled: !apiKeyInput,
                  className: "group relative w-full py-4 bg-white text-black rounded-xl font-bold text-lg overflow-hidden transition-all hover:scale-[1.02] hover:shadow-xl hover:shadow-white/10 disabled:opacity-50 disabled:hover:scale-100",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-gradient-to-r from-cyan-400 via-blue-500 to-purple-600 opacity-0 group-hover:opacity-10 transition-opacity" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "flex items-center justify-center gap-2", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Key, { size: 20 }),
                      " INITIALIZE SYSTEM"
                    ] })
                  ]
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: () => window.logoutUser(), className: "text-xs text-slate-500 hover:text-white flex items-center justify-center gap-2 mx-auto mt-8", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(LogOut, { size: 14 }),
              " Not you? Log out"
            ] })
          ] })
        ] });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeContext.Provider, { value: { isDark, toggleTheme }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(XPContext.Provider, { value: { xp, addXP, level }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScoreContext.Provider, { value: { scores, updateScore }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TestContext.Provider, { value: { listeningTest, setListeningTest, readingTest, setReadingTest, writingTest, setWritingTest }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(HashRouter, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollToTop, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "min-h-screen bg-slate-50 dark:bg-black text-slate-900 dark:text-slate-100 transition-colors duration-300 pb-20 md:pb-0 font-sans selection:bg-cyan-500/30 overflow-x-hidden", children: !onboarded ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 max-w-4xl mx-auto min-h-screen flex flex-col justify-start pt-20", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-end mb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: toggleTheme, className: "p-2 rounded-full bg-slate-200 dark:bg-white/10 hover:bg-slate-300 dark:hover:bg-white/20 transition-colors", children: isDark ? /* @__PURE__ */ jsxRuntimeExports.jsx(Sun, { size: 20 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Moon, { size: 20 }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DiagnosticTest, { onComplete: handleDiagnosticComplete })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("aside", { className: "hidden md:fixed md:inset-y-0 md:left-0 md:flex md:w-64 md:flex-col bg-white dark:bg-black border-r border-slate-200 dark:border-white/10 z-50", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-8 flex items-center gap-3 font-black text-2xl tracking-tighter text-slate-800 dark:text-white", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-8 h-8 bg-cyan-500 rounded-lg flex items-center justify-center", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Zap, { size: 18, className: "text-white", fill: "currentColor" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    src: logo3d,
                    alt: "IELTS ACE 3D Logo",
                    className: "w-full h-full object-contain relative z-10 mix-blend-screen drop-shadow-[0_0_30px_rgba(6,182,212,0.6)] contrast-125 brightness-90",
                    style: {
                      maskImage: "radial-gradient(circle at center, black 30%, transparent 70%)",
                      WebkitMaskImage: "radial-gradient(circle at center, black 30%, transparent 70%)"
                    }
                  }
                ),
                "                "
              ] }),
              "ACE"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("nav", { className: "flex-1 px-4 space-y-2 mt-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(SidebarItem, { to: "/", icon: LayoutDashboard, label: "Command Center" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(SidebarItem, { to: "/listening", icon: Volume2, label: "Listening" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(SidebarItem, { to: "/reading", icon: BookOpen, label: "Reading" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(SidebarItem, { to: "/writing", icon: PenTool, label: "Writing" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(SidebarItem, { to: "/speaking", icon: Mic, label: "Speaking" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(SidebarItem, { to: "/veo", icon: Video, label: "Visuals" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6 border-t border-slate-100 dark:border-white/10 space-y-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3 mb-4 px-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Trophy, { size: 16, className: "text-yellow-500" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-xs font-bold uppercase text-slate-500 dark:text-slate-400", children: [
                  "XP Level ",
                  level
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full h-1.5 bg-slate-100 dark:bg-white/10 rounded-full overflow-hidden mb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-full bg-gradient-to-r from-cyan-400 to-blue-500", style: { width: `${xp % 1e3 / 10}%` } }) }),
              user.isGuest && /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: () => window.upgradeToGoogle(), className: "w-full flex items-center justify-center gap-2 text-xs font-bold text-white bg-gradient-to-r from-cyan-500 to-blue-500 hover:from-cyan-400 hover:to-blue-400 py-2 rounded-lg transition-all shadow-lg shadow-cyan-500/20 mb-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(CircleArrowUp, { size: 14 }),
                " Upgrade Account"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: toggleTheme, className: "w-full flex items-center justify-center gap-2 text-xs font-bold text-slate-500 hover:text-cyan-600 py-2 rounded-lg hover:bg-slate-50 dark:hover:bg-white/5 transition-all", children: [
                isDark ? /* @__PURE__ */ jsxRuntimeExports.jsx(Sun, { size: 14 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Moon, { size: 14 }),
                " Toggle Mode"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: clearKey, className: "w-full flex items-center justify-center gap-2 text-xs font-bold text-slate-500 hover:text-red-500 py-2 rounded-lg hover:bg-slate-50 dark:hover:bg-white/5 transition-all", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Key, { size: 14 }),
                " Change API Key"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: () => window.logoutUser(), className: "w-full flex items-center justify-center gap-2 text-xs font-bold text-slate-500 hover:text-red-500 py-2 rounded-lg hover:bg-slate-50 dark:hover:bg-white/5 transition-all", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(LogOut, { size: 14 }),
                " Log Out"
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("main", { className: "md:pl-64 p-3 md:p-8 max-w-7xl mx-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Dashboard, { scores }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/listening", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Listening, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/reading", element: /* @__PURE__ */ jsxRuntimeExports.jsx(IELTSReading, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/writing", element: /* @__PURE__ */ jsxRuntimeExports.jsx(WritingSection, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/speaking", element: /* @__PURE__ */ jsxRuntimeExports.jsx(LiveSpeaking, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/veo", element: /* @__PURE__ */ jsxRuntimeExports.jsx(VeoVisuals, {}) })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("nav", { className: "md:hidden fixed bottom-0 left-0 right-0 bg-white/90 dark:bg-black/90 backdrop-blur-xl border-t border-slate-200 dark:border-white/10 pb-1 pt-3 px-2 flex justify-around z-50 shadow-2xl", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(NavItem, { to: "/listening", icon: Volume2, label: "Listen" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(NavItem, { to: "/reading", icon: BookOpen, label: "Read" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(NavItem, { to: "/", icon: LayoutDashboard, label: "Hub" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(NavItem, { to: "/writing", icon: PenTool, label: "Write" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(NavItem, { to: "/speaking", icon: Mic, label: "Speaking" })
          ] })
        ] }) })
      ] }) }) }) }) });
    };
    const mount = () => {
      const rootElement = document.getElementById("root");
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }
      const root = ReactDOM.createRoot(rootElement);
      root.render(
        /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
      );
    };
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", mount);
    } else {
      mount();
    }
    const firebaseConfig = {
      apiKey: "AIzaSyDInQWPq-TdSJGSUdRPV5A98dhYGSHtIOY",
      authDomain: "ielts-prac.firebaseapp.com",
      projectId: "ielts-prac",
      storageBucket: "ielts-prac.firebasestorage.app",
      messagingSenderId: "907025192758",
      appId: "1:907025192758:web:9751827c2e4fdd61600597",
      measurementId: "G-L1CGX452RB"
    };
    const app$1 = initializeApp(firebaseConfig);
    getAnalytics(app$1);
    const app = getApp();
    const auth = getAuth(app);
    const googleProvider = new GoogleAuthProvider();
    window.loginWithGoogle = function() {
      return __async(this, null, function* () {
        try {
          const result = yield signInWithPopup(auth, googleProvider);
          const user = result.user;
          localStorage.setItem("ielts_uid", user.uid);
          localStorage.setItem("ielts_email", user.email || "");
          localStorage.removeItem("ielts_guest");
          window.dispatchEvent(new Event("auth-change"));
        } catch (err) {
          console.error(err);
          alert("Google sign in failed: " + err.message);
        }
      });
    };
    window.startAsGuest = function() {
      return __async(this, null, function* () {
        try {
          const result = yield signInAnonymously(auth);
          const user = result.user;
          localStorage.setItem("ielts_uid", user.uid);
          localStorage.setItem("ielts_guest", "true");
          window.dispatchEvent(new Event("auth-change"));
        } catch (err) {
          console.error(err);
          alert("Guest login failed: " + err.message);
        }
      });
    };
    window.upgradeToGoogle = function() {
      return __async(this, null, function* () {
        try {
          const result = yield linkWithPopup(auth.currentUser, googleProvider);
          const user = result.user;
          localStorage.setItem("ielts_uid", user.uid);
          localStorage.setItem("ielts_email", user.email);
          localStorage.removeItem("ielts_guest");
          window.dispatchEvent(new Event("auth-change"));
        } catch (err) {
          console.error(err);
          alert("Account upgrade failed: " + err.message);
        }
      });
    };
    window.logoutUser = function() {
      return __async(this, null, function* () {
        yield signOut(auth);
        localStorage.removeItem("ielts_uid");
        localStorage.removeItem("ielts_email");
        localStorage.removeItem("ielts_guest");
        window.dispatchEvent(new Event("auth-change"));
      });
    };
    onAuthStateChanged(auth, (user) => {
      if (user) {
        localStorage.setItem("ielts_uid", user.uid);
      } else {
        localStorage.removeItem("ielts_uid");
      }
      window.dispatchEvent(new Event("auth-change"));
    });
  }
});
export default require_index_001();</script>
</head>

<body
  class="bg-slate-50 text-slate-900 dark:bg-black dark:text-slate-100 transition-colors duration-300 overflow-x-hidden">
  <div id="root">
    <div
      style="display: flex; justify-content: center; align-items: center; height: 100vh; color: #888; font-family: sans-serif;">
      Loading Application...
    </div>
  </div>

  <!-- Firebase App & Analytics -->

  <!-- Firebase Auth -->
</body>

</html>
